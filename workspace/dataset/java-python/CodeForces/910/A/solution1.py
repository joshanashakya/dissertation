#################### Problems from CodeForces solved by Sohaib Moradi aka Shmits #################### ######################################################################### 1###### World Cup ###### A problem from CodeForces ###### Wordl Cup ######        ## tags: binary search, math # def func(As, n, entranceNum=0):##     Min = min(As)#     p = entranceNum##     while True:#         if As[p] == 0:#             return p+1##         if p != n-1:#             for i in range(p + 1, n):  # checking the right side of position p in As for possible answer after 'Min'#                 # steps#                 d = i - p   # distance between position i in As and position p in As  (Right side)#                 if As[i] <= d:#                     return i + 1##         for i in range(p):  # checking the left side of position p in As for possible answer after 'Min' steps#             d = n - p + i   # distance between position i in As and position p in As  (Left side)#             if As[i] <= d:#                 return i + 1##         As = [As[i] - Min for i in range(n)]#         p = (Min % n + p) % n#         Min = min(As)### num = int(input())# A = list(map(int, input().split(" ")))## print(func(A, num))######################################################################### ######################################################################### 2###### Hit the Lottery ###### A problem from CodeForces ###### Hit the Lottery ######        ## tags: dp, greedy ############ greedy approach ############# coins = [1, 5, 10, 20, 100]## cash = int(input())# coinsNum = 0# for i in range(len(coins)-1, -1, -1):#     coinsNum += cash//coins[i]#     cash = cash % coins[i]#     if cash == 0:#         break# print(coinsNum) ############ dp approach ############# def minimumCoinsNeeded(coins, cash):##     dp = [0] * (cash + 1)##     for i in range(1, cash + 1):#         for coin in coins:#             if i - coin >= 0:#                 if dp[i] == 0:#                     dp[i] = dp[i - coin] + 1#                 else:#                     dp[i] = min(dp[i], dp[i - coin] + 1)##     return dp[cash]## cash = int(input())# coins = [1, 5, 10, 20, 100]# print(minimumCoinsNeeded(coins, cash))######################################################################### ######################################################################### 3###### Maximum Increase ###### A problem from CodeForces ###### Maximum Increase ######        ## tags: dp, greedy, implementation # n = int(input())## arr = list(map(int, input().split(" ")))# lens = [1 for i in arr]## for i in range(1, len(arr)):#     if arr[i] > arr[i-1]:#         lens[i] += lens[i-1]## print(max(lens))######################################################################### ######################################################################### 4###### Fair Division ###### A problem from CodeForces ###### Fair Division ######        ## tags: dp, greedy, math # n = int(input())## for i in range(n):#     t = int(input())#     arr = list(map(int, input().split(" ")))#     ones = arr.count(1)#     twos = arr.count(2)##     # if there are no cakes with weight 1, then the number of cakes with weight 2 should be even#     if ones == 0 and twos % 2 == 0:#         print("YES")#     elif ones % 2 == 0 and ones != 0:  # only the count of cakes with weight 1 matters#         print("YES")#     else:#         print("NO")######################################################################### ######################################################################### 5###### QAQ ###### A problem from CodeForces ###### QAQ ######        ## tags: brute force, dp # str = input()# n = len(str)# Qs = [0 for i in range(n+1)]# As = []## for i in range(n):#     if str[i] == "Q":#         # counting the number of Qs from the beginning#         # to the Ith character of the string#         Qs[i+1] = Qs[i] + 1#     else:#         Qs[i + 1] = Qs[i]#     if str[i] == "A":#         # storing the index of A's occurrence in the string#         As.append(i)## numOfSub = 0# for j in As:#     # Qs[n] - Qs[j+1] = the number of Qs from the Ith character#     # to the end of the string#     # number of Qs on the left of A * number of the Qs on the right of A == numOfSub#     numOfSub += Qs[j+1] * (Qs[n] - Qs[j+1])## print(numOfSub)######################################################################### ######################################################################### 6###### Last Year's Substring ###### A problem from CodeForces ###### Last Year's Substring ######        ## tags: dp, implementation, strings # t = int(input())## for i in range(t):#     n = int(input())#     s = input()##     if s[0:4] == '2020' or s[n-4:n] == '2020':#         print("YES")#     elif s[0] == '2' and s[n-3:n] == '020':#         print("YES")#     elif s[0:2] == '20' and s[n-2:n] == '20':#         print("YES")#     elif s[0:3] == '202' and s[n-1] == '0':#         print("YES")#     else:#         print("NO")######################################################################### ######################################################################### 7###### Last minute enhancements ###### A problem from CodeForces ###### Last minute enhancements ######        ## tags: dp, greedy # t = int(input())## for i in range(t):#     n = int(input())#     arr = list(map(int, input().split(" ")))#     counts = [0 for j in range(1, 2 * n + 3)]##     for k in range(len(arr)):#         if counts[arr[k]] == 0:#             counts[arr[k]] = 1#         elif counts[arr[k]] >= 1:#             arr[k] += 1#             counts[arr[k]] += 1##     print(len(counts) - counts.count(0))######################################################################### ######################################################################### 8###### Alex and a Rhombus ###### A problem from CodeForces ###### Alex and a Rhombus ######        ## tags: dp, implementation, math # n = int(input())# print(2 * (n ** 2) - 2 * n + 1)# 1+3+5+...+(2n-3)+(2n-1)+(2n-3)+(2n-5)+...+5+3+1 = n^2 + (n-1)^2# \--------\  /---------/ \--------\  /---------/#           \/                      \/#           n^2                   (n-1)^2######################################################################### ######################################################################### 9###### Even Subset Sum Problem ###### A problem from CodeForces ###### Even Subset Sum Problem ######        ## tags: brute force, dp, greedy, implementation        ## very easy # def func(arr):#     prev_odd_num_ind = -1  # index##     for j in range(len(arr)):#         if arr[j] % 2 == 0:#             print(1)#             print(j+1)#             return#         if arr[j] % 2 == 1:#             if prev_odd_num_ind != -1:#                 print(2)#                 print(prev_odd_num_ind + 1, j + 1)#                 return#             else:#                 prev_odd_num_ind = j##     print(-1)### t = int(input())## for i in range(t):#     n = int(input())#     As = list(map(int, input().split(" ")))##     func(As) ######################################################################### ######################################################################### 10###### The Way to Home ###### A problem from CodeForces ###### The Way to Home ######        ## tags: def func(n, d, path, p=0):    jumps = 0     while p != n - 1:        for i in range(d, -1, -1):            if i == 0:                print(-1)                return            elif p + i < n - 1 and path[p + i] == '1':                p = p + i                jumps += 1                break            elif p + i >= n - 1:                print(jumps + 1)                return  n, d = map(int, input().split(" "))Path = input() func(n, d, Path)    #########################################################################
