import os, sysfrom io import IOBase, BytesIOpy2 = round(0.5)if py2:    from future_builtins import ascii, filter, hex, map, oct, zip    range = xrangeBUFSIZE = 8192class FastIO(BytesIO):    newlines = 0     def __init__(self, file):        self._file = file        self._fd = file.fileno()        self.writable = 'x' in file.mode or 'w' in file.mode        self.write = super(FastIO, self).write if self.writable else None     def _fill(self):        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])        return s     def read(self):        while self._fill(): pass        return super(FastIO,self).read()     def readline(self):        while self.newlines == 0:            s = self._fill(); self.newlines = s.count(b'\n') + (not s)        self.newlines -= 1        return super(FastIO, self).readline()     def flush(self):        if self.writable:            os.write(self._fd, self.getvalue())            self.truncate(0), self.seek(0) class IOWrapper(IOBase):    def __init__(self, file):        self.buffer = FastIO(file)        self.flush = self.buffer.flush        self.writable = self.buffer.writable        if py2:            self.write = self.buffer.write            self.read = self.buffer.read            self.readline = self.buffer.readline        else:            self.write = lambda s:self.buffer.write(s.encode('ascii'))            self.read = lambda:self.buffer.read().decode('ascii')            self.readline = lambda:self.buffer.readline().decode('ascii')  sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)input = lambda: sys.stdin.readline().rstrip('\r\n') # Cout implemented in Pythonimport sysclass ostream:    def __lshift__(self,a):        sys.stdout.write(str(a))        return selfcout = ostream()endl = '\n' def get_input(a=str):    return a(input()) def get_int_input():    return get_input(int) def get_input_arr(a):    return list(map(a, input().split())) def get_int_input_arr():    return get_input_arr(int)  import operator as opfrom functools import reduceimport math def ncr(n, r):    r = min(r, n-r)    numer = reduce(op.mul, range(n, n-r, -1), 1)    denom = reduce(op.mul, range(1, r+1), 1)    return numer // denom def count_factors(num):    sq = math.sqrt(num)    i = 1    tot = 0    set_c = set()    while i <= sq:        if num % i == 0:            i_2 = num // i            tot += 1            set_c.add(i)            if i_2 != i:                tot += 1                set_c.add(i_2)        i += 1    return tot, set_c  def solve():        n, m, k = get_int_input_arr()     a_arr = get_int_input_arr()    b_arr = get_int_input_arr()     a_sp = []    b_sp = []      a_arr.append(0)    b_arr.append(0)        ptr = 0    curr = 0    while ptr < len(a_arr):        if a_arr[ptr] == 1:            curr += 1        else:            if curr:                a_sp.append(curr)            curr = 0        ptr += 1     ptr = 0    curr = 0    while ptr < len(b_arr):        if b_arr[ptr] == 1:            curr += 1        else:            if curr:                b_sp.append(curr)            curr = 0        ptr += 1         t, factors = count_factors(k)     factors = list(factors)     # print(a_sp)    # print(b_sp)    # print(factors)     res = 0    for fac in factors:        c_res_1 = 0        c_res_2 = 0        for idx, i in enumerate(a_sp):            if i >= fac:                c_res_1 += (i - fac + 1)        for idx, i in enumerate(b_sp):            if i >= (k // fac):                c_res_2 += (i - (k // fac) + 1)        # print(fac, k//fac)        # print(c_res_1, c_res_2)        res += (c_res_1 * c_res_2)     cout<<res<<endl          def main():    solve()  if __name__ == "__main__":    main()
