//    A Computer is Like a mischievous genie.//    It will give you exactly what you ask for,//    but not always what you want//    A code by Rahul Verma  import java.io.BufferedOutputStream;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.HashSet;import java.util.LinkedList;import java.util.Queue;import java.util.Set; import java.util.Stack;import java.util.StringTokenizer;import java.util.TreeMap;   public class Main {    public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));   static class FastReader {     BufferedReader br;    StringTokenizer st;     public FastReader() {      br = new BufferedReader(new          InputStreamReader(System.in));    }     String next() {      while (st == null || !st.hasMoreElements()) {        try {          st = new StringTokenizer(br.readLine());        } catch (IOException e) {          e.printStackTrace();        }      }      return st.nextToken();    }     int nextInt() {      return Integer.parseInt(next());    }     long nextLong() {      return Long.parseLong(next());    }     double nextDouble() {      return Double.parseDouble(next());    }     String[] nextSArray() {      String sr[] = null;      try {        sr = br.readLine().trim().split(" ");      } catch (IOException e) {        e.printStackTrace();      }      return sr;    }     String nextLine() {      String str = "";      try {        str = br.readLine();      } catch (IOException e) {        e.printStackTrace();      }       return str;    }  }   public static void buildTree(long arr[],long tree[],int s,int e,int i)  {    if(s>e)      return;    if(s==e)    {      tree[i]= arr[s];      return;    }     int mid=(s+e)/2;    buildTree(arr,tree,s,mid,2*i+1);    buildTree(arr,tree,mid+1,e,2*i+2);    tree[i]=Math.min(tree[2*i+1],tree[2*i+2]);   }   public static long queryTree(long tree[],int s,int e,int qs,int qe,int index)  {    //complete overap    if(qs<=s&&qe>=e)      return tree[index];     // no overlap    if(e<qs||s>qe)      return Long.MAX_VALUE;    int mid = (s+e)/2;    long lans=queryTree(tree,s,mid,qs,qe,2*index+1);    long rans=queryTree(tree,mid+1,e,qs,qe,2*index+2);    return Math.min(lans,rans);  }  public static int find(int tree[],int s,int e,int q,int i)  {     if(s==e&&s==q)      return tree[i]+1;     if(e<q||s>q)      return -2;     int mid=(s+e)/2;     int x = find(tree,s,mid,q,2*i+1);    int y = find(tree,mid+1,e,q,2*i+2);    return Math.max(x,y);   }   public static void updatequery(int tree[],int s,int e,int qs,int qe,int i,int val)  {      // base case outof Bounds and no overlap case   // System.out.println(i+" "+s+" "+e);    if(e<qs||s>qe)      return;     if(s==e)    {      if(tree[i]==-1)      tree[i]=val;      return;    }    if(qs<=s&&qe>=e)    {      if(tree[i]==-1)        tree[i] = val;      else        return;    }      int mid =(s+e)/2;     updatequery(tree,s,mid,qs,qe,2*i+1,val);    updatequery(tree,mid+1,e,qs,qe,2*i+2,val);  }   public static void main(String[] args) throws Exception {    FastReader sc = new FastReader();         int n=sc.nextInt();      int q=sc.nextInt();      //long arr[]=new long[n];      int tree[]=new int[4*n+1];      Arrays.fill(tree,-1);       // buildTree(arr,tree, 0,n-1,0);       //System.out.println(Arrays.toString(tree));      for (int i = 0; i <q ; i++) {        int s=sc.nextInt()-1;        int e=sc.nextInt()-1;        int w=sc.nextInt()-1;        if(w-1>=s)          updatequery(tree,0,n-1,s,w-1,0,w);        if(w+1<=e)          updatequery(tree,0,n-1,w+1,e,0,w);     }    for (int i = 0; i <n ; i++) {      int x =find(tree,0,n-1,i,0);         out.print(x+" ");    }    out.close();   // System.out.println(Arrays.toString(tree));   }}    
