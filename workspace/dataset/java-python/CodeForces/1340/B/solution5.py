import sysinput=lambda: sys.stdin.readline().rstrip("\r\n") #FOR READING STRING/TEXT INPUTS. def binStringToInt(s):    return int(s,base=2) def binIntToString(x):    return bin(x)[2:] numToString=["1110111", "0010010", "1011101", "1011011", "0111010", "1101011", "1101111", "1010010", "1111111", "1111011"] digits=[[-1 for _ in range(10)] for __ in range(2**7)] #digits[binaryInt][x] is the number of steps to go from binaryInt to xfor i in range(2**7):    iS=binIntToString(i)    for num in range(10):        numS=numToString[num]        num2=binStringToInt(numS)        if i|num2==num2: #i can become num            digits[i][num]=numS.count('1')-iS.count('1')  #main code starts heren,k=[int(x) for x in input().split()]board=[] #store binary integersfor _ in range(n):    board.append(binStringToInt(input())) #n,k=2000,2000#board=['0000010']*2000#board=[binStringToInt(x) for x in board]  possibleMoves=[set() for _ in range(n)] #possibleMoves[idx]={cost1,cost2,...}for i in range(n):    binaryInt=board[i]    for num in range(10):        if digits[binaryInt][num]!=-1:            possibleMoves[i].add(digits[binaryInt][num]) dp=[[False for _ in range(k+1)] for __ in range(n+1)] #dp[idx][k]dp[n][0]=True for i in range(n-1,-1,-1):    for kk in range(k+1):        for cost in possibleMoves[i]:            if kk-cost>=0 and dp[i+1][kk-cost]==True:                dp[i][kk]=True                break if dp[0][k]==True:    ans=''    currK=k    for i in range(n):        binaryInt=board[i]        for num in range(9,-1,-1):            cost=digits[binaryInt][num]            if cost!=-1 and currK-cost>=0 and dp[i+1][currK-cost]==True:                ans=ans+str(num)                currK-=cost                break    print(ans)else:    print(-1)
