import sysfrom collections import defaultdictD = ["1110111", "0010010", "1011101", "1011011", "0111010",     "1101011", "1101111", "1010010", "1111111", "1111011"]SIGN = [bin(i)[2:].zfill(7) for i in range(1 << 7)]RESTORE = {SIGN[i]: i for i in range(1 << 7)}COST = [[-1]*(10) for i in range(1 << 7)]for i in range(1 << 7):    for j in range(10):        si = SIGN[i]        sj = D[j]        cost = 0        possible = True        for k in range(7):            if si[k] == "1" and sj[k] == "0":                COST[i][j] = -1                possible = False                break            elif si[k] == "0" and sj[k] == "1":                cost += 1        if possible:            COST[i][j] = cost  def input():    return sys.stdin.readline().rstrip()  #V[now][cost] ->V = [[-1]*(10) for i in range(1 << 7)]for digit in range(1 << 7):    for n_digit in range(10):        c = COST[digit][n_digit]        if c >= 0:            V[digit][c] = max(V[digit][c], n_digit)  def slv():    n, K = map(int, input().split())    S = [input() for i in range(n)]    S.reverse()     DP = [[-1]*(K + 1) for i in range(n + 1)]    LOG = [[-1]*(K + 1) for i in range(n + 1)]    DP[0][0] = 0    for i in range(1, n + 1):        s = S[i - 1]        rs = RESTORE[s]        for cost in range(8):            for k in range(cost, min(K, 8*i) + 1):                if DP[i - 1][k - cost] >= 0 & V[rs][cost] >= 0:                     if DP[i][k] < V[rs][cost]:                        DP[i][k] = V[rs][cost]                        LOG[i][k] = (V[rs][cost], k - cost)    if DP[n][K] < 0:        print(-1)        return     else:        res = []        idx = n        cost = K        while idx >= 1:            digit, next_cost = LOG[idx][cost]            res.append(str(digit))            idx -= 1            cost = next_cost        ans = "".join(res)        print(ans)        return  slv()
