import java.io.*;import java.util.*;import java.util.List;  /** * Created by Katushka on 11.03.2020. */public class Main {     static void sortArray(int[] a) {        Random random = new Random();         for (int i = 0; i < a.length; i++) {            int randomPos = random.nextInt(a.length);            int t = a[i];            a[i] = a[randomPos];            a[randomPos] = t;        }        Arrays.sort(a);    }     static int[] readArray(int size, InputReader in, boolean subOne) {        int[] a = new int[size];        for (int i = 0; i < size; i++) {            a[i] = in.nextInt() + (subOne ? -1 : 0);        }        return a;    }     static long[] readLongArray(int size, InputReader in) {        long[] a = new long[size];        for (int i = 0; i < size; i++) {            a[i] = in.nextLong();        }        return a;    }     private static final boolean DEBUG = false;    private static final long MOD = 1000000007;      private static int[] getBinary(long a, int size) {        int[] result = new int[size];        for (int i = 0; i < size; i++) {            result[i] = (int) ((a >> i) & 1);        }        return result;    }     private static long fastPow(long x, long y, long mod) {        if (x == 1) {            return 1;        }        if (y == 0) {            return 1;        }        long p = fastPow(x, y / 2, mod) % mod;        p = p * p % mod;        if (y % 2 == 1) {            p = p * x % mod;        }        return p;    }     private static long inv(long x, long mod) {        return fastPow(x, mod - 2, mod);     }     private static long addMod(long x, long y, long mod) {        long res = x + y;        if (res >= mod) {            return res - mod;        }        return res;    }     private static long multMod(long x, long y, long mod) {        long res = x * y;        if (res >= mod) {            return res % mod;        }        return res;    }     private static long subMod(long x, long y, long mod) {        long res = x - y;        if (res < 0) {            return res + mod;        }        return res;    }     public static void main(String[] args) throws FileNotFoundException {//        InputReader in = new InputReader(new FileInputStream("input.txt"));//        PrintWriter out = new PrintWriter(new BufferedOutputStream(new FileOutputStream("seating.out")));         InputReader in = new InputReader(System.in);        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));         String s = in.nextString();        int n = s.length();        int k = in.nextInt();         int ans = Math.min(n + k, 2 * k);        if (ans % 2 == 1) {            ans -= 1;        }        for (int i = 0; i < n; i++) {            outer:            for (int j = i + ans / 2; j + j - i <= n; j++) {                for (int t = i; t < j; t++) {                    if (s.charAt(t) != s.charAt(t + j - i)) {                        continue outer;                    }                }                ans = Math.max((j - i) * 2, ans);            }        }         for (int i = n - 2; i >= 0; i--) {            int j = n - 1;            for (; j > i && i - (n - 1 - j) >= 0 && s.charAt(j) == s.charAt(i - (n - 1 - j)); j--) {             }            if (j - i <= k) {                ans = Math.max((n - 1 - j + j - i) * 2, ans);            }        }        out.println(ans);         out.close();     }      private static void outputArray(long[] ans, PrintWriter out, boolean addOne) {        StringBuilder str = new StringBuilder();        for (int i = 0; i < ans.length; i++) {            long an = ans[i] + (addOne ? 1 : 0);            str.append(an).append('\t');        }        out.println(str);        out.flush();    }     private static void outputArray(List<Long> ans, PrintWriter out) {        StringBuilder str = new StringBuilder();        for (long an : ans) {            str.append(an).append(' ');        }        out.println(str);        out.flush();    }      private static class InputReader {        public BufferedReader reader;        public StringTokenizer tokenizer;         public InputReader(InputStream stream) {            reader = new BufferedReader(new InputStreamReader(stream), 32768);            tokenizer = null;        }         public String next() {            while (tokenizer == null || !tokenizer.hasMoreTokens()) {                try {                    tokenizer = new StringTokenizer(reader.readLine());                } catch (IOException e) {                    throw new RuntimeException(e);                }            }            return tokenizer.nextToken();        }         public String nextString() {            try {                return reader.readLine();            } catch (IOException e) {                throw new RuntimeException(e);            }        }         public int nextInt() {            return Integer.parseInt(next());        }         public double nextDouble() {            return Double.parseDouble(next());        }         public long nextLong() {            return Long.parseLong(next());        }         public char nextChar() {            return next().charAt(0);        }         public String nextWord() {            return next();        }         private List<Integer>[] readTree(int n) {            List<Integer>[] result = new ArrayList[n];            for (int i = 0; i < n; i++) {                result[i] = new ArrayList<>();            }            for (int i = 0; i < n - 1; i++) {                int u = nextInt() - 1;                int v = nextInt() - 1;                result[u].add(v);                result[v].add(u);            }            return result;        }     }}
