#Code by Sounak, IIESTS#------------------------------warmup---------------------------- import osimport sysimport mathfrom io import BytesIO, IOBasefrom fractions import Fractionimport collectionsfrom itertools import permutationsfrom collections import defaultdictfrom collections import dequeimport threading    BUFSIZE = 8192  class FastIO(IOBase):    newlines = 0        def __init__(self, file):        self._fd = file.fileno()        self.buffer = BytesIO()        self.writable = "x" in file.mode or "r" not in file.mode        self.write = self.buffer.write if self.writable else None         def read(self):        while True:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            if not b:                break            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines = 0        return self.buffer.read()     def readline(self):        while self.newlines == 0:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            self.newlines = b.count(b"\n") + (not b)            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines -= 1        return self.buffer.readline()     def flush(self):        if self.writable:            os.write(self._fd, self.buffer.getvalue())            self.buffer.truncate(0), self.buffer.seek(0)  class IOWrapper(IOBase):    def __init__(self, file):        self.buffer = FastIO(file)        self.flush = self.buffer.flush        self.writable = self.buffer.writable        self.write = lambda s: self.buffer.write(s.encode("ascii"))        self.read = lambda: self.buffer.read().decode("ascii")        self.readline = lambda: self.buffer.readline().decode("ascii")  sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)input = lambda: sys.stdin.readline().rstrip("\r\n") #-------------------game starts now-----------------------------------------------------class Factorial:    def __init__(self, MOD):        self.MOD = MOD        self.factorials = [1, 1]        self.invModulos = [0, 1]        self.invFactorial_ = [1, 1]     def calc(self, n):        if n <= -1:            print("Invalid argument to calculate n!")            print("n must be non-negative value. But the argument was " + str(n))            exit()        if n < len(self.factorials):            return self.factorials[n]        nextArr = [0] * (n + 1 - len(self.factorials))        initialI = len(self.factorials)        prev = self.factorials[-1]        m = self.MOD        for i in range(initialI, n + 1):            prev = nextArr[i - initialI] = prev * i % m        self.factorials += nextArr        return self.factorials[n]     def inv(self, n):        if n <= -1:            print("Invalid argument to calculate n^(-1)")            print("n must be non-negative value. But the argument was " + str(n))            exit()        p = self.MOD        pi = n % p        if pi < len(self.invModulos):            return self.invModulos[pi]        nextArr = [0] * (n + 1 - len(self.invModulos))        initialI = len(self.invModulos)        for i in range(initialI, min(p, n + 1)):            next = -self.invModulos[p % i] * (p // i) % p            self.invModulos.append(next)        return self.invModulos[pi]     def invFactorial(self, n):        if n <= -1:            print("Invalid argument to calculate (n^(-1))!")            print("n must be non-negative value. But the argument was " + str(n))            exit()        if n < len(self.invFactorial_):            return self.invFactorial_[n]        self.inv(n)  # To make sure already calculated n^-1        nextArr = [0] * (n + 1 - len(self.invFactorial_))        initialI = len(self.invFactorial_)        prev = self.invFactorial_[-1]        p = self.MOD        for i in range(initialI, n + 1):            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p        self.invFactorial_ += nextArr        return self.invFactorial_[n]  class Combination:    def __init__(self, MOD):        self.MOD = MOD        self.factorial = Factorial(MOD)     def ncr(self, n, k):        if k < 0 or n < k:            return 0        k = min(k, n - k)        f = self.factorial        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD#-------------------------------------------------------------------------def dist(a, b):    return abs(a[0] - b[0]) + abs(a[1] - b[1])  def get_sorted_required_pruts(dists):    res = [dists[i * 2] + dists[i * 2 + 1] for i in range(len(dists) // 2)]    res = [(i, x) for i, x in enumerate(res)]    return sorted(res, key=lambda x: x[1])  def get_answer(pruts, required_pruts):    i = 0    j = 0    answer = "YES"    seq = []    while i < len(required_pruts):        if j == len(pruts):            answer = "NO"            return answer, None        if pruts[j][1] > required_pruts[i][1]:            answer = "NO"            return answer, None        if pruts[j][1] < required_pruts[i][1]:            j += 1        else:            seq.append((required_pruts[i][0], pruts[j][0] + 1))            i += 1            j += 1    return answer, [x[1] for x in sorted(seq)]  n, m = map(int,input().split()) gvozdi = [None] * nfor i in range(n):    gvozdi[i] = list(map(int,input().split())) pruts = list(map(int,input().split()))pruts = [(i, p) for i, p in enumerate(pruts)]pruts = sorted(pruts, key=lambda x: x[1]) dists = [dist(gvozdi[i], gvozdi[i + 1]) for i in range(len(gvozdi) - 1)]dists.append(dist(gvozdi[0], gvozdi[-1])) even_required_pruts = get_sorted_required_pruts(dists)# print(dists[-1:] + dists[:-1])odd_required_pruts = get_sorted_required_pruts(dists[-1:] + dists[:-1]) even_answer, even_seq = get_answer(pruts, even_required_pruts)odd_answer, odd_seq = get_answer(pruts, odd_required_pruts) if even_answer == "NO" and odd_answer == "NO":    print("NO")elif even_answer == "YES":    print("YES")    even_seq = [even_seq[i // 2] if i % 2 == 1 else -1 for i in range(n)]    print(" ".join(map(str, even_seq)))else:    print("YES")    # print(odd_seq)    odd_seq = [odd_seq[i // 2] if i % 2 == 0 else -1 for i in range(n)]    print(" ".join(map(str, odd_seq)))
