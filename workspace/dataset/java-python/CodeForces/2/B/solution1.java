import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader; /** * Place here class purpose. * * @author Kirill * @since 19.03.2021 */public class Task2B {    public static void main(String[] args) throws IOException {        Task2B task = new Task2B();        task.resolve();    }     private void resolve() throws IOException {        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));        int side = Integer.parseInt(bufferedReader.readLine());        int[][] field = new int[side][side];        inputField(field, bufferedReader);          Way wayWithZeroCount = processZerosInField(field);        Way wayWithMinTwoCount = getWayWithMinDividerCount(field, 2);        Way wayWithMinFiveCount = getWayWithMinDividerCount(field, 5);         if (wayWithZeroCount.way != null && Math.min(wayWithMinFiveCount.minDividersCount, wayWithMinTwoCount.minDividersCount) > 0) {            System.out.println(1);            System.out.println(wayWithZeroCount.way.toString());            return;        }         if (wayWithMinFiveCount.minDividersCount < wayWithMinTwoCount.minDividersCount) {            System.out.println(wayWithMinFiveCount.minDividersCount);            System.out.println(wayWithMinFiveCount.way.toString());            return;        }         System.out.println(wayWithMinTwoCount.minDividersCount);        System.out.println(wayWithMinTwoCount.way.toString());    }     private Way getWayWithMinDividerCount(int[][] field, int divider) {        int[][] minDividerCount = new int[field.length][field.length];         minDividerCount[0][0] = getDividerCount(field[0][0], divider);        fillLeftColumn(minDividerCount, field, divider);        fillTopRow(minDividerCount, field, divider);        fillOtherCells(minDividerCount, field, divider);         return new Way(minDividerCount[minDividerCount.length - 1][minDividerCount.length - 1], restoreWay(minDividerCount));    }     private void inputField(int[][] field, BufferedReader bufferedReader) throws IOException {        for (int i = 0; i < field.length; i++) {            String[] strings = bufferedReader.readLine().split(" ");            for (int j = 0; j < field[i].length; j++) {                field[i][j] = Integer.parseInt(strings[j]);            }        }    }     private Way processZerosInField(int[][] field) {        Way wayWithZero = new Way();        for (int i = 0; i < field.length; i++) {            for (int j = 0; j < field[i].length; j++) {                if (field[i][j] == 0) {                    field[i][j] = 10;                    if (wayWithZero.way == null) {                         wayWithZero.minDividersCount = 1;                        wayWithZero.way = createWayThroughZero(field.length, i);                    }                }            }        }         return wayWithZero;    }     private StringBuilder createWayThroughZero(int fieldSide, int rowWithZero) {        StringBuilder way = new StringBuilder();         for (int k = 0; k < rowWithZero; k++) {            way.append("D");        }         for (int k = 0; k < fieldSide - 1; k++) {            way.append("R");        }         for (int k = rowWithZero; k < fieldSide - 1; k++) {            way.append("D");        }         return way;    }     private void fillLeftColumn(int[][] minNumberCount, int[][] field, int divider) {        for (int i = 1; i < field.length; i++) {            minNumberCount[i][0] = minNumberCount[i - 1][0] + getDividerCount(field[i][0], divider);        }    }     private void fillTopRow(int[][] minNumberCount, int[][] field, int divider) {        for (int i = 1; i < field[0].length; i++) {            minNumberCount[0][i] = minNumberCount[0][i - 1] + getDividerCount(field[0][i], divider);        }    }     private void fillOtherCells(int[][] minNumberCount, int[][] field, int divider) {        for (int i = 1; i < field.length; i++) {            for (int j = 1; j < field[i].length; j++) {                minNumberCount[i][j] = Math.min(minNumberCount[i - 1][j], minNumberCount[i][j - 1]) + getDividerCount(field[i][j], divider);            }        }    }     private StringBuilder restoreWay(int[][] minDividersCount) {        StringBuilder way = new StringBuilder();        int y = minDividersCount.length - 1;        int x = minDividersCount[0].length - 1;         while (x != 0 || y != 0) {            if (x == 0 || (y != 0 && minDividersCount[y][x - 1] > minDividersCount[y - 1][x])) {                way.append("D");                y--;            } else {                way.append("R");                x--;            }        }         return way.reverse();    }     private int getDividerCount(int number, int divider) {        int dividerCount = 0;        while (number % divider == 0) {            dividerCount++;            number /= divider;        }         return dividerCount;    }     private static class Way {        private int minDividersCount;        private StringBuilder way;         public Way() {        }         public Way(int minDividersCount, StringBuilder way) {            this.minDividersCount = minDividersCount;            this.way = way;        }    }}  
