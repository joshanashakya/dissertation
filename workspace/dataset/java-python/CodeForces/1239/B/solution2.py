from __future__ import division, print_function def main():    n = int(input())    s = input()    if s.count('(') != s.count(')'):        print('0\n1 1')        return    ar = [(1 if c=='(' else -1) for c in s]    ps = [0]    lb = li = 0    for i, e in enumerate(ar):        v = e+ps[-1]        if v < lb:            lb = v            li = i+1        ps.append(v)    ps.pop()    ps = ps[li:] + ps[:li+1]    for i in indices(ps):        ps[i] += -lb     b0 = ps.count(0)    best2 = 0    this2 = 0    r = False    bsi, bei = 0, 0    for i, e in enumerate(ps):        if e == 2:            if not r:                r = True                this2 = 1                si = i-1            else:                this2 += 1        elif e == 1:            if r:                r = False                if best2 < this2:                    best2 = this2                    bsi, bei = si, i-1     best1 = 0    this1 = 0    r = False    bsi1, bei1 = 0, 0    for i, e in enumerate(ps):        if e == 1:            if not r:                r = True                this1 = 1                si = i-1            else:                this1 += 1        elif e == 0:            if r:                r = False                if best1 < this1:                    best1 = this1                    bsi1, bei1 = si, i-1     if best1 > b0+best2-1:        bsi, bei = bsi1, bei1     print(max(best1, b0+best2-1))    print((bsi+li)%n+1, (bei+li)%n+1) INF = float('inf')MOD = 10 ** 9 + 7__interactive = False import os, sysfrom atexit import registerfrom io import BytesIOimport itertoolsimport __pypy__ if sys.version_info[0] < 3:    input = raw_input    range = xrange     filter = itertools.ifilter    map = itertools.imap    zip = itertools.izip mulmod = __pypy__.intop.int_mulmod if "LOCAL_" in os.environ:    debug_print = printelse:    if not __interactive:        sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))        sys.stdout = BytesIO()        register(lambda: os.write(1, sys.stdout.getvalue()))         input = lambda: sys.stdin.readline().rstrip('\r\n')    debug_print = lambda *x, **y: None flush = sys.stdout.flush def gcd(x, y):    while y:        x, y = y, x % y    return x    def input_as_list():    return list(map(int, input().split())) def input_as_matrix(n, m):    return [input_as_list() for _ in range(n)]    def array_of(f, *dim):    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f() def range_with_count(start, step, count):    return range(start, start + step * count, step) def indices(l, start=0, end=0):    return range(start, len(l)+end) def ceil_power_of_2(n):    """ [0, 1, 2, 4, 4, 8, 8, 8, 8, 16, 16, ...] """    return 2 ** ((n - 1).bit_length()) def ceil_div(x, r):    """ = ceil(x / r) """    return (x + r - 1) // r    main()
