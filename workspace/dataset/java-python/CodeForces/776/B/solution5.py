from sys import stdin,stdout,setrecursionlimitfrom functools import lru_cache, cmp_to_keyfrom heapq import merge, heapify, heappop, heappush,nlargestfrom math import *from collections import defaultdict as dd, deque, Counter as Cfrom itertools import combinations as comb, permutations as perm , accumulatefrom bisect import bisect_left as bl, bisect_right as br, bisectfrom time import perf_counterfrom fractions import Fractionimport copyimport timesetrecursionlimit(10**9)starttime = time.time()mod = int(pow(10, 9) + 7)mod2 = 998244353# from sys import stdin# input = stdin.readline#def data(): return sys.stdin.readline().strip()def data(): return input()def num():return int(input())def L(): return list(sp())def LF(): return list(spf())def sl(): return list(ssp())def sp(): return map(int, data().split())def spf(): return map(int, input.readline().split())def ssp(): return map(str, data().split())def l1d(n, val=0): return [val for i in range(n)]def l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]def pmat(A):    for ele in A:        print(*ele,end="\n")def pmat2(A):    for ele in A:        for j in ele:            print(j,end='')        print()def iseven(n):    return n%2==0 def seive(r):    prime=[1 for i in range(r+1)]    prime[0]=0    prime[1]=0    for i in range(r+1):        if(prime[i]):            for j in range(2*i,r+1,i):                prime[j]=0    return prime#solution#ACPC #remeber cut ribbon problem# set data structures faster than binary search sometimes#bipartite match dfs#think in problems with recursive manner.n=int(input())prime=seive(min(n+1,10**5+1))a=[i+1 for i in range(1,n+1)]ans=[];t1,t2=0,0for i in a:    if prime[i]:        ans.append(1)        t1=1    else:        ans.append(2)        t2=1print(t1+t2)print(*ans)  endtime = time.time()#print(f"Runtime of the program is {endtime - starttime}")
