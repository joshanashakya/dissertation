import java.io.*;import java.util.*; public class Main {    static PrintWriter pw;    static Scanner sc;    static long ceildiv(long x, long y) { return (x+y-1)/y; }    static int mod(long x, int m) { return (int)((x%m+m)%m); }    static void put(TreeMap<Integer, Integer> map, Integer p){if(map.containsKey(p)) map.replace(p, map.get(p)+1); else map.put(p, 1); }    static void rem(TreeMap<Integer, Integer> map, Integer p){ if(map.get(p)==1) map.remove(p);else map.replace(p, map.get(p)-1); }    static void printf(double x, int dig){ String s="%."+dig+"f"; pw.printf(s, x); }    static int Int(boolean x){ return x?1:0; }    static final int inf=(int)1e9, mod=inf+7;    static final long infL=inf*1l*inf;    static final double eps=1e-9;    public static long gcd(long x, long y) { return y==0? x: gcd(y, x%y); }    public static void main(String[] args) throws IOException{        sc=new Scanner(System.in);        pw=new PrintWriter(System.out);        testcase();        pw.close();    }    static void testcase() throws IOException{        String s=sc.next();        TreeMap<Integer, Integer> a=new TreeMap<>(), b=new TreeMap<>();        int sumA=0, sumB=0;        for (int i = 0; i < 3; i++){            int x=Character.getNumericValue(s.charAt(i));            put(a, x);            sumA+=x;        }        for (int i = 3; i < 6; i++){            int x=Character.getNumericValue(s.charAt(i));            put(b, x);            sumB+=x;        }        int ans=0;        while(sumA!=sumB){            ans++;            if(sumA>sumB){                int max=Math.max(a.lastKey(), 9-b.firstKey());                if(sumA-max<=sumB)                    break;                if(max==a.lastKey()){                    rem(a, a.lastKey());                    put(a, 0);                    sumA-=max;                }else{                    rem(b, b.firstKey());                    put(b, 9);                    sumB+=max;                }            }else{                int max=Math.max(b.lastKey(), 9-a.firstKey());                if(sumB-max<=sumA)                    break;                if(max==b.lastKey()){                    rem(b, b.lastKey());                    put(b, 0);                    sumB-=max;                }else{                    rem(a, a.firstKey());                    put(a, 9);                    sumA+=max;                }            }        }        pw.println(ans);    }    static boolean sign(int x){        return x>=0;    }    static int solve(Integer[] arr, int k){        if(k<0)            return -inf;        Arrays.sort(arr);        int ans=0;        for (int i = 0; i < arr.length; i++) {            if(k>=arr[i]){                ans+=2;                k-=arr[i];            }else{                break;            }        }        return ans;    }    static void printArr(int[] arr) {        for (int i = 0; i < arr.length - 1; i++)            pw.print(arr[i] + " ");        pw.println(arr[arr.length - 1]);    }    static void printArr(long[] arr) {        for (int i = 0; i < arr.length - 1; i++)            pw.print(arr[i] + " ");        pw.println(arr[arr.length - 1]);    }    static void printArr(double[] arr) {        for (int i = 0; i < arr.length - 1; i++)            pw.print(arr[i] + " ");        pw.println(arr[arr.length - 1]);    }    static void printArr(Integer[] arr) {        for (int i = 0; i < arr.length; i++)            pw.print(arr[i] + " ");        pw.println();    }    static void printArr(ArrayList<Integer> list) {        for (int i = 0; i < list.size(); i++)            pw.print(list.get(i)+" ");        pw.println();    }    static void printArr(boolean[] arr) {        StringBuilder sb=new StringBuilder();        for(boolean b: arr)            sb.append(Int(b));        pw.println(sb);    }    static class Scanner {        StringTokenizer st;        BufferedReader br;        public Scanner(InputStream s) {            br = new BufferedReader(new InputStreamReader(s));        }         public Scanner(FileReader r) {            br = new BufferedReader(r);        }         public String next() throws IOException {            while (st == null || !st.hasMoreTokens())                st = new StringTokenizer(br.readLine());            return st.nextToken();        }         public int nextInt() throws IOException {            return Integer.parseInt(next());        }         public long nextLong() throws IOException {            return Long.parseLong(next());        }         public String nextLine() throws IOException {            return br.readLine();        }         public double nextDouble() throws IOException {            return Double.parseDouble(next());        }        public int[] nextDigits() throws IOException{            String s=nextLine();            int[] arr=new int[s.length()];            for(int i=0; i<arr.length; i++)                arr[i]=s.charAt(i)-'0';            return arr;        }        public int[] nextArr(int n) throws IOException {            int[] arr = new int[n];            for (int i = 0; i < arr.length; i++)                arr[i] = nextInt();            return arr;        }        public Integer[] nextsort(int n) throws IOException{            Integer[] arr=new Integer[n];            for(int i=0; i<n; i++)                arr[i]=nextInt();            return arr;        }        public Pair nextPair() throws IOException{            return new Pair(nextInt(), nextInt());        }        public long[] nextLongArr(int n) throws IOException{            long[] arr=new long[n];            for (int i = 0; i < n; i++)                arr[i]=sc.nextLong();            return arr;        }        public Pair[] nextPairArr(int n) throws IOException{            Pair[] arr=new Pair[n];            for(int i=0; i<n; i++)                arr[i]=nextPair();            return arr;        }        public boolean ready() throws IOException {            return br.ready();        }    }    static class Pair implements Comparable<Pair>{        int x;        int y;        public Pair(int x, int y) {            this.x=x;            this.y=y;        }        public boolean contains(int a){            return x==a || y==a;        }        public int hashCode() {            return (this.x*1000000000+this.y);        }        public int compareTo(Pair p){            if(x==p.x)                return y-p.y;            return x-p.x;        }        public boolean equals(Object obj) {            if (obj == null) {                return false;            }            if (this.getClass() != obj.getClass()) {                return false;            }            Pair p = (Pair) obj;            return this.x==p.x && this.y==p.y;        }        public Pair clone(){            return new Pair(x, y);        }        public String toString(){            return this.x+" "+this.y;        }        public void add(Pair p){            x+=p.x;            y+=p.y;        }        public Pair negative(){            return new Pair(-x, -y);        }    }    static class LP implements Comparable<LP>{        long x, y;        public LP(long a, long b){            x=a;            y=b;        }        public void add(LP p){            x+=p.x;            y+=p.y;        }        public boolean equals(LP p){            return p.x==x && y==p.y;        }        public String toString(){            return this.x+" "+this.y;        }        public int compareTo(LP p){            int a=Long.compare(x, p.x);            if(a!=0)                return a;            return Long.compare(y, p.y);        }    }    static class Triple implements Comparable<Triple>{        int x, y, z;        public Triple(int a, int b, int c){            x=a;            y=b;            z=c;        }        public int compareTo(Triple t){            if(this.y!=t.y)                return y-t.y;            return x-t.x;        }        public String toString(){            return x+" "+y+" "+z;        }    }}
