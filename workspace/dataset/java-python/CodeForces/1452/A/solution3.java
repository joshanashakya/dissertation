import java.awt.Point;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.PrintWriter;import java.lang.reflect.Array;import java.math.BigDecimal;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.HashSet;import java.util.Hashtable;import java.util.LinkedList;import java.util.PriorityQueue;import java.util.Queue;import java.util.Stack;import java.util.StringTokenizer;  public class Edu98 {	static PrintWriter out;	static Scanner sc;	static ArrayList<Integer>q,w;	static ArrayList<Point>ref[];	static HashSet<Integer>primesH;	static boolean prime[];	//static ArrayList<Integer>a;	static HashSet<Long>h,tmp;	static boolean[][]vis;	static int[]a,b,c,d,parent,dy=new int[] {-1,1,0,0},dx=new int[] {0,0,1,-1};	static long[]l,ti;	static double[][][]dp;	static char[][]mp;	static int px,py,tx,ty;	static long oo=(long)1e18;	public static void main(String[]args) throws IOException {		sc=new Scanner(System.in);		out=new PrintWriter(System.out);		A();		//B();	   // C();		//D();		//E();		//minimum for subarrays of fixed length		//F();		out.close();	}	  private static void A() throws IOException {		   int t=ni();		   while(t-->0) {			   int x=ni(),y=ni();			   int ans=2*Math.min(x, y);			   int left=Math.abs(x-y);			   ans+=(left>0?2*left-1:0);			   out.println(ans);		   }	   }		static void B() throws IOException {								}		static void C() throws IOException{					}  	static void D() throws IOException {					} 	static int gcd (int a, int b) {	    return b==0?a:gcd (b, a % b);	}		static void E() throws IOException {		int t=ni();		while(t-->0) {			long x=nl(),y=nl(),p=nl(),q=nl();			long ans=Long.MAX_VALUE;			for(long t1=x;t1<y+x;t1++) {				for(long t2=p;t2<p+q;t2++) {					long cur=crt(2*x+2*y,t1,p+q,t2);					if(cur!=-1) {						ans=Math.min(ans, cur);					}				}			}			out.println(ans==Long.MAX_VALUE?"infinity":ans);		}	}	  private static long crt(long p, long m, long q, long n) {	        if (p < q) {	            return crt(q, n, p, m);	        }	        long a = p, b = q;	        long pp = 1, qq = 0;	        while (b > 0) {	            final long c = a / b;	            long d;	            d = a;	            a = b;	            b = d % b;	            d = pp;	            pp = qq;	            qq = d - c * qq;	        }	        if ((n - m) % a != 0) {	            return -1;	        }	        final long mod = p / a * q;	        long ret = ((n - m) * pp % q) * (p / a) + m;	        if (ret < 0) {	            ret += mod;	        }	        return ret;	    }	    	private static int flood() {		Queue<Edge>q=new LinkedList<Edge>();		q.add(new Edge(new Point(px,py),0));		vis[px][py]=true;		while(!q.isEmpty()) {			Edge e=q.poll();			Point p=e.p;			int val=e.val,x=p.x,y=p.y;			if(x==tx&&y==ty)return val;			if(mp[x][y]>='a'&&mp[x][y]<='z') {				for(Point np:ref[mp[x][y]-'a']) {					int nx=np.x,ny=np.y;					if(!vis[nx][ny]&&valid(nx,ny)) {						q.add(new Edge(np,val+1));						vis[nx][ny]=true;					}				}				ref[mp[x][y]-'a'].clear();			}			for(int i=0;i<4;i++) {				Point np=new Point(x+dx[i],y+dy[i]);				if(valid(np.x,np.y)&&!vis[np.x][np.y]) {					q.add(new Edge(np,val+1));					vis[np.x][np.y]=true;				}			}		}		return -1;	}	static boolean valid(int i,int j) {		return i>=0&&i<mp.length&&j>=0&&j<mp[0].length&&mp[i][j]!='#';	}	static void F() throws IOException {						}	static class FenwickTree{		int n;int[]ft;		FenwickTree(int n){this.n=n;ft=new int[n+1];}		int rsq(int b) {			int sum =0;			while(b>0) {sum^=ft[b];b-= b & -b;}			return sum;		}		int rsq(int a,int b) {			return rsq(b)^rsq(a-1);		}		void point_update(int k,int val){			while(k<=n) {ft[k]^=val;k+= k & -k;}		} 		int point_query(int idx)	// c * O(log n), c < 1		{			int sum = ft[idx];			if(idx > 0)			{				int z = idx ^ (idx & -idx);				--idx;				while(idx != z)				{					sum ^= ft[idx];					idx ^= idx & -idx;				}			}			return sum;		}			} 	private static void disp(int[] revl) {		for(int i=0;i<revl.length;i++) {			out.print(revl[i]+" ");		}		out.println();	}	static class Pair implements Comparable<Pair>{		int a,b;		Pair(int a,int b){			this.a=a;			this.b=b;		}		@Override		public int compareTo(Pair p) {			return a-p.a;		}		public boolean equals(Pair p) {			return a==p.a&&b==p.b;		}		public String toString() {			return "("+a+" "+b+")";		}	}	static int ni() throws IOException {		return sc.nextInt();	}	static double nd() throws IOException {		return sc.nextDouble();	}	static long nl() throws IOException {		return  sc.nextLong();	}	static String ns() throws IOException {		return sc.next();	}	static int[] nai(int n) throws IOException {		int[] a = new int[n];		for (int i = 0; i < n; i++)			a[i] = sc.nextInt();		return a;	}	static long[] nal(int n) throws IOException {		long[] a = new long[n];		for (int i = 0; i < n; i++)			a[i] = sc.nextLong();		return a;	}	static int[][] nmi(int n,int m) throws IOException{		int[][]a=new int[n][m];		for(int i=0;i<n;i++) {			for(int j=0;j<m;j++) {				a[i][j]=sc.nextInt();			}		}		return a;	} 	static long[][] nml(int n,int m) throws IOException{		long[][]a=new long[n][m];		for(int i=0;i<n;i++) {			for(int j=0;j<m;j++) {				a[i][j]=sc.nextLong();			}		}		return a;	}	static void o(String x) {		out.print(x);	}	static void ol(String x) {		out.println(x);	}	static void ol(int x) {		out.println(x);	}	static void disp1(int []a) {		for(int i=0;i<a.length;i++) {			out.print(a[i]+" ");		}		out.println();	}	static void disp2(Pair []a) {		for(int i=0;i<a.length;i++) {			out.print(a[i]+" ");		}		out.println();	}	static class Edge {		Point p;		int val;		Edge(Point a,int b){			p=a;			val=b;		}			}	static class Scanner 	{		StringTokenizer st;		BufferedReader br; 		public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));} 		public String next() throws IOException 		{			while (st == null || !st.hasMoreTokens()) 				st = new StringTokenizer(br.readLine());			return st.nextToken();		}		public boolean hasNext() {return st.hasMoreTokens();}		public int nextInt() throws IOException {return Integer.parseInt(next());}				public double nextDouble() throws IOException {return Double.parseDouble(next());}				public long nextLong() throws IOException {return Long.parseLong(next());} 		public String nextLine() throws IOException {return br.readLine();}					public boolean ready() throws IOException {return br.ready(); }		 	}}
