import java.io.*;import java.util.*; public class MAIN{     private static BufferedReader reader = null;    private static BufferedWriter writer = null;     public static void main(String[] args) throws Exception{         reader = new BufferedReader(new InputStreamReader(System.in));         Map<String, Integer> map = new HashMap<>(0);        int n = Integer.parseInt(reader.readLine());        for(int i=0;i<n;++i){            String s = reader.readLine();            Integer c = map.get(s);            if(c == null){                map.put(s, 1);            } else {                // nothing to do, already picked            }        }         System.out.println(map.size());     }     private static class IntIntPair{        int first;        int second;        public IntIntPair(int first, int second) {            this.first = first;            this.second = second;        }        public IntIntPair getInversePair(){            return new IntIntPair(                    this.second,                    this.first            );        }        public boolean equals(IntIntPair p){            return p.first == this.first && p.second == this.second;        }    }    private static class StringStringPair{        String first;        String second;        public StringStringPair(String first, String second) {            this.first = first;            this.second = second;        }        public StringStringPair getInversePair(){            return new StringStringPair(                    this.second,                    this.first            );        }        public boolean equals(StringStringPair p){            return p.first.equals(this.first) && p.second.equals(this.second);        }    }    private static class StringIntPair{        String first;        int second;        public StringIntPair(String first, int second) {            this.first = first;            this.second = second;        }        public boolean equals(StringIntPair p){            return p.first.equals(this.first) && p.second == this.second;        }    }     private static List<List<Integer>> getCombinations(int[] a, int count){        List<List<Integer>> ret = new ArrayList<>(0);        if(a == null || a.length > 64 || count <= 0 || count > a.length){            return null;        } else {            long lim = (1L<<a.length);            for(long i=0;i<lim;++i){                List<Integer> poss = getBitPositionList(i);                if(poss.size() == count){                    List<Integer> list = new ArrayList<>(0);                    for(int j=0;j< poss.size();++j){                        list.add(a[poss.get(j)]);                    }                    ret.add(list);                }            }        }        return ret;     }     private static int getBitCount(long n){        int onCount = 0;        for(long i=0L;i<64L;++i){            if((n&(1L<<i)) != 0){                ++onCount;            }        }        return onCount;    }    private static List<Integer> getBitPositionList(long n){        List<Integer> idxs = new ArrayList<>(0);        for(long i=0L;i<64L;++i){            if((n&(1L<<i)) != 0){                idxs.add(((int) i));            }        }        return idxs;    }    private static IntIntPair getIrreducibleFraction(int x, int y){        int min = (x <= y) ? x : y;        for(int i=2; i<=min; ++i){            while (x%i==0 && y%i==0){                x = x/i;                y = y/i;            }        }        return new IntIntPair(x,y);    }     private static int getDigitSumInBase(int n, int b){        int sum = 0;        while (true){            sum += n%b;            n = n/b;            if(n==0){                break;            }        }        return sum;    }     private static List<Integer> getSegmentedPrimes(int start, int end){         List<Integer> ret = new ArrayList<>(0);        List<Integer> primes = getPrimes(((int) Math.ceil(Math.sqrt(end))));         boolean[] flags = new boolean[(end-start+1)+1];        for(int i=0; i< flags.length; ++i){            flags[i] = true;        }        for(int i=0;i< primes.size();++i){            int lLim = (start / primes.get(i)) * primes.get(i);            while (lLim< start) {                lLim += primes.get(i);            }            for (int j = lLim; j <= end; j += primes.get(i)){                flags[j- start] = false;            }        }        for(int i = start; i<= end; ++i){            if(flags[i- start]){                ret.add(i);            }        }         return ret;     }    private static List<Integer> getPrimes(int n){         List<Integer> primes = new ArrayList<>(0);         boolean[] flags = new boolean[n+1];        for(int i=0; i<flags.length; ++i){            flags[i] = true;        }        flags[0] = false;        flags[1] = false;         for(int i=2;i*i<=n;++i){            if(flags[i]){                for(int j = i*i; j <= n; j += i){                    flags[j] = false;                }            }        }         for(int i=0, len = n+1; i < len; ++i){            if(flags[i]){                primes.add(i);            }        }         return primes;    }    private static boolean isPrime(int n){        if(n<=1){            return false;        } else if(n==2){            return true;        } else {            for(int i=2;i<n;++i){                if(n%i == 0){                    return false;                }            }        }        return true;    }     private static void displayArray(int[] A, String header){        System.out.println(header);        for (int i=0;i<A.length; ++i){            System.out.println(A[i]);        }    }    private static void displayList(List<Integer> L, String header){        System.out.println(header);        for (int i=0;i<L.size(); ++i){            System.out.println(L.get(i));        }    }     private static void swap(boolean[] arr, int i1, int i2){        boolean tmp = arr[i1];        arr[i1] = arr[i2];        arr[i2] = tmp;    } }
