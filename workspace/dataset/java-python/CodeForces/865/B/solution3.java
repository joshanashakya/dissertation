import java.io.*;import java.math.BigInteger;import java.util.*;   public class Main {		static InputReader in = new InputReader(System.in);	static PrintWriter out = new PrintWriter(System.out);		static int oo = (int)1e9;//	static long oo = (long)1e15;	static int mod = 1_000_000_007;//	static int mod = 998244353;		static int[] dx = {0, -1, -1, -1, 0, 1, 1, 1};	static int[] dy = {-1, -1, 0, 1, 1, 1, 0, -1};		static int M = 1000005;	static double EPS = 1e-13;		public static void main(String[] args) throws IOException {Â 		int n = in.nextInt();		int S = in.nextInt();		ArrayList<Con> prefA = new ArrayList<>();		ArrayList<Con> prefB = new ArrayList<>();		long sum = 0, sum1 = 0, sum2 = 0;		for(int i = 0; i < n; ++i) {			int s = in.nextInt();			int a = in.nextInt();			int b = in.nextInt();			Con con = new Con(i, s, a, b);			if(a >= b) {				prefA.add(con);				sum1 += s;			}			else {				prefB.add(con);				sum2 += s;			}			sum += s;		}		Collections.sort(prefA, (x, y) -> -Integer.compare(x.a - x.b, y.a - y.b));		Collections.sort(prefB, (x, y) -> -Integer.compare(x.b - x.a, y.b - y.a));		long need = sum / S + (sum % S > 0 ? 1 : 0);		long need1 = sum1 / S + (sum1 % S > 0 ? 1 : 0);		long need2 = sum2 / S + (sum2 % S > 0 ? 1 : 0);		need *= S;		need1 *= S;		need2 *= S;		if(need1 + need2 == need) {			long ans = maxHappiness(prefA, prefB, need1, need2);			System.out.println(ans);		}		else {			long h1 = maxHappiness(prefA, prefB, need1 - S, need2);			long h2 = maxHappiness(prefA, prefB, need1, need2 - S);			long ans = Math.max(h1, h2);			System.out.println(ans);		}				out.close();	}		static long maxHappiness(ArrayList<Con> prefA, ArrayList<Con> prefB, long a, long b) {		long ret = 0;		for(Con con : prefA) {			long x = Math.min(a, con.s);			long y = con.s - x;			ret += con.a * x + con.b * y; 			a -= x; b -= y;		}		for(Con con : prefB) {			long y = Math.min(b, con.s);			long x = con.s - y;			ret += con.a * x + con.b * y;			a -= x; b -= y;		}		return ret;	}		static class Con {		int idx;		int s, a, b;		public Con(int idx, int s, int a, int b) {			super();			this.idx = idx;			this.s = s;			this.a = a;			this.b = b;		}	}			static void update(int[] f, int i) {		while(i < f.length) {			f[i]++;			i += (i & -i);		}	}		static int query(int[] f, int i) {		int ret = 0;		while(i > 0) {			ret += f[i];			i -= (i & -i);		}		return ret;	}		static long invmod(long a, long mod) {		BigInteger b = BigInteger.valueOf(a);		BigInteger m = BigInteger.valueOf(mod);		return b.modInverse(m).longValue();	}			static int find(int[] g, int x) {		return g[x] = g[x] == x ? x : find(g, g[x]);	}		static void union(int[] g, int[] size, int x, int y) {		x = find(g, x); y = find(g, y);		if(x == y)			return;		if(size[x] < size[y]) {			g[x] = y;			size[y] += size[x];		}		else {			g[y] = x;			size[x] += size[y];		}	}		static class Segment {		Segment left, right;		int size;		int max;//		int time, lazy;				public Segment(int[] a, int l, int r) {			super();			if(l == r) {				this.max = a[l];				return;			}			int mid = (l + r) / 2;			left = new Segment(a, l, mid);			right = new Segment(a, mid+1, r);			this.max = Math.max(left.max, right.max);		}				boolean covered(int ll, int rr, int l, int r) {			return ll <= l && rr >= r;		}				boolean noIntersection(int ll, int rr, int l, int r) {			return ll > r || rr < l;		}		//		void lazyPropagation() {//			if(lazy != 0) {//				if(left != null) {//					left.setLazy(this.time, this.lazy);//					right.setLazy(this.time, this.lazy);//				}//				else {//					val = lazy;//				}//			}//		}		//		void setLazy(int time, int lazy) {//			if(this.time != 0 && this.time <= time)//				return;//			this.time = time;//			this.lazy = lazy;//		}						int querySize(int ll, int rr, int l, int r) {//			lazyPropagation();			if(noIntersection(ll, rr, l, r))				return 0;			if(covered(ll, rr, l, r))				return size;			int mid = (l + r) / 2;			int leftSize = left.querySize(ll, rr, l, mid);			int rightSize = right.querySize(ll, rr, mid+1, r);			return leftSize + rightSize;		}				int query(int k, int l, int r) {			Segment trace = this;			while(l < r) {				int mid = (l + r) / 2;				if(trace.left.size > k) {					trace = trace.left;					r = mid;				}				else {					k -= trace.left.size;					trace = trace.right;					l = mid + 1;				}			}			return l;		}				void update(int ll, int rr, int value, int l, int r) {//			lazyPropagation();			if(noIntersection(ll, rr, l, r))				return;			if(covered(ll, rr, l, r)) {//				setLazy(time, knight);				this.max = value;				return;			}			int mid = (l + r) / 2;			left.update(ll, rr, value, l, mid);			right.update(ll, rr, value, mid+1, r);			this.max = Math.max(left.max, right.max);		}	}		static long pow(long a, long n, long mod) {		if(n == 0)			return 1;		if(n % 2 == 1)			return a * pow(a, n-1, mod) % mod;		long x = pow(a, n / 2, mod);		return x * x % mod;	}			static int[] getPi(char[] a) {		int m = a.length;		int j = 0;		int[] pi = new int[m];		for(int i = 1; i < m; ++i) {			while(j > 0 && a[i] != a[j])				j = pi[j-1];			if(a[i] == a[j]) {				pi[i] = j + 1;				j++;			}		}		return pi;	}		static long lcm(long a, long b) {		return a * b / gcd(a, b);	}		static BigInteger lcm2(long a, long b) {		long g = gcd(a, b);		BigInteger gg = BigInteger.valueOf(g);		BigInteger aa = BigInteger.valueOf(a);		BigInteger bb = BigInteger.valueOf(b);		return aa.multiply(bb).divide(gg);	}		static boolean nextPermutation(int[] a) {		for(int i = a.length - 2; i >= 0; --i) {			if(a[i] < a[i+1]) {				for(int j = a.length - 1; ; --j) {					if(a[i] < a[j]) {						int t = a[i];						a[i] = a[j];						a[j] = t;						for(i++, j = a.length - 1; i < j; ++i, --j) {							t = a[i];							a[i] = a[j];							a[j] = t;						}						return true;					}				}			}		}		return false;	}		static void shuffle(Object[] a) {		Random r = new Random();		for(int i = a.length - 1; i > 0; --i) {			int si = r.nextInt(i);			Object t = a[si];			a[si] = a[i];			a[i] = t;		}	}		static void shuffle(int[] a) {		Random r = new Random();		for(int i = a.length - 1; i > 0; --i) {			int si = r.nextInt(i);			int t = a[si];			a[si] = a[i];			a[i] = t;		}	}		static void shuffle(long[] a) {		Random r = new Random();		for(int i = a.length - 1; i > 0; --i) {			int si = r.nextInt(i);			long t = a[si];			a[si] = a[i];			a[i] = t;		}	}		static int lower_bound(int[] a, int n, int k) {		int s = 0;		int e = n;		int m;		while (e - s > 0) {			m = (s + e) / 2;			if (a[m] < k)				s = m + 1;			else				e = m;		}		return e;	}	static int lower_bound(long[] a, int n, long k) {		int s = 0;		int e = n;		int m;		while (e - s > 0) {			m = (s + e) / 2;			if (a[m] < k)				s = m + 1;			else				e = m;		}		return e;	}		static int gcd(int a, int b) {		return b == 0 ? a : gcd(b, a % b);	}	static long gcd(long a, long b) {		return b == 0 ? a : gcd(b, a % b);	}	static BigInteger gcd(BigInteger a, BigInteger b) {		return b.compareTo(BigInteger.ZERO) == 0 ? a : gcd(b, a.mod(b));	}		static class Pair implements Comparable<Pair> {		int first, second; 		public Pair(int first, int second) {			super();			this.first = first;			this.second = second;		} 		@Override		public int compareTo(Pair o) {			return this.first != o.first ? this.first - o.first : this.second - o.second;		}		//		@Override//		public int compareTo(Pair o) {//			return this.first != o.first ? o.first - this.first : o.second - this.second;//		} 		@Override		public int hashCode() {			final int prime = 31;			int result = 1;			result = prime * result + first;			result = prime * result + second;			return result;		} 		@Override		public boolean equals(Object obj) {			if (this == obj)				return true;			if (obj == null)				return false;			if (getClass() != obj.getClass())				return false;			Pair other = (Pair) obj;			if (first != other.first)				return false;			if (second != other.second)				return false;			return true;		}	}}   class InputReader { 	private final InputStream stream;	private final byte[] buf = new byte[8192];	private int curChar, snumChars; 	public InputReader(InputStream st) {		this.stream = st;	} 	public int read() {		if (snumChars == -1)			throw new InputMismatchException();		if (curChar >= snumChars) {			curChar = 0;			try {				snumChars = stream.read(buf);			} catch (IOException e) {				throw new InputMismatchException();			}			if (snumChars <= 0)				return -1;		}		return buf[curChar++];	} 	public int nextInt() {		int c = read();		while (isSpaceChar(c)) {			c = read();		}		int sgn = 1;		if (c == '-') {			sgn = -1;			c = read();		}		int res = 0;		do {			res *= 10;			res += c - '0';			c = read();		} while (!isSpaceChar(c));		return res * sgn;	} 	public long nextLong() {		int c = read();		while (isSpaceChar(c)) {			c = read();		}		int sgn = 1;		if (c == '-') {			sgn = -1;			c = read();		}		long res = 0;		do {			res *= 10;			res += c - '0';			c = read();		} while (!isSpaceChar(c));		return res * sgn;	} 	public int[] nextIntArray(int n) {		int a[] = new int[n];		for (int i = 0; i < n; i++) {			a[i] = nextInt();		}		return a;	} 	public String readString() {		int c = read();		while (isSpaceChar(c)) {			c = read();		}		StringBuilder res = new StringBuilder();		do {			res.appendCodePoint(c);			c = read();		} while (!isSpaceChar(c));		return res.toString();	} 	public String nextLine() {		int c = read();		while (isSpaceChar(c))			c = read();		StringBuilder res = new StringBuilder();		do {			res.appendCodePoint(c);			c = read();		} while (!isEndOfLine(c));		return res.toString();	} 	public boolean isSpaceChar(int c) {		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;	} 	private boolean isEndOfLine(int c) {		return c == '\n' || c == '\r' || c == -1;	} }
