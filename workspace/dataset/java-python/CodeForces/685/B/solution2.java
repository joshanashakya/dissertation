/*    Method 2, using Small to Large Merging. *///created by Whiplash99import java.io.*;import java.util.*;public class A{    private static ArrayDeque<Integer>[] edge;    private static TreeSet<Pair>[] set;    private static int[] ans;     static class Pair implements Comparable<Pair>    {        int f, s;        Pair(int f, int s){this.f = f;this.s = s;}        public int compareTo(Pair b){return Integer.compare(this.s,b.s);}    }    private static void merge(int u, int v) //Small to Large    {        for(Pair x:set[v])            set[u].add(x);    }    private static int DFS(int u)    {        int sizeU=1;        for(int v:edge[u])        {            int sizeV=DFS(v);            if(sizeV>sizeU)            {                TreeSet tmp=set[v];                set[v]=set[u];                set[u]=tmp;            }            merge(u,v);            sizeU+=sizeV;        }         set[u].add(new Pair(u,sizeU));        ans[u]=set[u].ceiling(new Pair(0,(sizeU+1)/2)).f;         return sizeU;    }    public static void main(String[] args) throws IOException    {        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));         int i,N;         String[] s=br.readLine().trim().split(" ");        N=Integer.parseInt(s[0]);        int Q=Integer.parseInt(s[1]);         ans=new int[N];        edge=new ArrayDeque[N]; set=new TreeSet[N];        for(i=0;i<N;i++) set[i]=new TreeSet<>();        for(i=0;i<N;i++) edge[i]=new ArrayDeque<>();         s=br.readLine().trim().split(" ");        for(i=0;i<N-1;i++)        {            int u=Integer.parseInt(s[i])-1;            edge[u].add(i+1);        }         DFS(0);         StringBuilder sb=new StringBuilder();        while (Q-->0)        {            int u=Integer.parseInt(br.readLine().trim())-1;            sb.append(ans[u]+1).append("\n");        }         System.out.println(sb);    }}
