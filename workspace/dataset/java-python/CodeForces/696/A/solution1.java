import java.io.*;import java.util.HashMap;import java.util.StringTokenizer; public class Lorenzo {    public static void main(String[] args) {        InputStream inputStream = System.in;        OutputStream outputStream = System.out;        InputReader in = new InputReader(inputStream);        PrintWriter out = new PrintWriter(outputStream);        TaskA solver = new TaskA();        solver.solve(1, in, out);        out.close();    }     public static class Edge {        private final long x;        private final long y;        public Edge(long x, long y) {            this.x = x;            this.y = y;        }        @Override        public boolean equals(Object obj) {            Edge other = (Edge) obj;            if(this.x == other.x && this.y == other.y)                return true;            else                return false;        }        @Override        public int hashCode() {            return (int) (x + y + x * y);        }    }    static class TaskA {        int n;        int q;        long c[];        long v[];        long u[];        long w[];        HashMap<Edge, Long> edgeWtMap = new HashMap<Edge, Long>();         public void fill(int testNumber, InputReader in, PrintWriter out) {            q = in.nextInt();            c = new long[q+1];            v = new long[q+1];            u = new long[q+1];            w = new long[q+1];            for (int i = 1; i <= q; i++) {                c[i] = Long.parseLong(in.next());                v[i] = Long.parseLong(in.next());                u[i] = Long.parseLong(in.next());                if(c[i] == 1)                    w[i] = Long.parseLong(in.next());            }        }         public long lca(long x, long y) {            if(x == y)                return x;            else if(x<y)                return lca(x, y/2);            else                return lca(x/2, y);        }        public void increase(long u, long p, long w) {            if(u != p) {                Edge edge1 = new Edge(u, u/2);                Edge edge2 = new Edge(u/2, u);                long curWt1 = 0;                if(edgeWtMap.containsKey(edge1))                    curWt1 = edgeWtMap.get(edge1);                edgeWtMap.put(edge1, curWt1 + w);                long curWt2 = 0;                if(edgeWtMap.containsKey(edge2))                    curWt2 = edgeWtMap.get(edge2);                edgeWtMap.put(edge2, curWt2 + w);                 increase(u/2, p, w);            }        }         public long pathSum(long u, long p) {            if(u == p)                return 0;            else {                long wt = 0;                Edge key = new Edge(u, u/2);                if(edgeWtMap.containsKey(key))                    wt = edgeWtMap.get(key);                 return wt + pathSum(u/2, p);            }        }        public void solve(int testNumber, InputReader in, PrintWriter out) {            fill(testNumber, in, out);            for (int i = 1; i <= q; i++) {                long p = lca(v[i], u[i]);                if(c[i] == 1) {                    increase(u[i], p, w[i]);                    increase(v[i], p, w[i]);                }                else                    out.println(pathSum(u[i], p) + pathSum(v[i], p));            }         }    }     static class InputReader {        public BufferedReader reader;        public StringTokenizer tokenizer;         public InputReader(InputStream stream) {            reader = new BufferedReader(new InputStreamReader(stream), 32768);            tokenizer = null;        }         public String next() {            while (tokenizer == null || !tokenizer.hasMoreTokens()) {                try {                    tokenizer = new StringTokenizer(reader.readLine());                } catch (IOException e) {                    throw new RuntimeException(e);                }            }            return tokenizer.nextToken();        }         public int nextInt() {            return Integer.parseInt(next());        }     }  } 
