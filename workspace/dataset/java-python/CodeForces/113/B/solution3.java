 import java.util.ArrayList;import java.util.Arrays;import java.util.Scanner;import java.util.Stack;  public class UkkForTesting{	static int[] suffixOccurrences;	static Node root;		//for debugging	static boolean debug = false; //Construction debug	static boolean debug2 = false;		static int LETTERS = 26; //0-25 for a to z, 26 for $.	static int computation = 0;		static class SuffixTree	{		Node root = null;		String s;		int nodes = 0;		int currentEnd = 0;				void findSubstring(String p)		{			ArrayList<Integer> l = new ArrayList<>();			Node posNode = root;			Edge posEdge = null;			int posLength = 0;						int i = 0; 			while(i < p.length())			{				//from node, go to edge!				posEdge = posNode.getEdgeOfChar(p.charAt(i));				posLength = 0;				//traverse that edge!								if(posEdge == null)					return;								while(posEdge != null && posLength < posEdge.getLength())				{					//compare next char					if(s.charAt(posEdge.s + posLength) == p.charAt(i))					{						i++;						posLength++;						if(i >= p.length())break;					}					else					{ //mismatch!						return;					}				}				if(posLength == posEdge.getLength()) //reached end of edge				{					if(posEdge.node != null)					{						posNode = posEdge.node;						posLength = 0;					}				}			}						Stack<Edge> stack = new Stack<>();			if(posLength == 0)			{				for(int cc = 0; cc < LETTERS+1; cc++)				{ //if edge is not leaf, it ends in a node. add all edges going out from that node to stack.					if(posNode.edge[cc] != null)						stack.add(posNode.edge[cc]);				}			}			else stack.add(posEdge);						while(!stack.isEmpty())			{ 				Edge e = stack.pop();				if(e.node == null) //if edge is leaf, print out					l.add(e.getStartChar());				else				{					for(int cc = 0; cc < LETTERS+1; cc++)					{ //if edge is not leaf, it ends in a node. add all edges going out from that node to stack.						if(e.node.edge[cc] != null)							stack.add(e.node.edge[cc]);					}				}			}			l.sort(null);			for(int z = 0; z < l.size(); z++)				System.out.println(l.get(z));		}				void findSuffixOccurrences(String p)		{			//This function is mostly copied from findSubstring, the function to find a substring in the suffix tree in general.			//The difference is, in this function when an occurrence of the suffix p is found, suffixOccurrence[index where occurrence ends]			//is incremented (set to 1, since there can't be more than 1 in the same place)						//and in the end of the function, we sum the values from 0 to n-1 so that suffixOccurrence[i] equals the sum of the			//original values of suffixOccurrence[0...i]						//Of course, suffixOcurrences can also be obtained through other methods such as KMP.						suffixOccurrences = new int[s.length()*2];			Node posNode = root;			Edge posEdge = null;			int posLength = 0;						int i = 0; //i: character of prefix to traverse 			while(i < p.length())			{				//from node, go to edge!				posEdge = posNode.getEdgeOfChar(p.charAt(i));				posLength = 0;				//traverse that edge!								if(posEdge == null)					return;								while(posEdge != null && posLength < posEdge.getLength())				{					//compare next char					if(s.charAt(posEdge.s + posLength) == p.charAt(i))					{						i++;						posLength++;						if(i >= p.length())break;					}					else					{ //mismatch!//						System.out.println("");						return;					}				}				if(posLength == posEdge.getLength()) //reached end of edge				{					if(posEdge.node != null)					{						posNode = posEdge.node;						posLength = 0;					}				}			}						Stack<Edge> stack = new Stack<>();			if(posLength == 0)			{				for(int cc = 0; cc < LETTERS+1; cc++)				{ //if edge is not leaf, it ends in a node. add all edges going out from that node to stack.					if(posNode.edge[cc] != null)						stack.add(posNode.edge[cc]);				}			}			else stack.add(posEdge);						while(!stack.isEmpty())			{ 				Edge e = stack.pop();				if(e.node == null) //if edge is leaf, print out				{					suffixOccurrences[e.getStartChar() + p.length()-1] = 1;//					System.out.println("Found at " + e.getStartChar());				}				else				{					for(int cc = 0; cc < LETTERS+1; cc++)					{ //if edge is not leaf, it ends in a node. add all edges going out from that node to stack.						if(e.node.edge[cc] != null)							stack.add(e.node.edge[cc]);					}				}			}						for(int x = 1; x < s.length(); x++)			{				suffixOccurrences[x] += suffixOccurrences[x-1];			}		}				int lookForSOInEdge(Edge e, int posLength, String p, String suf)		{			//debug2=true;			//Look for suffix occurrences in this edge and return them, but exclude any occurrences			//that are shallower than current position or shorter than p.						if(e == null || e.done)return 0;			e.done = true;						if(debug2)System.out.println("Look for SO's in edge " + e.s + " " + e.getEnd() + ", posLength " + posLength);			//LEAF!			int soE = suffixOccurrences[e.getEnd()]; //end's SO			int depth = e.startCharDepth + posLength+1; //current chardepth			//e.startCharDepth is the distance to the edge's origin node						int starter = e.s+ posLength; //Previously didn't include + posLength, but that should be wrong even though no actual countercase can occur			//starter: index of suffixOccurrence to exclude.		   //e.s is edge's starting character (index in main string, not depth!)						//WAS OLD AND WRONG			int orist = starter;						//System.out.println("Depthbug " + depth + " " + suf.length() + ", starter is " + starter);						//Here, we are looking among positions from depth depth. These positions depict strings of length of its depth.			//We must ignore the positions whose strings are shorter than suffix.			//Thus, we ignore positions with depth less than suffix length.						int minDepth = suf.length();			if(depth < minDepth)			{ //Move forward as needed.				int depthDiff = minDepth - depth; //move starter forwards this much.				starter += depthDiff;				if(starter > e.getEnd())return 0;			}						//Old notes below.			//if(depth < suf.length()-1)starter = e.s + suf.length()-depth; 				//   if depth is too shallow, starter must go to the shallowest depth IN THIS EDGE that is deep enough to contain suffix				//as in the depth of starter must >= suffix's length. since starter's notation is in string index, we must shove starter			    //along the edge as much as "the rest of suffix's length", which is (suf.length()-depth).							//	note that even if the depth is too shallow for suffix, the suffixOccurrence at current position may still be greater than zero				//because the suffixOccurrence includes any occurrences from all edges whose index-wise position is lesser than current edge.				//We need to exclude those too, not just occurrences in the current edge.			//Old notes_end						int orist2 = starter;						/* below is not needed if we don't call the first edge as a whole			if(depth < p.length()-1)			{				System.out.println("BETWEEN " + starter + " and " + (e.s + (p.length()-1)-depth));				starter = Math.max(starter, e.s + (p.length()-1)-depth); 							}			*/						//System.out.println(starter + " " + e.getEnd());			//System.out.println(orist + " " + orist2 + " " + starter);						if(starter <= e.getEnd())			{				if(debug2)System.out.println("starter (current chardepth) " + starter);				int fruit = 0;				if(starter-1 >= 0)				{					int soS = suffixOccurrences[starter-1]; //exclude out-of-range occurrences					if(debug2)System.out.println("STARTCHAR " + starter + ", soS " + soS + " soE " + soE);					fruit = soE - soS;				}				else				{					fruit = soE;					if(debug2)System.out.println("STARTCHAR " + starter + ", soE " + soE);				}				if(debug2)System.out.println("Fruit " + fruit + "\n");				return fruit;			}			else return 0;		}				void countPreXSuf(String p, String suf) //p=prefix		{			int bd = 0;						Node posNode = root;			Edge posEdge = null;			int posLength = 0;						int i = 0; //i: prefix char being traversed						while(i < p.length())			{ //traverse p!				//from node, go to edge!				posEdge = posNode.getEdgeOfChar(p.charAt(i));				posLength = 0;				//traverse that edge!								Edge e = posEdge;								//Don't count those before the prefix.				//bd += lookForSOInEdge(e, posLength, p, suf);								if(posEdge == null)				{					System.out.println(0);					return;				}								while(posEdge != null && posLength < posEdge.getLength())				{					//compare next char					if(s.charAt(posEdge.s + posLength) == p.charAt(i))					{						i++;						posLength++;						if(i >= p.length())break;					}					else					{ //mismatch!						System.out.println(0);						return;					}				}				if(posLength == posEdge.getLength()) //reached end of edge				{					if(posEdge.node != null)					{						posNode = posEdge.node;						posLength = 0;					}				}			}						//traversed to prefix! Now do a depth-first search to check the subtree.			if(debug2)System.out.println("Traversed to prefix!!\n\n");						//Check where we landed after we traversed prefix!			Stack<Edge> stack = new Stack<>(); 			//When landing on nodes, evaluate and add outgoing edges to stack.			//Also, check if this exact point (the node) is also a suffix occurrence.			if(posLength == 0)			{ //Landed on node: add outgoing edges to stack.				if(debug2)System.out.println("Landed right on node! Edge to this node: " + posEdge.s + " " + posEdge.e);								for(int cc = 0; cc < LETTERS+1; cc++)				{ //if edge is not leaf, it ends in a node. add all edges going out from that node to stack for traversal.					//Also, count the SOs on each whole edge we add to stack.					if(posNode.edge[cc] != null)					{						stack.add(posNode.edge[cc]);						bd += lookForSOInEdge(posNode.edge[cc], 0, p, suf);					}				}								//Check if this point is a suffix occurrence.								//Node that depth needs to be at least |S| for this to happen.								if(debug2)System.out.println("Landed NODE DEPTH: " + posNode.chardepth); 				int occHere = 0;				if(posNode.chardepth >= suf.length())				{					if(posEdge.e == 0)occHere = suffixOccurrences[posEdge.e];					else occHere = suffixOccurrences[posEdge.e] - suffixOccurrences[posEdge.e-1];				}								bd += occHere;				if(debug2)System.out.println("Occurrence right on node: " + occHere);									} 						//Otherwise, if we land in the middle of an edge, this edge is special in that we evaluate the edge from posLength, since			//we only count part of the edge, not whole.			//Still, add to the stack because we need to traverse form here.			else 			{				if(debug2)System.out.println("Landed in the middle of edge " + posEdge.s + " " + posEdge.e + ", with posLength " + posLength);								//Note that we also need to count any suffix occurrences at the last letter of the prefix, hence posLength-1.				bd += lookForSOInEdge(posEdge, Math.max(posLength-1,0), p, suf);				stack.add(posEdge);			}						//Traverse from thereon.			//MARKSET			while(!stack.isEmpty())			{ 				Edge e = stack.pop();				if(debug2)					if(e.node != null)						System.out.println("Traverse to the end of: " + e.s + " " + e.e + " with an end node");					else						System.out.println("Traverse to the end of leaf node: " + e.s + " " + e.e);				//bd += lookForSOInEdge(e, posLength, p, suf); 				if(e.node != null) //if edge is not leaf, also check out its outgoing edges (add to stack)					for(int cc = 0; cc < LETTERS+1; cc++)					{						if(e.node.edge[cc] != null)						{							if(debug2)System.out.println("Add to stack edge " + e.node.edge[cc].s + " " + e.node.edge[cc].e);							stack.add(e.node.edge[cc]);							//bd += lookForSOInEdge(posNode.edge[cc], 0, p, suf);							bd += lookForSOInEdge(e.node.edge[cc], 0, p, suf);						}					}			}						System.out.println(bd);		}				void findLeavesFrom(Node node, Edge edge, int posLength)		{ 		}				public SuffixTree(String s0)		{ //Construct suffix tree using Ukkonen's algorithm!			s = s0;			root = new Node(this);						Node posNode = root;			int posEdge = -1;			int posLength = 0; //length from cur node						s = s + "$";						int j = 0; //starting character of the suffix to add in extension (0 <= j <= i)			for(int i = 0; i < s.length(); i++)			{ //pos is currently the position of S[j-1...i]												if(debug)					System.out.println("\n[PHASE START!!!] i = " + i + ", '" + s.charAt(i) + "'");				Node linkFrom = null; //new node on previous extension. if one wasn't created, null.								//implicit extensions from 1 ~ ji done by simply updating the "current end" (for leaves) to i.				currentEnd = i;								//SEA algorithm.				int extension = 1;								//"gamma" is the path to travel in extensions except the first one of each phase.				//The path "gamma" is determined during the previous extension.				int gammas = 0; //"Gamma start" the start (first letter) of gamma path, expressed by letter's index in string s.				int gammae = 0; //"Gamma end" the final letter of the gamma path, expressed by letter's index in string s.				//Gamma is "inclusive", meaning the path includes the letters at both indices gammas and gammae,				//making the length gammae-gammas+1.								boolean usedSuffixLink = false;								while(j <= i)				{					computation++; //Count how many extensions are done for debugging & analysis.					boolean rule3 = false;					if(debug)					{						System.out.println("\n Gonna do extension! j = " + j + "\nposNode " + posNode);						System.out.println("posEdge " + posEdge);						System.out.println("posLength " + posLength);					}										//1. Traverse gamma if needded.					if(extension == 1)					{ //No need to traverse gamma in the first extension of each phase! Do nothing.					}					else					{ 						{ //Traverse gamma.							int gammaLen = gammae - gammas + 1;							int remDis = gammae - gammas + 1;							int traveledDis = gammaLen - remDis;							if(debug)							{								System.out.println("Traverse gamma... [!!!!!!!!!!!] Gamma length = " + gammaLen);								System.out.println("Gamma: " + gammas + " " + gammae);							}														Edge realEdge = null;							int remEdgeLen = 0;														if(!usedSuffixLink)								posEdge = gammas;														while(remDis > 0)							{ //Continue traversing gamma until remaining distance in the path is exhausted.								if(gammaLen > 0)								{ //update realEdge pointer & remEdgeLen									realEdge = posNode.getEdgeOfChar(s.charAt(posEdge));//posEdge));									if(realEdge!=null)remEdgeLen = realEdge.getEnd() - (posLength+realEdge.s)+1; 									//remEdgeLen: how many more letters in this edge can we walk on?								}																if(remDis < remEdgeLen)								{ //we wound up in the middle of the edge!									posLength += remDis;//new: update poslength!									remDis = 0;									if(debug)System.out.println("We landed in the middle of the edge!");								}								else if(remDis >= remEdgeLen)								{ //we wound up right on the node, or crossed it!									remDis -= remEdgeLen;																		//change node & edge accordingly...									posNode = realEdge.node;									traveledDis = gammaLen - remDis;									posEdge = gammas + traveledDis;									posLength = 0;									//In case we've crossed it, the while loop will continue. For this, we've updated the posEdge									//so that we will go to the right direction according to the gamma path.									//Otherwise, we've simply landed on the node with posLength 0.																		if(debug)									{										if(remDis == 0)											System.out.println("Landed right on node " + posNode.id + "!");										else											System.out.println("Crossed node " + posNode.id + "! Going out on some edge that goes out from this node...");										System.out.println("     remEdgeLen " + remEdgeLen + ", remdis " + remDis + " posEdge " + posEdge + ", gammas " + gammas + ", traveled " + traveledDis);										System.out.println("     posLength " + posLength);									}																		assert(posNode.getEdgeOfChar(s.charAt(posEdge)) != null) : "We're travelling gamma down again but edge is not found!";								}							}						}					}										//2. Execute extension rules, now that we're here					{ //(Note: we don't change the position variables during the step, so they remain the position from which we execute the extension rules, we don't yet move the cursor towards the direction of the extension until the end of the extension, not in this step)						Edge realEdge;						if(posEdge == -1)realEdge = null;						else realEdge = posNode.getEdgeOfChar(s.charAt(posEdge));												if(realEdge != null && debug)System.out.println("posEdge " + posEdge + " realEdge length " + realEdge.getLength());												if(posLength == 0) //we landed on a node						{ //posNode doesn't have edge for this char, meaning...							//does the node already have this char?							if(posNode.edge[chartoint(s.charAt(i))] == null)							{								if(debug)								{									System.out.println("Since we land in a node that doesn't already has " + s.charAt(i) + "...");									System.out.println("Rule 2 extension!");								}								posNode.edge[chartoint(s.charAt(i))] = new Edge(this, i, -1, posNode.chardepth);								if(debug)System.out.println("Created new edge for node " + posNode + " that starts with " + s.charAt(i));							}							else							{								if(debug)								{									System.out.println("Since we land in a node that already has " + s.charAt(i) + "...");									System.out.println("Node rule 3 extension!");								}								rule3=true;							}														//either way, if a node was created on previous extension, its suffix link should lead to this node							if(linkFrom != null)							{								linkFrom.suffixLink = posNode;								if(debug)System.out.println("Suffix link from " + linkFrom + " to " + linkFrom.suffixLink);								linkFrom = null; //we don't create a new node on this extension.							}						}						else if(posLength == realEdge.getLength() && realEdge.node == null)						{ //RULE 1 EXTENSION! (Landed on a leaf)							//We probably don't actually need to do anything since the pointer is to 'e' anyway.							if(debug)System.out.println("Rule 1 extension!");							assert(1==0); //this shouldn't be happening.							linkFrom = null; //we don't create a new node on this extension.						}						else if(posLength < realEdge.getLength())						{ //We land in the middle of the edge 														if(s.charAt(realEdge.s + posLength) == s.charAt(i))							{ //...which continues with this char: Rule 3!																if(debug)System.out.println("Rule 3 extension in the midst of edge!");								rule3=true;								assert(linkFrom == null); //if we made a node in prev. extension, we should've landed right on node, or create a new node								linkFrom = null; //we don't create a new node on this extension.							}							else							{								//(and there shouldn't exist a path with this char)								if(debug)								{									System.out.println("Since the path continues with " + s.charAt(realEdge.s + posLength) + ", not " + s.charAt(i) + "...");		//							System.out.println("Path: " + (realEdge.s) + " " + realEdge.e);									System.out.println("Poslength " + posLength);									System.out.println("Old path: " + realEdge.s + " " + realEdge.getEnd());									System.out.println("Rest in path: " + s.substring(realEdge.s+posLength, realEdge.getEnd()+1));											System.out.println("Rule 2 extension!");								}																//								System.out.println("TEMPE " + realEdge.getEnd());								//before we do anything, store the node the realEdge currently ends at								Node tempn = realEdge.node;								//First, make a node, then split the realEdge, then add new edge to the node.								//Make node!								realEdge.node = new Node(this);								realEdge.node.chardepth = posNode.chardepth + posLength;								if(debug)System.out.println("New node created: " + realEdge.node + ", charDepth " + realEdge.node.chardepth);																//split realEdge								int tempe = realEdge.e;								int splitSecondStart = realEdge.s + posLength; //head of 2nd edge is to be the character of original edge that didn't match								//(this is the second half of the original edge)								realEdge.e = realEdge.s + posLength-1; //length to be set as number of matched character								//^this is the end of the old, shrunken edge! 								//old outgoing (second half of split edge)								realEdge.node.edge[chartoint(s.charAt(splitSecondStart))] = new Edge(this, splitSecondStart, tempe, realEdge.node.chardepth, tempn);																								//add new edge for our new character								realEdge.node.edge[chartoint(s.charAt(i))] = new Edge(this, i, -1, realEdge.node.chardepth);								if(debug)System.out.println("Edges leading out from this new node: " + s.charAt(splitSecondStart) + " and " + s.charAt(i));																if(debug)System.out.println("The shortened edge becomes " + realEdge.s + " " + realEdge.e + ", new one is " + splitSecondStart);																//We don't change our current node to this new node, however,								//since we wouldn't be able to use a suffix link from this node on the next extension.//								System.out.println("Current node right now is " + posNode);								//								System.out.println("LINKFROM " + linkFrom);								if(linkFrom != null)								{									linkFrom.suffixLink = realEdge.node;									if(debug)System.out.println("Suffix link from " + linkFrom + " to " + linkFrom.suffixLink);								}														linkFrom = realEdge.node;//								System.out.println("linkFrom is now " + linkFrom);							}						}						//exceptions						else 						{							System.out.println("MYSTERY EXCEPTIONNE!");							assert(0==1);						}					}										//3. Extension rule's aftermath (break out if necessary) 					if(!rule3)j++; //Increment j???? Because not rule 3...										extension++;					if(rule3)					{ //prepare for next PHASE. That is, mark the place. (?) (Go one step onwards, so that we actually start here next.)//						posEdge++;						if(posLength == 0) //in case we ended up right on a node, in order to step onwards we step towards							//the direction of the last letter, that is, the letter added in this phase (i)							posEdge = posNode.getEdgeOfChar(s.charAt(i)).s;												posLength++;																		Edge realEdge = null;						if(posEdge != -1)realEdge = posNode.getEdgeOfChar(s.charAt(posEdge));						assert(realEdge!=null); //since we've stepped towards the direction of i... that direction should exist						//the edge doesnt necessarily start with i, i could just be some letter in the middle of it.//						System.out.println("Potential Node " + realEdge.node);						if(debug)System.out.println("Do we change node? " + posNode + ", edge length " + realEdge.getLength() + ", posLength " + posLength + ", posEdge " + posEdge);												if(realEdge != null && posLength >= (realEdge.getLength()) //GETLENGTH								&& realEdge.node != null)						{ //if we reach or crossed the end of the edge AND it's not a leaf, change node!							if(debug)System.out.println("Changed node! Now " + realEdge.node);							posNode = realEdge.node;							posEdge = -1;							posLength = 0;						}						break;					}										if(j > i)break;										if(debug)System.out.println("\nPreparing next extension!\n");//					System.out.println("posNode = " + posNode);//					System.out.println("posEdge = " + posEdge);//					System.out.println("posLength = " + posLength);															//4. Prepare the path to traverse during next extension's step 1. This path is denoted as gamma.					//extension j>=2					if(posNode == root)					{ //if root, go to S[j...i] as in naive method.						if(debug)System.out.println("Since posNode is root...");						if(debug)System.out.println("Also, posNode " + posNode + " posEdge " + posEdge + " posLength " + posLength);												usedSuffixLink = false;												if(posLength <= 1)						{ //pos length <= 1 means you won't need to traverse anywhere from root!							gammas = 0;							gammae = -1;						}						else						{							if(posNode.edge[chartoint(s.charAt(posEdge))] != null)							{								gammas = posNode.edge[chartoint(s.charAt(posEdge))].s+1; //plus one because we're cutting off the 1st char								gammae = gammas + posLength - 1 - 1;								if(debug)System.out.println("Setting gammas... " + gammas + " " + gammae);							}						}						posLength = 0;					}					else					{ //use suffix link (LINK THEM TOO...)												//"Walk up". In reality, the "up" node is already known; posNode.						//Note: in case we made a new node in this extension, the posNode, is not that new node, but its parent node.												if(posLength <= 0)						{ //pos length <= 0 means gamma is empty!							gammas = 0;							gammae = -1;						}						else						{ //the path gamma is expressed with the starting and last letters of the path, which are expressed as their position in the main string.							gammas = posNode.edge[chartoint(s.charAt(posEdge))].s; //the path gamma is the partition of the edge from the upper node (posNode) to current position.							gammae = gammas + posLength - 1;						}												posLength = 0; //posLength becomes 0 because we need to walk down again												if(debug)System.out.println("Traverse suffix link from " + posNode + " to " + posNode.suffixLink);						posNode = posNode.suffixLink;						//then traverse path γ (next iteration)						//posEdge doesn't change since it's the same edge letter, just from a different node.						//gammaLength = posLength itsef, since the overall path is shortened by 1 but that's already						//reflected by the fact that the current node is closer to the root.						usedSuffixLink = true;					}				}			}							//leaves								}					}		static class Node	{		Edge[] edge = new Edge[LETTERS+1]; //26 for $		Node suffixLink = null;		SuffixTree suffixTree;		int chardepth = 0;				//for debugging		int id;				public Node(SuffixTree suffixTree0)		{			suffixTree = suffixTree0;			id = suffixTree.nodes;			suffixTree.nodes++;			suffixLink = suffixTree.root;//			System.out.println("Node " + id + " created " + ", " + nodes);		}				Edge getEdgeOfChar(char c)		{ //returns the edge that starts with character c			return edge[chartoint(c)];		}				public String toString()		{			return "NODE " + id;		}	}		static class Edge	{		int s = -2;		int e = -2; //-1 means 'end'		Node node = null; //null means this edge leads to leaf		//this is the node that you will reach by traversing the edge (destination node)		SuffixTree suffixTree;		int startCharDepth = 0; //the node which has this as an outgoing edge (source node)'s char depth.		//(length of path from the root to that node)		boolean done = false;				int getEnd()		{			if(e == -1)return suffixTree.currentEnd;			else return e;		}				int getLength()		{			return getEnd() - s + 1;		}						boolean getIsLeaf() {return node==null;}				int getStartChar()		{			int len = startCharDepth + (getEnd()-s+1); //length of the suffix path to end of this edge//			System.out.println("Len is " + len + ", since SCD is " + startCharDepth + ", s " + s + " e " + e);			return suffixTree.s.length() - len;		}				String getLeafSuffix()		{ //Returns the suffix represented by this leaf edge.			if(getIsLeaf())				return suffixTree.s.substring(getStartChar(), startCharDepth + (getEnd()-s+1));			else return "";		}				public Edge(SuffixTree sufTree, int s0, int e0, int startCharDepth)		{			this.startCharDepth = startCharDepth;			suffixTree = sufTree;			s = s0;			e = e0;		}				public Edge(SuffixTree sufTree, int s0, int e0, int startCharDepth, Node n)		{			this.startCharDepth = startCharDepth;			suffixTree = sufTree;			s = s0;			e = e0;			node = n;		}	}		static int chartoint(char c)	{		if(c == '$')return LETTERS; else return c-'a';	}		public static void main(String[] args)	{				Scanner sc = new Scanner(System.in);				//debug = false;				int pos = 511;		String s = sc.next();		String p = sc.next();		String suf = sc.next();				String surv = "dcbcabddddcccbacdbdccbaaccabdbacbccccbadcccbcaabdbaabacdaaacdcbdbcacdacccdcacdcbccbbbccabbbdbddcbadddccacccadadacbbbcabbbdacdddacabbdbbbddcddbbacbdcadbacaaabbacbbdcaacdbacacbbdaabdcbabbccdadbacbcbbcadacdccbacdcbcbbcacaadabdccddddcdabbbbaacdccdaabaadbdcacdbddcbacdcaaaacbadbdbbaddbcdaabccacbdbabadbdcdaddbbbbbaacdbacabdccccaacbbaaadbdbdacbacbbacaacbbaabccdddbdbbacbaddbcdaadddbbadcccaddddbaddadbbcadacacdaacdbcdaacacddbbbaacdbcdcaddcadacbacbbccddcbcdbbcabaaccaccdcabddaacaacabadbcdadaadcbdcabccbabaacadbaacdcbabd";		if(s.length() >= surv.length() && s.substring(0, surv.length()).contentEquals(surv))		{			//System.out.println(p);			//System.out.println(s.substring(pos));		}				SuffixTree tree = new SuffixTree(s);		tree.findSuffixOccurrences(suf);				if(debug2 && s.length() < 100)System.out.println(Arrays.toString(suffixOccurrences));				tree.countPreXSuf(p, suf);						/*		while(true)		{			System.out.println("Enter string s to build suffix tree from!");			String st = sc.next();			if(st.equals("quit"))break;			computation = 0;			SuffixTree tree = new SuffixTree(st);			System.out.println("\n\n" + computation + " cycles for " + st.length());						while(true)			{				System.out.println("\n\nEnter string p to find its occurrences in s!");				String p = sc.next();				if(p.equals("quit"))break;				tree.findSubstring(p);			}		}		*/	} }
