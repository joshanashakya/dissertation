def calc_lcp(s, sa):    n = len(s)    rank = [0 for _ in range(n)]    for i in range(n):        rank[sa[i]] = i    lcp = [0 for _ in range(n - 1)]    h = 0    for i in range(n):        if rank[i] < n - 1:            while s[i + h] == s[sa[rank[i] + 1] + h]:                h += 1            lcp[rank[i]] = h            if h > 0:                h -= 1    return lcp, rank  def index_sort(r):    n = len(r)    mask = (1 << 32) - 1    ls = [(r[i] << 32) | i for i in range(n)]    ls.sort()    res = [i & mask for i in ls]    return res  def suffix_array(s):        n = len(s) - 1        rank = [ord(c) for c in s]        sa = index_sort(rank)        a = [0 for _ in range(n + 1)]        b = [0 for _ in range(n + 1)]        h = 0        while True:            for i in range(n):                x, y = sa[i + 1], sa[i]                b[i + 1] = b[i]                if rank[x] > rank[y] or rank[x + h] > rank[y + h]:                    b[i + 1] += 1             for i in range(n + 1):                rank[sa[i]] = b[i]            if b[n] == n:                break            h = max(1, h << 1)            for k in range(h, -1, -h):                b = [0 for _ in range(n + 1)]                b[0] = k                for i in range(k, n + 1):                    b[rank[i]] += 1                for i in range(n):                    b[i + 1] += b[i]                for i in range(n, -1, -1):                    r = 0 if sa[i] + k > n else rank[sa[i] + k]                    b[r] -= 1                    a[b[r]] = sa[i]                sa, a = a, sa        return sa def kmp(s, p):    m = len(p)    pi = [0 for _ in range(m)]    k = 0    for i in range(1, m):        while k > 0 and p[k] != p[i]:            k = pi[k - 1]        if p[k] == p[i]:            k += 1        pi[i] = k     k = 0    n = len(s)    resp = []    for i in range(n):        while k > 0 and p[k] != s[i]:            k = pi[k - 1]        if p[k] == s[i]:            k += 1        if k == m:            resp.append(i - m + 1)            k = pi[k - 1]    return resp  def lower_bound(list, value):    left = 0    right = len(list)    while left < right:        mid = int((left + right) / 2)        if list[mid] < value:            left = mid + 1        else:            right = mid    return left  s = input()start = input()end = input() indStart = kmp(s, start)indEnd = kmp(s, end) if len(indStart) == 0 or len(indEnd) == 0:    print(0) else:    s += chr(0)    sa = suffix_array(s)    lcp, rank = calc_lcp(s, sa)     ind = rank[indStart[0]]    for st in indStart:        ind = min(ind, rank[st])     resp = len(indEnd) - lower_bound(indEnd, sa[ind] + max(0, len(start) - len(end)))    while ind < len(lcp) and lcp[ind] >= len(start):        ind += 1        resp += len(indEnd) - lower_bound(indEnd, sa[ind] + max(0, max(lcp[ind - 1] + 1, len(start)) - len(end)))     print(resp) 
