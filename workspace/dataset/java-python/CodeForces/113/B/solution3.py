def calc_lcp(s, sa):    n = len(s)    rank = [0 for _ in range(n)]    for i in range(n):        rank[sa[i]] = i    lcp = [0 for _ in range(n - 1)]    h = 0    for i in range(n):        if rank[i] < n - 1:            while max(i, sa[rank[i] + 1]) + h < n and s[i + h] == s[sa[rank[i] + 1] + h]:                h += 1            lcp[rank[i]] = h            if h > 0:                h -= 1    return lcp, rank def suffix_array(s):    def countinSort(array, key):        max_val = max(key)        cnt = [0 for _ in range(max_val + 1)]        for i in key:            cnt[i] += 1        for i in range(1, len(cnt)):            cnt[i] += cnt[i - 1]        resp = [0 for _ in array]        for i in range(len(array) - 1, -1, -1):            cnt[key[array[i]]] -= 1            resp[cnt[key[array[i]]]] = array[i]        return resp        n = len(s)    sa = [i for i in range(n)]    ranks = [ord(c) for c in s]     k = 1    while k < n:         sa = countinSort(sa, [ranks[i + k] if i + k < n else -1 for i in range(n)])        sa = countinSort(sa, ranks)         rank_new = [0 for _ in range(n)]        for i in range(1, n):            if ranks[sa[i - 1]] == ranks[sa[i]] and sa[i] + k < n and sa[i - 1] + k < n and ranks[sa[i - 1] + k] == ranks[sa[i] + k]:                rank_new[sa[i]] = rank_new[sa[i - 1]]            else:                rank_new[sa[i]] = i        ranks = rank_new         k *= 2     return sa  def kmp(s, p):    m = len(p)    pi = [0 for _ in range(m)]    k = 0    for i in range(1, m):        while k > 0 and p[k] != p[i]:            k = pi[k - 1]        if p[k] == p[i]:            k += 1        pi[i] = k     k = 0    n = len(s)    resp = []    for i in range(n):        while k > 0 and p[k] != s[i]:            k = pi[k - 1]        if p[k] == s[i]:            k += 1        if k == m:            resp.append(i - m + 1)            k = pi[k - 1]    return resp  def lower_bound(list, value):    left = 0    right = len(list)    while left < right:        mid = int((left + right) / 2)        if list[mid] < value:            left = mid + 1        else:            right = mid    return left  s = input()start = input()end = input() indStart = kmp(s, start)indEnd = kmp(s, end) if len(indStart) == 0 or len(indEnd) == 0:    print(0) else:    sa = suffix_array(s)    lcp, rank = calc_lcp(s, sa)     ind = rank[indStart[0]]    for st in indStart:        ind = min(ind, rank[st])     resp = len(indEnd) - lower_bound(indEnd, sa[ind] + max(0, len(start) - len(end)))    while ind < len(lcp) and lcp[ind] >= len(start):        ind += 1        resp += len(indEnd) - lower_bound(indEnd, sa[ind] + max(0, max(lcp[ind - 1] + 1, len(start)) - len(end)))     print(resp) 
