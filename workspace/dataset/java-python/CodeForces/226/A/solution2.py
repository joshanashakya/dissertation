#include <bits/stdc++.h> using namespace std;const int p=1000000007;#define int long long int //__builtin_ffs(x)=1+index of rightmost 1-bit//__builtin_clz(x)=no of leading 0's in binary(x)//__builtin_ctz(x)=no of trailing zeroes in binary(x)//_builtin_popcount(x)=no of 1's in binary(x)int factorialmod(int n)    //returns factorial of n mod p{    int fact=1;    for(int i=1;i<=n;i++)    fact=(fact*i)%p;    fact=fact%p;    return fact;}int factorial(int n)    //returns factorial of n{    int fact=1;    for(int i=1;i<=n;i++)    fact=(fact*i);   // fact=fact;    return fact;}int powermod(int a,int b,int p)    //calculates a^b mod p in log(b) time{    a=a%p;    int res=1;    while(b>0)    {        if(b&1)        res=(res*a)%p;        a=a*a%p;        b>>=1;    }    return res;}int power(int a,int b)    //calculates a^b in log(b) time{    a=a;    int res=1;    while(b>0)    {        if(b&1)        res=(res*a);        a=a*a;        b>>=1;    }    return res;}int modInverse(int x)   //Calculates modular inverse of x mod p  if p is a prime and gcd(p,i)=1 ===>Fermat's little theorem{    return power(x,p-2);}int nCi(int n,int i,int fact[])   //calculates nCi mod p{    if(n<i)    return 0;    if(i==0)    return 1;   // cout<<fact[i]<<endl;    return (fact[n]%p*modInverse(fact[i])%p*modInverse(fact[n-i])%p)%p;}int gcd(int a,int b)     //returns gcd of a,b in O(log(min(a,b))){    return b?gcd(b,a%b):a;}int lcm(int a,int b)    //returns lcm of a,b{    return (a*b)/gcd(a,b);}int exgcd(int a,int b,int& x,int& y)     //returns the solution to the extended euclid algo a.x+b.y=gcd(a,b){    if (b == 0) {        x = 1;        y = 0;        return a;    }    int x1, y1;    int d = exgcd(b, a % b, x1, y1);    x = y1;    y = x1 - y1 * (a / b);    return d;}/*bool find_any_dio_solution(int a, int b, int c, int &x0, int &y0, int &g) {    g = exgcd(abs(a), abs(b), x0, y0);    if (c % g) {        return false;    }     x0 *= c / g;    y0 *= c / g;    if (a < 0) x0 = -x0;    if (b < 0) y0 = -y0;    return true;}*///Fibonacci using matrix exponentiationvoid matmultiply(int F[2][2], int M[2][2]){    int x = (F[0][0] * M[0][0]%p + F[0][1] * M[1][0]%p)%p;    int y = (F[0][0] * M[0][1]%p + F[0][1] * M[1][1]%p)%p;    int z = (F[1][0] * M[0][0]%p + F[1][1] * M[1][0]%p)%p;    int w = (F[1][0] * M[0][1]%p + F[1][1] * M[1][1]%p)%p;         F[0][0] = x;    F[0][1] = y;    F[1][0] = z;    F[1][1] = w;}void matpower(int F[2][2], int n){    if(n == 0 || n == 1)       return;    int M[2][2] = {{1, 1}, {1, 0}};         matpower(F, n / 2);    matmultiply(F, F);         if (n % 2 != 0)        matmultiply(F, M);}int fib(int n){    int F[2][2] = {{1, 1}, {1, 0}};    if (n == 0)        return 0;    matpower(F, n - 1);   // cout<<F[1][1]<<endl;    return F[0][0]%p;} int bin_search(int a[],int n,int val){    int l=0,u=n-1,mid;    while(l<=u)    {        mid=(l+u)/2;        if(val<a[mid])        u=mid-1;        else if(val>a[mid])        l=mid+1;        else        {            break;        }    }    return (l+u)/2;}void solution(){    int n,m;    cin>>n>>m;    int s=((powermod(3,n,m)%m-(1%m))%m+m)%m;    cout<<s;}int32_t main(){    //Enter code here   /* int t;    cin>>t;    while(t--)    {*/        solution(); //   }    return 0;}  
