from itertools import permutationsfrom sys import stdin, stdoutly, lx = map(int, input().split())grid = [[c for c in inp] for inp in stdin.read().splitlines()] first = set()bl = []bpattern = []bcost = 1e6flip_row = False for l in permutations('AGCT'):    if bcost == 0:        break    if ''.join(l[:2]) in first:        continue     first |= set([''.join(l[:2]), ''.join(l[1::-1])])    #try row flip    cost = 0    pattern = [0] * ly    for i in range(ly):        diff1, diff2 = 0, 0        for j in range(lx):            if grid[i][j] != l[((i & 1) << 1) + (j & 1)]:                diff1 += 1            if grid[i][j] != l[((i & 1) << 1) + ((j ^ 1) & 1)]:                diff2 += 1        cost += min(diff1, diff2)        if diff1 >= diff2:  # 1 -> diff1, 0 -> diff2            pattern[i] = 1    if cost < bcost:        bcost = cost        bpattern = pattern.copy()        flip_row = True        bl = l    # try col flip    cost = 0    pattern = [0] * lx    for j in range(lx):        diff1 = diff2 = 0        for i in range(ly):            if grid[i][j] != l[((j & 1) << 1) + (i & 1)]:                diff1 += 1            if grid[i][j] != l[((j & 1) << 1) + ((i ^ 1) & 1)]:                diff2 += 1        cost += min(diff1, diff2)        if diff1 >= diff2:            pattern[j] = 1    if cost < bcost:        bcost = cost        bpattern = pattern.copy()        flip_row = False        bl = l if flip_row:    for i in range(ly):        grid[i] = ''.join(            [bl[((i & 1) << 1) + ((j ^ bpattern[i]) & 1)] for j in range(lx)]) else:    for i in range(ly):        grid[i] = ''.join(            [bl[((j & 1) << 1) + ((i ^ bpattern[j]) & 1)] for j in range(lx)]) # print(f'need at least:{bcost}')stdout.write('\n'.join(''.join((k for k in grid[i])) for i in range(ly)))
