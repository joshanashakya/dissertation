#include <bits/stdc++.h>using namespace std; typedef long long ll; const int maxn=1e5+5; int fa[maxn]; int sz[maxn]; void init(){	for(int i=0;i<maxn;i++) fa[i]=i;} int findset(int x){	if(x==fa[x]) return x;	else return fa[x]= findset(fa[x]);} void unin(int x,int y){	int fx=findset(x);	int fy=findset(y);	fa[fx]=fy;	sz[fy]+=sz[fx];	} map<int,int> mp;  vector<int> a[maxn]; int main(){	int n,m;	cin>>n>>m;	init();	for(int i=1;i<=m;i++)	{		int u,v;		cin>>u>>v;		a[u].push_back(v);		a[v].push_back(u);	} 	vector<int> gp; 	for(int i=1;i<=n;i++)	{		sz[i]=1;		mp.clear(); 		for(int j=0;j<a[i].size();j++)		{			int v=a[i][j];			if(v>=i) continue;			int fv=findset(v);			//存储当前顶点连出去的爸爸数			mp[fv]++;		} 		for(int j=0;j<gp.size();j++)		{			int tmp=findset(gp[j]);			int tmp2=findset(i);			if(tmp==tmp2) continue;						//说明这个顶点有机会可以直接连一条零边			if(sz[tmp]>mp[tmp])			{				unin(i,tmp);			}		} 		int fx=findset(i);		if(fx==i) gp.push_back(fx);	} 	int cnt=0;	for(int i=1;i<=n;i++)	{		if(fa[i]==i) cnt++;	}	cout<<cnt-1<<endl; 	 		}
