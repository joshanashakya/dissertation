 import java.io.*;import java.math.BigDecimal;import java.math.BigInteger;import java.math.RoundingMode;import java.util.*;import java.util.concurrent.LinkedBlockingDeque; import java.util.ArrayList;import java.util.HashMap;import java.util.LinkedList;  // graph, dfs,bfs, get connected components,iscycle, isbipartite, dfs on trees   public class scratch_25 {    static class Graph{         public static class Vertex{            HashMap<Integer,Integer> nb= new HashMap<>();     // for neighbours of each vertex        }         public static HashMap<Integer,Vertex> vt;   // for vertices(all)         public Graph(){            vt= new HashMap<>();        }         public static int numVer(){            return vt.size();        }         public static boolean contVer(int ver){            return vt.containsKey(ver);        }         public static void addVer(int ver){            Vertex v= new Vertex();            vt.put(ver,v);        }              public static void addEdge(int ver1, int ver2, int weight){            if(!vt.containsKey(ver1) || !vt.containsKey(ver2)){                return;            }            Vertex v1= vt.get(ver1);            Vertex v2= vt.get(ver2);            v1.nb.put(ver2,weight);                                 // if previously there is an edge, then this replaces that edge            v2.nb.put(ver1,weight);        }         public static void delEdge(int ver1, int ver2){             if(!vt.containsKey(ver1) || !vt.containsKey(ver2)){                return;            }            vt.get(ver1).nb.remove(ver2);            vt.get(ver2).nb.remove(ver1);        }        public static void delVer(int ver){            if(!vt.containsKey(ver)){                return;            }            Vertex v1= vt.get(ver);            ArrayList<Integer> arr= new ArrayList<>(v1.nb.keySet());            for (int i = 0; i <arr.size() ; i++) {                int s= arr.get(i);                vt.get(s).nb.remove(ver);            }            vt.remove(ver);        }        static boolean done[];        static int parent[];        static ArrayList<Integer>vals= new ArrayList<>();          public static boolean isCycle(int i){            Stack<Integer>stk= new Stack<>();             stk.push(i);            while(!stk.isEmpty()){                int x= stk.pop();                vals.add(x);                //   System.out.print("current="+x+" stackinit="+stk);                if(!done[x]){                    done[x]=true;                }                else if(done[x] ){                    return true;                }                 ArrayList<Integer>ar= new ArrayList<>(vt.get(x).nb.keySet());                for (int j = 0; j <ar.size() ; j++) {                    if(parent[x]!=ar.get(j)){                        parent[ar.get(j)]=x;                        stk.push(ar.get(j));                    }                }                // System.out.println(" stackfin="+stk);            }            return false;        }        static int[]level;        static int[] curr;        static int[] fin;         public static void dfs(int src){            done[src]=true;            level[src]=0;            Queue<Integer>q= new LinkedList<>();            q.add(src);            while(!q.isEmpty()){                int x= q.poll();                ArrayList<Integer>arr= new ArrayList<>(vt.get(x).nb.keySet());                for (int i = 0; i <arr.size() ; i++) {                    int v= arr.get(i);                    if(!done[v]){                        level[v]=level[x]+1;                        done[v]=true;                        q.offer(v);                    }                }            }        }        static int oc[];        static int ec[];          public static void dfs1(int src){            Queue<Integer>q= new LinkedList<>();            q.add(src);            done[src]= true;            //    int count=0;            while(!q.isEmpty()){                 int x= q.poll();                //   System.out.println("x="+x);                int even= ec[x];                int odd= oc[x];                if(level[x]%2==0){                    int val= (curr[x]+even)%2;                    if(val!=fin[x]){                        //  System.out.println("bc");                        even++;                        vals.add(x);                    }                }                else{                    int val= (curr[x]+odd)%2;                    if(val!=fin[x]){                        //   System.out.println("bc");                        odd++;                        vals.add(x);                    }                 }                ArrayList<Integer>arr= new ArrayList<>(vt.get(x).nb.keySet());                //   System.out.println(arr);                for (int i = 0; i <arr.size() ; i++) {                    int v= arr.get(i);                    if(!done[v]){                        done[v]=true;                        oc[v]=odd;                        ec[v]=even;                        q.add(v);                    }                }            }         }    }                           // int count=0;    //static long count=0;    static class Reader {        static BufferedReader reader;        static StringTokenizer tokenizer;         /**         * call this method to initialize reader for InputStream         */        static void init(InputStream input) {            reader = new BufferedReader(                    new InputStreamReader(input));            tokenizer = new StringTokenizer("");        }         /**         * get next word         */        static String next() throws IOException {            while (!tokenizer.hasMoreTokens()) {                //TODO add check for eof if necessary                tokenizer = new StringTokenizer(                        reader.readLine());            }            return tokenizer.nextToken();        }         static int nextInt() throws IOException {            return Integer.parseInt(next());        }         static double nextDouble() throws IOException {            return Double.parseDouble(next());        }         static long nextLong() throws IOException {            return Long.parseLong(next());        }    }    static class Pair implements Comparable<Pair> {        int pos;        int point;        String val;         public Pair(int pos, int point,String val) {            this.pos = pos;            this.point = point;            this.val=val;        }         @Override        public int compareTo(Pair o) {            if(this.pos!=o.pos){                return this.pos-o.pos;            }            else{                return o.point-this.point;            }           }        //        @Override//        public boolean equals(Object me) {//            Pair binMe = (Pair)me;//            if(this.ver==binMe.ver && this.cl==binMe.cl)//                return true;//            else//                return false;//        }//        @Override        public String toString() {            return pos + " " + point+" "+val;        }      }       // After writing solution, quick scan for:    //   array out of bounds    //   special cases e.g. n=1?    //    // Big numbers arithmetic bugs:    //   int overflow    //   sorting, or taking max, or negative after MOD    public static void main(String[] args)  throws IOException {        Reader.init(System.in);        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));        int n= Reader.nextInt();        int m= Reader.nextInt();        int arr[][]= new int[n][m];        for (int i = 0; i <n ; i++) {            for (int j = 0; j <m ; j++) {                arr[i][j]= Reader.nextInt();            }        }        ArrayList<Integer>ar= new ArrayList<>();        int x=n;        while(x%2==0){            ar.add(x);            x/=2;        }        ar.add(x);        Collections.sort(ar);        boolean b1=false;      //  System.out.println(ar);        for (int i = 0; i <ar.size()-1 ; i++) {            int v= ar.get(i);            int a[][]= new int[v][m];            for (int j = 0; j <v ; j++) {                for (int k = 0; k <m ; k++) {                    a[j][k]=arr[j][k];                }            }//            System.out.println("v="+v);//            for (int j = 0; j <v ; j++) {//                System.out.println(Arrays.toString(a[j]));//            }            boolean b=true;            for (int j = 0; j <n ; j+=2*v) {                for (int k = j; k <j+v ; k++) {                    for (int l = 0; l <m ; l++) {                        if(a[k-j][l]!=arr[k][l]){                            b=false;                            if(v==2){                            //    System.out.println("loolxd");                            }                            break;                        }                    }                    if(!b){                        break;                    }                }                for (int k = j+v; k <j+2*v ; k++) {                    for (int l = 0; l <m ; l++) {                        if(a[j+2*v-k-1][l]!=arr[k][l]){                            if(v==2){//                                System.out.println("bc");//                                System.out.println(k+" "+j+" "+(k-(j+v))+" "+l+" "+(j+2*v-1-k));                            }                            b=false;                            break;                        }                    }                    if(!b){                        break;                    }                }                if(!b){                    break;                }            }            if(b){                b1=true;                out.append(v+"\n");                break;            }            }        if(!b1){            out.append(n+"\n");        }             out.flush();        out.close();     }        public static String convert(String s,int n){        if(s.length()==n){            return s;        }        else{            int x= s.length();            int v=n-x;            String str="";            for (int i = 0; i <v ; i++) {                str+='0';            }            str+=s;            return str;         }    }     static long modExp(long a, long b, long mod) {        //System.out.println("a is " + a + " and b is " + b);        if (a==1) return 1;        long ans = 1;        while (b!=0) {            if (b%2==1) {                ans = (ans*a)%mod;            }            a = (a*a)%mod;            b/=2;        }        return ans;    }      public static long modmul(long a, long b, long mod) {        return b == 0 ? 0 : ((modmul(a, b >> 1, mod) << 1) % mod + a * (b & 1)) % mod;    }     static long sum(long n){        //   System.out.println("lol="+ (n*(n-1))/2);        return (n*(n+1))/2;    }          public static ArrayList<Integer> Sieve(int n) {        boolean arr[]= new boolean [n+1];        Arrays.fill(arr,true);        arr[0]=false;        arr[1]=false;        for (int i = 2; i*i <=n ; i++) {            if(arr[i]){                for (int j = 2; j <=n/i ; j++) {                    int u= i*j;                    arr[u]=false;                }}        }        ArrayList<Integer> ans= new ArrayList<>();        for (int i = 0; i <n+1 ; i++) {            if(arr[i]){                ans.add(i);            }        }        return ans;    }        static long power( long x, long y, long p)    {         long res = 1;          x = x % p;         if (x == 0) return 0;         while (y > 0)        {             if((y & 1)==1)                res = (res * x) % p;              y = y >> 1;            x = (x * x) % p;        }        return res;    }     public static long ceil_div(long a, long b){        return (a+b-1)/b;    }     static long gcd(long a, long b)    {        if (a == 0)            return b;        return gcd(b % a, a);    }     static long lcm(long a, long b)    {        return (a*b)/gcd(a, b);    } }
