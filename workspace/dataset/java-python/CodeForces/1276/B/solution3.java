import java.util.*;   public class TwoFairs {     public static void main(String[] args) {        int t, n, m, a, b, u, v;        Graph graph;        Scanner sc = new Scanner(System.in);        t = sc.nextInt();         for (int i = 0; i < t; i++) {            n = sc.nextInt();            m = sc.nextInt();            a = sc.nextInt();            b = sc.nextInt();            graph = new Graph(n, a, b);             for (int j = 0; j < m; j++) {                u = sc.nextInt();                v = sc.nextInt();                graph.addEdge(u, v);            }            System.out.println(graph.findAns());         }    }}class Graph {     static final int NOANS = -1;     class Node {         long NNO, LNO;        boolean visited;        List<Integer> adjs = new LinkedList<>();    }     Node[] graph;    long nele1, nele2, NodeNo;    int Vertex1, Vertex2;     Graph(int size, int v1, int v2) {        this.graph = new Node[size];        for (int i = 0; i < size; i++) {            this.graph[i] = new Node();        }        this.Vertex1 = v1 - 1;        this.Vertex2 = v2 - 1;    }     public void addEdge(int v1, int v2) {        this.graph[v1 - 1].adjs.add(v2 - 1);        this.graph[v2 - 1].adjs.add(v1 - 1);    }     int Dfs(int curr, int parent) {        int TotalChild = 1, artiNodes = 0;        graph[curr].visited = true;        NodeNo++;        graph[curr].LNO = graph[curr].NNO = NodeNo;        for (int adj : graph[curr].adjs) {            int flag = 0;            boolean prevVal = graph[Vertex2].visited;             if (!graph[adj].visited) {                flag = Dfs(adj, curr);                graph[curr].LNO = min(graph[curr].LNO, graph[adj].LNO);                if (flag == NOANS) {                    return NOANS;                } else {                    TotalChild += flag;                }            } else if (adj != parent) {                graph[curr].LNO = min(graph[curr].LNO, graph[adj].NNO);            }            if (graph[adj].LNO >= graph[curr].NNO && prevVal == graph[Vertex2].visited) {                artiNodes += flag;            }        }        if ((curr == Vertex1 || curr == Vertex2) && artiNodes == 0) {            return NOANS;        }        if (curr == Vertex1) {            nele1 = artiNodes;        }        if (curr == Vertex2) {            nele2 = artiNodes;        }        return TotalChild;    }     public long findAns() {        int flag = Dfs(Vertex1, Vertex1);        if (flag == NOANS) {            return 0;        }        return nele1 * nele2;    }     long min(long a, long b) {        return a < b ? a : b;    }}
