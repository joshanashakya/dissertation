import java.util.HashSet;import java.util.Objects;import java.util.Scanner;import java.util.Set;import java.util.function.Predicate;import java.util.stream.Collectors; public class Main {  public static void main(String[] args) {    Scanner sc = new Scanner(System.in);    char[][] strings = new char[8][8];    for (int i = 0; i < 8; i++) {      strings[i] = sc.nextLine().toCharArray();    }    System.out.println(solve(strings));    sc.close();  }   static class Point {    int x;    int y;     public Point(int x, int y) {      this.x = x;      this.y = y;    }     @Override    public boolean equals(Object o) {      if (this == o) return true;      if (o == null || getClass() != o.getClass()) return false;      Point point = (Point) o;      return x == point.x && y == point.y;    }     @Override    public int hashCode() {      return Objects.hash(x, y);    }  }   private static String solve(char[][] strings) {    Set<Point> currentPositions = new HashSet<>();    currentPositions.add(new Point(7, 0));    for (int i = 0; i < 8; i++) {      Predicate<? super Point> notSameWithStatues = point -> strings[point.x][point.y] != 'S';      currentPositions = findPossiblePositions(currentPositions, strings);      changePosition(strings);      currentPositions =          currentPositions.stream().filter(notSameWithStatues).collect(Collectors.toSet());      if (currentPositions.isEmpty()) {        return "LOSE";      }    }    return "WIN";  }   private static void changePosition(char[][] strings) {    for (int i = 7; i >= 1; i--) {      for (int j = 0; j < 8; j++) {        if (strings[i - 1][j] == 'S') {          strings[i - 1][j] = '.';          strings[i][j] = 'S';        }      }    }  }   private static Set<Point> findPossiblePositions(Set<Point> currentPositions, char[][] strings) {    Set<Point> newPoints = new HashSet<>();    int[] x = {-1, -1, -1, 0, 0, 1, 1, 1, 0};    int[] y = {0, 1, -1, 1, -1, 0, 1, -1, 0};    for (Point p : currentPositions) {      for (int i = 0; i < 9; i++) {        if (possible(p, x[i], y[i], strings)) {          Point p1 = new Point(p.x + x[i], p.y + y[i]);          newPoints.add(p1);        }      }    }    return newPoints;  }   private static boolean possible(Point p, int x, int y, char[][] strings) {    if (p.x + x < 0 || p.x + x >= 8 || p.y + y < 0 || p.y + y >= 8) {      return false;    } else {      return strings[p.x + x][p.y + y] != 'S';    }  }}
