import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.Arrays;import java.util.StringTokenizer; public class B128 implements Runnable {		int n, k;	char[] s;	int[] sa, lcp;	RMQ rmq;		int lcp(int l, int r) {		if(l < 0) return 0;		if(l == r) return n - sa[l];		return rmq.query(l, r - 1);	}		public void solve(FS in, PrintWriter out) {		s = in.next().toCharArray();		k = in.nextInt();		n = s.length;		sa = FastSuffixArray.suffixArray(s);		lcp = FastSuffixArray.lcp(sa, s);		rmq = new RMQ(lcp);		for(int i = 0; i < n; ++i) {			int prevLen = lcp(i - 1, i); //this much is already done			for(int len = prevLen + 1; ; ++len) {				int lo = i, hi = n - 1;				while(lo <= hi) {					int m = lo + hi >> 1;					if(lcp(i, m) >= len) lo = m + 1;					else hi = m - 1;				}				int cnt = hi - i + 1;				if(cnt <= 0) break;				if(cnt >= k) {					for(int c = 0; c < len; ++c) {						out.print(s[sa[i] + c]);					}					out.println();					return;				}				k -= cnt;			}		}		out.println("No such line.");	}		public void run() {		System.err.println("go!");		FS in = new FS();		PrintWriter out = new PrintWriter(System.out);		solve(in, out);		out.close();	}		static class FastSuffixArray { 		  // sort suffixes of S in O(n*log(n))		  public static int[] suffixArray(char[] S) {		    int n = S.length;		    Integer[] order = new Integer[n];		    for (int i = 0; i < n; i++)		      order[i] = n - 1 - i; 		    // stable sort of characters //%		    Arrays.sort(order, (a, b) -> Character.compare(S[a], S[b])); 		    int[] sa = new int[n];		    int[] classes = new int[n];		    for (int i = 0; i < n; i++) {		      sa[i] = order[i];		      classes[i] = S[i];		    }		    // sa[i] - suffix on i'th position after sorting by first len characters //%		    // classes[i] - equivalence class of the i'th suffix after sorting by first len characters //% 		    for (int len = 1; len < n; len *= 2) {		      int[] c = classes.clone();		      for (int i = 0; i < n; i++) {		        // condition sa[i - 1] + len < n simulates 0-symbol at the end of the string //%		        // a separate class is created for each suffix followed by simulated 0-symbol //%		        classes[sa[i]] = i > 0 && c[sa[i - 1]] == c[sa[i]] && sa[i - 1] + len < n && c[sa[i - 1] + len / 2] == c[sa[i] + len / 2] ? classes[sa[i - 1]] : i;		      }		      // Suffixes are already sorted by first len characters //%		      // Now sort suffixes by first len * 2 characters //%		      int[] cnt = new int[n];		      for (int i = 0; i < n; i++)		        cnt[i] = i;		      int[] s = sa.clone();		      for (int i = 0; i < n; i++) {		        // s[i] - order of suffixes sorted by first len characters //%		        // (s[i] - len) - order of suffixes sorted only by second len characters //%		        int s1 = s[i] - len;		        // sort only suffixes of length > len, others are already sorted //%		        if (s1 >= 0)		          sa[cnt[classes[s1]]++] = s1;		      }		    }		    return sa;		  } 		  // sort rotations of S in O(n*log(n))		  public static int[] rotationArray(char[] S) {		    int n = S.length;		    Integer[] order = new Integer[n];		    for (int i = 0; i < n; i++)		      order[i] = i;		    Arrays.sort(order, (a, b) -> Character.compare(S[a], S[b]));		    int[] sa = new int[n];		    int[] classes = new int[n];		    for (int i = 0; i < n; i++) {		      sa[i] = order[i];		      classes[i] = S[i];		    }		    for (int len = 1; len < n; len *= 2) {		      int[] c = classes.clone();		      for (int i = 0; i < n; i++)		        classes[sa[i]] = i > 0 && c[sa[i - 1]] == c[sa[i]] && c[(sa[i - 1] + len / 2) % n] == c[(sa[i] + len / 2) % n] ? classes[sa[i - 1]] : i;		      int[] cnt = new int[n];		      for (int i = 0; i < n; i++)		        cnt[i] = i;		      int[] s = sa.clone();		      for (int i = 0; i < n; i++) {		        int s1 = (s[i] - len + n) % n;		        sa[cnt[classes[s1]]++] = s1;		      }		    }		    return sa;		  } 		  // longest common prefixes array in O(n)		  public static int[] lcp(int[] sa, char[] s) {		    int n = sa.length;		    int[] rank = new int[n];		    for (int i = 0; i < n; i++)		      rank[sa[i]] = i;		    int[] lcp = new int[n - 1];		    for (int i = 0, h = 0; i < n; i++) {		      if (rank[i] < n - 1) {		        for (int j = sa[rank[i] + 1]; Math.max(i, j) + h < s.length && s[i + h] == s[j + h]; ++h)		          ;		        lcp[rank[i]] = h;		        if (h > 0)		          --h;		      }		    }		    return lcp;		  }		}		class RMQ {		int[] vs;		int[][] lift; 		public RMQ(int[] vs) {			this.vs = vs;			int n = vs.length;			int maxlog = Integer.numberOfTrailingZeros(Integer.highestOneBit(n)) + 2;			lift = new int[maxlog][n];			for (int i = 0; i < n; i++)				lift[0][i] = vs[i];			int lastRange = 1;			for (int lg = 1; lg < maxlog; lg++) {				for (int i = 0; i < n; i++) {					lift[lg][i] = Math.min(lift[lg - 1][i], lift[lg - 1][Math.min(i + lastRange, n - 1)]);				}				lastRange *= 2;			}		} 		public int query(int low, int hi) {			int range = hi - low + 1;			int exp = Integer.highestOneBit(range);			int lg = Integer.numberOfTrailingZeros(exp);			return Math.min(lift[lg][low], lift[lg][hi - exp + 1]);		}	}		public static void main(String[] args) {		new Thread(null, new B128(), "lmao", 1L<<28).start();	}	static class FS {		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));		StringTokenizer st = new StringTokenizer("");		String next() {			while(!st.hasMoreElements()) {				try { st = new StringTokenizer(br.readLine()); }				catch(Exception e) {}			}			return st.nextToken();		}		int nextInt() {			return Integer.parseInt(next());		}		long nextLong() {			return Long.parseLong(next());		}	}}
