import java.io.OutputStream;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.util.Arrays;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.TreeMap;import java.util.StringTokenizer;import java.io.BufferedReader;import java.io.FileReader;import java.util.Collections;import java.io.InputStream; /** * Built using CHelper plug-in * Actual solution is at the top */public class Main {    public static void main(String[] args) {        InputStream inputStream = System.in;        OutputStream outputStream = System.out;        Scanner in = new Scanner(inputStream);        PrintWriter out = new PrintWriter(outputStream);        BString solver = new BString();        solver.solve(1, in, out);        out.close();    }     static class BString {        SuffixAutomaton SA;        char[] arr;        int n;        int k;        long[] memo;         public void solve(int testNumber, Scanner sc, PrintWriter pw) {            arr = sc.next().toCharArray();            n = arr.length;            k = sc.nextInt();            SA = new SuffixAutomaton(arr);            memo = new long[n << 1];            Arrays.fill(memo, -1);            if (dp(0) < k) {                pw.println("No such line.");                return;            }            int root = 0;            while (k > 0) {                if (root != 0)                    k -= SA.count[root];                if (k <= 0)                    break;                for (char i = 'a'; i <= 'z'; i++) {                    if (SA.next[root].get(i) != null) {                        if (dp(SA.next[root].get(i)) < k) {                            k -= dp(SA.next[root].get(i));                        } else {                            root = SA.next[root].get(i);                            pw.print(i);                            break;                        }                    }                }            }        }         private long dp(int u) {            if (memo[u] != -1)                return memo[u];            long ans = SA.count[u];            for (char i = 'a'; i <= 'z'; i++) {                if (SA.next[u].containsKey(i)) {                    ans += dp(SA.next[u].get(i));                }            }            return memo[u] = ans;        }         public class SuffixAutomaton {            int[] link;            int[] len;            int[] count;            ArrayList<int[]> endSizes;            TreeMap<Character, Integer>[] next;            int lst;            int idx;             SuffixAutomaton(char[] s) {                int n = s.length;                link = new int[n << 1];                len = new int[n << 1];                next = new TreeMap[n << 1];                count = new int[n << 1];                endSizes = new ArrayList<>();                next[0] = new TreeMap<>();                for (char c : s)                    addLetter(c);                Collections.sort(endSizes, (a, b) -> len[b[1]] - len[a[1]]);                for (int i = 0; i < endSizes.size(); i++) {                    int[] temp = endSizes.get(i);                    int idx = temp[1];                    count[idx] += temp[0];                    count[link[idx]] += count[idx];                }            }             void addLetter(char c) {                int cur = ++idx, p = lst;                endSizes.add(new int[]{1, cur});                while (!next[p].containsKey(c)) {                    next[p].put(c, cur);                    p = link[p];                }                int q = next[p].get(c);                if (q != cur)                    if (len[q] == len[p] + 1)                        link[cur] = q;                    else {                        int clone = ++idx;                        endSizes.add(new int[]{0, clone});                        len[clone] = len[p] + 1;                        link[clone] = link[q];                        next[clone] = new TreeMap<>(next[q]);                        link[cur] = link[q] = clone;                        while (next[p].get(c) == q) {                            next[p].put(c, clone);                            p = link[p];                        }                    }                len[cur] = len[lst] + 1;                next[cur] = new TreeMap<>();                lst = cur;            }         }     }     static class Scanner {        StringTokenizer st;        BufferedReader br;         public Scanner(FileReader r) {            br = new BufferedReader(r);        }         public Scanner(InputStream s) {            br = new BufferedReader(new InputStreamReader(s));        }         public String next() {            while (st == null || !st.hasMoreTokens()) {                try {                    st = new StringTokenizer(br.readLine());                } catch (IOException e) {                    throw new RuntimeException(e);                }            }            return st.nextToken();        }         public int nextInt() {            return Integer.parseInt(next());        }     }} 
