# include <iostream>#include <cstdio>#include <sstream>#include <algorithm>#include <iomanip>#include <cmath>#include <ctime>#include <cstdlib>#include <set>#include <map>#include <vector>#include <queue>#include <iterator> #include <ext/pb_ds/assoc_container.hpp>#include <ext/pb_ds/tree_policy.hpp> #define x0 abc#define y0 ABC#define x1 abcd#define y1 ABCD#define xn abcde#define yn ABCDE #define l_b lower_bound#define u_b upper_bound #define in insert#define er erase #define fi first#define se second#define m_p make_pair #define p_b push_back#define po_b pop_back #define uns unsigned #define ld long double#define ll long long #define cont continue#define re return #define MAXLL 9000000000000000000LL#define MAXINT 2000000000 #define MINLL -9000000000000000000LL#define MININT -2000000000 #define pi acos(-1.) #define endl '\n' #define OUT cout << "-------" << endl; using namespace std; using namespace __gnu_pbds; typedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set; map <string, string> Map; string s, s1, s2; int i, q, k, k1; int main(){    //freopen("input.txt", "r", stdin);    //freopen("output.txt", "w", stdout);     ios::sync_with_stdio(0);    cin.tie(0);     cin >> q;     while (q--) {        cin >> s;         if (s == "typedef") {            cin >> s1 >> s2;             k = k1 = 0;             while (s1.front() == '&') {                k++;                 s1.er(0, 1);            }             while (s1.back() == '*') {                k1++;                 s1.er(s1.size() - 1, 1);            }             if (s1 == "void") {                for (i = 1; i <= k; i++) s1 = "&" + s1;                 for (i = 1; i <= k1; i++) s1 += "*";                 while (s1.front() == '&' && s1.back() == '*') {                    s1.er(0, 1);                     s1.er(s1.size() - 1, 1);                }                 if (s1.front() == '&') {                    Map[s2] = "errtype";                     cont;                }                 Map[s2] = s1;                 cont;            }             if (s1 == "errtype") {                Map[s2] = s1;                 cont;            }             if (Map.find(s1) == Map.end()) {                Map[s2] = "errtype";                 cont;            }             s1 = Map[s1];             if (s1 == "errtype") {                Map[s2] = s1;                 cont;            }             for (i = 1; i <= k; i++) s1 = "&" + s1;             for (i = 1; i <= k1; i++) s1 += "*";             while (s1.front() == '&' && s1.back() == '*') {                s1.er(0, 1);                 s1.er(s1.size() - 1, 1);            }             if (s1.front() == '&') {                Map[s2] = "errtype";                 cont;            }             Map[s2] = s1;        }        else {            cin >> s1;             k = k1 = 0;             while (s1.front() == '&') {                k++;                 s1.er(0, 1);            }             while (s1.back() == '*') {                k1++;                 s1.er(s1.size() - 1, 1);            }             if (s1 == "void") {                cout << s1 << endl;                 cont;            }             if (Map.find(s1) == Map.end()) {                cout << "errtype" << endl;                 cont;            }             s1 = Map[s1];             if (s1 == "errtype") {                cout << s1 << endl;                 cont;            }             for (i = 1; i <= k; i++) s1 = "&" + s1;             for (i = 1; i <= k1; i++) s1 += "*";             while (s1.front() == '&' && s1.back() == '*') {                s1.er(0, 1);                 s1.er(s1.size() - 1, 1);            }             if (s1.front() == '&') {                cout << "errtype" << endl;                 cont;            }             cout << s1 << endl;        }    }     re 0;}
