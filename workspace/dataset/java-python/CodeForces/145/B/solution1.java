import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.util.Arrays;import java.util.StringTokenizer; public class Main {	public static void main(String[] args) throws FileNotFoundException {		InputReader in = new InputReader(System.in);		PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));		TaskB solver = new TaskB();		solver.solve(1, in, out);		out.flush();		out.close();	}} class Pair implements Comparable<Pair> {	int first;	int second; 	Pair(int first, int second) {		this.first = first;		this.second = second;	} 	@Override	public int compareTo(Pair e) {		return Long.compare(second, e.second); 	}} // didn't look at the editorial// failed on test case when a[2]==a[3]class TaskB {	long INF = (long) 1e9 + 7;	int MAX_N = (int) 1e5 + 5;	long mod = (long) 1e8; 	void solve(int testNumber, InputReader in, PrintWriter pw) {		int a[] = new int[4];		for (int i = 0; i < 4; i++) {			a[i] = in.nextInt();		}		int diff = Math.abs(a[3] - a[2]);		if (diff > 1) {			pw.println(-1);		} else {			StringBuilder ans = new StringBuilder();			if (a[3] == a[2]) {				if (a[3] + 1 > a[0]) {					a[1] -= (a[3] + 1);					a[0] -= (a[3]);					if (a[0] < 0 || a[1] < 0) {						pw.println(-1);						return;					}					for (int i = 0; i < a[3]; i++) {						ans.append('7'); 						ans.append('4');						if (a[0] > 0) {							for (int k = 0; k < a[0]; k++) {								ans.append('4');							}							a[0] = 0;						}					}					ans.append('7');					if (a[1] > 0) {						for (int k = 0; k < a[1]; k++) {							ans.append('7');						}						a[1] = 0;					}					pw.println(ans);				} else {					a[1] -= (a[2]);					a[0] -= (a[2] + 1);					if (a[0] < 0 || a[1] < 0) {						pw.println(-1);						return;					}					for (int i = 0; i < a[2]; i++) {						ans.append('4');						if (a[0] > 0) {							for (int k = 0; k < a[0]; k++) {								ans.append('4');							}							a[0] = 0;						}						ans.append('7');						if (a[1] > 0 && i == a[2] - 1) {							for (int k = 0; k < a[1]; k++) {								ans.append('7');							}							a[1] = 0;						}					}					ans.append('4');					pw.println(ans);				}			} else {				if (a[2] > a[3]) {					a[1] -= (a[2]);					a[0] -= (a[2]);					if (a[0] < 0 || a[1] < 0) {						pw.println(-1);						return;					}					for (int i = 0; i < a[2]; i++) {						ans.append('4');						if (a[0] > 0) {							for (int k = 0; k < a[0]; k++) {								ans.append('4');							}							a[0] = 0;						}						ans.append('7');						if (a[1] > 0 && i == a[2] - 1) {							for (int k = 0; k < a[1]; k++) {								ans.append('7');							}							a[1] = 0;						}					}					pw.println(ans);				} else {					a[1] -= (a[3]);					a[0] -= (a[3]);					if (a[0] < 0 || a[1] < 0) {						pw.println(-1);						return;					}					for (int i = 0; i < a[3]; i++) {						ans.append('7');						if (a[1] > 0 && i == a[3] - 1) {							for (int k = 0; k < a[1]; k++) {								ans.append('7');							}							a[1] = 0;						}						ans.append('4');						if (a[0] > 0) {							for (int k = 0; k < a[0]; k++) {								ans.append('4');							}							a[0] = 0;						}					}					pw.println(ans);				}			}		} 	} 	int dist(int[] x, int[] y) {		return (x[0] - y[0]) * (x[0] - y[0]) + (x[1] - y[1]) * (x[1] - y[1]); 	} 	long gcd(long a, long b) {		if (b == 0) {			return a;		} else {			return gcd(b, a % b);		}	} 	int[] shrink(int a[]) {		int n = a.length;		long b[] = new long[n];		for (int i = 0; i < n; i++) {			b[i] = ((long) (a[i] << 32)) | i;		}		Arrays.sort(b);		int ret[] = new int[n];		int p = 0;		for (int i = 0; i < n; i++) {			if (i > 0 && (b[i] ^ b[i - 1]) >> 32 != 0) {				p++;			}			ret[(int) b[i]] = p;		}		return ret;	} 	int sum(int ft[], int i) {		int sum = 0;		for (int j = i; j >= 1; j -= (j & -j)) {			sum += ft[j];//			System.out.println(sum);		}		return sum;	} 	void add(int ft[], int i, int x) {		for (int j = i; j < ft.length; j += (j & -j)) {//			System.out.println(j);			ft[j] += x;		}	} 	boolean isValid(int i, int j, char arr[][]) { 		if (i >= arr[0].length || j >= arr[0].length) {			return false;		}		if (arr[i][j] == '*') {			return false;		}		return true;	} 	long pow(long m, long k) {		long prod = 1;		for (int i = 0; i < k; i++) {			prod = (prod * m) % INF;		}		return prod % INF;	} //	int sum(int k) {//		int sum=0;//		for(int i=k;i>=1;i) {//			sum+=ft[k];//		}//	} 	long fib(int N) {		long fib[] = new long[N + 1];		fib[0] = 1;		fib[1] = 1;		for (int i = 2; i <= N; i++) {			fib[i] = (fib[i - 1] + fib[i - 2]) % mod;		}		return fib[N] % mod;	} 	long sum(int i, int j, long arr[]) {		long sum = 0;		for (int k = i; k <= j; k++) {			sum += arr[k];		}		return sum;	} 	int __gcd(int a, int b) {		if (b == 0)			return a;		return __gcd(b, a % b); 	} 	public int isPow(long num) {		int count = 0;		while (num > 0) {			num /= 2;			count++;		}		return count;	}} class InputReader {	BufferedReader br;	StringTokenizer st; 	public InputReader(InputStream in) {		br = new BufferedReader(new InputStreamReader(in));		st = null;	} 	public String next() {		while (st == null || !st.hasMoreTokens()) {			try {				st = new StringTokenizer(br.readLine());			} catch (IOException e) {				throw new RuntimeException(e);			}		}		return st.nextToken();	} 	public int nextInt() {		return Integer.parseInt(next());	} 	public long nextLong() {		return Long.parseLong(next());	} 	public double nextDouble() {		return Double.parseDouble(next());	}}
