import java.io.IOException;import java.util.*;import java.util.Arrays;import java.util.Scanner;Â public class Bit_year{	static List<Integer>[] adj;	static boolean[] visited;	    static int cyclenumber;	 	    // Function to mark the vertex with	    // different colors for different cycles	    static void dfs_cycle(int u, int p, int[] color,	                       int[] mark, int[] par)	    {	 	        // already (completely) visited vertex.	        if (color[u] == 2)	        {	            return;	        }	 	        // seen vertex, but was not completely visited -> cycle detected.	        // backtrack based on parents to find the complete cycle.	        visited[u]=true;	        if (color[u] == 1)	        {	 	            cyclenumber++;	            int cur = p;	            mark[cur] = cyclenumber;	 	            // backtrack the vertex which are	            // in the current cycle thats found	            while (cur != u)	            {	                cur = par[cur];	                mark[cur] = cyclenumber;	            }	            return;	        }	        par[u] = p;	 	        // partially visited.	        color[u] = 1;	 	        // simple dfs on graph	        for (int v : adj[u])	        {	 	            // if it has not been visited previously	            if (v == par[u])	            {	                continue;	            }	            dfs_cycle(v, u, color, mark, par);	        }	 	        // completely visited.	        color[u] = 2;	    }	public static void main(String[] args) throws IOException {				Scanner sc = new Scanner(System.in);		int n = sc.nextInt();		int k = sc.nextInt();		Vector<Integer>[] cycles = new Vector[n+1];		adj = new LinkedList[n+1];		visited = new boolean[n+1];		for(int i=1;i<=n;i++)		{			adj[i]=new LinkedList();			cycles[i] = new Vector<>();		}		List<Integer> circle = new ArrayList<Integer>();		int j=1;		while(j<=k)		{			int u = sc.nextInt();int v = sc.nextInt();			adj[u].add(v);adj[v].add(u);			j++;		}				 int[] color = new int[n+1];	     int[] par = new int[n+1];	 	     int[] mark = new int[n+1];	 	        // store the numbers of cycle	        cyclenumber = 0;	 	        // call DFS to mark the cycles	        dfs_cycle(1, 0, color, mark, par);	 	      // System.out.println(Arrays.toString(mark));	       //System.out.println(Arrays.toString(par));	      	        	        boolean possible=true;	        for (int i = 1; i <= n; i++)	        {	            if (mark[i] != 0)	                cycles[mark[i]].add(i);	        }	        for(int i=1;i<=n;i++)possible&=visited[i];	        if(possible && cyclenumber==1 && cycles[1].size()>=3)System.out.println("FHTAGN!");	        else System.out.println("NO");	        			}}
