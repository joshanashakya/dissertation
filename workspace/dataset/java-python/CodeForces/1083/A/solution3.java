import java.util.*;import java.io.*;public class helloworld { static long fact[]; static long max;	static class Reader     {         final private int BUFFER_SIZE = 1 << 16;         private DataInputStream din;         private byte[] buffer;         private int bufferPointer, bytesRead;           public Reader()         {             din = new DataInputStream(System.in);             buffer = new byte[BUFFER_SIZE];             bufferPointer = bytesRead = 0;         }           public Reader(String file_name) throws IOException         {             din = new DataInputStream(new FileInputStream(file_name));             buffer = new byte[BUFFER_SIZE];             bufferPointer = bytesRead = 0;         }           public String readLine() throws IOException         {             byte[] buf = new byte[64]; // line length             int cnt = 0, c;             while ((c = read()) != -1)             {                 if (c == '\n')                     break;                 buf[cnt++] = (byte) c;             }             return new String(buf, 0, cnt);         }           public int nextInt() throws IOException         {             int ret = 0;             byte c = read();             while (c <= ' ')                 c = read();             boolean neg = (c == '-');             if (neg)                 c = read();             do            {                 ret = ret * 10 + c - '0';             }  while ((c = read()) >= '0' && c <= '9');               if (neg)                 return -ret;             return ret;         }           public long nextLong() throws IOException         {             long ret = 0;             byte c = read();             while (c <= ' ')                 c = read();             boolean neg = (c == '-');             if (neg)                 c = read();             do {                 ret = ret * 10 + c - '0';             }             while ((c = read()) >= '0' && c <= '9');             if (neg)                 return -ret;             return ret;         }           public double nextDouble() throws IOException         {             double ret = 0, div = 1;             byte c = read();             while (c <= ' ')                 c = read();             boolean neg = (c == '-');             if (neg)                 c = read();               do {                 ret = ret * 10 + c - '0';             }             while ((c = read()) >= '0' && c <= '9');               if (c == '.')             {                 while ((c = read()) >= '0' && c <= '9')                 {                     ret += (c - '0') / (div *= 10);                 }             }               if (neg)                 return -ret;             return ret;         }           private void fillBuffer() throws IOException         {             bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);             if (bytesRead == -1)                 buffer[0] = -1;         }           private byte read() throws IOException         {             if (bufferPointer == bytesRead)                 fillBuffer();             return buffer[bufferPointer++];         }           public void close() throws IOException         {             if (din == null)                 return;             din.close();         }     } 		static int getSum(int index , int BITree[])     { 		index++;        int  sum = 0; // Iniialize result               // index in BITree[] is 1 more than         // the index in arr[]                   // Traverse ancestors of BITree[index]         while(index>0)         {             // Add current element of BITree              // to sum             sum += BITree[index];                   // Move index to parent node in              // getSum View             index -= index & (-index);         }         return sum;     }   	static int getMid(int s, int e)     {         return s + (e - s) / 2;     }       /*     * A recursive function to get the sum      of values in given range of the array.     * The following are parameters for this function.     *      * st -> Pointer to segment tree     * node -> Index of current node in     *         the segment tree.     * ss & se -> Starting and ending indexes     *         of the segment represented     *         by current node, i.e., st[node]     * l & r -> Starting and ending indexes     *         of range query     */    static int MaxUtil(int[] st, int ss, int se,                          int l, int r, int node)      {                   // If segment of this node is completely         // part of given range, then return         // the max of segment         if (l <= ss && r >= se)             return st[node];           // If segment of this node does not         // belong to given range         if (se < l || ss > r)             return -1;           // If segment of this node is partially         // the part of given range         int mid = getMid(ss, se);           return Math.max(MaxUtil(st, ss, mid, l, r, 2 * node + 1),                     MaxUtil(st, mid + 1, se, l, r, 2 * node + 2));     }       /*     * A recursive function to update the      nodes which have the given index in their     * range. The following are parameters      st, ss and se are same as defined above     * index -> index of the element to be updated.     */    static void updateValue(int arr[], int[] st, int ss,                     int se, int index, int value, int node)     {         if (index < ss || index > se)         {             System.out.println("Invalid Input");             return;         }           if (ss == se)         {               // update value in array and in segment tree             arr[index] = value;             st[node] = value;         }          else        {             int mid = getMid(ss, se);               if (index >= ss && index <= mid)                 updateValue(arr, st, ss, mid, index, value, 2 * node + 1);             else                updateValue(arr, st, mid + 1, se, index, value, 2 * node + 2);               st[node] = Math.max(st[2 * node + 1], st[2 * node + 2]);         }         return;     }       // Return max of elements in range from     // index l (query start) to r (query end).     static int getMax(int[] st, int n, int l, int r)     {           // Check for erroneous input values         if (l < 0 || r > n - 1 || l > r)          {             System.out.printf("Invalid Input\n");             return -1;         }           return MaxUtil(st, 0, n - 1, l, r, 0);     }       // A recursive function that constructs Segment     // Tree for array[ss..se]. si is index of     // current node in segment tree st     static int constructSTUtil(int arr[], int ss,                         int se, int[] st, int si)      {                   // If there is one element in array, store         // it in current node of segment tree and return         if (ss == se)          {             st[si] = arr[ss];             return arr[ss];         }           // If there are more than one elements, then         // recur for left and right subtrees and         // store the max of values in this node         int mid = getMid(ss, se);           st[si] = Math.max(constructSTUtil(arr, ss, mid, st, si * 2 + 1),                 constructSTUtil(arr, mid + 1, se, st, si * 2 + 2));           return st[si];     }       /*     * Function to construct segment tree from     given array. This function allocates     * memory for segment tree.     */    static int[] constructST(int arr[], int n)     {           // Height of segment tree         int x = (int) Math.ceil(Math.log(n) / Math.log(2));           // Maximum size of segment tree         int max_size = 2 * (int) Math.pow(2, x) - 1;           // Allocate memory         int[] st = new int[max_size];           // Fill the allocated memory st         constructSTUtil(arr, 0, n - 1, st, 0);           // Return the constructed segment tree         return st;     }     public static void updateBIT(int n, int index,                                          int val , int BITree[] )     {         // index in BITree[] is 1 more than          // the index in arr[]         index++;        // Traverse all ancestors and add 'val'         while(index <= n)         {         // Add 'val' to current node of BIT Tree         BITree[index] += val;               // Update index to that of parent          // in update View         index += index & (-index);         }     }     static long mod = 1000000007;   static long pow(long a , long b , long c)   {	   	   if(b==0)		   return 1;	   	   long ans = pow(a,b/2,c);	   if(b%2 == 0)		   return ans*ans%c;	   	   return ans*ans%c*a%c;   }      static long modInverse(long a , long b)   {	   return pow(a,b-2,mod);   }         static double d(int x1 , int y1 , int x2 , int y2)   {	   double d1 = x1-x2;	   double d2 = y1-y2;	   	   return Math.sqrt(d1*d1-d2*d2);   }  static void dfs(int n , LinkedList<Integer> arr[] , boolean visited[], long dp[],TreeMap<pair,Integer> map , int w[]){	visited[n] = true;		if(arr[n].size() == 1 && visited[arr[n].get(0)])	{	       dp[n] = w[n];	       return;	}	int sz = 0;	if(n == 1)		sz = arr[n].size();		else		sz = arr[n].size()-1;		long a[] = new long[sz];	sz = 0;	for(Integer i : arr[n])	{		if(!visited[i])		{			dfs(i,arr,visited,dp,map,w);			int cost = map.get(new pair(n,i));			a[sz++] = dp[i]-cost;		}	}	Arrays.sort(a);	if(sz == 0)	System.out.println(n);	max = Math.max(max,a[sz-1]+w[n]);	if(sz > 1)	{		max = Math.max(max,a[sz-1]+a[sz-2]+w[n]);	}		dp[n] = Math.max(a[sz-1]+w[n], w[n]);}  static int low[];static int p[];static int parent(int x , int k , int dp[][]){while(k > 0){	if(x == -1)		break;		int up = low[k];	k -= p[up];	x = dp[x][up];}return x;}public static void main(String []args) throws IOException{	Reader sc = new Reader();	int n = sc.nextInt();	TreeMap<pair , Integer> map = new TreeMap<pair,Integer>(new Compare());	int w[] = new int[n+1];	max = Long.MIN_VALUE;	for(int i = 1 ; i <= n ; i++)	{		w[i] = sc.nextInt();		max = Math.max(max,w[i]);	}	LinkedList<Integer> arr[] = new LinkedList[n+1];	for(int i = 1 ; i <= n ; i++)	{		arr[i] = new LinkedList<Integer>();	}	for(int i = 1 ; i <= n-1 ; i++)	{		int x = sc.nextInt();		int y = sc.nextInt();		int ww = sc.nextInt();		arr[x].add(y);		arr[y].add(x);		map.put(new pair(x,y),ww);		map.put(new pair(y,x) , ww);	}		long dp[] = new long[n+1];	boolean visited[] = new boolean[n+1];	if(n > 1)	{	dfs(1,arr,visited,dp,map,w);     		System.out.println(max);	}		else	System.out.println(w[1]);}} class pair{	int x , y;	public pair(int x , int y)	{		this.x = x;		this.y =y;	}} class Compare implements Comparator<pair>{	public int compare(pair a , pair b)	{		if(a.x != b.x)			return a.x-b.x;				return a.y-b.y;	}} 
