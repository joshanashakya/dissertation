//package com.cf.r526;//package com.cf.r664; import java.io.BufferedReader;import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.StringTokenizer;import java.util.stream.Collectors;import java.util.stream.IntStream; public class A { 	private FastScanner in;	private PrintWriter out;	private int n;	private int[] w;	private List<List<Road>> graph; 	public static void main(String[] args) {		new A().run();	} 	private static class Road {		int from;		int to;		long c; 		public Road(int from, int to, int c) {			this.from = from;			this.to = to;			this.c = c;		}	} 	private void run() {		in = new FastScanner(System.in);		out = new PrintWriter(System.out); 		int n = in.nextInt(); 		int[] w = IntStream.range(0, n).map(i -> in.nextInt()).toArray(); 		List<List<Road>> graph = IntStream.range(0, n).mapToObj(i -> new ArrayList<Road>()).collect(Collectors.toList());		for (int i = 0; i < n - 1; i++) {			int u = in.nextInt() - 1;			int v = in.nextInt() - 1;			int c = in.nextInt(); 			graph.get(u).add(new Road(u, v, c));			graph.get(v).add(new Road(v, u, c));		} 		this.n = n;		this.w = w;		this.graph = graph;		Arrays.fill(memoBest, -1);		Arrays.fill(memoSecondBest, -1);		out.println(solve(0, -1)); 		out.close();	} 	private long solve(int from, int parent) {		long one = bestFrom(from, parent);		long two = secondBestFrom(from, parent);		long best = one + (two >= w[from]? two - w[from] : 0);		for (Road neighbor : graph.get(from)) if (neighbor.to != parent) {			best = Math.max(best, solve(neighbor.to, from));		} 		return best;	} 	private final long[] memoBest = new long[(int) (3 * 1e5 + 10)];	private long bestFrom(int from, int parent) {		if (memoBest[from] != -1) return memoBest[from]; 		long best = w[from];		for (Road neighbor : graph.get(from)) if (neighbor.to != parent) {			best = Math.max(best, w[from] - neighbor.c + bestFrom(neighbor.to, from));		} 		memoBest[from] = best; 		return best;	} 	private final long[] memoSecondBest = new long[(int) (3 * 1e5 + 10)];	private long secondBestFrom(int from, int parent) {		if (memoSecondBest[from] != -1) return memoSecondBest[from]; 		long best = 0;		long secondBest = 0;		for (Road neighbor : graph.get(from)) if (neighbor.to != parent) {			long path = w[from] - neighbor.c + bestFrom(neighbor.to, from);			if (best < path) {				secondBest = best;				best = path;			} else if (secondBest < path) {				secondBest = path;			}		} 		memoSecondBest[from] = secondBest; 		return secondBest;	} 	static class FastScanner { 		BufferedReader br;		StringTokenizer st; 		public FastScanner(File f) {			try {				br = new BufferedReader(new FileReader(f));			} catch (FileNotFoundException e) {				e.printStackTrace();			}		} 		public FastScanner(InputStream f) {			br = new BufferedReader(new InputStreamReader(f));		} 		String next() {			while (st == null || !st.hasMoreTokens()) {				String s = null;				try {					s = br.readLine();				} catch (IOException e) {					e.printStackTrace();				}				if (s == null)					return null;				st = new StringTokenizer(s);			}			return st.nextToken();		} 		boolean hasMoreTokens() {			while (st == null || !st.hasMoreTokens()) {				String s = null;				try {					s = br.readLine();				} catch (IOException e) {					e.printStackTrace();				}				if (s == null)					return false;				st = new StringTokenizer(s);			}			return true;		} 		int nextInt() {			return Integer.parseInt(next());		} 		long nextLong() {			return Long.parseLong(next());		} 		double nextDouble() {			return Double.parseDouble(next());		}	} }
