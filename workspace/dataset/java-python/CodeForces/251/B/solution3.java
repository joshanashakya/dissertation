import java.io.InputStreamReader;import java.io.IOException;import java.util.Arrays;import java.io.BufferedReader;import java.io.OutputStream;import java.io.PrintWriter;import java.util.StringTokenizer;import java.math.BigInteger;import java.io.InputStream; /** * Built using CHelper plug-in * Actual solution is at the top * @author AlexFetisov */public class Main {	public static void main(String[] args) {		InputStream inputStream = System.in;		OutputStream outputStream = System.out;		InputReader in = new InputReader(inputStream);		PrintWriter out = new PrintWriter(outputStream);		TaskB solver = new TaskB();		solver.solve(1, in, out);		out.close();	}} class TaskB {    public void solve(int testNumber, InputReader in, PrintWriter out) {        int n = in.nextInt();        int k = in.nextInt();        int[] p = Utils.readIntArray(in, n);        int[] q = Utils.readIntArray(in, n);        int[] cool = new int[n];        for (int i = 0; i < n; ++i) {            cool[i] = i;            --p[i];            --q[i];        }        int dstForward = calcDstForward(cool.clone(), p.clone(), q.clone(), k);        int dstBack = calcDstBack(cool.clone(), p.clone(), q.clone(), k);         if (dstForward == 0) {            out.println("NO");            return;        }         if (dstForward == 1 && dstBack == 1) {            if (k == 1) {                out.println("YES");            } else {                out.println("NO");            }            return;        }         if (dstForward <= k) {            int rest = dstForward - k;            if (rest % 2 == 0) {                out.println("YES");                return;            }        }         if (dstBack <= k) {            int rest = dstBack - k;            if (rest % 2 == 0) {                out.println("YES");                return;            }        }         out.println("NO");    }     private int calcDstBack(int[] p, int[] apply, int[] q, int k) {        int step = 0;        while (!Arrays.equals(p, q) && step < k + 5) {            int[] newP = new int[p.length];            for (int i = 0; i < p.length; ++i) {                newP[i] = p[apply[i]];            }            p = newP;            ++step;        }        if (step >= k + 5) {            step = 1000000;        }        return step;    }     private int calcDstForward(int[] p, int[] apply, int[] q, int k) {        int step = 0;        while (!Arrays.equals(p, q) && step < k + 5) {            int[] newP = new int[p.length];            for (int i = 0; i < p.length; ++i) {                newP[apply[i]] = p[i];            }            p = newP;            ++step;        }        if (step >= k + 5) {            step = 1000000;        }        return step;    }} class InputReader {    private BufferedReader reader;    private StringTokenizer stt;     public InputReader(InputStream stream) {        reader = new BufferedReader(new InputStreamReader(stream));    }     public String nextLine() {        try {            return reader.readLine();        } catch (IOException e) {            return null;        }    }     public String nextString() {        while (stt == null || !stt.hasMoreTokens()) {            stt = new StringTokenizer(nextLine());        }        return stt.nextToken();    }     public int nextInt() {        return Integer.parseInt(nextString());    } } class Utils {    public static int[] readIntArray(InputReader in, int n) {        int[] a = new int[n];        for (int i = 0; i < n; ++i) {            a[i] = in.nextInt();        }        return a;    } } 
