import java.io.BufferedOutputStream;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.io.Reader;import java.util.Arrays;import java.util.Comparator;import java.util.StringTokenizer; public class B {     static final long MODULO = (long) (1e9 + 7);     public static void main(String[] args) {        BufferedScanner scanner = new BufferedScanner();        PrintWriter writer = new PrintWriter(new BufferedOutputStream(System.out));         int t = 1;//scanner.nextInt();        for (int tc = 0; tc < t; tc++) {            int n = scanner.nextInt();            Pair[] a = new Pair[n];            for (int i = 0; i < n; i++) {                int x = scanner.nextInt();                a[i] = new Pair(x, i);            }            Arrays.sort(a, Comparator.comparingInt(o -> o.val));            int[] b = new int[n];            boolean ans = true;            for (int i = 0; i < n; i++) {                // place a number just larger than a[i] at i                b[a[i].idx] = a[(i + 1) % n].val;                if (n > 1 && b[a[i].idx] == a[i].val) {                    ans = false;                    break;                }            }            if (ans) {                for (int x : b) {                    writer.print(x + " ");                }            } else {                writer.println(-1);            }        }         scanner.close();        writer.flush();        writer.close();    }     static class Pair {        final int val, idx;         Pair(int val, int idx) {            this.val = val;            this.idx = idx;        }    }     public static class BufferedScanner {        BufferedReader br;        StringTokenizer st;         public BufferedScanner(Reader reader) {            br = new BufferedReader(reader);        }         public BufferedScanner() {            this(new InputStreamReader(System.in));        }         String next() {            while (st == null || !st.hasMoreElements()) {                try {                    st = new StringTokenizer(br.readLine());                } catch (IOException e) {                    e.printStackTrace();                }            }            return st.nextToken();        }         int nextInt() {            return Integer.parseInt(next());        }         long nextLong() {            return Long.parseLong(next());        }         double nextDouble() {            return Double.parseDouble(next());        }         String nextLine() {            String str = "";            try {                str = br.readLine();            } catch (IOException e) {                e.printStackTrace();            }            return str;        }         void close() {            try {                br.close();            } catch (IOException e) {                e.printStackTrace();            }        }     }     static long gcd(long a, long b) {        if (a < b) {            return gcd(b, a);        }        while (b > 0) {            long tmp = b;            b = a % b;            a = tmp;        }        return a;    }     static long inverse(long a, long m) {        long[] ans = extgcd(a, m);        return ans[0] == 1 ? (ans[1] + m) % m : -1;    }     private static long[] extgcd(long a, long m) {        if (m == 0) {            return new long[]{a, 1, 0};        } else {            long[] ans = extgcd(m, a % m);            long tmp = ans[1];            ans[1] = ans[2];            ans[2] = tmp;            ans[2] -= ans[1] * (a / m);            return ans;        }    }     static long add(long a, long b) {        a += b;        if (a >= MODULO) {            a -= MODULO;        }        return a;    }     static long sub(long a, long b) {        a -= b;        if (a < 0) {            a += MODULO;        }        return a;    }     static long mul(long a, long b) {        return a * b % MODULO;    }     static long div(long a, long b) {        return a * inverse(b, MODULO) % MODULO;    }     static class Comb {        final long modulo;        final long[] fac, fnv;         Comb(int limit, long modulo) {            fac = new long[limit + 1];            fnv = new long[limit + 1];            fac[0] = 1;            fnv[0] = 1;            for (int i = 1; i <= limit; i++) {                fac[i] = mul(fac[i - 1], i);                fnv[i] = div(fnv[i - 1], i);            }            this.modulo = modulo;        }         long c(int total, int choose) {            if (total < choose) {                return 0;            }            if (total == 0 || total == choose) {                return 1;            }            return mul(mul(fac[total], fnv[choose]), fnv[total - choose]);        }    } }
