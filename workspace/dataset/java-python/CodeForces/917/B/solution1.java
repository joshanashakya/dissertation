import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.ArrayList;import java.util.Arrays;import java.util.StringTokenizer; /* * Java Input / Output Class using Buffered/ Input Straem * Created by @neelbhallabos * File Created at: Sept 28, 2020 */public class CF917B {	public static BufferedReader sc = new BufferedReader(new InputStreamReader(System.in));	public static StringTokenizer st;	public static PrintWriter pw = new PrintWriter(System.out);	final static boolean debugmode = true;	public static int k = 7; // for 10^9 + k mods.	public static long STMOD = 1000000000 + k; // 10^9 + k	public static int[][][] dp;	public static void main(String[] args) throws IOException {		int numnodes = getInt();		int numedges = getInt();		Node[] graph = new Node[numnodes];		for(int i = 0; i < numnodes;i++) {			graph[i] = new Node(i);		}				for(int i = 0; i < numedges;i++) {			int from = getInt()-1;			int to = getInt()-1;			int via = getString().charAt(0)-'a';						graph[from].addEdge(to, via);		}				dp = new int[numnodes][numnodes][26]; // cmovplay, omoveplay, minChar.		for(int n1 = 0; n1 < numnodes;n1++) {			for(int n2 = 0; n2 < numnodes;n2++) {				for(int i = 0; i < 26; i++) {					computeDP(n1, n2, i, graph);				}			}		} 		StringBuilder results = new StringBuilder();			for(int i = 0; i < numnodes;i++) {			// i is max: first player (row)			for(int j = 0; j < numnodes;j++) {				boolean wins = doesP1Win(i,j, graph);				if(wins) {					results.append("A");				}				else {					results.append("B");				}			}			results.append("\n");		}		submit(results.toString(), true);			 	} 	private static boolean doesP1Win(int i, int j, Node[] graph) {		Node consider = graph[i];		for(int[] edgepair : consider.ids){			int res = computeDP(j, edgepair[0], edgepair[1], graph);			if(res == 2) {				return true;			}		}		return false;	}   	private static int computeDP(int cpn, int opn, int minChar, Node[] graph) {			if(dp[cpn][opn][minChar] != 0) {			//System.out.println("returning: " + dp[cpn][opn][minChar]);			return dp[cpn][opn][minChar];		}		Node consider = graph[cpn];		for(int[] edgepair : consider.ids) {			int nextNode = edgepair[0];			int nextChar = edgepair[1];			if(nextChar >= minChar) {				int solu = computeDP(opn, nextNode, nextChar, graph);				if(solu == 2) {					dp[cpn][opn][minChar] = 1;					return 1;				}			}		}		dp[cpn][opn][minChar] = 2;		return 2;	}   	public static void setInputFile(String fn) throws IOException {		sc = new BufferedReader(new FileReader(fn));	} 	public static void setOutputFile(String fn) throws IOException {		pw = new PrintWriter(new BufferedWriter(new FileWriter(fn)));	} 	public static int GCD(int a, int b) {		if (b == 0)			return a;		return GCD(b, a % b);	} 	public static double log(int k, int v) {		return Math.log(k) / Math.log(v);	} 	public static long longpower(int a, int b) {		long[] vals = new long[(int) (log(b, 2) + 2)];		vals[0] = a;		vals[1] = a * a;		for (int i = 1; i < vals.length; i++) {			vals[i] = vals[i - 1] * vals[i - 1];		}		long ans = 1;		int cindex = 0;		while (b != 0) {			if (b % 2 == 1) {				ans *= vals[cindex];			}			cindex += 1;			b /= 2;		}		return ans; 	} 	public static void debug(String toPrint) {		if (!debugmode) {			return;		}		pw.println("[DEBUG]: " + toPrint);	} 	public static void submit(int[] k, boolean close) {		pw.println(Arrays.toString(k));		if (close) {			pw.close();		}	} 	public static void submit(int p, boolean close) {		pw.println(Integer.toString(p));		if (close) {			pw.close();		}	} 	public static void submit(String k, boolean close) {		pw.println(k);		if (close) {			pw.close();		}	} 	public static void submit(double u, boolean close) {		pw.println(Double.toString(u));		if (close) {			pw.close();		}	} 	public static void submit(long lng, boolean close) {		pw.println(Long.toString(lng));		if (close) {			pw.close();		} 	} 	public static void submit() {		pw.close();	} 	public static int getInt() throws IOException {		if (st != null && st.hasMoreTokens()) {			return Integer.parseInt(st.nextToken());		}		st = new StringTokenizer(sc.readLine());		return Integer.parseInt(st.nextToken());	} 	public static long getLong() throws IOException {		if (st != null && st.hasMoreTokens()) {			return Long.parseLong(st.nextToken());		}		st = new StringTokenizer(sc.readLine());		return Long.parseLong(st.nextToken());	} 	public static double getDouble() throws IOException {		if (st != null && st.hasMoreTokens()) {			return Double.parseDouble(st.nextToken());		}		st = new StringTokenizer(sc.readLine());		return Double.parseDouble(st.nextToken());	} 	public static String getString() throws IOException {		if (st != null && st.hasMoreTokens()) {			return st.nextToken();		}		st = new StringTokenizer(sc.readLine());		return st.nextToken();	} 	public static String getLine() throws IOException {		return sc.readLine();	} 	public static int[][] readMatrix(int lines, int cols) throws IOException {		int[][] matrr = new int[lines][cols];		for (int i = 0; i < lines; i++) {			for (int j = 0; j < cols; j++) {				matrr[i][j] = getInt();			}		}		return matrr;	} 	public static int[] readArray(int lines) throws IOException {		int[] ar = new int[lines];		for (int i = 0; i < lines; i++)			ar[i] = getInt();		return ar;	}		static class Node{		public ArrayList<int[]> ids;		public int id;		public Node(int id) {			this.id = id;			ids = new ArrayList<>();		}		public void addEdge(int other, int via) {			ids.add(new int[] {other, via});		}	} }
