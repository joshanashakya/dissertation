import java.io.OutputStream;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.util.Arrays;import java.io.IOException;import java.io.InputStreamReader;import java.util.Stack;import java.util.ArrayList;import java.util.StringTokenizer;import java.io.BufferedReader;import java.util.Comparator;import java.io.InputStream; /** * Built using CHelper plug-in * Actual solution is at the top */public class Main {    public static void main(String[] args) {        InputStream inputStream = System.in;        OutputStream outputStream = System.out;        InputReader in = new InputReader(inputStream);        PrintWriter out = new PrintWriter(outputStream);        TaskA solver = new TaskA();        solver.solve(1, in, out);        out.close();    }     static class TaskA {        public void solve(int testNumber, InputReader in, PrintWriter out) {            int n = in.nextInt();            claster[] clasters = new claster[n];            claster[] clastersSort = new claster[n];            for (int i = 0; i < n; i++) {                clasters[i] = new claster();                clastersSort[i] = clasters[i];            }            int m = in.nextInt();            for (int i = 0; i < m; i++) {                int size = in.nextInt();                for (int j = 0; j < size; j++) {                    int a = in.nextInt() - 1;                    clasters[a].fileId = i;                    clasters[a].filePartNumb = j;                    clasters[a].used = true;                }            }            Arrays.sort(clastersSort, new Comparator<claster>() {                 public int compare(claster first, claster second) {                    int used = (second.used ? 1 : 0) - (first.used ? 1 : 0);                    if (used != 0) {                        return used;                    }                    int fileCmp = first.fileId - second.fileId;                    if (fileCmp != 0) {                        return fileCmp;                    }                    return first.filePartNumb - second.filePartNumb;                }            });            for (int i = 0; i < n; i++) {                clastersSort[i].neededPos = i;            }            for (int i = 0; i < n; i++) {                clasters[i].realPos = i;            }            Stack<Integer> free = new Stack<>();            for (int i = 0; i < n; i++) {                if (!clasters[i].used) {                    free.push(i);                }            }            ArrayList<claster> clastersList = new ArrayList<>();            for (int i = 0; i < n; i++) {                if (clasters[i].used && clasters[i].realPos != clasters[i].neededPos) {                    clastersList.add(clasters[i]);                }                if (!clasters[i].used) {                    clasters[i] = null;                }            }            ArrayList<op> ans = new ArrayList<>();            for (claster cur : clastersList) {                if (cur.realPos == cur.neededPos) continue;                if (clasters[cur.neededPos] != null) {                    int curFree = free.pop();                    ans.add(new op(cur.neededPos, curFree));                    clasters[curFree] = clasters[cur.neededPos];                    clasters[curFree].realPos = curFree;                }                ans.add(new op(cur.realPos, cur.neededPos));                clasters[cur.neededPos] = clasters[cur.realPos];                free.push(cur.realPos);                clasters[cur.realPos] = null;                cur.realPos = cur.neededPos;            }            out.println(ans.size());            for (op cur : ans) {                out.println(cur);            }        }     }     static class op {        int from;        int to;         op(int i, int j) {            from = i;            to = j;        }         public String toString() {            return (from + 1) + " " + (to + 1);        }     }     static class claster {        int fileId;        int filePartNumb;        int neededPos;        int realPos;        boolean used;     }     static class InputReader {        private BufferedReader reader;        private StringTokenizer stt;         public InputReader(InputStream stream) {            reader = new BufferedReader(new InputStreamReader(stream));        }         public String nextLine() {            try {                return reader.readLine();            } catch (IOException e) {                return null;            }        }         public String next() {            while (stt == null || !stt.hasMoreTokens()) {                stt = new StringTokenizer(nextLine());            }            return stt.nextToken();        }         public int nextInt() {            return Integer.parseInt(next());        }     }} 
