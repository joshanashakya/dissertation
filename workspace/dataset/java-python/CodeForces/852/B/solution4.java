import java.io.OutputStream;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.util.Arrays;import java.util.StringTokenizer;import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.InputStream; /** * Built using CHelper plug-in * Actual solution is at the top * * @author koneko096 */public class Main {  public static void main(String[] args) {    InputStream inputStream = System.in;    OutputStream outputStream = System.out;    InputReader in = new InputReader(inputStream);    PrintWriter out = new PrintWriter(outputStream);    BNeuralNetworkCountry solver = new BNeuralNetworkCountry();    solver.solve(1, in, out);    out.close();  }   static class BNeuralNetworkCountry {    final int mod = 1000000007;     int add(int a, int b) {      int res = a + b;      if (res >= mod)        res -= mod;      return res;    }     public void solve(int testNumber, InputReader in, PrintWriter out) {      int n = in.nextInt();      int l = in.nextInt();      int m = in.nextInt();       int[] inL = new int[m];      for (int i = 0; i < n; i++) {        int x = in.nextInt();        inL[x % m]++;      }       int[] midTrans = new int[n];      int[] midL = new int[m];      for (int i = 0; i < n; i++) {        int x = in.nextInt();        midTrans[i] = x;        midL[x % m]++;      }       int[] outL = new int[n];      for (int i = 0; i < n; i++) {        outL[i] = in.nextInt();      }       // Compute       Mat mat = new Mat(midL);      Mat res = new Mat(m);       l -= 2;      while (l > 0) {        if (l % 2 == 1) {          res.multiply(mat);          l--;        }        mat.multiply(mat);        l >>= 1;      }       int[] resVec = res.frontMultiply(inL);       int[] lastL = new int[m];      int ans = 0;      for (int i = 0; i < n; i++) {        Arrays.fill(lastL, 0);         int trans = midTrans[i];        for (int j = 0; j < m; j++) {          lastL[(j + trans) % m] = add(lastL[(j + trans) % m], resVec[j]);        }         trans = outL[i];        ans = add(ans, lastL[(m - trans) % m]);      }       out.println(ans);    }     class Mat {      int[][] M;      int dim;      final int mod = 1000000007;       Mat(int n) {        M = new int[n][n];        for (int i = 0; i < n; i++) {          M[i][i] = 1;        }        this.dim = n;      }       Mat(int[] src) {        int n = src.length;        M = new int[n][n];         System.arraycopy(src, 0, M[0], 0, n);        for (int i = 1; i < n; i++) {          for (int j = 0; j < n; j++) {            M[i][j] = src[(n - i + j) % n];          }        }         this.dim = n;      }       int add(int a, int b) {        int res = a + b;        if (res >= mod)          res -= mod;        return res;      }       int mul(int a, int b) {        return (int) ((long) a * b % mod);      }       void multiply(Mat rhs) {        int[][] res = new int[this.dim][this.dim];         for (int i = 0; i < this.dim; i++) {          for (int j = 0; j < this.dim; j++) {            int sum = 0;            for (int k = 0; k < this.dim; k++) {              sum = add(sum, mul(this.M[i][k], rhs.M[k][j]));            }            res[i][j] = sum;          }        }         this.M = res;      }       int[] frontMultiply(int[] lhs) {        int[] res = new int[this.dim];         for (int j = 0; j < this.dim; j++) {          int sum = 0;          for (int k = 0; k < this.dim; k++) {            sum = add(sum, mul(lhs[k], this.M[k][j]));          }          res[j] = sum;        }         return res;      }     }   }    static class InputReader {    public BufferedReader reader;    public StringTokenizer tokenizer;     public InputReader(InputStream stream) {      reader = new BufferedReader(new InputStreamReader(stream), 32768);      tokenizer = null;    }     public String next() {      while (tokenizer == null || !tokenizer.hasMoreTokens()) {        try {          tokenizer = new StringTokenizer(reader.readLine());        } catch (IOException e) {          throw new RuntimeException(e);        }      }      return tokenizer.nextToken();    }     public int nextInt() {      return Integer.parseInt(next());    }   }} 
