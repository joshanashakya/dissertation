	import java.util.*;	import java.io.*;Â 			public class codeforces			{					public static long M = 1000000007;				public static TreeSet<Integer> adj[];							public static void main(String[] args)				{					InputReader in = new InputReader(System.in);					PrintWriter pw = new PrintWriter(System.out);										int n = in.nextInt();					int l = in.nextInt();					int m = in.nextInt();					long[][] dp = new long[m][1];					int[] start = new int[n];					int[] layer = new int[n];					int[] end = new int[n];					long[][] mat = new long[m][m];										for(int i=0;i<n;i++)					{						start[i] = in.nextInt();						dp[start[i]][0]++;					}					for(int i=0;i<n;i++)						layer[i] = in.nextInt();					for(int i=0;i<n;i++)						end[i] = in.nextInt();					HashMap<Integer, Long> map = new HashMap<>();					for(int i=0;i<n;i++)					{						if(!map.containsKey(layer[i]))							map.put(layer[i], 1L);						else							map.put(layer[i], map.get(layer[i])+1);					}					for(int i=0;i<m;i++)					{						int key = m+i;						for(int j=0;j<m;j++)						{							if(map.containsKey(key%m))								mat[i][j] = map.get(key%m);							key--;						}					}					mat = matrixpower(mat, l-2, M);					dp = matrixmultiply(mat, dp, M);					long ans = 0;					for(int i=0;i<n;i++)					{						ans += dp[(m-(layer[i]+end[i])%m)%m][0];						if(ans >= M)							ans %= M;					}					pw.println(ans);					pw.flush();					pw.close();				}								public static long[][] matrixpower(long[][] mat, long n, long p)				{					int r = mat.length;					long[][] ans = new long[r][r];										for(int i=0;i<r;i++)						ans[i][i] = 1;										while(n > 0)					{						if(n%2 == 1)							ans = matrixmultiply(ans, mat, p);						mat = matrixmultiply(mat, mat, p);						n /= 2;					}										return ans;				}								public static long[][] matrixmultiply(long[][] M1, long[][] M2, long p)				{					int m1 = M1.length, m2 = M2[0].length;					long[][] ans = new long[m1][m2];										for(int i=0;i<m1;i++)					{						for(int j=0;j<m2;j++)						{							for(int k=0;k<M2.length;k++)							{								ans[i][j] += M1[i][k]*M2[k][j];								if(ans[i][j] >= p)									ans[i][j] %= p;							}						}						//System.out.println(Arrays.toString(ans[i]));					}					return ans;				}								public static long prime(long nth) {				    				    long num, count, i;				    num=1;				    count=0;				 				    while (count < nth){				      num=num+1;				      for (i = 2; i <= num; i++){ //Here we will loop from 2 to num				        if (num % i == 0) {				          break;				        }				      }				      if ( i == num){//if it is a prime number				        count = count+1;				      }				    }				    return num;				  }			  								public static int[] suffle(int[] a,Random gen)				{					int n = a.length;					for(int i=0;i<n;i++)					{						int ind = gen.nextInt(n-i)+i;						int temp = a[ind];						a[ind] = a[i];						a[i] = temp;					}					return a;				}								public static long modularExponentiation(long x,long n,long M)				{				    long result=1;				    while(n>0)				    {				        if(n % 2 ==1)				            result=(result * x)%M;				        x=(x*x)%M;				        n=n/2;				    }				    return result;				}								public static long modInverse(long A,long M)				{				    return modularExponentiation(A,M-2,M);				}								public static int BinarySearch_l(long[] a, long k)				{					int n = a.length;					int i = 0, j = n-1;					int mid = 0;										if(k - a[n-1] > 0)						return n;					else					{						while(j - i > 0)						{							mid = (i+j)/2;														if(k - a[mid] > 0)								i = mid + 1;							else								j = mid;						}					}										return i;				}								public static int BinarySearch_r(long[] a, long k)				{					int n = a.length;					int i = 0, j = n-1;					int mid = 0;										if(k - a[0] < 0)						return -1;					else					{						while(j - i > 0)						{							mid = (int)Math.ceil((double)(i+j)/2);														if(k - a[mid] >= 0)								i = mid;							else								j = mid - 1;						}					}										return i;				}				public static long fact(long n, long M)				{					long ans = 1;										for(long i=n;i>0;i--)					{						ans = (ans*i)%M;					}										return ans;				}							/*	public static void DFS(int sourse)				{					int count = 0;					visited[sourse] = true;										for(int u : adj[sourse])					{						if(!visited[u])						{							DFS(u);						}					}														}*/								public static ArrayList Divisors(int n)				{				    ArrayList<Integer> div = new ArrayList<>();				    				    for (int i=1; i<=Math.sqrt(n); i++)				    {				        if (n%i == 0)				        {				        	div.add(i);				                				            if(n/i != i)				            	div.add(n/i);				        }				    }				    return div;				}							public static long GCD(long a,long b)				{					if(b==0)						return a;					else						return GCD(b,a%b);				}								public static long LCM(long a,long b)				{					return (a*b)/GCD(a, b);				}								static class pair implements Comparable<pair>				{					Integer x, y;					pair(int x,int y)					{						this.x=x;						this.y=y;					}										public int compareTo(pair o) {						int result = x.compareTo(o.x);						if(result==0)							result = y.compareTo(o.y);												return result;					}  										public String toString()					{						return x+" "+y;					}										public boolean equals(Object o)					{						if (o instanceof pair)					    {							pair p = (pair)o;							return p.x - x == 0 && p.y - y == 0 ;						}						return false;					}										public int hashCode()					{						return new Long(x).hashCode()*31 + new Long(y).hashCode();					}				}								static class InputReader 				{					 					private final InputStream stream;					private final byte[] buf = new byte[8192];					private int curChar, snumChars;					private SpaceCharFilter filter;			 					public InputReader(InputStream stream) 					{						this.stream = stream;					}			 					public int snext() 					{						if (snumChars == -1)							throw new InputMismatchException();						if (curChar >= snumChars) 						{							curChar = 0;							try 							{								snumChars = stream.read(buf);							} 							catch (IOException e) 							{								throw new InputMismatchException();							}							if (snumChars <= 0)								return -1;						}						return buf[curChar++];					}			 					public int nextInt() 				    {						int c = snext();						while (isSpaceChar(c)) 						{							c = snext();						}						int sgn = 1;						if (c == '-')					    {							sgn = -1;							c = snext();						}						int res = 0;						do 						{							if (c < '0' || c > '9')								throw new InputMismatchException();							res *= 10;							res += c - '0';							c = snext();						} while (!isSpaceChar(c));						return res * sgn;					}			 					public long nextLong()				    {						int c = snext();						while (isSpaceChar(c)) 						{							c = snext();						}						int sgn = 1;						if (c == '-') 						{							sgn = -1;							c = snext();						}						long res = 0;						do 						{							if (c < '0' || c > '9')								throw new InputMismatchException();							res *= 10;							res += c - '0';							c = snext();						} while (!isSpaceChar(c));						return res * sgn;					}			 					public int[] nextIntArray(int n) 					{						int a[] = new int[n];						for (int i = 0; i < n; i++) 						{							a[i] = nextInt();						}						return a;					}			 					public String readString()				    {						int c = snext();						while (isSpaceChar(c)) 						{							c = snext();						}						StringBuilder res = new StringBuilder();						do 						{							res.appendCodePoint(c);							c = snext();						} while (!isSpaceChar(c));						return res.toString();					}			 					public String nextLine() 					{						int c = snext();						while (isSpaceChar(c))							c = snext();						StringBuilder res = new StringBuilder();						do 						{							res.appendCodePoint(c);							c = snext();						} while (!isEndOfLine(c));						return res.toString();					}			 					public boolean isSpaceChar(int c) 					{						if (filter != null)							return filter.isSpaceChar(c);						return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;					}			 					private boolean isEndOfLine(int c) 					{						return c == '\n' || c == '\r' || c == -1;					}			 					public interface SpaceCharFilter				    {						public boolean isSpaceChar(int ch);					}				}								static class CodeX {		        public static void sort(long arr[]) {		            merge_sort(arr, 0, arr.length - 1);		        }				        private static void merge_sort(long A[], long start, long end) {		            if (start < end) {		                long mid = (start + end) / 2;		                merge_sort(A, start, mid);		                merge_sort(A, mid + 1, end);		                merge(A, start, mid, end);		            }				        }				        private static void merge(long A[], long start,long mid, long end) {		            long p = start, q = mid + 1;		            long Arr[] = new long[(int)(end - start + 1)];		            long k = 0;				            for (int i = (int)start; i <= end; i++) {		                if (p > mid)		                    Arr[(int)k++] = A[(int)q++];				                else if (q > end)		                    Arr[(int)k++] = A[(int)p++];				                else if (A[(int)p] < A[(int)q])		                    Arr[(int)k++] = A[(int)p++];				                else		                    Arr[(int)k++] = A[(int)q++];		            }		            for (int i = 0; i < k; i++) {		                A[(int)start++] = Arr[i];		            }				        }				    }			}									
