import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.Arrays;import java.util.HashMap;import java.util.StringTokenizer;import java.util.TreeSet; public class A {	static PrintWriter out = new PrintWriter(System.out); 	static int R,C,b[][];	static int rows[][];	static int[] uR,uC;	static int cols[][];	public static void main(String[] args) {		FS in = new FS();		R = in.nextInt();		C = in.nextInt();		b = new int[R][C];		for(int i = 0; i < R; i++)			for(int j = 0; j < C; j++)				b[i][j] = in.nextInt();				// do rows		rows = new int[R][C];		uR = new int[R];		for(int r = 0; r < R; r++) {			rows[r] = Arrays.copyOf(b[r], C);			TreeSet<Integer> ts = new TreeSet<Integer>();			HashMap<Integer, Integer> m = new HashMap<Integer, Integer>();			for(int ii : rows[r]) ts.add(ii);			for(int ii : ts) m.put(ii, m.size());			for(int c = 0; c < C; c++) rows[r][c] = m.get(rows[r][c]);			uR[r] = m.size();		}				// Do cols		uC = new int[C];		cols = new int[C][];		for(int c = 0 ;c < C; c++) {			int v[] = new int[R];			for(int r = 0; r < R; r++) v[r] = b[r][c];			cols[c] = v;			TreeSet<Integer> ts = new TreeSet<Integer>();			HashMap<Integer, Integer> m = new HashMap<Integer, Integer>();			for(int ii : cols[c]) ts.add(ii);			for(int ii : ts) m.put(ii, m.size());			for(int r = 0; r < R; r++) cols[c][r] = m.get(cols[c][r]);			uC[c] = m.size();		}				for(int r = 0; r < R; r++) {			for(int c = 0; c < C; c++) {				int res = 1023123123;				int mr = rows[r][c];				int mc = cols[c][r];				// keep row same				if(mr == mc) {					res = Math.max(uR[r], uC[c]);				}				else if(mr < mc) {					res = Math.max(uC[c], mc + (uR[r]-mr));				}				else {					res = Math.max(uR[r], mr + (uC[c]-mc));				}								out.print(res+" ");			}			out.println();		}				out.close();	}		static class FS{		BufferedReader br;		StringTokenizer st;		public FS() {			br = new BufferedReader(new InputStreamReader(System.in));		}		String next() {			while(st == null || !st.hasMoreElements()) {				try {st = new StringTokenizer(br.readLine());}				catch(Exception e) { throw null;}			}			return st.nextToken();		}		int nextInt() { return Integer.parseInt(next());}		double nextDouble() { return Double.parseDouble(next());}		long nextLong() { return Long.parseLong(next());}		int[] NIA(int n) {			int r[] = new int[n];			for(int i = 0; i < n; i++) r[i] = nextInt();			return r;		}		long[] NLA(int n) {			long r[] = new long[n];			for(int i = 0; i < n; i++) r[i] = nextLong();			return r;		}		char[][] grid(int r, int c){			char res[][] = new char[r][c];			for(int i = 0; i < r; i++) {				char l[] = next().toCharArray();				for(int j = 0; j < c; j++) {					res[i][j] = l[j];				}			}			return res;		}	}	}
