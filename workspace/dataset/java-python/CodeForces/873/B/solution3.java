import java.util.ArrayList;import java.util.Scanner; public class BalancedSubstring { 	public static void main(String[] args) {		Scanner scanner = new Scanner(System.in);		int n = Integer.parseInt(scanner.nextLine());		String s = scanner.nextLine();		scanner.close();				int output = solveProblem(n, s);		System.out.println(output);	}		private static int solveProblem(int n, String s) {		int ones = 0;		int zeroes = 0;		int[] nums = new int[n];		for(int i = 0; i < n; i++) {			char c = s.charAt(i);			//put -1 in array if c was 0, 1 if it was 1			nums[i] = Character.getNumericValue(c)*2-1;			if(c == '0') {				zeroes++;				continue;			}			ones++;		}		if(ones == zeroes) return n;		//weight negative if too many -1 in array, positive if too many 1		int weight = ones-zeroes;		int weightMod = weight/Math.abs(weight);				//fill removal steps, storing removal index and total weight change		ArrayList<Integer[]> leftRemovals = new ArrayList<Integer[]>();		ArrayList<Integer[]> rightRemovals = new ArrayList<Integer[]>();		int rightChange = 0;		int leftChange = 0;		for(int i = 0; i < n; i++) {			leftChange += nums[i];			rightChange += nums[n-i-1];			if(nums[i]*weightMod > 0 && (i+1 >= n || nums[i+1]*weightMod < 0)) {				Integer[] toAdd = {i, leftChange};				leftRemovals.add(toAdd);			}			if(nums[n-i-1]*weightMod > 0 && (i+1 >= n || nums[n-i-2]*weightMod < 0)) {				Integer[] toAdd = {i, rightChange};				rightRemovals.add(toAdd);			}		}				//remove bad options from removal arrays		for(int i = 0; i < leftRemovals.size(); i++) {			int change = leftRemovals.get(i)[1];			if(change*weightMod <= 0 || (i > 0 && change*weightMod <= leftRemovals.get(i-1)[1]*weightMod)) {				leftRemovals.remove(i);				i--;				if(i == leftRemovals.size()-1) break;			}		}		for(int i = 0; i < rightRemovals.size(); i++) {			int change = rightRemovals.get(i)[1];			if(change*weightMod <= 0 || (i > 0 && change*weightMod <= rightRemovals.get(i-1)[1]*weightMod)) {				rightRemovals.remove(i);				i--;				if(i == rightRemovals.size()-1) break;			}		} 		//match the removal steps		int fewestRemovals = Integer.MAX_VALUE;		for(int i = 0; i < leftRemovals.size(); i++) {			Integer[] leftRemoval = leftRemovals.get(i);			int newWeight = (weight-leftRemoval[1])*weightMod;			if(newWeight <= 0) {				int leaveOn = newWeight*-1;				int numToRemove = leftRemoval[0]+1-leaveOn;				if(numToRemove < fewestRemovals) fewestRemovals = numToRemove;				continue;			}			int neededDiff = newWeight;			Integer[] rightRemoval = binarySearch(neededDiff, rightRemovals, weightMod, leftRemoval[0], n);			if(rightRemoval == null) continue;			int leaveOn = (weight-leftRemoval[1]-rightRemoval[1])*weightMod*-1;			int numToRemove = leftRemoval[0]+2+rightRemoval[0]-leaveOn;			if(numToRemove < fewestRemovals) fewestRemovals = numToRemove;		}		//check best right option that could solve problem with no left input		Integer[] rightRemoval = binarySearch(weight*weightMod, rightRemovals, weightMod, -1, n);		if(rightRemoval != null) {			int leaveOn = (weight-rightRemoval[1])*weightMod*-1;			int numToRemove = rightRemoval[0]+1-leaveOn;			if(numToRemove < fewestRemovals) fewestRemovals = numToRemove;		}				return n-fewestRemovals;	}		private static Integer[] binarySearch(int neededDiff, ArrayList<Integer[]> rightRemovals, int weightMod, int leftIdx, int n) {		int l = 0;		int r = rightRemovals.size()-1;		while(true) {			if(l > r) return null;			int idx = (l+r)/2;			if(rightRemovals.get(idx)[0] + leftIdx > n-2) {				r = idx-1;				continue;			}			if(rightRemovals.get(idx)[1]*weightMod >= neededDiff) {				 if(idx == 0 || rightRemovals.get(idx-1)[1]*weightMod < neededDiff) return rightRemovals.get(idx);				 r = idx-1;				 continue;			}			l = idx+1;		}	} }
