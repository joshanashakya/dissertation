import java.util.*;import java.io.*;  public class Main {     public static void main(String[] args)    {        InputReader in = new InputReader(System.in);        OutputWriter out = new OutputWriter(System.out);        int n = in.nextInt();        long A = in.nextLong();        long cf = in.nextLong();        long cm = in.nextLong();        long m = in.nextLong();        long[]a = new long[n];        long[]index= new long[n];         for (int i =0;i<n;i++)        {            a[i]=in.nextLong();            index[i]=i;        }        MergeSort(a,index,0,n-1);        long[] preMin= new long[n];        long[]postMax = new long[n+1];        for (int i =1;i<n;i++)        {            preMin[i]+=(long)(preMin[i-1]+(i*(a[i]-a[i-1])));        }        postMax[n-1]= A-a[n-1];        for (int i =n-2;i>=0;i--)        {            postMax[i]=(long)(postMax[i+1]+(A-a[i]));        }        int t1=-1;        int t2=-1;        long max=0;    long incMin=0;        for (int i=n;i>=0;i--)        {            int start=0;            int end=i-1;            int h =-1;            long min=0;            long k = m-postMax[i];                 if (k >= 0) {                    while (end >= start) {                        int mid = (start + end) / 2;                        if (preMin[mid] <= k) {                            h = mid;                            start = mid + 1;                         } else                            end = mid - 1;                    }                    long current=0;                    if (h>-1) {                        min = Math.min((k - preMin[h]) / (h + 1) + a[h], A);                        current = (long) (min * cm);                        current += (long) ((n - i) * cf);                     }                    else                    {                        current=(long)(A*cm);                        current+=(long)((n-i)*cf);                    }                       if (current >= max) {                        max = current;                        t1 = i;                        t2 = h;                        incMin = min;                    }                }          }     out.printLine(max);        for (int i =0;i<=t2;i++)            a[i]=(long)incMin;        for (int i =t1;i<n;i++)            a[i]=A;         MergeSort(index,a,0,n-1);        for (long item:a             ) {            out.print(item+" ");        }        out.flush();    }    static void MergeSort(long[] a, long[] b,  int p, int r)    {        if (p < r)        {            int q = (r + p) / 2;            MergeSort(a, b,  p, q);            MergeSort(a, b,  q + 1, r);            Merge(a, b, p, q, r);        }    }    static void Merge(long[] a, long[] b,int p, int q, int r)    {        int n1 = q - p + 1;        int n2 = r - q;        long[] R = new long[n1 + 1];        long[] L = new long[n2 + 1];        long[] R1 = new long[n1];        long[] L1 = new long[n2];         for (int i = 0; i < n1; i++)        {            R[i] = a[p + i];            R1[i] = b[p + i];         }        R[n1] = Integer.MAX_VALUE;        for (int i = 0; i < n2; i++)        {            L[i] = a[q + i + 1];            L1[i] = b[q + i + 1];         }        L[n2] =Integer.MAX_VALUE;        int n = a.length;        int j = 0;        int k = 0;        for (int i = p; i <= r; i++)        {            if (L[j] < R[k])            {                a[i] = L[j];                b[i] = L1[j];                 j++;            }            else if (L[j]>R[k])            {                a[i] = R[k];                b[i] = R1[k];                 k++;            }            else            {                if (L1[j] < R1[k])                {                    a[i] = L[j];                    b[i] = L1[j];                     j++;                }                else                {                    a[i] = R[k];                    b[i] = R1[k];                     k++;                }            }         }    }}       class pair  implements Comparable{     int key;    int value;    public pair(Object key, Object value) {         this.key = (int)key;        this.value=(int)value;    }     @Override    public int compareTo(Object o) {        pair temp =(pair)o;        return  key-temp.key;    }}class Graph {      int n;    ArrayList<Integer>[] adjList;     public Graph(int n) {        this.n = n;        adjList = new ArrayList[n];        for (int i = 0; i < n; i++)            adjList[i] = new ArrayList<>();    } }  class InputReader {     private final InputStream stream;    private final byte[] buf = new byte[8192];    private int curChar, snumChars;     public InputReader(InputStream stream) {        this.stream = stream;    }     public int read() {        if (snumChars == -1)            throw new InputMismatchException();        if (curChar >= snumChars) {            curChar = 0;            try {                snumChars = stream.read(buf);            } catch (IOException e) {                throw new InputMismatchException();            }            if (snumChars <= 0)                return -1;        }        return buf[curChar++];    }     public int nextInt() {        int c = read();        while (isSpaceChar(c)) {            c = read();        }        int sgn = 1;        if (c == '-') {            sgn = -1;            c = read();        }        int res = 0;        do {            res *= 10;            res += c - '0';            c = read();        } while (!isSpaceChar(c));        return res * sgn;    }     public long nextLong() {        int c = read();        while (isSpaceChar(c)) {            c = read();        }        int sgn = 1;        if (c == '-') {            sgn = -1;            c = read();        }        long res = 0;        do {            res *= 10;            res += c - '0';            c = read();        } while (!isSpaceChar(c));        return res * sgn;    }     public int[] nextIntArray(int n) {        int a[] = new int[n];        for (int i = 0; i < n; i++) {            a[i] = nextInt();        }        return a;    }     public String readString() {        int c = read();        while (isSpaceChar(c)) {            c = read();        }        StringBuilder res = new StringBuilder();        do {            res.appendCodePoint(c);            c = read();        } while (!isSpaceChar(c));        return res.toString();    }     public String nextLine() {        int c = read();        while (isSpaceChar(c))            c = read();        StringBuilder res = new StringBuilder();        do {            res.appendCodePoint(c);            c = read();        } while (!isEndOfLine(c));        return res.toString();    }     public boolean isSpaceChar(int c) {        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;    }     private boolean isEndOfLine(int c) {        return c == '\n' || c == '\r' || c == -1;    } } class OutputWriter {    private final PrintWriter writer;     public OutputWriter(OutputStream outputStream) {        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));    }     public OutputWriter(Writer writer) {        this.writer = new PrintWriter(writer);    }     public void print(Object... objects) {        for (int i = 0; i < objects.length; i++) {            if (i != 0)                writer.print(' ');            writer.print(objects[i]);        }    }      public void printLine(Object... objects) {        print(objects);        writer.println();    }     public void close() {        writer.close();    }     public void flush() {        writer.flush();    } }
