import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.Objects;import java.util.Random;import java.util.StringTokenizer;Â public class Solution{			    public static void main(String[] args) throws IOException {         	FastScanner fs = new FastScanner();    	PrintWriter out = new PrintWriter(System.out);    	    	    		    	int tt = 1;    	while(tt-->0) {    		    		    		int n = fs.nextInt();    		Point p = new Point(fs.nextInt(), fs.nextInt());    		    		Point[] pts = new Point[n];    		for(int i=0;i<n;i++) {    			pts[i] = new Point(fs.nextInt(), fs.nextInt());    		}    		    		double maxR = 0, minR = Double.MAX_VALUE;    		    		for(int i=0;i<n;i++) {    			int cur = i;    			int next = (i+1)%n;    			double r = p.dist2(pts[cur]);    			maxR = Math.max(maxR, r);    			minR = Math.min(minR, r);    			    			Point intP;    			    			if(pts[cur].x==pts[next].x) {    				intP = new Point(pts[cur].x, p.y);    			}    			else {    				Line l = new Line(pts[cur], pts[next]);        			intP = p.perFoot(l);    			}    			    			boolean bool = isInside(intP, pts[cur], pts[next]);    			if(isInside(intP, pts[cur], pts[next])) {    				minR = Math.min(minR, p.dist2(intP));    			}    			    			int x = 1;    		}    		    		double area = Math.PI*(maxR-minR);    		out.println(area);    		    		    	}    	    		    		    		    	out.close();    		    }        static boolean isInside(Point p, Point p1, Point p2) {    	boolean bool1 = p.x>=p1.x && p.y<=p1.y && p.x<=p2.x && p.y>=p2.y;    	boolean bool2 = p.x<=p1.x && p.x<=p1.y && p.x>=p2.x && p.y>=p2.y;    	Point temp = p1; p1 = p2; p2 = temp;    	boolean bool3 = p.x>=p1.x && p.y<=p1.y && p.x<=p2.x && p.y>=p2.y;    	boolean bool4 = p.x<=p1.x && p.x<=p1.y && p.x>=p2.x && p.y>=p2.y;    	return bool1 || bool2 || bool3 || bool4;    }                  static class Point{    	double x, y;    	    	Point(double x,double y){    		this.x = x; this.y = y;    	}    	    	double dist2(Point p) {    		double dx = this.x-p.x;    		double dy = this.y-p.y;    		return dx*dx + dy*dy;    	}    	    	    	    	Point perFoot(Line l) {    		double x = (this.x + l.m*this.y - l.m*l.c)/(1 + l.m*l.m);    		double y = (l.m*this.x + l.m*l.m*this.y + l.c)/(1 + l.m*l.m);    		return new Point(x, y);    	}    }            static class Line{    	double m, c;    	    	Line(Point p1, Point p2){    		this.m = ((double)(p1.y-p2.y))/(p1.x-p2.x);    		this.c = p1.y - m*p1.x;    	}    	    }                                                                static final Random random=new Random();    	    static void ruffleSort(int[] a) {    	int n=a.length;//shuffle, then sort     	for (int i=0; i<n; i++) {    		int oi=random.nextInt(n); int temp=a[oi];    		a[oi]=a[i]; a[i]=temp;    	}    	Arrays.sort(a);    }             static void reverse(int[] arr, int l, int r) {    	for(int i=l;i<l+(r-l)/2;i++){    		int temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;    	}    }        	    	    static class FastScanner{    	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    	StringTokenizer st = new StringTokenizer("");         	public String next(){    		while(!st.hasMoreElements()){    			try{    				st = new StringTokenizer(br.readLine());    			} catch(IOException e){    				e.printStackTrace();    			}    		}    		return st.nextToken();    	}    		    	public String nextLine() throws IOException {    		return br.readLine();    	}    		    	public int nextInt(){    		return Integer.parseInt(next());    	}         	public int[] readArray(int n){    		int[] a = new int[n];    		for(int i=0;i<n;i++)    			a[i] = nextInt();    		return a;    	}    		    	public long nextLong() {    		return Long.parseLong(next());    	}    		    	public char nextChar() {    		return next().toCharArray()[0];    	}    }   	}
