import java.io.OutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.IOException;import java.io.UncheckedIOException;import java.math.BigDecimal;import java.io.Closeable;import java.io.Writer;import java.io.OutputStreamWriter;import java.io.InputStream; /** * Built using CHelper plug-in * Actual solution is at the top */public class Main {    public static void main(String[] args) throws Exception {        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);        thread.start();        thread.join();    }     static class TaskAdapter implements Runnable {        @Override        public void run() {            InputStream inputStream = System.in;            OutputStream outputStream = System.out;            FastInput in = new FastInput(inputStream);            FastOutput out = new FastOutput(outputStream);            APeterAndSnowBlower solver = new APeterAndSnowBlower();            solver.solve(1, in, out);            out.close();        }    }     static class APeterAndSnowBlower {        public void solve(int testNumber, FastInput in, FastOutput out) {            int n = in.readInt();            Point2 center = new Point2(in.readInt(), in.readInt());            Point2 last = null;            double maxR = -1;            double minR = (long) 1e18;            Point2 first = null;            for (int i = 0; i < n; i++) {                Point2 cur = new Point2(in.readInt(), in.readInt());                double r = Point2.dist(center, cur);                maxR = Math.max(r, maxR);                minR = Math.min(r, minR);                 if (last != null) {                    Line2 line = new Line2(last, cur);                    Point2 pt = line.projection(center);                    if (Point2.onSegment(last, cur, pt)) {                        minR = Math.min(minR, Point2.dist(pt, center));                    }                } else {                    first = cur;                }                 last = cur;            }            Line2 line = new Line2(last, first);            Point2 pt = line.projection(center);            if (Point2.onSegment(last, first, pt)) {                minR = Math.min(minR, Point2.dist(pt, center));            }             double ans = (maxR * maxR - minR * minR) * Math.PI;            out.println(ans);        }     }     static class FastInput {        private final InputStream is;        private byte[] buf = new byte[1 << 13];        private int bufLen;        private int bufOffset;        private int next;         public FastInput(InputStream is) {            this.is = is;        }         private int read() {            while (bufLen == bufOffset) {                bufOffset = 0;                try {                    bufLen = is.read(buf);                } catch (IOException e) {                    bufLen = -1;                }                if (bufLen == -1) {                    return -1;                }            }            return buf[bufOffset++];        }         public void skipBlank() {            while (next >= 0 && next <= 32) {                next = read();            }        }         public int readInt() {            int sign = 1;             skipBlank();            if (next == '+' || next == '-') {                sign = next == '+' ? 1 : -1;                next = read();            }             int val = 0;            if (sign == 1) {                while (next >= '0' && next <= '9') {                    val = val * 10 + next - '0';                    next = read();                }            } else {                while (next >= '0' && next <= '9') {                    val = val * 10 - next + '0';                    next = read();                }            }             return val;        }     }     static class Line2 {        public Point2 vec;        public double c;         public Line2(Point2 vec, double c) {            this.vec = vec;            this.c = c;        }         public Line2(double a, double b, double c) {            this(new Point2(b, -a), c);        }         public Line2(Point2 a, Point2 b) {            this.vec = Point2.minus(b, a);            this.c = Point2.cross(vec, a);        }         private double side0(Point2 pt) {            return Point2.cross(vec, pt) - c;        }         public Point2 projection(Point2 pt) {            double factor = side0(pt) / vec.square();            return new Point2(pt.x - (-vec.y * factor), pt.y - vec.x * factor);            //return Point2.minus(pt, Point2.mul(vec.perpendicular(), side0(pt) / vec.square()));        }         public String toString() {            return -vec.y + "x + " + vec.x + "y = " + c;        }     }     static class Point2 implements Cloneable {        public final double x;        public final double y;         public Point2(double x, double y) {            this.x = x;            this.y = y;        }         public Point2() {            this(0, 0);        }         public double square() {            return dot(this, this);        }         public static Point2 minus(Point2 a, Point2 b) {            return new Point2(a.x - b.x, a.y - b.y);        }         public static double dot(Point2 a, Point2 b) {            return a.x * b.x + a.y * b.y;        }         public static double dot(double x1, double y1, double x2, double y2) {            return x1 * x2 + y1 * y2;        }         public static double cross(Point2 a, Point2 b) {            return a.x * b.y - a.y * b.x;        }         public static int orient(Point2 a, Point2 b, Point2 c) {            return GeoConstant.sign(GeoConstant.cross(b.x - a.x, b.y - a.y, c.x - a.x, c.y - a.y));        }         public static boolean inDisk(Point2 a, Point2 b, Point2 c) {            return GeoConstant.sign(dot(a.x - c.x, a.y - c.y, b.x - c.x, b.y - c.y)) <= 0;        }         public static boolean onSegment(Point2 a, Point2 b, Point2 c) {            return orient(a, b, c) == 0 && inDisk(a, b, c);        }         public static double dist2(Point2 a, Point2 b) {            double dx = a.x - b.x;            double dy = a.y - b.y;            return dx * dx + dy * dy;        }         public static double dist(Point2 a, Point2 b) {            return Math.sqrt(dist2(a, b));        }         public Point2 clone() {            try {                return (Point2) super.clone();            } catch (CloneNotSupportedException e) {                throw new RuntimeException(e);            }        }         public String toString() {            return String.format("(%.6f, %.6f)", x, y);        }     }     static class FastOutput implements AutoCloseable, Closeable, Appendable {        private static final int THRESHOLD = 1 << 13;        private final Writer os;        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);         public FastOutput append(CharSequence csq) {            cache.append(csq);            return this;        }         public FastOutput append(CharSequence csq, int start, int end) {            cache.append(csq, start, end);            return this;        }         private void afterWrite() {            if (cache.length() < THRESHOLD) {                return;            }            flush();        }         public FastOutput(Writer os) {            this.os = os;        }         public FastOutput(OutputStream os) {            this(new OutputStreamWriter(os));        }         public FastOutput append(char c) {            cache.append(c);            afterWrite();            return this;        }         public FastOutput append(double c) {            cache.append(new BigDecimal(c).toPlainString());            afterWrite();            return this;        }         public FastOutput append(String c) {            cache.append(c);            afterWrite();            return this;        }         public FastOutput println(double c) {            return append(c).println();        }         public FastOutput println() {            return append(System.lineSeparator());        }         public FastOutput flush() {            try {                os.append(cache);                os.flush();                cache.setLength(0);            } catch (IOException e) {                throw new UncheckedIOException(e);            }            return this;        }         public void close() {            flush();            try {                os.close();            } catch (IOException e) {                throw new UncheckedIOException(e);            }        }         public String toString() {            return cache.toString();        }     }     static class GeoConstant {        public static final double PREC = 1e-12;         public static boolean isZero(double x) {            return -PREC <= x && x <= PREC;        }         public static int sign(double x) {            return isZero(x) ? 0 : x < 0 ? -1 : 1;        }         public static double cross(double x1, double y1, double x2, double y2) {            return x1 * y2 - y1 * x2;        }     }} 
