import java.util.Scanner;import java.util.Stack; public class Main {    private static final char STATUS_PASSENGER = 'S';    private static final char PASSENGER = 'P';    private static final char EMPTY_SEAT = '.';    private static final char SEATED_PASSENGER = 'x';     private static final int SYMBOLS_IN_A_ROW = 12;     public static void main(final String[] args) {        final Scanner scanner = new Scanner(System.in);        final int rowsInPlane = scanner.nextInt();        int passengersToSeat = scanner.nextInt();         int statusPassengersNeighbours = 0;        // "Bad" case allocated seats - i.e. adding a passenger increases status passengers' neighbours by 1        final Stack<RowSeat> badAllocatedSeats = new Stack<>();        // "Worst" case allocated seats - i.e. adding a passenger increase status passengers' neighbours by 2        final Stack<RowSeat> worstAllocatedSeats = new Stack<>();         final char[][] seats = new char[rowsInPlane][SYMBOLS_IN_A_ROW];         for (int rowNumber = 0; rowNumber < rowsInPlane; rowNumber++) {            final char[] row = scanner.next().toCharArray();             if (passengersToSeat == 0 && badAllocatedSeats.isEmpty() && worstAllocatedSeats.isEmpty()) {                // We already have optimal seating, we can leave the rest as is                seats[rowNumber] = row;                for (int seat = 0; seat < row.length; seat++) {                    final int previousSeat = seat - 1;                    final int nextSeat = seat + 1;                    switch (row[seat]) {                        case STATUS_PASSENGER:                            // If current seat is status passenger, just count his neighbours                            if (previousSeat >= 0) {                                if (row[previousSeat] == STATUS_PASSENGER || row[previousSeat] == PASSENGER) {                                    ++statusPassengersNeighbours;                                }                            }                            if (nextSeat < row.length) {                                if (row[nextSeat] == STATUS_PASSENGER || row[nextSeat] == PASSENGER) {                                    ++statusPassengersNeighbours;                                }                            }                            break;                    }                }                continue;            }             for (int seat = 0; seat < row.length; seat++) {                final int previousSeat = seat - 1;                final int nextSeat = seat + 1;                 switch (row[seat]) {                    case STATUS_PASSENGER:                        // If current seat is status passenger, just count his neighbours                        if (previousSeat >= 0) {                            if (row[previousSeat] == STATUS_PASSENGER || row[previousSeat] == PASSENGER) {                                ++statusPassengersNeighbours;                            }                        }                        if (nextSeat < row.length) {                            if (row[nextSeat] == STATUS_PASSENGER || row[nextSeat] == PASSENGER) {                                ++statusPassengersNeighbours;                            }                        }                        break;                    case EMPTY_SEAT:                        // We will try to seat all passengers at first available place, possibly moving them later                        int additionalPassengers = 0;                        if (previousSeat >= 0) {                            if (row[previousSeat] == STATUS_PASSENGER) {                                ++additionalPassengers;                            }                        }                        if (nextSeat < row.length) {                            if (row[nextSeat] == STATUS_PASSENGER) {                                ++additionalPassengers;                            }                        }                        if (passengersToSeat > 0) {                            // We still have passenger to seat, so we cannot be picky about place                            if (additionalPassengers == 1) {                                badAllocatedSeats.push(new RowSeat(rowNumber, seat));                                ++statusPassengersNeighbours;                            } else if (additionalPassengers == 2) {                                statusPassengersNeighbours += 2;                                worstAllocatedSeats.push(new RowSeat(rowNumber, seat));                            }                             row[seat] = SEATED_PASSENGER;                        }                         if (additionalPassengers < 2) {                            // If by placing at current seat we do not increase additional status passenger neighbours                            // and we have already placed all passengers, let's move some of the "bad" or "worst" ones here.                            if (passengersToSeat == 0) {                                if (!worstAllocatedSeats.isEmpty()) {                                    final RowSeat worstSeat = worstAllocatedSeats.pop();                                    seats[worstSeat.row][worstSeat.number] = EMPTY_SEAT;                                    if (worstSeat.row == rowNumber) {                                        row[worstSeat.number] = EMPTY_SEAT;                                    }                                    statusPassengersNeighbours -= (2 - additionalPassengers);                                    if (additionalPassengers == 1) {                                        badAllocatedSeats.push(new RowSeat(rowNumber, seat));                                    }                                    row[seat] = SEATED_PASSENGER;                                } else if (!badAllocatedSeats.isEmpty() && additionalPassengers < 1) {                                    final RowSeat badSeat = badAllocatedSeats.pop();                                    seats[badSeat.row][badSeat.number] = EMPTY_SEAT;                                    if (badSeat.row == rowNumber) {                                        row[badSeat.number] = EMPTY_SEAT;                                    }                                    --statusPassengersNeighbours;                                    row[seat] = SEATED_PASSENGER;                                }                            }                        }                         passengersToSeat = Math.max(0, --passengersToSeat);                }            }             seats[rowNumber] = row;        }         System.out.println(statusPassengersNeighbours);        for (int i = 0; i < seats.length; i++) {            System.out.println(seats[i]);        }    }     private static class RowSeat {        final int row;        final int number;         RowSeat(final int row, final int number) {            this.row = row;            this.number = number;        }    }}
