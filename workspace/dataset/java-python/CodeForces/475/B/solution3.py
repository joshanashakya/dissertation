import math,sys,bisect,heapqfrom collections import defaultdict,Counter,dequefrom itertools import groupby,accumulate#sys.setrecursionlimit(200000000)int1 = lambda x: int(x) - 1#def input(): return sys.stdin.readline().strip()input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__ilele = lambda: map(int,input().split())alele = lambda: list(map(int, input().split()))ilelec = lambda: map(int1,input().split())alelec = lambda: list(map(int1, input().split()))def list2d(a, b, c): return [[c] * b for i in range(a)]def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]#MOD = 1000000000 + 7def Y(c):  print(["NO","YES"][c])def y(c):  print(["no","yes"][c])def Yy(c):  print(["No","Yes"][c]) n,m = ilele()S1 = input()S2 = input() V = n*mINF = float('inf') v = 0Id = [[-1 for i in range(m)] for j in range(n)]for i in range(n):    for j in range(m):        Id[i][j] = v        v+=1graph = [[INF]*(n*m) for i in range(n*m)] def addEdge(a,b):    i,j =a    ii,jj =b    id1 = Id[i][j]    id2 = Id[ii][jj]    graph[id1][id2] = 1     for i in range(n):    for j in range(m):        if i==0:            if S1[i] == ">":                if j!=m-1:                    addEdge((i,j),(i,j+1))            else:                if j!=0:                    addEdge((i,j),(i,j-1))            if S2[j] == "v":                if i!=n-1:                    addEdge((i,j),(i+1,j))        elif i == n-1:            if S1[i] == ">":                if j!=m-1:                    addEdge((i,j),(i,j+1))            else:                if j!=0:                    addEdge((i,j),(i,j-1))            if S2[j] == "^":                if i!=0:                    addEdge((i,j),(i-1,j))        else:            if S1[i] == ">":                if j!=m-1:                    addEdge((i,j),(i,j+1))            else:                if j!=0:                    addEdge((i,j),(i,j-1))            if S2[j] == "^":                if i!=0:                    addEdge((i,j),(i-1,j))            else:                if i!= n-1:                    addEdge((i,j),(i+1,j)) def floydWarshall(graph):    dist = graph.copy()    for k in range(V):        for i in range(V):            for j in range(V):                dist[i][j] = min(dist[i][j],dist[i][k]+ dist[k][j])    return dist Ans = floydWarshall(graph)for i in Ans:    if INF in i:        Y(0)        exit(0)Y(1)  
