def z_algorithm(s):    n = len(s)    Z = [0]*n    Z[0] = n    i = 1    j = 0    while i < n:        while i+j < n and s[j] == s[i+j]:            j += 1        Z[i] = j        if j == 0:            i += 1            continue        k = 1        while i+k < n and k+Z[k] < j:            Z[i+k] = Z[k]            k += 1        i += k        j -= k    return Z class BIT:    def __init__(self, n):        self.n = n        self.bit = [0]*(self.n+1) # 1-indexed     def init(self, init_val):        for i, v in enumerate(init_val):            self.add(i, v)     def add(self, i, x):        # i: 0-indexed        i += 1 # to 1-indexed        while i <= self.n:            self.bit[i] += x            i += (i & -i)     def sum(self, i, j):        # return sum of [i, j)        # i, j: 0-indexed        return self._sum(j) - self._sum(i)     def _sum(self, i):        # return sum of [0, i)        # i: 0-indexed        res = 0        while i > 0:            res += self.bit[i]            i -= i & (-i)        return res     def lower_bound(self, x):        s = 0        pos = 0        depth = self.n.bit_length()        v = 1 << depth        for i in range(depth, -1, -1):            k = pos + v            if k <= self.n and s + self.bit[k] < x:                    s += self.bit[k]                    pos += v            v >>= 1        return pos     def __str__(self): # for debug        arr = [self.sum(i,i+1) for i in range(self.n)]        return str(arr) import sysimport io, osinput = sys.stdin.readline n, m, q = map(int, input().split())s = str(input().rstrip())t = str(input().rstrip()) S = t+'#'+sZ = z_algorithm(S)#print(Z)Z = Z[m+1:]LR = []for i in range(q):    l, r = map(int, input().split())    l, r = l-1, r-1    LR.append((l, r, 1, i))for i in range(n):    if Z[i] == m:        LR.append((i, i+m-1, 0, 0)) LR.sort(key=lambda x: (x[1], x[2]))bit = BIT(10**3+50)ans = [0]*qfor l, r, t, i in LR:    if t == 0:        bit.add(l, 1)    else:        ans[i] = bit.sum(l, r+1)print(*ans, sep='\n')
