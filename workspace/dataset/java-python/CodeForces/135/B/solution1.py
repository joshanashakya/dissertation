from itertools import combinations def get_center(points):    center = []    for d in range(len(points[0])):        c = sum(p[d] for p in points)        center.append(c / 4)    return tuple(center)  def all_the_same(xs):    if len(xs) <= 1:        return True    first, *ys = xs     return all(y == first for y in ys)  def distance(p1, p2):    return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 def all_distance(points):    stack = list(points)    distances = []    while len(stack) > 1:        point = stack.pop()        distances.extend([distance(point, p) for p in stack])    return distances def is_rect(points):    center = get_center(points)    l = [distance(center, p) for p in points]    return all_the_same(l)  def is_sqr(points):    if not is_rect(points):        return False    distances = all_distance(points)    distances.sort()    return all_the_same(distances[:-2])  def main(points):    idcs = list(range(0, 8))    for group in combinations(idcs, 4):        xs = [points[i] for i in group]        ys = [points[i] for i in idcs if i not in group]        if is_rect(xs) and is_rect(ys):            if is_sqr(xs):                print('YES')                print(' '.join([str(i+1) for i in group]))                print(' '.join([str(i+1) for i in idcs if i not in group]))                break            elif is_sqr(ys):                print('YES')                print(' '.join([str(i+1) for i in idcs if i not in group]))                print(' '.join([str(i+1) for i in group]))                break    else:        print('NO') all_points = [] for _ in range(8):    all_points.append(list(map(int, input().split()))) main(all_points)
