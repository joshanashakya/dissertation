#!/usr/bin/env pythonfrom __future__ import division, print_functionimport mathimport osimport sysfrom sys import stdin,stdoutfrom io import BytesIO, IOBasefrom itertools import accumulatefrom collections import deque#sys.setrecursionlimit(10**5)if sys.version_info[0] < 3:    from __builtin__ import xrange as range    from future_builtins import ascii, filter, hex, map, oct, zip#sys.setrecursionlimit(10**6) # region fastio BUFSIZE = 8192  class FastIO(IOBase):    newlines = 0     def __init__(self, file):        self._fd = file.fileno()        self.buffer = BytesIO()        self.writable = "x" in file.mode or "r" not in file.mode        self.write = self.buffer.write if self.writable else None     def read(self):        while True:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            if not b:                break            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines = 0        return self.buffer.read()     def readline(self):        while self.newlines == 0:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            self.newlines = b.count(b"\n") + (not b)            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines -= 1        return self.buffer.readline()     def flush(self):        if self.writable:            os.write(self._fd, self.buffer.getvalue())            self.buffer.truncate(0), self.buffer.seek(0)  class IOWrapper(IOBase):    def __init__(self, file):        self.buffer = FastIO(file)        self.flush = self.buffer.flush        self.writable = self.buffer.writable        self.write = lambda s: self.buffer.write(s.encode("ascii"))        self.read = lambda: self.buffer.read().decode("ascii")        self.readline = lambda: self.buffer.readline().decode("ascii")  def print(*args, **kwargs):    """Prints the values to a stream, or to sys.stdout by default."""    sep, file = kwargs.pop("sep", " "), kwargs.pop("file", sys.stdout)    at_start = True    for x in args:        if not at_start:            file.write(sep)        file.write(str(x))        at_start = False    file.write(kwargs.pop("end", "\n"))    if kwargs.pop("flush", False):        file.flush()  if sys.version_info[0] < 3:    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)else:    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip("\r\n")#----------------------------------------------------------------- def regularbracket(t):    p=0    for i in t:        if i=="(":            p+=1        else:            p-=1        if p<0:            return False    else:        if p>0:            return False        else:            return True #-------------------------------------------------def binarySearchCount(arr, n, key):    left = 0    right = n - 1     count = 0     while (left <= right):        mid = int((right + left) / 2)         # Check if middle element is        # less than or equal to key        if (arr[mid] <= key):            count = mid+1            left = mid + 1         # If key is smaller, ignore right half        else:            right = mid - 1    return count#------------------------------reverse string(pallindrome)def reverse1(string):    pp=""    for i in string[::-1]:        pp+=i    if pp==string:        return True    return False#--------------------------------reverse list(paindrome)def reverse2(list1):    l=[]    for i in list1[::-1]:        l.append(i)    if l==list1:        return True    return False# endregionimport mathdef mex(list1):    #list1 = sorted(list1)    p = max(list1)+1    for i in range(len(list1)):        if list1[i]!=i:            p = i            break    return p#----endregion"""def main():    n,k= map(int,input().split())    arr = list(map(int,input().split()))    if max(arr)-min(arr)>k:        print("NO")    else:        print("YES")        l=[]        for i in range(k):            l.append(i+1)        p=[*l]*100        l+=p        for x in arr:            print(*l[:x])""""""def main():    t = int(input())    for _ in range(t):        n, m = map(int, input().split())        a = list(map(int, input().split()))        b = [0] * m        for j in a:            b[j % m] += 1        ans = 0        if b[0] > 0:            ans += 1        for j in range(1, (m + 1) // 2):            if b[j] or b[m - j]:                ans += max(1, abs(b[m - j] - b[j]))        if m % 2 == 0:            if b[m // 2]:                ans += 1        print(ans)"""l=[]for i in range(1,30):    l.append(2**i)def main():    sum,limit = map(int,input().split())    r = []    while (limit > 0 and sum > 0):        if sum - (limit & limit) >= 0:            sum -= (limit & -limit)            r.append(limit)        limit -= 1    if sum != 0:        print(-1)    else:        print(len(r))        print(*r)if __name__ == '__main__':    main()
