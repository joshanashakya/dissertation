import java.util.*; import java.io.*; import java.math.*;public class Main{	static void solve(){//Here is the main function		int N = nextInt();		int Q = nextInt();		HashMap<Integer, HashSet<Integer>> map = new HashMap<>();		long sum = 0;		int index = 0;		ArrayList<Query> list = new ArrayList<>();		for(int i = 0; i < Q; i++){			int type = nextInt();			switch(type){				case 1:					int xi = nextInt();					if(!map.containsKey(xi)){						map.put(xi, new HashSet<>());					}					HashSet<Integer> set = map.get(xi);					set.add(i);					list.add(new Query(xi, i));					map.put(xi, set);					sum++;					break;				case 2:					int xii = nextInt();					if(map.containsKey(xii)){						sum -= map.get(xii).size();						map.put(xii, new HashSet<>());					}					break;				case 3:					int ti = nextInt();					while(index < ti){						Query now = list.get(index);						HashSet<Integer> check = map.get(now.xi);						if(check.contains(now.index)){							check.remove(now.index);							sum--;							map.put(now.xi, check);						}						index++;					}					break;			}			myout(sum);		}	}	//Method addition frame start static class Query{	int xi;	int index;	Query(int xi, int index){		this.xi = xi;		this.index = index;	}}  	//Method addition frame end 	//Don't have to see. start------------------------------------------	static class InputIterator{		ArrayList<String> inputLine = new ArrayList<>(1024);		int index = 0; int max; String read;		InputIterator(){			BufferedReader br = new BufferedReader(new InputStreamReader(System.in));			try{				while((read = br.readLine()) != null){					inputLine.addAll(Arrays.asList(read.split(" ")));				}			}catch(IOException e){}			max = inputLine.size();		}		boolean hasNext(){return (index < max);}		String next(){			if(hasNext()){				return inputLine.get(index++);			}else{				throw new IndexOutOfBoundsException("There is no more input");			}		}	}	static HashMap<Integer, String> CONVSTR = new HashMap<>();	static InputIterator ii = new InputIterator();//This class cannot be used in reactive problem.	static PrintWriter out = new PrintWriter(System.out);	static void flush(){out.flush();}	static void myout(Object t){out.println(t);}	static void myerr(Object t){System.err.print("debug:");System.err.println(t);}	static String next(){return ii.next();}	static boolean hasNext(){return ii.hasNext();}	static int nextInt(){return Integer.parseInt(next());}	static long nextLong(){return Long.parseLong(next());}	static double nextDouble(){return Double.parseDouble(next());}	static ArrayList<String> nextCharArray(){return myconv(next(), 0);}	static ArrayList<String> nextStrArray(int size){		ArrayList<String> ret = new ArrayList<>(size);		for(int i = 0; i < size; i++){			ret.add(next());		}		return ret;	}	static ArrayList<Integer> nextIntArray(int size){		ArrayList<Integer> ret = new ArrayList<>(size);		for(int i = 0; i < size; i++){			ret.add(Integer.parseInt(next()));		}		return ret;	}	static ArrayList<Long> nextLongArray(int size){		ArrayList<Long> ret = new ArrayList<>(size);		for(int i = 0; i < size; i++){			ret.add(Long.parseLong(next()));		}		return ret;	}	@SuppressWarnings("unchecked")	static String myconv(Object list, int no){//only join		String joinString = CONVSTR.get(no);		if(list instanceof String[]){			return String.join(joinString, (String[])list);		}else if(list instanceof ArrayList){			return String.join(joinString, (ArrayList)list);		}else{			throw new ClassCastException("Don't join");		}	}	static ArrayList<String> myconv(String str, int no){//only split		String splitString = CONVSTR.get(no);		return new ArrayList<String>(Arrays.asList(str.split(splitString)));	}	public static void main(String[] args){		CONVSTR.put(8, " "); CONVSTR.put(9, "\n"); CONVSTR.put(0, "");		solve();flush();	}	//Don't have to see. end------------------------------------------}
