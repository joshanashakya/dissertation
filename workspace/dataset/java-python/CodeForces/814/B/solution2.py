import sys# sys.setrecursionlimit(300000)# Get out of main functoindef main():    pass# decimal to binarydef binary(n):    return (bin(n).replace("0b", ""))# binary to decimaldef decimal(s):    return (int(s, 2))# power of a number base 2def pow2(n):    p = 0    while n > 1:        n //= 2        p += 1    return (p)# if  number is prime in √n timedef isPrime(n):    if (n == 1):        return (False)    else:        root = int(n ** 0.5)        root += 1        for i in range(2, root):            if (n % i == 0):                return (False)        return (True)# list to string ,no spacesdef lts(l):    s = ''.join(map(str, l))    return s# String to listdef stl(s):    # for each character in string to list with no spaces -->    l = list(s)    # for space in string  -->    # l=list(s.split(" "))    return l# Returns list of numbers with a particular sumdef sq(a, target, arr=[]):    s = sum(arr)    if (s == target):        return arr    if (s >= target):        return    for i in range(len(a)):        n = a[i]        remaining = a[i + 1:]        ans = sq(remaining, target, arr + [n])        if (ans):            return ans# Sieve for prime numbers in a rangedef SieveOfEratosthenes(n):    cnt = 0    prime = [True for i in range(n + 1)]    p = 2    while (p * p <= n):        if (prime[p] == True):            for i in range(p * p, n + 1, p):                prime[i] = False        p += 1    for p in range(2, n + 1):        if prime[p]:            cnt += 1            # print(p)    return (cnt)# for positive integerse onlydef nCr(n, r):    f = math.factorial    return f(n) // f(r) // f(n - r)# 1000000007mod = int(1e9) + 7def ssinp(): return sys.stdin.readline().strip()# s=input()def iinp(): return int(input())# n=int(input())def nninp(): return map(int, sys.stdin.readline().strip().split())# n, m, a=[int(x) for x in input().split()]def llinp(): return list(map(int, sys.stdin.readline().strip().split()))# a=list(map(int,input().split()))def p(xyz): print(xyz)def p2(a, b): print(a, b)import math# d1.setdefault(key, []).append(value)# ASCII of A-Z= 65-90# ASCII of a-z= 97-122import randomfrom collections import OrderedDictfrom fractions import Fraction#for __ in range(iinp()):n=iinp()a=llinp()b=llinp()ans=[0]*ns1=set()s2=set()for i in range(n):    if(a[i]==b[i]):        ans[i]=a[i]        s1.add(a[i])    s2.add(i+1)s2=s2-s1if(len(s2)==1):    c=s2.pop()    ans[ans.index(0)]=celse:    ind1=ind2=-1    for i in range(0,n):        if(ans[i]==0 and ind1==-1):            ind1=i        elif(ans[i]==0):            ind2=i    if(a[ind1] in s2 and b[ind1] in s2):        if(a[ind2] in s2):            ans[ind2]=a[ind2]            s2.remove(a[ind2])            c=s2.pop()            ans[ind1]=c        else:            ans[ind2] = b[ind2]            s2.remove(b[ind2])            c = s2.pop()            ans[ind1] = c    elif(a[ind1] in s2):        ans[ind1] = a[ind1]        s2.remove(a[ind1])        c = s2.pop()        ans[ind2] = c    else:        ans[ind1] = b[ind1]        s2.remove(b[ind1])        c = s2.pop()        ans[ind2] = cprint(*ans)     """ Stuff you should look for    int overflow, array bounds    special cases (n=1?)    do something instead of nothing and stay organized    WRITE STUFF DOWN	DON'T GET STUCK ON ONE APPROACH """
