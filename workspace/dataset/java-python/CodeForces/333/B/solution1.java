import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.PrintWriter;import java.math.BigInteger;import java.util.*; /** * @author Mubtasim Shahriar */ public class Chips {     public static void main(String[] args) {         InputStream inputStream = System.in;        OutputStream outputStream = System.out;        InputReader sc = new InputReader(inputStream);        PrintWriter out = new PrintWriter(outputStream);        Solver solver = new Solver();//		int t = sc.nextInt();        int t = 1;        while (t-- != 0) {            solver.solve(sc, out);        }        out.close();     }     static class Solver {        public void solve(InputReader sc, PrintWriter out) {            int n = sc.nextInt();            int m = sc.nextInt();            boolean[] rowFalse = new boolean[n];            boolean[] colFalse = new boolean[n];            boolean[][] arr = new boolean[n][n];            for(int i = 0; i < m; i++) {                int x = sc.nextInt()-1;                int y = sc.nextInt()-1;                rowFalse[x] = true;                colFalse[y] = true;            }            int ans = 0;            for(int col = 1; col < n/2; col++) {                int[][] nows = new int[8][2]; //                FIRST                nows[0][0] = 0;                nows[1][0] = 0;                nows[0][1] = col;                nows[1][1] = n-1-col; //                SECOND                nows[2][0] = col;                nows[3][0] = col;                nows[2][1] = 0;                nows[3][1] = n-1; //                THIRD                nows[4][0] = n-1-col;                nows[5][0] = n-1-col;                nows[4][1] = 0;                nows[5][1] = n-1; //                FOURTH                nows[6][0] = n-1;                nows[7][0] = n-1;                nows[6][1] = col;                nows[7][1] = n-1-col;                ans += getMax(nows,rowFalse,colFalse);             }            int half = n/2;            if(n%2!=0 && (!colFalse[half] || !rowFalse[half])) ans++;            out.println(ans);        }         private int getMax(int[][] nows, boolean[] rowFalse, boolean[] colFalse) {            int len = nows.length;            int max = 0;            int n = rowFalse.length;            for(int mask = 1; mask < 1<<len; mask++) {                boolean[] rowChecker = new boolean[n];                boolean[] colChecker = new boolean[n];                boolean ok = canFill(nows,rowFalse,colFalse,rowChecker,colChecker,mask);                if(ok) max = Math.max(max,Integer.bitCount(mask));            }            return max;        }         private boolean canFill(int[][] nows, boolean[] rowFalse, boolean[] colFalse, boolean[] rowChecker, boolean[] colChecker, int mask) {            int len = nows.length;            int n = rowChecker.length;            int half = n/2;//            if(mask==13)  {//                System.out.println("I am here!");//            }            HashMap<Integer,HashSet<Integer>> map = new HashMap<>();            for(int bit = 0; bit < len; bit++) {                if((mask&(1<<bit))==0) continue;                int[] ar = nows[bit];                add(map,ar[0],ar[1]);            }            for(int i = 0; i < len; i++) {                if((mask&(1<<i))==0) continue;                int row = nows[i][0];                int col = nows[i][1];                boolean updown = row == 0 || row == n-1;                int[][] tmp = gen(row,col,n);                for(int[] ar : tmp) {                    if(ar[0]==row && ar[1]==col) continue;                    int nrow = ar[0];                    int ncol = ar[1];                    boolean nupdown = nrow == 0 || nrow == n-1;                    if(nupdown==updown) {                        if(updown) {                            if(col!=ncol) continue;                        } else {                            if(nrow!=row) continue;                        }                    }                    if(map.containsKey(nrow) && map.get(nrow).contains(ncol)) return false;                }            }            for(int bit = 0; bit < len; bit++) {                if((mask&(1<<bit))==0) continue;                int row = nows[bit][0];                int col = nows[bit][1];                if(row==0 || row==n-1) {                    if(colFalse[col]) return false;                    if(colChecker[col]) return false;                    colChecker[col] = true;                } else {                    if(rowFalse[row]) return false;                    if(rowChecker[row]) return false;                    rowChecker[row] = true;                }            }            return true;        }         private int[][] gen(int row, int col, int n) {            int[] tmp = new int[4];            int c = col;            if(col==0) {                c = row;            } else if(col==n-1) {                c = n-1-row;            } else if(row==n-1) {                c = n-1-col;            }            int r = 0;            int[][] ret = new int[4][2];            ret[0][0] = 0;            ret[0][1] = c;            ret[1][0] = c;            ret[1][1] = 0;            ret[2][0] = n-1-c;            ret[2][1] = n-1;            ret[3][0] = n-1;            ret[3][1] = n-1-c;            return ret;        }         private void add(HashMap<Integer, HashSet<Integer>> map, int key, int val) {            if(!map.containsKey(key)) map.put(key,new HashSet<>());            map.get(key).add(val);        }    }     static void sort(int[] arr) {        Random rand = new Random();        int n = arr.length;        for (int i = 0; i < n; i++) {            int idx = rand.nextInt(n);            if (idx == i) continue;            arr[i] ^= arr[idx];            arr[idx] ^= arr[i];            arr[i] ^= arr[idx];        }        Arrays.sort(arr);    }     static void sort(long[] arr) {        Random rand = new Random();        int n = arr.length;        for (int i = 0; i < n; i++) {            int idx = rand.nextInt(n);            if (idx == i) continue;            arr[i] ^= arr[idx];            arr[idx] ^= arr[i];            arr[i] ^= arr[idx];        }        Arrays.sort(arr);    }     static void sortDec(int[] arr) {        Random rand = new Random();        int n = arr.length;        for (int i = 0; i < n; i++) {            int idx = rand.nextInt(n);            if (idx == i) continue;            arr[i] ^= arr[idx];            arr[idx] ^= arr[i];            arr[i] ^= arr[idx];        }        Arrays.sort(arr);        int l = 0;        int r = n - 1;        while (l < r) {            arr[l] ^= arr[r];            arr[r] ^= arr[l];            arr[l] ^= arr[r];            l++;            r--;        }    }     static void sortDec(long[] arr) {        Random rand = new Random();        int n = arr.length;        for (int i = 0; i < n; i++) {            int idx = rand.nextInt(n);            if (idx == i) continue;            arr[i] ^= arr[idx];            arr[idx] ^= arr[i];            arr[i] ^= arr[idx];        }        Arrays.sort(arr);        int l = 0;        int r = n - 1;        while (l < r) {            arr[l] ^= arr[r];            arr[r] ^= arr[l];            arr[l] ^= arr[r];            l++;            r--;        }    }     static class InputReader {        private boolean finished = false;         private InputStream stream;        private byte[] buf = new byte[1024];        private int curChar;        private int numChars;        private SpaceCharFilter filter;         public InputReader(InputStream stream) {            this.stream = stream;        }         public int read() {            if (numChars == -1) {                throw new InputMismatchException();            }            if (curChar >= numChars) {                curChar = 0;                try {                    numChars = stream.read(buf);                } catch (IOException e) {                    throw new InputMismatchException();                }                if (numChars <= 0) {                    return -1;                }            }            return buf[curChar++];        }         public int peek() {            if (numChars == -1) {                return -1;            }            if (curChar >= numChars) {                curChar = 0;                try {                    numChars = stream.read(buf);                } catch (IOException e) {                    return -1;                }                if (numChars <= 0) {                    return -1;                }            }            return buf[curChar];        }         public int nextInt() {            int c = read();            while (isSpaceChar(c)) {                c = read();            }            int sgn = 1;            if (c == '-') {                sgn = -1;                c = read();            }            int res = 0;            do {                if (c < '0' || c > '9') {                    throw new InputMismatchException();                }                res *= 10;                res += c - '0';                c = read();            } while (!isSpaceChar(c));            return res * sgn;        }         public long nextLong() {            int c = read();            while (isSpaceChar(c)) {                c = read();            }            int sgn = 1;            if (c == '-') {                sgn = -1;                c = read();            }            long res = 0;            do {                if (c < '0' || c > '9') {                    throw new InputMismatchException();                }                res *= 10;                res += c - '0';                c = read();            } while (!isSpaceChar(c));            return res * sgn;        }         public String nextString() {            int c = read();            while (isSpaceChar(c)) {                c = read();            }            StringBuilder res = new StringBuilder();            do {                if (Character.isValidCodePoint(c)) {                    res.appendCodePoint(c);                }                c = read();            } while (!isSpaceChar(c));            return res.toString();        }         public boolean isSpaceChar(int c) {            if (filter != null) {                return filter.isSpaceChar(c);            }            return isWhitespace(c);        }         public static boolean isWhitespace(int c) {            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;        }         private String readLine0() {            StringBuilder buf = new StringBuilder();            int c = read();            while (c != '\n' && c != -1) {                if (c != '\r') {                    buf.appendCodePoint(c);                }                c = read();            }            return buf.toString();        }         public String readLine() {            String s = readLine0();            while (s.trim().length() == 0) {                s = readLine0();            }            return s;        }         public String readLine(boolean ignoreEmptyLines) {            if (ignoreEmptyLines) {                return readLine();            } else {                return readLine0();            }        }         public BigInteger readBigInteger() {            try {                return new BigInteger(nextString());            } catch (NumberFormatException e) {                throw new InputMismatchException();            }        }         public char nextCharacter() {            int c = read();            while (isSpaceChar(c)) {                c = read();            }            return (char) c;        }         public double nextDouble() {            int c = read();            while (isSpaceChar(c)) {                c = read();            }            int sgn = 1;            if (c == '-') {                sgn = -1;                c = read();            }            double res = 0;            while (!isSpaceChar(c) && c != '.') {                if (c == 'e' || c == 'E') {                    return res * Math.pow(10, nextInt());                }                if (c < '0' || c > '9') {                    throw new InputMismatchException();                }                res *= 10;                res += c - '0';                c = read();            }            if (c == '.') {                c = read();                double m = 1;                while (!isSpaceChar(c)) {                    if (c == 'e' || c == 'E') {                        return res * Math.pow(10, nextInt());                    }                    if (c < '0' || c > '9') {                        throw new InputMismatchException();                    }                    m /= 10;                    res += (c - '0') * m;                    c = read();                }            }            return res * sgn;        }         public boolean isExhausted() {            int value;            while (isSpaceChar(value = peek()) && value != -1) {                read();            }            return value == -1;        }         public String next() {            return nextString();        }         public SpaceCharFilter getFilter() {            return filter;        }         public void setFilter(SpaceCharFilter filter) {            this.filter = filter;        }         public interface SpaceCharFilter {            public boolean isSpaceChar(int ch);        }         public int[] nextIntArray(int n) {            int[] array = new int[n];            for (int i = 0; i < n; ++i) array[i] = nextInt();            return array;        }         public int[] nextSortedIntArray(int n) {            int array[] = nextIntArray(n);            Arrays.sort(array);            return array;        }         public int[] nextSumIntArray(int n) {            int[] array = new int[n];            array[0] = nextInt();            for (int i = 1; i < n; ++i) array[i] = array[i - 1] + nextInt();            return array;        }         public long[] nextLongArray(int n) {            long[] array = new long[n];            for (int i = 0; i < n; ++i) array[i] = nextLong();            return array;        }         public long[] nextSumLongArray(int n) {            long[] array = new long[n];            array[0] = nextInt();            for (int i = 1; i < n; ++i) array[i] = array[i - 1] + nextInt();            return array;        }         public long[] nextSortedLongArray(int n) {            long array[] = nextLongArray(n);            Arrays.sort(array);            return array;        }    }  }
