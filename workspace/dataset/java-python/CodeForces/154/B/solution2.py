import osimport sysfrom io import BytesIO, IOBase  BUFSIZE = 8192  class FastIO(IOBase):    newlines = 0     def __init__(self, file):        self._fd = file.fileno()        self.buffer = BytesIO()        self.writable = "x" in file.mode or "r" not in file.mode        self.write = self.buffer.write if self.writable else None     def read(self):        while True:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            if not b:                break            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines = 0        return self.buffer.read()     def readline(self):        while self.newlines == 0:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            self.newlines = b.count(b"\n") + (not b)            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines -= 1        return self.buffer.readline()     def flush(self):        if self.writable:            os.write(self._fd, self.buffer.getvalue())            self.buffer.truncate(0), self.buffer.seek(0)  class IOWrapper(IOBase):    def __init__(self, file):        self.buffer = FastIO(file)        self.flush = self.buffer.flush        self.writable = self.buffer.writable        self.write = lambda s: self.buffer.write(s.encode("ascii"))        self.read = lambda: self.buffer.read().decode("ascii")        self.readline = lambda: self.buffer.readline().decode("ascii")  sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)input = lambda: sys.stdin.readline().rstrip("\r\n")# Python3 program to find prime factorization  # of a number n in O(Log n) time with  # precomputation allowed. import math as mt  # Calculating SPF (Smallest Prime Factor)  # for every number till MAXN. # Time Complexity : O(nloglogn) def sieve():     spf[1] = 1    for i in range(2, MAXN):                   # marking smallest prime factor          # for every number to be itself.         spf[i] = i       # separately marking spf for      # every even number as 2     for i in range(4, MAXN, 2):         spf[i] = 2      for i in range(3, mt.ceil(mt.sqrt(MAXN))):                   # checking if i is prime         if (spf[i] == i):                           # marking SPF for all numbers             # divisible by i             for j in range(i * i, MAXN, i):                                    # marking spf[j] if it is                  # not previously marked                 if (spf[j] == j):                     spf[j] = i   # A O(log n) function returning prime  # factorization by dividing by smallest  # prime factor at every step def getFactorization(x, check = False):     ret = set()     while (x != 1):        if len(primetaken[spf[x]]) != 0 and check:            z = primetaken[spf[x]].pop()            print(f'Conflict with {z}')            primetaken[spf[x]].add(z)            return None        ret.add(spf[x])         x = x // spf[x]       return ret  n, m = map(int, input().rstrip().split(" "))MAXN = n + 1 # stores smallest prime factor for # every number spf = [0 for i in range(n + 1)] sieve()#print(spf)   primetaken = [set() for i in range(n + 1)]numtaken = [False] * (n + 1)  for _ in range(m):    s, x = input().rstrip().split(" ")    x = int(x)    if s == '+':        if numtaken[x]:            print('Already on')        else:            f = getFactorization(x, True)            if f is not None:                for ele in f:                    primetaken[ele].add(x)                print('Success')                numtaken[x] = True    else:        if numtaken[x]:            f = getFactorization(x)            for ele in f:                primetaken[ele].remove(x)            numtaken[x] = False            print('Success')        else:            print('Already off')  
