import osimport sysfrom io import BytesIO, IOBase BUFSIZE = 8192  class FastIO(IOBase):    newlines = 0     def __init__(self, file):        self._fd = file.fileno()        self.buffer = BytesIO()        self.writable = "x" in file.mode or "r" not in file.mode        self.write = self.buffer.write if self.writable else None     def read(self):        while True:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            if not b:                break            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines = 0        return self.buffer.read()     def readline(self):        while self.newlines == 0:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            self.newlines = b.count(b"\n") + (not b)            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines -= 1        return self.buffer.readline()     def flush(self):        if self.writable:            os.write(self._fd, self.buffer.getvalue())            self.buffer.truncate(0), self.buffer.seek(0)  class IOWrapper(IOBase):    def __init__(self, file):        self.buffer = FastIO(file)        self.flush = self.buffer.flush        self.writable = self.buffer.writable        self.write = lambda s: self.buffer.write(s.encode("ascii"))        self.read = lambda: self.buffer.read().decode("ascii")        self.readline = lambda: self.buffer.readline().decode("ascii")  sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)input = lambda: sys.stdin.readline().rstrip("\r\n")##########################################################import mathimport bisect mod = 998244353# for _ in range(int(input())):from collections import Counter# sys.setrecursionlimit(10**6)# dp=[[-1 for i in range(n+5)]for j in range(cap+5)]# arr= list(map(int, input().split()))# n,l= map(int, input().split())# arr= list(map(int, input().split()))# for _ in range(int(input())):# n=int(input())# for _ in range(int(input())):import bisectfrom heapq import *from collections import defaultdict,dequedef okay(x,y):    if x<0 or x>=3 :        return False    if y<n and mat[x][y]!=".":        return False    if y+1<n and mat[x][y+1]!=".":        return False    if y+2<n and mat[x][y+2]!=".":        return False     return True '''for i in range(int(input())): n,m=map(int, input().split())g=[[] for i in range(n+m)]for i in range(n):    s=input()    for j,x in enumerate(s):        if x=="#":            g[i].append(n+j)            g[n+j].append(i)q=deque([0])dis=[10**9]*(n+m)dis[0]=0while q:    node=q.popleft()    for i in g[node]:        if dis[i]>dis[node]+1:             dis[i]=dis[node]+1            q.append(i)print(-1 if dis[n-1]==10**9 else dis[n-1])'''from collections import deque t = int(input())for _ in range(t):    q = deque([])    flag=False    n,k = map(int, input().split())    mat = [input() for i in range(3)]    vis=[[0 for i in range(105)]for j in range(3)]    for i in range(3):        if mat[i][0]=="s":            q.append((i,0))    while q:        x,y=q.popleft()         if y+1>=n:            flag=True            break        if vis[x][y]==1:            continue        vis[x][y]=1        if (y+1<n and mat[x][y+1]=='.' and okay(x-1,y+1)==True):            q.append((x-1,y+3))         if  (y+1<n and mat[x][y+1]=='.' and okay(x,y+1)==True):            q.append((x,y+3))        if  (y+1<n and mat[x][y+1]=='.' and okay(x+1,y+1)==True):            q.append((x+1,y+3))    if flag:        print("YES")    else:        print("NO")     # ls=list(map(int, input().split()))# d=defaultdict(list)#for _ in range(int(input())):#import math#print(math.factorial(20)//200)# n=int(input())     # n,k= map(int, input().split())     # arr=list(map(int, input().split()))                       
