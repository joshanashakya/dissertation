import java.io.BufferedOutputStream;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.io.Reader;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.StringTokenizer; public class B2 {     static final long MODULO = (long) (1e9 + 7);    private static final long INF = Long.MAX_VALUE / 2;    private static int n, k;    private static int[] a;    private static int minLen;     public static void main(String[] args) {        BufferedScanner scanner = new BufferedScanner();        PrintWriter writer = new PrintWriter(new BufferedOutputStream(System.out));         int t = 1;//scanner.nextInt();        for (int tc = 0; tc < t; tc++) {            n = scanner.nextInt();            k = scanner.nextInt();            {                List<Integer> tmp = new ArrayList<>(n);                for (int i = 0; i < n; i++) {                    tmp.add(scanner.nextInt());                }                tmp.sort(Integer::compareTo);                a = tmp.stream().mapToInt(i -> i).toArray();            }            minLen = n / k;            cache = new long[k + 1][n % k + 1];            for (int i = 0; i < cache.length; i++) {                Arrays.fill(cache[i], -1);            }            writer.println(dfs(0, 0, n % k));        }         scanner.close();        writer.flush();        writer.close();    }     static long[][] cache;     private static long dfs(int idx, int group, int remain) {        if (idx == n) {            return remain == 0 ? 0 : INF;        }        if (group >= k) {            return INF;        }        if (cache[group][remain] != -1) {            return cache[group][remain];        }        long ans = INF;        if (idx + minLen <= n) {            ans = Math.min(ans, dfs(idx + minLen, group + 1, remain) + a[idx + minLen - 1] - a[idx]);        }        if (remain > 0 && idx + minLen + 1 <= n) {            ans = Math.min(ans, dfs(idx + minLen + 1, group + 1, remain - 1) + a[idx + minLen] - a[idx]);        }        return cache[group][remain] = ans;    }     static class ListInt extends ArrayList<Integer> {}     public static class BufferedScanner {        BufferedReader br;        StringTokenizer st;         public BufferedScanner(Reader reader) {            br = new BufferedReader(reader);        }         public BufferedScanner() {            this(new InputStreamReader(System.in));        }         String next() {            while (st == null || !st.hasMoreElements()) {                try {                    st = new StringTokenizer(br.readLine());                } catch (IOException e) {                    e.printStackTrace();                }            }            return st.nextToken();        }         int nextInt() {            return Integer.parseInt(next());        }         long nextLong() {            return Long.parseLong(next());        }         double nextDouble() {            return Double.parseDouble(next());        }         String nextLine() {            String str = "";            try {                str = br.readLine();            } catch (IOException e) {                e.printStackTrace();            }            return str;        }         void close() {            try {                br.close();            } catch (IOException e) {                e.printStackTrace();            }        }     }     static long gcd(long a, long b) {        if (a < b) {            return gcd(b, a);        }        while (b > 0) {            long tmp = b;            b = a % b;            a = tmp;        }        return a;    }     static long inverse(long a, long m) {        long[] ans = extgcd(a, m);        return ans[0] == 1 ? (ans[1] + m) % m : -1;    }     private static long[] extgcd(long a, long m) {        if (m == 0) {            return new long[]{a, 1, 0};        } else {            long[] ans = extgcd(m, a % m);            long tmp = ans[1];            ans[1] = ans[2];            ans[2] = tmp;            ans[2] -= ans[1] * (a / m);            return ans;        }    }     static long add(long a, long b) {        a += b;        if (a >= MODULO) {            a -= MODULO;        }        return a;    }     static long sub(long a, long b) {        a -= b;        if (a < 0) {            a += MODULO;        }        return a;    }     static long mul(long a, long b) {        return a * b % MODULO;    }     static long div(long a, long b) {        return a * inverse(b, MODULO) % MODULO;    }     static class Comb {        final long modulo;        final long[] fac, fnv;         Comb(int limit, long modulo) {            fac = new long[limit + 1];            fnv = new long[limit + 1];            fac[0] = 1;            fnv[0] = 1;            for (int i = 1; i <= limit; i++) {                fac[i] = mul(fac[i - 1], i);                fnv[i] = div(fnv[i - 1], i);            }            this.modulo = modulo;        }         long c(int total, int choose) {            if (total < choose) {                return 0;            }            if (total == 0 || total == choose) {                return 1;            }            return mul(mul(fac[total], fnv[choose]), fnv[total - choose]);        }    } }
