//package CodeForces; import java.io.*;import java.util.*;import javafx.util.Pair; public class Main {     public static MyScanner sc = new MyScanner();    public static int MOD = 1000000007;    // __builtin_popcountll(n) <-- c++ // binary count(1) ex. 8 --> 0100 --> 1    HashSet<Integer> set = new HashSet<>();    HashMap<Integer, Integer> map = new HashMap<>();    Random r = new Random();    ArrayList<Integer> l = new ArrayList<>();    public static int[][] dp;     /* ********************************* main ********************************* */    public static void main(String[] args) {        int t = 1;//        t = sc.nextInt();        while(t-->0){            int n = sc.nextInt();            String s = sc.next();            int[][] a = new int[n][500];            for (int i = 0; i < n; i++) {                int x = 0;                if(s.charAt(i) == '1'){                    x = 1;                } else{                    for (int j = 0; j < 500; j++) a[i][j] = 1;                    x = 0;                }                int ai = sc.nextInt();                int bi = sc.nextInt();                for (int j = 0; j < bi && j < 500; j++) a[i][j] = x;                int xx = ai, yy = bi, zz = ai+bi;                while(zz < 500){                    for (int j = xx+yy; j < (2*xx)+yy && j < 500; j++) a[i][j] = x;                    yy = (2*xx)+yy;                    zz = xx + yy;                }            }//            for (int i = 0; i < n; i++) System.out.println(Arrays.toString(a[i]));            int max = -1;            for (int i = 0; i < 500; i++) {                int curr = 0;                for (int j = 0; j < n; j++)                     if(a[j][i] == 1) curr++;                if(max < curr) max = curr;            }            System.out.println(max);        }    }    /* ********************************* End ********************************* */        public static void reverse(int[] a, int le){        if(le == a.length/2) return;        int temp = a[le];        a[le] = a[a.length - le - 1];        a[a.length - le - 1] = temp;        reverse(a, --le);    }        public static int gcdEuclids(int m, int n){        int r = m % n;        while (r != 0) {            m = n;            n = r;            r = m % n;        }        return n;    }     public static int gcd(int m, int n){        return n != 0 ? gcd(n, m%n) : n;    }        public static int BinarySearch(int[] a, int v, int f, int l){        int pos = -1;        if(f <= l){            int mid = (f + l)/2;            if(a[mid] == v)                pos = mid;            else if(v < a[mid])                pos = BinarySearch(a, v, f, mid - 1);            else if(v > a[mid])                pos = BinarySearch(a, v, mid + 1, l);        }        return pos;    }        public static ArrayList<Integer> factorize(Long n){        HashSet<Integer> set = new HashSet<>();        while(n%2 == 0){            set.add(2);            n /= 2;        }        for (int i = 3; i <= Math.sqrt(n); i = i + 2) {            while (n % i == 0) {                set.add(i);                n /= i;            }        }        ArrayList<Integer> l = new ArrayList<>(set);        return l;    }        public static class MyScanner {         BufferedReader br;        StringTokenizer st;         public MyScanner() {            br = new BufferedReader(new InputStreamReader(System.in));        }         String next() {            while (st == null || !st.hasMoreElements()) {                try {                    st = new StringTokenizer(br.readLine());                } catch (IOException e) {                    e.printStackTrace();                }            }            return st.nextToken();        }         int nextInt() {            return Integer.parseInt(next());        }         long nextLong() {            return Long.parseLong(next());        }         double nextDouble() {            return Double.parseDouble(next());        }         String nextLine() {            String str = "";            try {                str = br.readLine();            } catch (IOException e) {                e.printStackTrace();            }            return str;        }    }     public static class MyPair {         int x;        int y;         public MyPair(int x, int y) {            this.x = x;            this.y = y;        }    }     public static int Fibonacci(int n) {        int[] a = new int[n + 1];        a[0] = 0;        a[1] = 1;        for (int i = 2; i < a.length; i++) {            a[i] = a[i - 1] + a[i - 2];        }        return a[n];    }     public static boolean isprime(int n) {        for (int i = 2; i * i <= n; i++) {            if (n % i == 0) {                return false;            }        }        return true;    }     public static int[] addarr(int[] a, int n) {        for (int i = 0; i < n; i++) {            a[i] = sc.nextInt();        }        return a;    }     public static long factt(int n) {        if (n == 0) {            return 1;        }        return n * factt(n - 1);    }     public static long sumDigit(long n) {        int a = 0;        while (n != 0) {            a += n % 10;            n /= 10;        }        return a;    }     public static long pow(long n, long p) {        return p == 0 ? 1 : n * pow(n, p - 1);    }     public static long fastpow(long v, long p) {        if (p == 0) {            return 1;        }        if (p == 1) {            return v;        }        long ans = fastpow(v, p / 2);        if (p % 2 == 1) {            return ans * ans * v;        } else {            return ans * ans;        }    }     public static int LCS(String s1, String s2, int i, int j) {//        String s1 = sc.next();//        String s2 = sc.next();//        dp = new int[s1.length()][s2.length()];//        System.out.println(LCS(s1, s2, s1.length()-1, s2.length()-1));        if (i == -1 || j == -1) {            return 0;        } else if (dp[i][j] != 0) {            return dp[i][j];        } else if (s1.charAt(i) == s2.charAt(j)) {            return dp[i][j] = 1 + LCS(s1, s2, i - 1, j - 1);        } else {            return dp[i][j] = Math.max(LCS(s1, s2, i - 1, j), LCS(s1, s2, i, j - 1));        }    } }
