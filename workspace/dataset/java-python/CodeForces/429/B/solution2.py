"""    Author - Satwik Tiwari .    15th Dec , 2020  - Tuesday""" #===============================================================================================#importing some useful libraries. from __future__ import division, print_functionfrom fractions import Fractionimport sysimport osfrom io import BytesIO, IOBasefrom functools import cmp_to_key # from itertools import *from heapq import *from math import gcd, factorial,floor,ceil,sqrt from copy import deepcopyfrom collections import deque  from bisect import bisect_left as blfrom bisect import bisect_right as brfrom bisect import bisect #==============================================================================================#fast I/O regionBUFSIZE = 8192  class FastIO(IOBase):    newlines = 0     def __init__(self, file):        self._fd = file.fileno()        self.buffer = BytesIO()        self.writable = "x" in file.mode or "r" not in file.mode        self.write = self.buffer.write if self.writable else None     def read(self):        while True:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            if not b:                break            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines = 0        return self.buffer.read()     def readline(self):        while self.newlines == 0:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            self.newlines = b.count(b"\n") + (not b)            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines -= 1        return self.buffer.readline()     def flush(self):        if self.writable:            os.write(self._fd, self.buffer.getvalue())            self.buffer.truncate(0), self.buffer.seek(0)  class IOWrapper(IOBase):    def __init__(self, file):        self.buffer = FastIO(file)        self.flush = self.buffer.flush        self.writable = self.buffer.writable        self.write = lambda s: self.buffer.write(s.encode("ascii"))        self.read = lambda: self.buffer.read().decode("ascii")        self.readline = lambda: self.buffer.readline().decode("ascii")  def print(*args, **kwargs):    """Prints the values to a stream, or to sys.stdout by default."""    sep, file = kwargs.pop("sep", " "), kwargs.pop("file", sys.stdout)    at_start = True    for x in args:        if not at_start:            file.write(sep)        file.write(str(x))        at_start = False    file.write(kwargs.pop("end", "\n"))    if kwargs.pop("flush", False):        file.flush()  if sys.version_info[0] < 3:    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)else:    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) # inp = lambda: sys.stdin.readline().rstrip("\r\n") #===============================================================================================### START ITERATE RECURSION ###from types import GeneratorTypedef iterative(f, stack=[]):  def wrapped_func(*args, **kwargs):    if stack: return f(*args, **kwargs)    to = f(*args, **kwargs)    while True:      if type(to) is GeneratorType:        stack.append(to)        to = next(to)        continue      stack.pop()      if not stack: break      to = stack[-1].send(to)    return to  return wrapped_func#### END ITERATE RECURSION #### #===============================================================================================#some shortcuts def inp(): return sys.stdin.readline().rstrip("\r\n") #for fast inputdef out(var): sys.stdout.write(str(var))  #for fast output, always take stringdef lis(): return list(map(int, inp().split()))def stringlis(): return list(map(str, inp().split()))def sep(): return map(int, inp().split())def strsep(): return map(str, inp().split())# def graph(vertex): return [[] for i in range(0,vertex+1)]def testcase(t):    for pp in range(t):        solve(pp)def google(p):    print('Case #'+str(p)+': ',end='')def lcm(a,b): return (a*b)//gcd(a,b)def power(x, y, p) :    y%=(p-1)  #not so sure about this. used when y>p-1. if p is prime.    res = 1     # Initialize result    x = x % p  # Update x if it is more , than or equal to p    if (x == 0) :        return 0    while (y > 0) :        if ((y & 1) == 1) : # If y is odd, multiply, x with result            res = (res * x) % p         y = y >> 1      # y = y/2        x = (x * x) % p    return resdef ncr(n,r): return factorial(n) // (factorial(r) * factorial(max(n - r, 1)))def isPrime(n) :    if (n <= 1) : return False    if (n <= 3) : return True    if (n % 2 == 0 or n % 3 == 0) : return False    i = 5    while(i * i <= n) :        if (n % i == 0 or n % (i + 2) == 0) :            return False        i = i + 6    return Trueinf = pow(10,20)mod = 10**9+7#===============================================================================================# code here ;)) def safe(x,y):    global n,m    return (0<=x<n and 0<=y<m) def solve(case):    global n,m    n,m = sep()    g = []    for i in range(n):        tmep = lis()        g.append(tmep)        dp1 = [[0]*(m) for i in range(n)]    dp2 = [[0]*(m) for i in range(n)]    dp3 = [[0]*(m) for i in range(n)]    dp4 = [[0]*(m) for i in range(n)]        dp1[0][0] = g[0][0]    for i in range(n):        for j in range(m):            if(i == 0 and j==0):                continue            dp1[i][j] = g[i][j]            if(safe(i-1,j) and safe(i,j-1)):                dp1[i][j] += max(dp1[i-1][j],dp1[i][j-1])            elif(safe(i-1,j)):                dp1[i][j] += dp1[i-1][j]            else:                dp1[i][j] += dp1[i][j-1]     for i in range(n-1,-1,-1):        for j in range(m-1,-1,-1):            if(i == n-1 and j == m-1):                dp2[i][j] = g[i][j]                continue            dp2[i][j] = g[i][j]            if(safe(i,j+1) and safe(i+1,j)):                dp2[i][j] += max(dp2[i][j+1],dp2[i+1][j])            elif(safe(i+1,j)):                dp2[i][j] += dp2[i+1][j]            else:                dp2[i][j] += dp2[i][j+1]     for i in range(n-1,-1,-1):        for j in range(m):            if(i == n-1 and j == 0):                dp3[i][j] = g[i][j]                continue            dp3[i][j] = g[i][j]            if(safe(i,j-1) and safe(i+1,j)):                dp3[i][j] += max(dp3[i][j-1],dp3[i+1][j])            elif(safe(i+1,j)):                dp3[i][j] += dp3[i+1][j]            else:                dp3[i][j] += dp3[i][j-1]     for i in range(n):        for j in range(m-1,-1,-1):            if(i == 0 and j == m-1):                dp4[i][j] = g[i][j]                continue            dp4[i][j] = g[i][j]            if(safe(i-1,j) and safe(i,j+1)):                dp4[i][j] += max(dp4[i-1][j],dp4[i][j+1])            elif(safe(i-1,j)):                dp4[i][j] += dp4[i-1][j]            else:                dp4[i][j] += dp4[i][j+1]     ans = -inf    # for i in range(n):    #     print(dp1[i])    # print('==')    # for i in range(n):    #     print(dp2[i])    # print('===')    # for i in range(n):    #     print(dp3[i])    # print('===')    # for i in range(n):    #     print(dp4[i])    # print('==')    for i  in range(1,n-1):        for j in range(1,m-1):            temp = dp1[i-1][j] + dp2[i+1][j] + dp3[i][j-1] + dp4[i][j+1]            ans=  max(ans,temp)            temp = dp1[i][j-1] + dp2[i][j+1] + dp3[i+1][j] + dp4[i-1][j]            ans = max(ans,temp)     print(ans)    n,m = 0,0testcase(1)# testcase(int(inp()))    
