import java.io.*;import java.math.BigDecimal;import java.math.BigInteger;import java.math.RoundingMode;import java.util.*;import java.util.concurrent.LinkedBlockingDeque; import java.util.ArrayList;import java.util.HashMap;import java.util.LinkedList;  // graph, dfs,bfs, get connected components,iscycle, isbipartite, dfs on trees   public class scratch_25 {    static class Graph{         public static class Vertex{            HashMap<Integer,Integer> nb= new HashMap<>();     // for neighbours of each vertex        }         public static HashMap<Integer,Vertex> vt;   // for vertices(all)         public Graph(){            vt= new HashMap<>();        }         public static int numVer(){            return vt.size();        }         public static boolean contVer(int ver){            return vt.containsKey(ver);        }         public static void addVer(int ver){            Vertex v= new Vertex();            vt.put(ver,v);        }        public class Pair{            int vname;            ArrayList<Integer> psf= new ArrayList<>();       // path so far            int dis;            int col;        }             public static void addEdge(int ver1, int ver2, int weight){            if(!vt.containsKey(ver1) || !vt.containsKey(ver2)){                return;            }            Vertex v1= vt.get(ver1);            Vertex v2= vt.get(ver2);            v1.nb.put(ver2,weight);                                 // if previously there is an edge, then this replaces that edge            v2.nb.put(ver1,weight);        }         public static void delEdge(int ver1, int ver2){             if(!vt.containsKey(ver1) || !vt.containsKey(ver2)){                return;            }            vt.get(ver1).nb.remove(ver2);            vt.get(ver2).nb.remove(ver1);        }        public static void delVer(int ver){            if(!vt.containsKey(ver)){                return;            }            Vertex v1= vt.get(ver);            ArrayList<Integer> arr= new ArrayList<>(v1.nb.keySet());            for (int i = 0; i <arr.size() ; i++) {                int s= arr.get(i);                vt.get(s).nb.remove(ver);            }            vt.remove(ver);        }           static boolean done[];            static int parent[];            static ArrayList<Integer>vals= new ArrayList<>();          public static boolean isCycle(int i){            Stack<Integer>stk= new Stack<>();             stk.push(i);            while(!stk.isEmpty()){                int x= stk.pop();                vals.add(x);             //   System.out.print("current="+x+" stackinit="+stk);                if(!done[x]){                    done[x]=true;                }                else if(done[x] ){                    return true;                }                 ArrayList<Integer>ar= new ArrayList<>(vt.get(x).nb.keySet());                for (int j = 0; j <ar.size() ; j++) {                   if(parent[x]!=ar.get(j)){                       parent[ar.get(j)]=x;                    stk.push(ar.get(j));                   }                }               // System.out.println(" stackfin="+stk);            }            return false;        }        static int distance[];        static ArrayList<Integer>ans= new ArrayList<>();         public static long bfs(int v){           long total=0;           Queue<Integer>q= new LinkedList<>();           q.add(v);           while(!q.isEmpty()){               int x= q.poll();               done[x]=true;               total++;               ArrayList<Integer>vals= new ArrayList<>(vt.get(x).nb.keySet());               for (int i = 0; i <vals.size() ; i++) {                   int c= vals.get(i);                   if(!done[c]){                       q.add(c);                   }               }              }               return total;            }        }      // int count=0;    //static long count=0;    static class Reader {        static BufferedReader reader;        static StringTokenizer tokenizer;         /**         * call this method to initialize reader for InputStream         */        static void init(InputStream input) {            reader = new BufferedReader(                    new InputStreamReader(input));            tokenizer = new StringTokenizer("");        }         /**         * get next word         */        static String next() throws IOException {            while (!tokenizer.hasMoreTokens()) {                //TODO add check for eof if necessary                tokenizer = new StringTokenizer(                        reader.readLine());            }            return tokenizer.nextToken();        }         static int nextInt() throws IOException {            return Integer.parseInt(next());        }         static double nextDouble() throws IOException {            return Double.parseDouble(next());        }         static long nextLong() throws IOException {            return Long.parseLong(next());        }    }        // After writing solution, quick scan for:    //   array out of bounds    //   special cases e.g. n=1?    //    // Big numbers arithmetic bugs:    //   int overflow    //   sorting, or taking max, or negative after MOD    public static void main(String[] args)  throws IOException {        Reader.init(System.in);        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));        int t= Reader.nextInt();        for (int tt = 0; tt <t ; tt++) {            int n= Reader.nextInt();            char a[]= Reader.next().toCharArray();            char b[]= Reader.next().toCharArray();            long ans=0;            boolean b1=true;            for (int i = 0; i <20 ; i++) {                char c= (char)(i+97);                char min='{';                for (int j = 0; j <a.length ; j++) {                    if(a[j]==c && a[j]!=b[j]){                        if(b[j]<min){                            min=b[j];                        }                    }                }                if(min<c){                    b1=false;                    break;                }                for (int j = 0; j <a.length ; j++) {                    if(a[j]==c && a[j]!=b[j]){                        a[j]=min;                    }                }                if(!(min=='{' || min==c )) {                  ans++;              }               // System.out.println("c="+c+"ans="+ans+" arr= "+Arrays.toString(a));                     }   if(!b1){    out.append(-1+"\n");}else {      out.append(ans + "\n");}         }                        out.flush();        out.close();     }       static long modExp(long a, long b, long mod) {        //System.out.println("a is " + a + " and b is " + b);        if (a==1) return 1;        long ans = 1;        while (b!=0) {            if (b%2==1) {                ans = (ans*a)%mod;            }            a = (a*a)%mod;            b/=2;        }        return ans;    }      public static long modmul(long a, long b, long mod) {        return b == 0 ? 0 : ((modmul(a, b >> 1, mod) << 1) % mod + a * (b & 1)) % mod;    }     static long sum(long n){        //   System.out.println("lol="+ (n*(n-1))/2);        return (n*(n+1))/2;    }          public static ArrayList<Integer> Sieve(int n) {        boolean arr[]= new boolean [n+1];        Arrays.fill(arr,true);        arr[0]=false;        arr[1]=false;        for (int i = 2; i*i <=n ; i++) {            if(arr[i]){                for (int j = 2; j <=n/i ; j++) {                    int u= i*j;                    arr[u]=false;                }}        }        ArrayList<Integer> ans= new ArrayList<>();        for (int i = 0; i <n+1 ; i++) {            if(arr[i]){                ans.add(i);            }        }        return ans;    }        static long power( long x, long y, long p)    {         long res = 1;          x = x % p;         if (x == 0) return 0;         while (y > 0)        {             if((y & 1)==1)                res = (res * x) % p;              y = y >> 1;            x = (x * x) % p;        }        return res;    }     public static long ceil_div(long a, long b){        return (a+b-1)/b;    }     static long gcd(long a, long b)    {        if (a == 0)            return b;        return gcd(b % a, a);    }     static long lcm(long a, long b)    {        return (a*b)/gcd(a, b);    } }
