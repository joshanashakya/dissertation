import java.io.ByteArrayInputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.nio.charset.StandardCharsets;import java.util.Arrays;import java.util.InputMismatchException; public class B425 { 	static class Solver { 		int N, M, K, grid[][], g2[][]; 		int fix(int[] model, int[] cand, int cap) {			// reg			int a = 0, b = 0;			for (int i = 0; i < cap; i++) {				a += model[i] ^ cand[i];				b += model[i] ^ cand[i] ^ 1;			}			return a < b ? a : b;		} 		void solve(FastScanner s, PrintWriter out) {			N = s.nextInt();			M = s.nextInt();			K = s.nextInt();			grid = s.next2DIntArray(N, M);			if (M > N) {				g2 = new int[M][N];				for (int i = 0; i < N; i++)					for (int j = 0; j < M; j++)						g2[M - j - 1][i] = grid[i][j];				N = swap(M, M = N);				grid = g2;			} 			if (N > 10) {				// select and force				// since you have max 10 edits, if there are more than				// 10 rows, you can just choose one row as the model row				// since every row of the checkerboard will have the same				// relative cell widths				// you just either make it match completely with the model				// row, or you make it the exact opposite. Either way you				// end up with a proper checkerboard				int min = 11;				models: for (int[] model : grid) {					int changed = 0;					for (int[] row : grid) {						changed += fix(model, row, M);						if (changed > K)							continue models;					}					min = min < changed ? min : changed;				}				out.println(min == 11 ? -1 : min);			} else {				// brute force				int[] model = new int[N], row = new int[N];				int min = 11;				models: for (int i = 0; i < 1 << N; i++) {					Arrays.fill(model, 0);					for (int j = 0; j < N; j++)						model[j] = (i & 1 << j) >> j;					int changed = 0;					for (int j = 0; j < M; j++) {						for (int k = 0; k < N; k++)							row[k] = grid[k][j];						changed += fix(model, row, N);						if (changed > K)							continue models;					}					min = min < changed ? min : changed;				}				out.println(min == 11 ? -1 : min);			}		} 	} 	public static void main(String[] args) { 		FastScanner s = new FastScanner(System.in);		PrintWriter out = new PrintWriter(System.out); 		Solver solver = new Solver();		solver.solve(s, out); 		out.close(); 	} 	static int swap(int a, int b) {		return a;	} 	static Object swap(Object a, Object b) {		return a;	} 	static String ts(Object... o) {		return Arrays.deepToString(o);	} 	static class FastScanner {		private InputStream stream;		private byte[] buf = new byte[1024];		private int curChar;		private int numChars; 		public FastScanner(InputStream stream) {			this.stream = stream;		} 		public FastScanner(File f) throws FileNotFoundException {			this(new FileInputStream(f));		} 		public FastScanner(String s) {			this.stream = new ByteArrayInputStream(s.getBytes(StandardCharsets.UTF_8));		} 		int read() {			if (numChars == -1)				throw new InputMismatchException();			if (curChar >= numChars) {				curChar = 0;				try {					numChars = stream.read(buf);				} catch (IOException e) {					throw new InputMismatchException();				}				if (numChars <= 0)					return -1;			}			return buf[curChar++];		} 		boolean isSpaceChar(int c) {			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;		} 		boolean isEndline(int c) {			return c == '\n' || c == '\r' || c == -1;		} 		public int nextInt() {			return Integer.parseInt(next());		} 		public long nextLong() {			return Long.parseLong(next());		} 		public double nextDouble() {			return Double.parseDouble(next());		} 		public String next() {			int c = read();			while (isSpaceChar(c))				c = read();			StringBuilder res = new StringBuilder();			do {				res.appendCodePoint(c);				c = read();			} while (!isSpaceChar(c));			return res.toString();		} 		public String nextLine() {			int c = read();			while (isEndline(c))				c = read();			StringBuilder res = new StringBuilder();			do {				res.appendCodePoint(c);				c = read();			} while (!isEndline(c));			return res.toString();		} 		// Jacob Garbage 		public int[] nextIntArray(int N) {			int[] ret = new int[N];			for (int i = 0; i < N; i++)				ret[i] = this.nextInt();			return ret;		} 		public int[][] next2DIntArray(int N, int M) {			int[][] ret = new int[N][];			for (int i = 0; i < N; i++)				ret[i] = this.nextIntArray(M);			return ret;		} 		public long[] nextLongArray(int N) {			long[] ret = new long[N];			for (int i = 0; i < N; i++)				ret[i] = this.nextLong();			return ret;		} 		public long[][] next2DLongArray(int N, int M) {			long[][] ret = new long[N][];			for (int i = 0; i < N; i++)				ret[i] = nextLongArray(M);			return ret;		} 		public double[] nextDoubleArray(int N) {			double[] ret = new double[N];			for (int i = 0; i < N; i++)				ret[i] = this.nextDouble();			return ret;		} 		public double[][] next2DDoubleArray(int N, int M) {			double[][] ret = new double[N][];			for (int i = 0; i < N; i++)				ret[i] = this.nextDoubleArray(M);			return ret;		} 	}}
