import sys# import math# from collections import Counter# from collections import defaultdict# from collections import deque# from bisect import bisect_left as bl, bisect_right as br# from itertools import accumulate,permutations as perm,combinations as comb# from heapq import heapify,heappush,heappop,nlargest,nsmallest# from fractions import Fraction# from functools import reduce, lru_cache  # author: violist# FastIO code by pajenegod  def main():         #for _ in range(ii()):    t, s, x = mi()    print("YES" if x - t >= 0 and x - t != 1 and (x - t) % s <= 1 else "NO")  FIO = 10  def debug(*args, c=6):    # return    starter = '\033[3{}m'.format(c)    ender = '\033[0m'    if c == 0:        starter, ender = '', ''    print(starter, *args, ender, file=sys.stderr, sep='')  BUFSIZE = 8*1024 en = enumerateinf = float("inf")# IO region1    def ii(): return int(input())  def li(): return list(map(int, input().split()))   # int list  def mi(): return map(int, input().split())   # int map  if not FIO:    if __name__ == '__main__':        main()        exit()else:    from io import BytesIO, IOBase    import os# FastIO  class FastIO(IOBase):    newlines = 0     def __init__(self, file):        self._fd = file.fileno()        self.buffer = BytesIO()        self.writable = "x" in file.mode or "r" not in file.mode        self.write = self.buffer.write if self.writable else None     def read(self):        while True:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            if not b:                break            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines = 0        return self.buffer.read()     def readline(self):        while self.newlines == 0:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            self.newlines = b.count(b"\n") + (not b)            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines -= 1        return self.buffer.readline()     def flush(self):        if self.writable:            os.write(self._fd, self.buffer.getvalue())            self.buffer.truncate(0), self.buffer.seek(0)  class IOWrapper(IOBase):    def __init__(self, file):        self.buffer = FastIO(file)        self.flush = self.buffer.flush        self.writable = self.buffer.writable        self.write = lambda s: self.buffer.write(s.encode("ascii"))        self.read = lambda: self.buffer.read().decode("ascii")        self.readline = lambda: self.buffer.readline().decode("ascii")  sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)  def input(): return sys.stdin.readline().rstrip("\r\n") # /IO region  # print(type(sys.stdout), type(sys.stdin), type(open("a.py"))) if __name__ == '__main__':    main() 
