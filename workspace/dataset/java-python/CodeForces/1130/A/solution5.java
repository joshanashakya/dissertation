import java.io.*;import java.math.BigDecimal;import java.math.BigInteger;import java.math.RoundingMode;import java.util.*;import java.util.concurrent.LinkedBlockingDeque;  public class scratch_25 {    // int count=0;    //static long count=0;    static class Reader {        static BufferedReader reader;        static StringTokenizer tokenizer;         /**         * call this method to initialize reader for InputStream         */        static void init(InputStream input) {            reader = new BufferedReader(                    new InputStreamReader(input));            tokenizer = new StringTokenizer("");        }         /**         * get next word         */        static String next() throws IOException {            while (!tokenizer.hasMoreTokens()) {                //TODO add check for eof if necessary                tokenizer = new StringTokenizer(                        reader.readLine());            }            return tokenizer.nextToken();        }         static int nextInt() throws IOException {            return Integer.parseInt(next());        }         static double nextDouble() throws IOException {            return Double.parseDouble(next());        }         static long nextLong() throws IOException {            return Long.parseLong(next());        }    }         static class Pair implements Comparable<Pair>{        long x;        long y;        public Pair(long x,long y){            this.x=x;            this.y=y;        }        @Override        public int compareTo(Pair o){            return (int)this.x-(int)o.x;          }        @Override        public boolean equals(Object me) {            Pair binMe = (Pair)me;            if(this.x==binMe.x && this.y==binMe.y)                return true;            else                return false;        }         @Override        public int hashCode() {            return (int)this.x + (int)this.y;        }         @Override        public String toString() {            return x+" "+y;        }      }           public static void main(String[] args)  throws IOException {        Reader.init(System.in);        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));            int n= Reader.nextInt();            double arr[]= new double[n];            int count=0;            for (int i = 0; i <n ; i++) {                arr[i]= Reader.nextDouble();                if(arr[i]>0){                    count++;                }            }            if(count>=ceil_div(n,2)){                out.append(1+"\n");            }            else{                int count1=0;                for (int i = 0; i <n ; i++) {                    if(arr[i]<0){                        count1++;                    }                }                if(count1>=ceil_div(n,2)){                    out.append(-1+"\n");                }                else{                    out.append(0+"\n");                }               }                                          out.flush();        out.close();     }                             public static ArrayList<Integer> Sieve(int n) {        boolean arr[]= new boolean [n+1];        Arrays.fill(arr,true);        arr[0]=false;        arr[1]=false;        for (int i = 2; i*i <=n ; i++) {            if(arr[i]){                for (int j = 2; j <=n/i ; j++) {                    int u= i*j;                    arr[u]=false;                }}        }        ArrayList<Integer> ans= new ArrayList<>();        for (int i = 0; i <n+1 ; i++) {            if(arr[i]){                ans.add(i);            }        }        return ans;    }        static long power( long x, long y, long p)    {         long res = 1;          x = x % p;         if (x == 0) return 0;         while (y > 0)        {             if((y & 1)==1)                res = (res * x) % p;              y = y >> 1;            x = (x * x) % p;        }        return res;    }     public static long ceil_div(long a, long b){        return (a+b-1)/b;    }     static long gcd(long a, long b)    {        if (a == 0)            return b;        return gcd(b % a, a);    }     static long lcm(long a, long b)    {        return (a*b)/gcd(a, b);    } }
