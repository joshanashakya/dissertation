import java.io.OutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.util.Set;import java.util.HashMap;import java.io.IOException;import java.util.Random;import java.io.UncheckedIOException;import java.util.HashSet;import java.util.Map;import java.io.Closeable;import java.io.Writer;import java.io.OutputStreamWriter;import java.math.BigInteger;import java.util.Collections;import java.io.InputStream; /** * Built using CHelper plug-in * Actual solution is at the top */public class Main {    public static void main(String[] args) throws Exception {        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);        thread.start();        thread.join();    }     static class TaskAdapter implements Runnable {        @Override        public void run() {            InputStream inputStream = System.in;            OutputStream outputStream = System.out;            FastInput in = new FastInput(inputStream);            FastOutput out = new FastOutput(outputStream);            AOnNumberOfDecompositionsIntoMultipliers solver = new AOnNumberOfDecompositionsIntoMultipliers();            solver.solve(1, in, out);            out.close();        }    }     static class AOnNumberOfDecompositionsIntoMultipliers {        int mod = (int) 1e9 + 7;        Combination comb = new Combination((int) 1e5, mod);         public void solve(int testNumber, FastInput in, FastOutput out) {            int n = in.ri();            int[] a = in.ri(n);            Map<Integer, Integer> map = new HashMap<>();            for (int x : a) {                Set<Integer> set = PollardRho.findAllFactors(x);                for (int y : set) {                    int p = 0;                    while (x % y == 0) {                        x /= y;                        p++;                    }                    map.put(y, map.getOrDefault(y, 0) + p);                }            }             long ans = 1;            for (int v : map.values()) {                //x1 + x2 + ... + xn = v                ans = ans * comb.combination(v + (n - 1), v) % mod;            }            out.println(ans);        }     }     static interface InverseNumber {    }     static interface IntCombination {    }     static class DigitUtils {        private DigitUtils() {        }         public static int mod(long x, int mod) {            if (x < -mod || x >= mod) {                x %= mod;            }            if (x < 0) {                x += mod;            }            return (int) x;        }     }     static class GCDs {        private GCDs() {        }         public static int gcd(int a, int b) {            return a >= b ? gcd0(a, b) : gcd0(b, a);        }         private static int gcd0(int a, int b) {            return b == 0 ? a : gcd0(b, a % b);        }     }     static class RandomWrapper {        private Random random;        public static final RandomWrapper INSTANCE = new RandomWrapper();         public RandomWrapper() {            this(new Random());        }         public RandomWrapper(Random random) {            this.random = random;        }         public RandomWrapper(long seed) {            this(new Random(seed));        }         public int nextInt(int n) {            return random.nextInt(n);        }     }     static class Combination implements IntCombination {        final Factorial factorial;        int modVal;         public Combination(Factorial factorial) {            this.factorial = factorial;            this.modVal = factorial.getMod();        }         public Combination(int limit, int mod) {            this(new Factorial(limit, mod));        }         public int combination(int m, int n) {            if (n > m || n < 0) {                return 0;            }            return (int) ((long) factorial.fact(m) * factorial.invFact(n) % modVal * factorial.invFact(m - n) % modVal);        }     }     static class FastInput {        private final InputStream is;        private byte[] buf = new byte[1 << 13];        private int bufLen;        private int bufOffset;        private int next;         public FastInput(InputStream is) {            this.is = is;        }         public void populate(int[] data) {            for (int i = 0; i < data.length; i++) {                data[i] = readInt();            }        }         private int read() {            while (bufLen == bufOffset) {                bufOffset = 0;                try {                    bufLen = is.read(buf);                } catch (IOException e) {                    bufLen = -1;                }                if (bufLen == -1) {                    return -1;                }            }            return buf[bufOffset++];        }         public void skipBlank() {            while (next >= 0 && next <= 32) {                next = read();            }        }         public int ri() {            return readInt();        }         public int[] ri(int n) {            int[] ans = new int[n];            populate(ans);            return ans;        }         public int readInt() {            int sign = 1;             skipBlank();            if (next == '+' || next == '-') {                sign = next == '+' ? 1 : -1;                next = read();            }             int val = 0;            if (sign == 1) {                while (next >= '0' && next <= '9') {                    val = val * 10 + next - '0';                    next = read();                }            } else {                while (next >= '0' && next <= '9') {                    val = val * 10 - next + '0';                    next = read();                }            }             return val;        }     }     static class MillerRabin {        static int mod;        static Power power;         public static boolean mr(int n, int s) {            if (n <= 1) {                return false;            }            if (n == 2) {                return true;            }            if (n % 2 == 0) {                return false;            }            int m = n - 1;            while (m % 2 == 0) {                m /= 2;            }            mod = n;            power = new Power(mod);            for (int i = 0; i < s; i++) {                int x = RandomWrapper.INSTANCE.nextInt(n - 2) + 2;                if (!mr0(x, n, m)) {                    return false;                }            }            return true;        }         private static boolean mr0(int x, int n, int m) {            return test(power.pow(x, m), m, n);        }         private static boolean test(int y, int exp, int n) {            int y2 = (int) ((long) y * y % mod);            if (!(exp == n - 1 || test(y2, exp * 2, n))) {                return false;            }            if (exp != n - 1 && y2 != 1) {                return true;            }            if (y != 1 && y != n - 1) {                return false;            }            return true;        }     }     static class PollardRho {        public static int findFactor(int n) {            if (n == 1) {                return n;            }            if (MillerRabin.mr(n, 10)) {                return n;            }            while (true) {                int f = rho(n);                if (f != n) {                    return f;                }            }        }         public static Set<Integer> findAllFactors(int n) {            if (n == 1) {                return Collections.emptySet();            }            Set<Integer> set = new HashSet<>();            findAllFactors(set, n);            return set;        }         private static void findAllFactors(Set<Integer> set, int n) {            int f = findFactor(n);            if (f == n) {                set.add(f);                return;            }            findAllFactors(set, f);            findAllFactors(set, n / f);        }         private static int rho(int n) {            if (n == 1) {                return 1;            }            if (n % 2 == 0) {                return 2;            }            if (n % 3 == 0) {                return 3;            }            int x = 0, y = x, t, q = 1, c = RandomWrapper.INSTANCE.nextInt(n - 1) + 1;            for (int k = 2; ; k <<= 1, y = x, q = 1) {                for (int i = 1; i <= k; ++i) {                    x = DigitUtils.mod((long) x * x + c, n);                    q = DigitUtils.mod((long) q * Math.abs(x - y), n);                    if ((i & 127) == 0) {                        t = GCDs.gcd(q, n);                        if (t > 1) {                            return t;                        }                    }                }                if ((t = GCDs.gcd(q, n)) > 1) {                    return t;                }            }        }     }     static class FastOutput implements AutoCloseable, Closeable, Appendable {        private static final int THRESHOLD = 32 << 10;        private final Writer os;        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);         public FastOutput append(CharSequence csq) {            cache.append(csq);            return this;        }         public FastOutput append(CharSequence csq, int start, int end) {            cache.append(csq, start, end);            return this;        }         private void afterWrite() {            if (cache.length() < THRESHOLD) {                return;            }            flush();        }         public FastOutput(Writer os) {            this.os = os;        }         public FastOutput(OutputStream os) {            this(new OutputStreamWriter(os));        }         public FastOutput append(char c) {            cache.append(c);            afterWrite();            return this;        }         public FastOutput append(long c) {            cache.append(c);            afterWrite();            return this;        }         public FastOutput println(long c) {            return append(c).println();        }         public FastOutput println() {            return append('\n');        }         public FastOutput flush() {            try {//            boolean success = false;//            if (stringBuilderValueField != null) {//                try {//                    char[] value = (char[]) stringBuilderValueField.get(cache);//                    os.write(value, 0, cache.length());//                    success = true;//                } catch (Exception e) {//                }//            }//            if (!success) {                os.append(cache);//            }                os.flush();                cache.setLength(0);            } catch (IOException e) {                throw new UncheckedIOException(e);            }            return this;        }         public void close() {            flush();            try {                os.close();            } catch (IOException e) {                throw new UncheckedIOException(e);            }        }         public String toString() {            return cache.toString();        }     }     static class Factorial {        int[] fact;        int[] inv;        int mod;         public int getMod() {            return mod;        }         public Factorial(int[] fact, int[] inv, int mod) {            this.mod = mod;            this.fact = fact;            this.inv = inv;            fact[0] = inv[0] = 1;            int n = Math.min(fact.length, mod);            for (int i = 1; i < n; i++) {                fact[i] = i;                fact[i] = (int) ((long) fact[i] * fact[i - 1] % mod);            }            inv[n - 1] = BigInteger.valueOf(fact[n - 1]).modInverse(BigInteger.valueOf(mod)).intValue();            for (int i = n - 2; i >= 1; i--) {                inv[i] = (int) ((long) inv[i + 1] * (i + 1) % mod);            }        }         public Factorial(int limit, int mod) {            this(new int[Math.min(limit + 1, mod)], new int[Math.min(limit + 1, mod)], mod);        }         public int fact(int n) {            if (n >= mod) {                return 0;            }            return fact[n];        }         public int invFact(int n) {            if (n >= mod) {                throw new IllegalArgumentException();            }            return inv[n];        }     }     static class Power implements InverseNumber {        int mod;         public Power(int mod) {            this.mod = mod;        }         public int pow(int x, int n) {            if (n == 0) {                return 1 % mod;            }            long r = pow(x, n >> 1);            r = r * r % mod;            if ((n & 1) == 1) {                r = r * x % mod;            }            return (int) r;        }     }} 
