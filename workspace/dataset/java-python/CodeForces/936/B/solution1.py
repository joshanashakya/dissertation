n, m = list(map(int, input().split())) from collections import defaultdict graph = defaultdict(list) for i in range(1, n + 1):    neighbours = list(map(int, input().split()))[1:]    graph[(i, 0)] = [(x, 1) for x in neighbours]    graph[(i, 1)] = [(x, 0) for x in neighbours] start = int(input()) # terminal stateterminal_states = []for x in graph:    if len(graph[x]) == 0 and x[1] == 1:        terminal_states.append(x[0]) # Find if there is a path from (start,0) to (terminal,1)import sys stack = [(start, 0)]parents = {}visited = {}visited[(start, 0)] = Trueparents[(start, 0)] = Nonewhile (len(stack) != 0):    current = stack.pop()    for neighbour in graph[current]:        if neighbour not in visited:            stack.append(neighbour)            visited[neighbour] = True            parents[neighbour] = current for terminal in terminal_states:    if (terminal, 1) in visited:        print("Win")        solution = []        current = (terminal, 1)        while (current != None):            solution.append(current[0])            current = parents[current]        print(" ".join(list(map(str, solution[::-1]))))        sys.exit() # Check for cycles in the graphfrom queue import Queue # we need an adjancy lsit of indegree .. actually only the value is enoughingoing_graph = defaultdict(int)for node in visited:    ingoing_graph[node] += 0    for neighbour in graph[node]:        if neighbour in visited:            ingoing_graph[neighbour] += 1 zero_indegree_nodes = []deleted = {} for node in ingoing_graph:    if node in visited and ingoing_graph[node] == 0:        zero_indegree_nodes.append(node)  count = 0 while zero_indegree_nodes:    current = zero_indegree_nodes.pop()    count += 1    for neighbour in graph[current]:        if neighbour not in deleted:            ingoing_graph[neighbour] -= 1            if ingoing_graph[neighbour] == 0:                zero_indegree_nodes.append(neighbour)                deleted[neighbour] = True if count < len(visited):    print("Draw")else:    print("Lose")
