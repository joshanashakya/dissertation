import java.util.*;import java.io.*; public class Main {	public static void main(String args[]) {new Main().run();} 	FastReader in = new FastReader();	PrintWriter out = new PrintWriter(System.out);	void run(){		work();		out.flush();	}	long mod=998244353;	long gcd(long a,long b) {		return b==0?a:gcd(b,a%b);	}	ArrayList<Integer>[] graph;	ArrayList<Integer> ret=new ArrayList<>();	int[][] dp;	int[][] route;	boolean loop;	void work() {		int n=in.nextInt();		int m=in.nextInt();		graph=(ArrayList<Integer>[])new ArrayList[n];		for(int i=0;i<n;i++)graph[i]=new ArrayList<>();		dp=new int[n][2];		route=new int[n][2];		for(int i=0;i<n;i++) {			int len=in.nextInt();			for(int j=0;j<len;j++) {				graph[i].add(in.nextInt()-1);			}		}		int s=in.nextInt()-1;		dfs(s,0,new int[n][2]);		if(dp[s][0]>0) {			out.println("Win");			int index=s+1,type=0;			while(index!=0) {				ret.add(index);				index=route[index-1][type];				type^=1;			}			for(int r:ret) {				out.print(r+" ");			}		}else if(loop) {			out.println("Draw");		}else {			out.println("Lose");		}	}	private void dfs(int node, int d, int[][] col) {		col[node][d]=1;		int next=1^d;		boolean f=false;		for(int nn:graph[node]) {			f=true;			if(col[nn][next]==0||col[nn][next]==2) {				if(col[nn][next]==0)dfs(nn,next,col);				if(dp[nn][0]!=0) {					if(dp[node][1]==0||dp[node][1]>dp[nn][0]+1) {						dp[node][1]=dp[nn][0]+1;						route[node][1]=nn+1;					}				}				if(dp[nn][1]!=0) {					if(dp[node][0]==0||dp[node][0]>dp[nn][1]+1) {						dp[node][0]=dp[nn][1]+1;						route[node][0]=nn+1;					}				}			}else if(col[nn][next]==1){				loop=true;			}		}		col[node][d]=2;		if(!f) {			dp[node][1]=1;		}	}}	   class FastReader{	BufferedReader br;	StringTokenizer st; 	public FastReader()	{		br=new BufferedReader(new InputStreamReader(System.in));	} 	public String next() 	{		if(st==null || !st.hasMoreElements())		{			try {				st = new StringTokenizer(br.readLine());			} catch (IOException e) {				e.printStackTrace();			}		}		return st.nextToken();	} 	public int nextInt() 	{		return Integer.parseInt(next());	} 	public long nextLong()	{		return Long.parseLong(next());	}}
