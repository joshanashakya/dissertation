# 936Bimport collections def do():    nodes, edges = map(int, input().split(" "))    outd = [0] * (nodes + 1)    g = collections.defaultdict(list)    for i in range(1, nodes + 1):        tmp = [int(c) for c in input().split(" ")]        outd[i] = tmp[0]        g[i] = tmp[1:]    dp = [[0] * 2 for _ in range(nodes + 1)]    pre = [[0] * 2 for _ in range(nodes + 1)]    st = int(input())    mask = [0] * (nodes + 1)     def dfs(entry):        has_loop = False        stack = [[entry, 0, True]]        dp[entry][0] = 1 # d[st][0], 0 means reach here by even(0) steps        while stack:            cur, step, first = stack.pop()            if first:                mask[cur] = 1                stack.append([cur, -1, False])                for nei in g[cur]:                    if mask[nei]:                        has_loop = True                    if dp[nei][step ^ 1]:                        continue                    pre[nei][step ^ 1] = cur                    dp[nei][step ^ 1] = 1                    stack.append([nei, step ^ 1, first])            else:                mask[cur] = 0        return has_loop     has_loop = dfs(st)    for i in range(1, nodes + 1):        if outd[i] == 0: # out degree            if dp[i][1]: # must reach here by odd steps                print("Win")                res = []                cur = i                step = 1                while cur != st or step:                    res.append(cur)                    cur = pre[cur][step]                    step ^= 1                res.append(st)                print(" ".join(str(c) for c in res[::-1]))                return    res = "Draw" if has_loop else "Lose"    print(res) do()           
