#define _CRT_SECURE_NO_WARNINGS#include <cstdio>#include <iostream>#include <cstring>#include <string>#include <cmath>#include <algorithm>#include <vector>#include <set>#include <map>#include <queue>#include <cwctype>#include <functional>using namespace std; vector<vector<int>> group;vector<pair<int, int>> ans;int p[100005];bool f[100005];int n; void NO () {	printf("NO\n");	exit(0);} void YES () {	printf("YES\n");	for (int i = 0; i < (int) ans.size(); i++) {		printf("%d %d\n", ans[i].first + 1, ans[i].second + 1);	}	exit(0);} int main() {	//freopen("in.txt", "r", stdin);	//freopen("out.txt", "w", stdout); 	scanf("%d", &n);	for (int i = 0; i < n; i++) {		scanf("%d", &p[i]);		p[i]--;	} 	memset(f, false, sizeof(f));	int groupOne = -1;	int groupTwo = -1;	bool haveOddGroupSize = false;	for (int i = 0; i < n; i++) {		if (f[i])			continue;		int s = i, cur = i;		group.push_back(vector<int>());		while (group.back().empty() || cur != s) {			group.back().push_back(cur);			f[cur] = true;			cur = p[cur];		}		int groupSize = (int) group.back().size();		if (groupSize == 1)			groupOne = (int) group.size() - 1;		if (groupSize == 2)			groupTwo = (int) group.size() - 1;		if (groupSize != 1 && groupSize % 2 == 1)			haveOddGroupSize = true;	} 	if (groupOne == -1 && (groupTwo == -1 || haveOddGroupSize))		NO();		if (groupOne != -1) {		int v = group[groupOne][0];		int groups = (int) group.size();		for (int i = 0; i < groups; i++) {			if (i == groupOne)				continue;			int groupSize = (int) group[i].size();			for (int j = 0; j < groupSize; j++)				ans.push_back(make_pair(v, group[i][j]));		}	} else {		ans.push_back(make_pair(group[groupTwo][0], group[groupTwo][1]));		int groups = (int) group.size();		for (int i = 0; i < groups; i++) {			if (i == groupTwo)				continue;			int groupSize = (int) group[i].size();			for (int j = 0; j < groupSize; j++) {				if (!(j & 1))					ans.push_back(make_pair(group[groupTwo][0], group[i][j]));				else					ans.push_back(make_pair(group[groupTwo][1], group[i][j]));			}		}	}	YES(); 	return 0;}
