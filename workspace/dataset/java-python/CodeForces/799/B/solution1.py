#!/usr/bin/env python# from __future__ import division, print_functionimport osimport sys,mathfrom io import BytesIO, IOBase# from itertools import permutations, combinations# from collections import defaultdict,deque,OrderedDictfrom os import path# import random# import bisect as bidef yes():print('YES')def no():print('NO')def I():return (int(input()))def In():return(map(int,input().split()))from heapq import heappush,heappop#complete the main function with number of test cases to completedef main():    try:        n=I()        p=list(In())        a=list(In())        b=list(In())        p12,p11,p13,p22,p23,p33=[],[],[],[],[],[]        for i in range(n):            a[i],b[i]=min(a[i],b[i]),max(a[i],b[i])            if a[i]==1 and b[i]==1:                heappush(p11,p[i])            elif a[i]==1 and b[i]==2:                heappush(p12,p[i])            elif a[i]==1 and b[i]==3:                heappush(p13,p[i])            elif a[i]==2 and b[i]==2:                heappush(p22,p[i])            elif a[i]==2 and b[i]==3:                heappush(p23,p[i])            else:                heappush(p33,p[i])        nq=I()        c=list(In())        ans=[]        for i in range(nq):            q=c[i]            cost=float('inf')            co=-1            if q==1:                if len(p11) and cost>p11[0]:                    co='p11'                    cost=p11[0]                if len(p12) and cost>p12[0]:                    co='p12'                    cost=p12[0]                if len(p13) and cost>p13[0]:                    co='p13'                    cost=p13[0]                if co=='p11':                    ans.append(heappop(p11))                elif co=='p12':                    ans.append(heappop(p12))                elif co=='p13':                    ans.append(heappop(p13))                else:                    ans.append(-1)            elif q==2:                if len(p22) and cost>p22[0]:                    cost=p22[0]                    co='p22'                if len(p12) and cost>p12[0]:                    co='p12'                    cost=p12[0]                if len(p23) and cost>p23[0]:                    co='p23'                    cost=p23[0]                 if co=='p22':                    ans.append(heappop(p22))                elif co=='p12':                    ans.append(heappop(p12))                elif co=='p23':                    ans.append(heappop(p23))                else:                    ans.append(-1)            elif q==3:                if len(p33) and cost>p33[0]:                    cost=p33[0]                    co='p33'                if len(p13) and cost>p13[0]:                    co='p13'                    cost=p13[0]                if len(p23) and cost>p23[0]:                    co='p23'                    cost=p23[0]                 if co=='p33':                    ans.append(heappop(p33))                elif co=='p13':                    ans.append(heappop(p13))                elif co=='p23':                    ans.append(heappop(p23))                else:                    ans.append(-1)        print(*ans)     except:        pass        M = 998244353P = 1000000007  # region fastio BUFSIZE = 8192  class FastIO(IOBase):    newlines = 0     def __init__(self, file):        self._fd = file.fileno()        self.buffer = BytesIO()        self.writable = "x" in file.mode or "r" not in file.mode        self.write = self.buffer.write if self.writable else None     def read(self):        while True:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            if not b:                break            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines = 0        return self.buffer.read()     def readline(self):        while self.newlines == 0:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            self.newlines = b.count(b"\n") + (not b)            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines -= 1        return self.buffer.readline()     def flush(self):        if self.writable:            os.write(self._fd, self.buffer.getvalue())            self.buffer.truncate(0), self.buffer.seek(0)  class IOWrapper(IOBase):    def __init__(self, file):        self.buffer = FastIO(file)        self.flush = self.buffer.flush        self.writable = self.buffer.writable        self.write = lambda s: self.buffer.write(s.encode("ascii"))        self.read = lambda: self.buffer.read().decode("ascii")        self.readline = lambda: self.buffer.readline().decode("ascii")  def print(*args, **kwargs):    """Prints the values to a stream, or to sys.stdout by default."""    sep, file = kwargs.pop("sep", " "), kwargs.pop("file", sys.stdout)    at_start = True    for x in args:        if not at_start:            file.write(sep)        file.write(str(x))        at_start = False    file.write(kwargs.pop("end", "\n"))    if kwargs.pop("flush", False):        file.flush()  if sys.version_info[0] < 3:    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)else:    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout) input = lambda: sys.stdin.readline().rstrip("\r\n") # endregion if __name__ == '__main__':    #for _ in range(I()):main()    for _ in range(1):main()     			    		  	  		 	      			
