from os import pathimport sys# mod = int(1e9 + 7)# import refrom math import ceil, floor,gcd,log,log2 ,factorialfrom collections import defaultdict , Counterfrom itertools import permutations# from bisect import bisect_left, bisect_right#popping from the end is less taxing,since you don't have to shift any elementsmaxx = float('inf')I = lambda :int(sys.stdin.buffer.readline())tup= lambda : map(int , sys.stdin.buffer.readline().split())lint = lambda :[int(x) for x in sys.stdin.buffer.readline().split()]S = lambda: sys.stdin.readline().replace('\n', '').strip()def grid(r, c): return [lint() for i in range(r)]# def debug(*args, c=6): print('\033[3{}m'.format(c), *args, '\033[0m', file=sys.stderr)stpr = lambda x : sys.stdout.write(f'{x}' + '\n')star = lambda x: print(' '.join(map(str, x)))if (path.exists('input.txt')):	sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w'); #left shift --- num*(2**k) --(k - shift)# input = sys.stdin.readlinefor _ in range(I()):	n ,r = tup()	ls = lint()	ls = sorted(set(ls))	ans = 0	c=0	f =0	for i in range(len(ls)-1,-1,-1):		if ls[i] - c*r <=0:			ls[i]=-1			continue		if f==0:			if ls[i] - c*r > r:				ls[i]=-1				ans+=1				c+=1				f=1		else:			ans+=1			c+=1			ls[i]=-1    	if ans ==0:		print(1)	else:		ans +=len([i for i in ls if i >0])		print(ans)	
