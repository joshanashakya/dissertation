import java.util.Arrays;import java.util.Scanner; public class Solution {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        String input = sc.nextLine();        sc.close();//        String input = "999999999999999999999999999999";        System.out.println(solution(input));    }     private static long solution(String input) {        long max = -1;        for (int i = 1; i < input.length(); i++) {            for (int j = i + 1; j < input.length(); j++) {                long first = valueOf(input.substring(0, i));                long second = valueOf(input.substring(i, j));                long third = valueOf(input.substring(j));                long sum = first + second + third;                if(sum > max && sum <= 3_000_000) {//                    System.out.println(first + ", " + second + ", " + third + " => " + sum);                    max = sum;                }            }        }        return max < 0 ? -1 : max;    }     private static long valueOf(String input) {        try {            if(input == null || input.length() < 1) {                return 0;            } else if (input.startsWith("0") && input.length() > 1) {                return Integer.MIN_VALUE;            } else if(Long.valueOf(input) > 1_000_000) {                return Integer.MIN_VALUE;            }            return Long.valueOf(input);        } catch (NumberFormatException aE) {            return Integer.MIN_VALUE;        }    }    private static String optimalDivision(int[] nums) {        Expression myExpression = optimal(nums, 0, nums.length - 1);        return myExpression.max_str;    }     private static Expression optimal(int[] nums, int start, int end) {        Expression myExpression = new Expression();        if (start == end) {            myExpression.max_val = nums[start];            myExpression.min_val = nums[start];            myExpression.min_str = "" + nums[start];            myExpression.max_str = "" + nums[start];            return myExpression;        }        myExpression.min_val = Float.MAX_VALUE;        myExpression.max_val = Float.MIN_VALUE;        myExpression.min_str = myExpression.max_str = "";        for (int i = start; i < end; i++) {            Expression myLeft = optimal(nums, start, i);            Expression myRight = optimal(nums, i + 1, end);            if (myExpression.min_val > myLeft.min_val / myRight.max_val) {                myExpression.min_val = myLeft.min_val / myRight.max_val;                myExpression.min_str = myLeft.min_str + "/" + (i + 1 != end ? "(" : "") + myRight.max_str + (i + 1 != end ? ")" : "");            }            if (myExpression.max_val < myLeft.max_val / myRight.min_val) {                myExpression.max_val = myLeft.max_val / myRight.min_val;                myExpression.max_str = myLeft.max_str + "/" + (i + 1 != end ? "(" : "") + myRight.min_str + (i + 1 != end ? ")" : "");            }        }        return myExpression;    }     static class Expression {        float max_val, min_val;        String min_str, max_str;    }} class MaxHeap {    private int[] data;    private int endIndex;     MaxHeap(Integer[] aData) {        endIndex = aData.length;        data = new int[endIndex + 1];        for (int i = 0; i < aData.length; i++) {            data[i + 1] = aData[i];        }        buildHeap();    }     private void buildHeap() {        for (int i = 1; i < data.length; i++) {            sink(i);        }    }     int extractMax() {        int maxElement = data[1];        exchange(1, endIndex);        --endIndex;        sink(1);        return maxElement;    }     private void exchange(int i, int j) {        int temp = data[i];        data[i] = data[j];        data[j] = temp;    }     private void sink(int k) {        while (2 * k <= endIndex) {            int j = 2 * k;            if (j < endIndex && less(j + 1, j)) {                ++j;            }            if (!less(k, j)) {                break;            }            exchange(k, j);            k = j;        }    }     private void swim(int k) {        while (k > 1 && less(k / 2, k)) {            exchange(k / 2, k);            k = k / 2;        }    }     private boolean less(int i, int j) {        return data[i] > data[j];    }     @Override    public String toString() {        return Arrays.toString(data);    }}
