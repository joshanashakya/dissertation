import java.io.OutputStream;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.io.OutputStream;import java.util.Collection;import java.util.Random;import java.io.IOException;import java.io.InputStreamReader;import java.io.BufferedOutputStream;import java.util.StringTokenizer;import java.io.Writer;import java.io.BufferedReader;import java.util.NoSuchElementException;import java.io.InputStream; /** * Built using CHelper plug-in * Actual solution is at the top * * @author An Almost Retired Guy */public class Main {    public static void main(String[] args) {        InputStream inputStream = System.in;        OutputStream outputStream = System.out;        InputReader in = new InputReader(inputStream);        OutputWriter out = new OutputWriter(outputStream);        TaskA solver = new TaskA();        solver.solve(1, in, out);        out.close();    }     static class TaskA {        public void solve(int testNumber, InputReader in, OutputWriter out) {            int n = in.nextInt();            char[][] tab = new char[4][n];            for (int i = 0; i < n; i += 2) {                EzCharHashSet used = new EzCharHashSet();                if (i > 0) {                    used.add(tab[0][i - 1]);                    used.add(tab[1][i - 1]);                }                char next = 'a';                while (used.contains(next)) next++;                if (i == n - 1) tab[0][i] = tab[1][i] = next;                else {                    tab[0][i] = tab[0][i + 1] = next;                    used.add(next);                    while (used.contains(next)) next++;                    tab[1][i] = tab[1][i + 1] = next;                }            }            tab[2][0] = tab[3][0] = tab[1][0] == 'a' ? 'b' : 'a';            for (int i = 1; i < n; i += 2) {                EzCharHashSet used = new EzCharHashSet();                used.add(tab[2][i - 1]);                used.add(tab[3][i - 1]);                used.add(tab[1][i]);                char next = 'a';                while (used.contains(next)) next++;                if (i == n - 1) tab[2][i] = tab[3][i] = next;                else {                    used.add(tab[1][i + 1]);                    while (used.contains(next)) next++;                    tab[2][i] = tab[2][i + 1] = next;                    used.add(next);                    while (used.contains(next)) next++;                    tab[3][i] = tab[3][i + 1] = next;                }            }            for (char[] arr : tab) out.println(arr);        }     }     static final class EzCharSort {        private static final double HEAPSORT_DEPTH_COEFFICIENT = 2.0;        private static final Random rnd = new Random();         private EzCharSort() {        }         private static int maxQuickSortDepth(int length) {            if (length <= 1) {                return 0;            }            int log = Integer.numberOfTrailingZeros(Integer.highestOneBit(length - 1)) + 1;            return (int) (HEAPSORT_DEPTH_COEFFICIENT * log);        }         public static void sort(char[] a) {            quickSort(a, 0, a.length, 0, maxQuickSortDepth(a.length));        }         private static void quickSort(char[] a, int left, int right, int depth, int maxDepth) {            if (right - left <= 1) {                return;            }            if (depth > maxDepth) {                heapSort(a, left, right - left);                return;            }            final char pivot = a[left + rnd.nextInt(right - left)];            int i = left;            int j = right - 1;            do {                while (a[i] < pivot) i++;                while (pivot < a[j]) j--;                if (i <= j) {                    char tmp = a[i];                    a[i++] = a[j];                    a[j--] = tmp;                }            } while (i <= j);            quickSort(a, left, j + 1, depth + 1, maxDepth);            quickSort(a, i, right, depth + 1, maxDepth);        }         private static void heapSort(char[] a, int offset, int size) {            // If size <= 1, nothing is executed            for (int i = (size >>> 1) - 1; i >= 0; i--) {                down(a, i, offset, size);            }            for (int i = size - 1; i > 0; i--) {                char tmp = a[offset];                a[offset] = a[offset + i];                a[offset + i] = tmp;                down(a, 0, offset, i);            }        }         private static void down(char[] a, int index, int offset, int size) {            final char element = a[offset + index];            final int firstLeaf = (size >>> 1);            while (index < firstLeaf) {                int largestChild = (index << 1) + 1;                if (largestChild + 1 < size && a[offset + largestChild + 1] > a[offset + largestChild]) {                    largestChild++;                }                if (a[offset + largestChild] <= element) {                    break;                }                a[offset + index] = a[offset + largestChild];                index = largestChild;            }            a[offset + index] = element;        }     }     static class EzCharHashSet implements EzCharSet {        private static final int DEFAULT_CAPACITY = 8;        private static final int HASHCODE_INITIAL_VALUE = 0x811c9dc5;        private static final int HASHCODE_MULTIPLIER = 0x01000193;        private static final byte FREE = 0;        private static final byte FILLED = 2;        private static final Random rnd = new Random();        private static final int POS_RANDOM_SHIFT_1;        private static final int POS_RANDOM_SHIFT_2;        private static final int STEP_RANDOM_SHIFT_1;        private static final int STEP_RANDOM_SHIFT_2;        private char[] table;        private byte[] status;        private int size;        private int removedCount;        private int mask;        private final int hashSeed;         static {            POS_RANDOM_SHIFT_1 = rnd.nextInt(10) + 11;            POS_RANDOM_SHIFT_2 = rnd.nextInt(10) + 21;            STEP_RANDOM_SHIFT_1 = rnd.nextInt(10) + 11;            STEP_RANDOM_SHIFT_2 = rnd.nextInt(10) + 21;        }         public EzCharHashSet() {            this(DEFAULT_CAPACITY);        }         public EzCharHashSet(int capacity) {            if (capacity < 0) {                throw new IllegalArgumentException("Capacity must be non-negative");            }            // Actually we need 4x more memory            int length = 4 * Math.max(1, capacity);            if ((length & (length - 1)) != 0) {                length = Integer.highestOneBit(length) << 1;            }            // Length is a power of 2 now            initEmptyTable(length);            hashSeed = rnd.nextInt();        }         public EzCharHashSet(EzCharCollection collection) {            this(collection.size());            for (EzCharIterator iterator = collection.iterator(); iterator.hasNext(); ) {                add(iterator.next());            }        }         public EzCharHashSet(char[] srcArray) {            this(srcArray.length);            for (char element : srcArray) {                add(element);            }        }         public EzCharHashSet(Collection<Character> javaCollection) {            this(javaCollection.size());            for (char element : javaCollection) {                add(element);            }        }         private int getStartPos(int h) {            h ^= hashSeed;            h ^= (h >>> POS_RANDOM_SHIFT_1) ^ (h >>> POS_RANDOM_SHIFT_2);            return h & mask;        }         private int getStep(int h) {            h ^= hashSeed;            h ^= (h >>> STEP_RANDOM_SHIFT_1) ^ (h >>> STEP_RANDOM_SHIFT_2);            return ((h << 1) | 1) & mask;        }          public int size() {            return size;        }          public boolean contains(char element) {            final int elementHash = PrimitiveHashCalculator.getHash(element);            int pos = getStartPos(elementHash);            final int step = getStep(elementHash);            for (; status[pos] != FREE; pos = (pos + step) & mask) {                if (status[pos] == FILLED && table[pos] == element) {                    return true;                }            }            return false;        }          public EzCharIterator iterator() {            return new EzCharHashSetIterator();        }          public char[] toArray() {            char[] result = new char[size];            for (int i = 0, j = 0; i < table.length; i++) {                if (status[i] == FILLED) {                    result[j++] = table[i];                }            }            return result;        }          public boolean add(char element) {            final int elementHash = PrimitiveHashCalculator.getHash(element);            int pos = getStartPos(elementHash);            final int step = getStep(elementHash);            for (; status[pos] == FILLED; pos = (pos + step) & mask) {                if (table[pos] == element) {                    return false;                }            }            if (status[pos] == FREE) {                status[pos] = FILLED;                table[pos] = element;                size++;                if ((size + removedCount) * 2 > table.length) {                    rebuild(table.length * 2); // enlarge the table                }                return true;            }            final int removedPos = pos;            for (pos = (pos + step) & mask; status[pos] != FREE; pos = (pos + step) & mask) {                if (status[pos] == FILLED && table[pos] == element) {                    return false;                }            }            status[removedPos] = FILLED;            table[removedPos] = element;            size++;            removedCount--;            return true;        }         private void rebuild(int newLength) {            char[] oldTable = table;            byte[] oldStatus = status;            initEmptyTable(newLength);            for (int i = 0; i < oldTable.length; i++) {                if (oldStatus[i] == FILLED) {                    add(oldTable[i]);                }            }        }         private void initEmptyTable(int length) {            table = new char[length];            status = new byte[length];            size = 0;            removedCount = 0;            mask = length - 1;        }          public boolean equals(Object o) {            if (this == o) return true;            if (o == null || getClass() != o.getClass()) return false;            EzCharHashSet that = (EzCharHashSet) o;             if (size != that.size) {                return false;            }            for (int i = 0; i < table.length; i++) {                if (status[i] == FILLED) {                    if (!that.contains(table[i])) {                        return false;                    }                }            }            return true;        }          public int hashCode() {            char[] array = toArray();            EzCharSort.sort(array);            int hash = HASHCODE_INITIAL_VALUE;            for (int i = 0; i < size; i++) {                hash = (hash ^ PrimitiveHashCalculator.getHash(array[i])) * HASHCODE_MULTIPLIER;            }            return hash;        }          public String toString() {            StringBuilder sb = new StringBuilder();            sb.append('[');            for (int i = 0; i < table.length; i++) {                if (status[i] == FILLED) {                    if (sb.length() > 1) {                        sb.append(", ");                    }                    sb.append(table[i]);                }            }            sb.append(']');            return sb.toString();        }         private class EzCharHashSetIterator implements EzCharIterator {            private int curIndex = 0;              public boolean hasNext() {                while (curIndex < table.length && status[curIndex] != FILLED) {                    curIndex++;                }                return curIndex < table.length;            }              public char next() {                while (curIndex < table.length && status[curIndex] != FILLED) {                    curIndex++;                }                if (curIndex == table.length) {                    throw new NoSuchElementException("Iterator doesn't have more elements");                }                return table[curIndex++];            }         }     }     static interface EzCharIterator {        boolean hasNext();         char next();     }     static interface EzCharCollection {        int size();         EzCharIterator iterator();         boolean equals(Object object);         int hashCode();         String toString();     }     static final class PrimitiveHashCalculator {        private PrimitiveHashCalculator() {        }         public static int getHash(char x) {            return x;        }     }     static interface EzCharSet extends EzCharCollection {        int size();         EzCharIterator iterator();         boolean equals(Object object);         int hashCode();         String toString();     }     static class OutputWriter extends PrintWriter {        public OutputWriter(OutputStream outputStream) {            super(new BufferedOutputStream(outputStream));        }         public OutputWriter(Writer writer) {            super(writer);        }         public void close() {            super.close();        }     }     static class InputReader {        BufferedReader br;        StringTokenizer st;         public InputReader(InputStream inputStream) {            br = new BufferedReader(new InputStreamReader(inputStream));        }         public String next() {            while (st == null || !st.hasMoreElements()) {                st = new StringTokenizer(nextLine());            }            return st.nextToken();        }         public int nextInt() {            return Integer.parseInt(next());        }         public String nextLine() {            try {                return br.readLine();            } catch (IOException e) {                throw new RuntimeException(e);            }        }     }} 
