import java.io.*;import java.util.*; public class Main {    static BufferedReader br;    static StringTokenizer st;     static String nextToken() {        try {            while (st == null || !st.hasMoreTokens()) {                st = new StringTokenizer(br.readLine());            }        } catch (IOException e) {            e.printStackTrace();        }        return st.nextToken();    }     static int nextInt() {        return Integer.parseInt(nextToken());    }     static char nextChar() throws IOException {        return (char) br.read();    }     private static long nextLong() {        return Long.parseLong(nextToken());    }     private static String nextString() throws IOException {        return br.readLine();    }     public static void main(String[] args) throws IOException {        br = new BufferedReader(new InputStreamReader(System.in));//new FileInputStream("input.txt")));        int n = nextInt();        Pair[] a = new Pair[n];        for (int i = 0; i < n; i++) {            a[i] = new Pair(nextInt(), i + 1);        }        Arrays.sort(a);        int min = a[0].x1;        int sum = 0;        for (int i = 1; i < n - 1; i++) {            sum += a[i].x1 - min;        }        int p = 0;        while (sum + p * (n - 1) < a[n - 1].x1 - min && min != 0) {            min--;            p++;        }        for (int i = 0; i < n; i++) {            a[i].x1 -= min;        }        ArrayList<int[]> ans = new ArrayList<>();        while (a[n - 1].x1 != 0) {            if (a[n - 2].x1 == 0) {                a[n - 2].x1 = a[n - 1].x1;            }            int raz = n - 2;            sum = 0;            int nol = 0;            for (int i = 0; i < n; i++) {                if (a[i].x1 == 0) {                    nol = i;                } else break;            }            for (int i = 0; i < n - 2; i++) {                sum += a[i].x1;                if (sum >= a[n - 1].x1 - a[n - 2].x1) {                    raz = i + 1;                    break;                }            }             raz = Math.max(n - 5, raz);            raz = Math.max(0, raz);            while (a[raz].x1 == 0) {                raz++;            }            raz = Math.min(n - 2, raz);            if (raz - nol == 2 && raz != n - 2) {                raz++;            }            for (int i = 0; i < a[raz].x1; i++) {                ans.add(new int[n]);                for (int j = raz; j < n; j++) {                    ans.get(ans.size() - 1)[a[j].x2 - 1] = 1;                }            }            for (int i = n - 1; i >= raz; i--) {                a[i].x1 = Math.max(0, a[i].x1 - a[raz].x1);            }            Arrays.sort(a);        }        System.out.println(min);        System.out.println(ans.size());        for (int[] c :                ans) {            for (int i = 0; i < n; i++) {                System.out.print(c[i]);            }            System.out.println();        }      }         /*Pair[] tochki = new Pair[n * 2];        int min = 1000000;        for (int i = 0; i < n; i++) {            a[i] = new Pair(nextInt(), nextInt());            if (a[i].x2 - a[i].x1 < min) min = a[i].x2 - a[i].x1;        }        for (int i = 0; i < 2 * n; i += 2) {            tochki[i] = new Pair(a[i / 2].x1, 1);            tochki[i + 1] = new Pair(a[i / 2].x2, -1);        }        Arrays.sort(a);        for (int i = 1; i < min; i++) {            if (!prow(a, i, tochki)) {                System.out.println(i - 1);                System.exit(0);            }        }                 PrintWriter pw = new PrintWriter("output.txt");        int n = nextInt();        int m = nextInt();        int q = nextInt();        TreeMap<Integer, Integer> dobr = new TreeMap();        TreeMap<Integer, Integer> zlie = new TreeMap();        Pair[] save = new Pair[m];        for (int i = 0; i < m; i++) {            save[i] = new Pair(nextInt() - 1, nextInt() - 1);        }        int start = 0;        Pair[] prefsum = new Pair[m];        int c;        for (int i = 0; i < m; i++) {            boolean tr = false;            while ((zlie.containsKey(save[i].x2) && zlie.containsKey(save[i].x1))                    || (dobr.containsKey(save[i].x2) && dobr.containsKey(save[i].x1))) {                if (zlie.get(save[start].x1) > 1) {                    zlie.put(save[start].x1, zlie.get(save[start].x1) - 1);                } else {                    zlie.remove(save[start].x1);                }                if (dobr.get(save[start].x2) > 1) {                    dobr.put(save[start].x2, dobr.get(save[start].x2) - 1);                } else {                    dobr.remove(save[start].x2);                }                start++;                tr = true;            }            if (!tr && (zlie.containsKey(save[i].x2) || dobr.containsKey(save[i].x1))) {                c = save[i].x2;                save[i].x2 = save[i].x1;                save[i].x1 = c;            }            if (dobr.containsKey(save[i].x2)) {                dobr.put(save[i].x2, dobr.get(save[i].x2) + 1);            } else                dobr.put(save[i].x2, 1);            if (zlie.containsKey(save[i].x1)) {                zlie.put(save[i].x1, zlie.get(save[i].x1) + 1);            } else                zlie.put(save[i].x1, 1);            prefsum[i] = new Pair(start, i);        }        Pair[] zap = new Pair[q];        for (int i = 0; i < q; i++) {            zap[i] = new Pair(nextInt() - 1, nextInt() - 1);        }        for (int i = 0; i < q; i++) {            if (prefsum[zap[i].x2].x1 <= zap[i].x1) {                System.out.println("Possible");            } else {                System.out.println("Impossible");            }        }         int x1, x2;        for (int i = 0; i < q; i++) {            x1 = nextInt() - 1;            x2 = nextInt() - 1;            if (prefsum[x2].x1 <= x1) {                System.out.println("Possible");            } else {                System.out.println("Impossible");            }        }     }     private static boolean prow(Pair[] a, int min, Pair[] tochki) {        int vosh = 0;        int dolgi[] = new int[a.length];        for (int i = 1; i < tochki.length; i++) {            vosh += (tochki[i].x1 - tochki[i - 1].x1);            if (tochki[i].x2 ==)        }        return true;    }*/}  class Pair implements Comparable<Pair> {    int x1, x2;     public Pair(int x1, int x2) {        this.x1 = x1;        this.x2 = x2;    }     @Override    public int compareTo(Pair o) {        if (o.x1 != x1) return Integer.compare(x1, o.x1);        return Integer.compare(o.x2, x2);    }}
