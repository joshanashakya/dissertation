from __future__ import division, print_functionfrom io import BytesIO, IOBaseimport os,sys,math,heapq,copyfrom collections import defaultdict,dequefrom bisect import bisect_left,bisect_rightfrom functools import cmp_to_keyfrom itertools import permutations,combinations,combinations_with_replacement# <fastio>if sys.version_info[0] < 3:	from __builtin__ import xrange as range	from future_builtins import ascii, filter, hex, map, oct, zipBUFSIZE = 8192class FastIO(IOBase):    newlines = 0    def __init__(self, file):        self._fd = file.fileno()        self.buffer = BytesIO()        self.writable = "x" in file.mode or "r" not in file.mode        self.write = self.buffer.write if self.writable else None    def read(self):        while True:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            if not b:                break            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines = 0        return self.buffer.read()    def readline(self):        while self.newlines == 0:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            self.newlines = b.count(b"\n") + (not b)            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines -= 1        return self.buffer.readline()    def flush(self):        if self.writable:            os.write(self._fd, self.buffer.getvalue())            self.buffer.truncate(0), self.buffer.seek(0)class IOWrapper(IOBase):    def __init__(self, file):        self.buffer = FastIO(file)        self.flush = self.buffer.flush        self.writable = self.buffer.writable        self.write = lambda s: self.buffer.write(s.encode("ascii"))        self.read = lambda: self.buffer.read().decode("ascii")        self.readline = lambda: self.buffer.readline().decode("ascii")def print(*args, **kwargs):    """Prints the values to a stream, or to sys.stdout by default."""    sep, file = kwargs.pop("sep", " "), kwargs.pop("file", sys.stdout)    at_start = True    for x in args:        if not at_start:            file.write(sep)        file.write(str(x))        at_start = False    file.write(kwargs.pop("end", "\n"))    if kwargs.pop("flush", False):        file.flush()if sys.version_info[0] < 3:    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)else:    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)input = lambda: sys.stdin.readline().rstrip("\r\n")# </fastio># sys.setrecursionlimit(10**6)# sys.stdin=open('Input.txt','r')# sys.stdout=open('Output.txt','w')mod=1000000007# Reading Single Inputdef get_int(): return int(sys.stdin.readline().strip())def get_str(): return sys.stdin.readline().strip()def get_float(): return float(sys.stdin.readline().strip())# Reading Multiple Inputsdef get_ints(): return map(int, sys.stdin.readline().strip().split())def get_strs(): return map(str, sys.stdin.readline().strip().split())def get_floats(): return map(float, sys.stdin.readline().strip().split())# Reading List Of Inputsdef list_ints(): return list(map(int, sys.stdin.readline().strip().split()))def list_strs(): return list(map(str, sys.stdin.readline().strip().split()))def list_floats(): return list(map(float, sys.stdin.readline().strip().split()))# ------------------------------------------------------------------------------------- #Â n,m=get_ints()blacks=0sr=sc=math.infer=ec=-math.inffor i in range(n):	s=get_str()	for j in range(m):		if(s[j]=='B'):			sr=min(sr,i)			sc=min(sc,j)			er=max(sr,i)			ec=max(ec,j)			blacks+=1if(sr==math.inf):   sr=sc=er=ec=0length=max(er-sr,ec-sc)+1if(length>n or length>m):	print(-1)else:	print(pow(length,2)-blacks)
