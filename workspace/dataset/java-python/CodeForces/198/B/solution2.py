def bfs(n):    visited=[False]*(2*n)    queue=[]    queue2=[]    queue.append(0)    queue2.append(0)    visited[0]=True    flag=True    water=0    while queue and flag:        s=queue.pop(0)        water= queue2.pop(0)        for i in graph[s]:            if not visited[i]:                a=0                #print(water,i)                if i>=n:                    a=i-n                else:                    a=i                if a>water:                    if i==n-1 or i==2*n-1:                        flag=False                    else:                        queue.append(i)                        queue2.append(water+1)                        visited[i]=True    return not flag   n,k=map(int,input().split())l=input()r=input()graph=[]for i in range(n):    graph.append([])    if l[i]=='-':        if i+1<n:            if l[i+1]=='-':                graph[i].append(i+1)        if i-1>=0:            if l[i-1]=='-':                graph[i].append(i-1)        if i+k<n:            if r[i+k]=='-':                graph[i].append(n+i+k)        else:            graph[i].append(2*n-1)for i in range(n):    graph.append([])    if r[i]=='-':        if i+1<n:            if r[i+1]=='-':                graph[n+i].append(n+i+1)        if i-1>=0:            if r[i-1]=='-':                graph[n+i].append(n+i-1)        if i+k<n:            if l[i+k]=='-':                graph[n+i].append(i+k)        else:            graph[n+i].append(n-1)#print(graph)  if n==1:    print("YES")elif bfs(n):    print("YES")else:    print("NO")        
