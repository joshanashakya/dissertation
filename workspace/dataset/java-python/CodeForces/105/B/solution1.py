import itertools as it def powerset(iterable):    "powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"    s = list(iterable)    return it.chain.from_iterable(it.combinations(s, r) \                                  for r in range(len(s)+1))  n, k, A = map(int, input().split()) best_result = 0 missing = 0 senators = []for _ in range(n):    level, loyality = map(int, input().split())    senators += [[level, loyality]]    missing += 10 - loyality // 10 k = min([k, missing]) # no need for too many candies for comb in it.combinations_with_replacement(range(n), k):    candies = [0] * n    for senator, amount in [(x, len(list(y))) for x, y in it.groupby(comb)]:        candies[senator] = amount    overflow = False    for senator in range(n):        if candies[senator] * 10 + senators[senator][1] > 100:            overflow = True    if overflow:        continue    senators_tmp = [x[:] for x in senators]    for senator in range(n):        senators_tmp[senator][1] += candies[senator] * 10    cresult = 0    needed_to_win = n // 2 + 1    for sub_set in powerset(range(n)):        prob = 1        bad_ones_str = 0        taken = [False] * n        for i in sub_set:            taken[i] = True        for i in range(n):            if taken[i]:                prob *= senators_tmp[i][1] / 100            else:                prob *= (100 - senators_tmp[i][1]) / 100                bad_ones_str += senators_tmp[i][0]          if len(sub_set) >= needed_to_win:            cresult += prob        else:            cresult += prob * A / (A + bad_ones_str)     if cresult > best_result:        best_result = cresult print(best_result)
