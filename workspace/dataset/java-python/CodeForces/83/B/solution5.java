/*   合    */import java.io.*;import java.util.*;import java.math.*; public final class doctor{    static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));	static FastScanner sc=new FastScanner(br);    static PrintWriter out=new PrintWriter(System.out);	static Random rnd=new Random();	static int n,m;	static long k;	static Pair[] a;	static Node[] val;	static TreeSet<Long> ts=new TreeSet<>();	static Map<Long,Integer> m1=new HashMap<>();		static int getLast(long mid1)	{		int low=0,high=m;				while(low<high)		{			int mid=(low+high+1)>>1;						if(val[mid].a<=mid1)			{				low=mid;			}			else			{				high=mid-1;			}		}			return low;	}		static boolean check(long mid)	{		int low=getLast(mid);				long now=(mid-val[low].a)*val[low].b;now=now+val[low].c;				return now<=k;	}	    public static void main(String args[]) throws Exception    {		n=sc.nextInt();k=sc.nextLong();a=new Pair[n];				for(int i=0;i<n;i++)		{			a[i]=new Pair(i,sc.nextInt());ts.add(a[i].val);						m1.put(a[i].val,m1.getOrDefault(a[i].val,0)+1);		}				m=ts.size();val=new Node[m+1];val[0]=new Node(1,n,n);long last=0,tot=0;				// number of passes, streak, total...				for(int i=1;i<=m;i++)		{			long curr=ts.higher(last);val[i]=new Node(-1,-1,-1);						val[i].a=curr+1;						long now=(curr-val[i-1].a);						val[i].c=val[i-1].c+(now*val[i-1].b);						tot+=m1.get(curr);						val[i].c+=n-tot;						val[i].b=n-tot;						last=curr;		}				long low=0,high=(long)(1e9);				while(low<high)		{			long mid=(low+high+1)>>1;						if(check(mid))			{				low=mid;			}			else			{				high=mid-1;			}		}				ArrayDeque<Pair> ad=new ArrayDeque<Pair>();				for(int i=0;i<n;i++)		{			if(a[i].val>low)			{				ad.add(new Pair(i,a[i].val-low));			}		}				int now=getLast(low);long done=(low-val[now].a)*val[now].b;done=done+val[now].c;				long diff=k-done;boolean ans=true;				//if(diff>n) throw new Exception("Wrong");				while(diff>0)		{			if(ad.size()>0)			{				Pair curr=ad.removeFirst();								curr.val--;								if(curr.val>0)				{					ad.add(curr);				}								diff--;			}			else			{				ans=false;break;			}		}				if(ans)		{			for(Pair x:ad)			{				out.print((x.idx+1)+" ");			}						out.println("");		}		else		{			out.println(-1);		}				out.close();    }} class Pair implements Comparable<Pair>{	int idx;long val;		public Pair(int idx,long val)	{		this.idx=idx;this.val=val;	}		public int compareTo(Pair x)	{		return Long.compare(this.val,x.val);	}}class Node{	long a,b,c;		public Node(long a,long b,long c)	{		this.a=a;this.b=b;this.c=c;	}}class FastScanner{    BufferedReader in;    StringTokenizer st;     public FastScanner(BufferedReader in) {        this.in = in;    }	    public String nextToken() throws Exception {        while (st == null || !st.hasMoreTokens()) {            st = new StringTokenizer(in.readLine());        }        return st.nextToken();    }		public String next() throws Exception {		return nextToken().toString();	}	    public int nextInt() throws Exception {        return Integer.parseInt(nextToken());    }     public long nextLong() throws Exception {        return Long.parseLong(nextToken());    }     public double nextDouble() throws Exception {        return Double.parseDouble(nextToken());    }}
