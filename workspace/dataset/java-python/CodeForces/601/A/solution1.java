import java.io.OutputStream;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.util.Arrays;import java.util.Collection;import java.util.InputMismatchException;import java.io.IOException;import java.util.ArrayList;import java.util.HashSet;import java.util.Objects;import java.util.Queue;import java.util.LinkedList;import java.io.InputStream; /** * Built using CHelper plug-in * Actual solution is at the top * * @author Pranay2516 */public class Main {    public static void main(String[] args) {        InputStream inputStream = System.in;        OutputStream outputStream = System.out;        FastReader in = new FastReader(inputStream);        PrintWriter out = new PrintWriter(outputStream);        ATheTwoRoutes solver = new ATheTwoRoutes();        solver.solve(1, in, out);        out.close();    }     static class ATheTwoRoutes {        public void solve(int testNumber, FastReader in, PrintWriter out) {            int n = in.nextInt(), m = in.nextInt();            ArrayList<Integer>[] a = new ArrayList[n];            for (int i = 0; i < n; ++i) {                a[i] = new ArrayList<>();            }            boolean railFirst = false;            HashSet<Pair<Integer, Integer>> h = new HashSet<>();            for (int i = 0; i < m; ++i) {                int u = in.nextInt() - 1, v = in.nextInt() - 1;                if (Math.abs(v - u) == n - 1) {                    railFirst = true;                }                Pair<Integer, Integer> pair = new Pair<>(Math.min(u, v), Math.max(v, u));                h.add(pair);                a[u].add(v);                a[v].add(u);            }            if (railFirst) {                for (int i = 0; i < n; ++i) {                    a[i].clear();                }                for (int i = 0; i < n; ++i) {                    for (int j = i + 1; j < n; ++j) {                        Pair<Integer, Integer> p = new Pair<>(i, j);                        if (h.contains(p)) continue;                        a[i].add(j);                        a[j].add(i);                    }                }            }            Queue<Integer> q = new LinkedList<>();            int[] d = new int[n];            Arrays.fill(d, -1);            q.add(0);            d[0] = 0;            while (!q.isEmpty()) {                int u = q.poll();                for (Integer v : a[u]) {                    if (d[v] == -1) {                        d[v] = d[u] + 1;                        q.add(v);                    }                }            }            out.println(d[n - 1]);        }     }     static class FastReader {        private InputStream stream;        private byte[] buf = new byte[1024];        private int curChar;        private int numChars;        private FastReader.SpaceCharFilter filter;         public FastReader(InputStream stream) {            this.stream = stream;        }         public int read() {            if (numChars == -1) throw new InputMismatchException();            if (curChar >= numChars) {                curChar = 0;                try {                    numChars = stream.read(buf);                } catch (IOException e) {                    throw new InputMismatchException();                }                if (numChars <= 0) return -1;            }            return buf[curChar++];        }         public int nextInt() {            int c = read();            while (isSpaceChar(c)) c = read();            int sgn = 1;            if (c == '-') {                sgn = -1;                c = read();            }            int res = 0;            do {                if (c < '0' || c > '9') throw new InputMismatchException();                res *= 10;                res += c - '0';                c = read();            }            while (!isSpaceChar(c));            return res * sgn;        }         public boolean isSpaceChar(int c) {            if (filter != null) return filter.isSpaceChar(c);            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;        }         public interface SpaceCharFilter {            public boolean isSpaceChar(int ch);         }     }     static class Pair<U, V> implements Comparable<Pair<U, V>> {        public U x;        public V y;         public Pair(U x, V y) {            this.x = x;            this.y = y;        }         public int compareTo(Pair<U, V> o) {            int value = ((Comparable<U>) x).compareTo(o.x);            if (value != 0) return value;            return ((Comparable<V>) y).compareTo(o.y);        }         public boolean equals(Object o) {            if (this == o) return true;            if (o == null || getClass() != o.getClass()) return false;            Pair<?, ?> pair = (Pair<?, ?>) o;            return x.equals(pair.x) && y.equals(pair.y);        }         public int hashCode() {            return Objects.hash(x, y);        }     }} 
