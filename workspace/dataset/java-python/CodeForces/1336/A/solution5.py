 ######      ###      #######    #######    ##      #     #####        ###     #####  #     #    #   #          #        #       # #     #    #     #      #   #     ###   #     #   #     #        #         #       #  #    #   #       #    #     #    ###   ######   #########      #          #       #   #   #   #           #########    #    ######   #########     #           #       #    #  #   #           #########    #    #     #  #       #    #            #       #     # #   #    ####   #       #    #    #     #  #       #   #             #       #      ##   #    #  #   #       #         ######   #       #  #######     #######    #       #    #####  #   #       #    #    from __future__ import print_function # for PyPy2from collections import Counter, OrderedDictfrom itertools import permutations as permfrom fractions import Fractionfrom collections import dequefrom sys import stdinfrom bisect import *from heapq import *from math import * g   = lambda : stdin.readline().strip()gl  = lambda : g().split()gil = lambda : [int(var) for var in gl()]gfl = lambda : [float(var) for var in gl()]gcl = lambda : list(g())gbs = lambda : [int(var) for var in g()]mod = int(1e9)+7inf = float("inf")     n, k = gil()adj = [[] for _ in range(n+1)] for _ in range(n-1):	x, y = gil()	adj[x].append(y)	adj[y].append(x) sub, dp = [0]*(n+1), [-1]*(n+1)stack = [1]dp[1] = 0 while stack:	p = stack.pop()	for c in adj[p]:		if dp[c] == -1:			dp[c] = dp[p]+1			stack.append(c) stack.append(1)vis = [0]*(n+1)fin = [0]*(n+1)ans = []while stack:	p = stack[-1]	if vis[p]:		for c in adj[p]:			if fin[c]:				sub[p] += 1+sub[c]		fin[p] = 1		ans.append(dp[p]-sub[p])		stack.pop()	else:		vis[p] = 1		for c in adj[p]:			if not vis[c]:				stack.append(c) ans.sort(reverse=True)print(sum(ans[:k]))
