import java.io.*;import java.util.*; public class KIndustrialCities {    public static void main(String[] args) throws IOException {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));         String[] nk = br.readLine().split(" ");        int n = Integer.parseInt(nk[0]);        int k = Integer.parseInt(nk[1]);         ArrayList<Integer>[] adj = new ArrayList[n+1];        for(int i=0; i<(n+1); i++) {            adj[i] = new ArrayList<Integer>();        }        adj[1].add(0);        for(int l=0; l<(n-1); l++) { //n-1 edges, root is 1            String[] ij = br.readLine().split(" "); //an edge from i--j            int i = Integer.parseInt(ij[0]);            int j = Integer.parseInt(ij[1]);             //adding the other element on both elements            adj[i].add(j);            adj[j].add(i);        }         int[] happiness = new int[n+1];        happiness[0] = Integer.MIN_VALUE; //making o index min so that it is not considered in calculating happiness after choosing k industrial towns        calculateHappiness(1, 0, 1, happiness, adj);         Arrays.sort(happiness);         long happinessAfterChoosingKIndustrialTowns = 0;        for(int i=n; i>n-k; i--) {            happinessAfterChoosingKIndustrialTowns += (long)happiness[i];        }         bw.write(happinessAfterChoosingKIndustrialTowns + "\n");        bw.flush();    }     //happiness of node being made industrial = depth - subtreeSize of this node    //dfs is performed to calculate happiness for each node    //depth is maintained top down in the depth parameter    //subtreeSize is maintained bottom up by returning it from function    public static int calculateHappiness(int node, int parent, int depth, int[] happiness, ArrayList<Integer>[] adj) {        int subtreeSize = 1;                for(int i=0; i<adj[node].size(); i++) {            if(adj[node].get(i) != parent) {                subtreeSize += calculateHappiness(adj[node].get(i), node, depth+1, happiness, adj);            }        }         happiness[node] = (depth - subtreeSize);         return subtreeSize;    }}
