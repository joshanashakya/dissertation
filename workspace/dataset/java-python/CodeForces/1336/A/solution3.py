'''from heapq import *t=int(input())for i in range(t):    n=int(input())    arr=[0 for i in range(n)]    heap=[]    heappush(heap,[n,1])    while heap:        pop=heappop(heap)'''import sys, threadingsys.setrecursionlimit(300000)threading.stack_size(10**8)def solve():    n,k=map(int,input().split())    n1=[n,k]    adj={}    depths={}    cities=[]    subtrees={}    nums={}    for i in range(n-1):        a,b=map(int,input().split())        if a not in adj:            adj[a]=[]        if b not in adj:            adj[b]=[]        adj[a].append(b)        adj[b].append(a)    v=set()    def dfs(node,depth):        v.add(node)        depths[node]=depth        subtrees[node]=0        for child in adj.get(node,[]):            if child not in v:                #parent[child]=node                r=dfs(child,depth+1)                if type(r)==int:                    subtrees[node]+=r        return subtrees[node]+1    dfs(1,0)    ans=[]    for i in range(1,n+1):        ans.append(depths.get(i,0)-subtrees.get(i,0))    ans.sort(reverse=True)    print(sum(ans[:k]))threading.Thread(target=solve).start()
