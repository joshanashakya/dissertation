import sys, heapq as hinput = sys.stdin.readline def getInts():    return [int(s) for s in input().split()] def getInt():    return int(input()) def getStrs():    return [s for s in input().split()] def getStr():    return input().strip() def listStr():    return list(input().strip()) import collections as colimport math """pick any triple, immediately we have an upper boundfor a given value D, is it possible to find a triple that satisfies (x-y)**2 + (y-z)**2 + (z-x)**2 <= D?if the same element appears in all three arrays, return 0can immediately discard any pairs s.t. (x-y)**2 >= D Given (x0, y0) as a candidate pair, if there are any values of z between x0 and y0, they are the only candidates, with preference to the one closest to (x0+y0)/2Otherwise we are interested in the values of z immediately either side of x0 and y0 One element has to be in the middle; given this, pick the two immediately either side of it R <= G <= BR <= B <= GG <= R <= BG <= B <= RB <= R <= GB <= G <= R""" def sq_sum(a,b,c):    return (a-b)**2 + (b-c)**2 + (c-a)**2 def solve():    NR, NG, NB = getInts()    Cols = []    for j in range(3):        Cols.append(getInts())        Cols[j].sort()    best = 3*10**18+1    for i in range(3):        for j in range(3):            for k in range(3):                if len(set([i,j,k])) == 3:                    #we enumerate over the elements of Cols[j], while looking for the elements of Cols[i] immediately smaller                    #and the element of Cols[k] immediately bigger                    for jj in range(len(Cols[j])):                        arr1 = Cols[j][jj]                        if Cols[j][jj] < Cols[i][0] or Cols[j][jj] > Cols[k][-1]:                            continue                        #find smaller element in Cols[i]                        if Cols[i][0] == arr1:                            arr0 = Cols[i][0]                        elif Cols[i][-1] <= arr1:                            arr0 = Cols[i][-1]                        else:                            left = 0                            right = len(Cols[i])-1                            while right - left > 1:                                middle = (left+right)//2                                if Cols[i][middle] == arr1:                                    left = middle                                    break                                if Cols[i][middle] < arr1:                                    left = middle                                else:                                    right = middle                            arr0 = Cols[i][left]                        #find bigger element in Cols[k]                        if Cols[k][-1] == arr1:                            arr2 = Cols[k][-1]                        elif Cols[k][0] >= arr0:                            arr2 = Cols[k][0]                        else:                            left = 0                            right = len(Cols[k])-1                            while right - left > 1:                                middle = (left+right)//2                                if Cols[k][middle] == arr1:                                    right = middle                                    break                                if Cols[k][middle] > arr1:                                    right = middle                                else:                                    left = middle                            arr2 = Cols[k][right]                        best = min(best,sq_sum(arr0,arr1,arr2))    return best                            for _ in range(getInt()):    print(solve())#print(solve())    
