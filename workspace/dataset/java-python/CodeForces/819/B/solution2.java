import java.io.*;import java.math.BigDecimal;import java.math.MathContext;import java.util.*;import java.util.function.Function; import static java.math.BigDecimal.ROUND_HALF_UP; public class Solution {    static MyScanner sc;    private static PrintWriter out;    static long M2 = 1_000_000_000L + 7;     public static void main(String[] s) throws Exception {        StringBuilder stringBuilder = new StringBuilder();//        stringBuilder.append("100000 1000000000 10001 100000 ");//        for (int i = 1; i < 100000; i++) {//            stringBuilder.append(" 10000 100000 ");//        }//        stringBuilder.append(" 3\n" +//                "2 3 1 ");//        stringBuilder.append("10 1 2 3 4 5 6 7 8 9 10");        if (stringBuilder.length() == 0) {            sc = new MyScanner(System.in);        } else {            sc = new MyScanner(new BufferedReader(new StringReader(stringBuilder.toString())));        }          out = new PrintWriter(new OutputStreamWriter(System.out));        initData();        solve();        out.flush();    }      private static void initData() {     }      private static void solve() throws IOException {          int n = sc.nextInt();        int[] f = new int[n];        CumSum s = new CumSum(n);        int[] data = sc.na(n);          for (int i = 0; i < n; i++) {            f[i] = data[i] - 1;            int left = f[i];            int right = n - f[i] - 1;            int mid = (f[i] - i + n) % n;             int lb = mid - left;            int rb = mid + right;            if (lb >= 0 && left >= 0) {                s.add(lb, left, left, -1);            } else {                s.add(0, mid, mid, -1);            }            if (rb <= n - 1 && right >= 1) {                s.add(mid, rb - mid + 1, 0, 1);            } else {                s.add(mid, rb - mid, 0, 1);            }            if (lb != 0) {                if (lb > 0) {                    s.add(0, lb, right + n - rb, 1);                } else {                    s.add(rb + 1, -lb, left, -1);                }            }        }          long[] k = s.cumSum(); //        out.println(Arrays.toString(k));        int l = 0;        for (int ans = 1; ans < n; ans++) {            if (k[l] > k[ans]) l = ans;        }        out.println(k[l] + " " + l);    }      private static final class CumSum {        long[] shift;        long[] extra;        int n;         CumSum(int v) {            this.n = v;            shift = new long[n];            extra = new long[n];        }         void add(int start, int count, int val, int offset) {            extra[start] += val;            if (start + 1 < n) {                shift[start + 1] += offset;            }            int end = start + count;            if (end >= n) return;            shift[end] -= offset;            extra[end] -= val + (count - 1) * offset;        }         long[] cumSum() {            long[] res = new long[shift.length];            long ex = 0;            for (int s = 0; s < shift.length; s++) {                ex += shift[s];                if (s != 0) res[s] = res[s - 1];                res[s] += ex + extra[s];            }            return res;        }     }     private static void solveT() throws IOException {        int t = sc.nextInt();        while (t-- > 0) {            solve();        }    }     private static long gcd(long l, long l1) {        if (l > l1) return gcd(l1, l);        if (l == 0) return l1;        return gcd(l1 % l, l);    }     private static long pow(long a, long b, long m) {        if (b == 0) return 1;        if (b == 1) return a;        long pp = pow(a, b / 2, m);        pp *= pp;        pp %= m;        return (pp * (b % 2 == 0 ? 1 : a)) % m;    }      static class MyScanner {        BufferedReader br;        StringTokenizer st;         MyScanner(BufferedReader br) {            this.br = br;        }         public MyScanner(InputStream in) {            this(new BufferedReader(new InputStreamReader(in)));        }         void findToken() {            while (st == null || !st.hasMoreTokens()) {                try {                    st = new StringTokenizer(br.readLine());                } catch (IOException e) {                    throw new RuntimeException(e);                }            }        }         String next() {            findToken();            return st.nextToken();        }         Integer[] nab(int n) {            Integer[] k = new Integer[n];            for (int i = 0; i < n; i++) {                k[i] = sc.fi();            }            return k;        }         int[] na(int n) {            int[] k = new int[n];            for (int i = 0; i < n; i++) {                k[i] = sc.fi();            }            return k;        }         long[] nl(int n) {            long[] k = new long[n];            for (int i = 0; i < n; i++) {                k[i] = sc.nextLong();            }            return k;        }         int nextInt() {            return Integer.parseInt(next());        }         int fi() {            String t = next();            int cur = 0;            boolean n = t.charAt(0) == '-';            for (int a = n ? 1 : 0; a < t.length(); a++) {                cur = cur * 10 + t.charAt(a) - '0';            }            return n ? -cur : cur;        }         long nextLong() {            return Long.parseLong(next());        }         double nextDouble() {            return Double.parseDouble(next());        }    }  }
