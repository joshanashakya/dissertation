import java.io.*;import java.util.*; public class Solution {    static MyScanner sc;    private static PrintWriter out;    static long M2 = 1_000_000_000L + 7;     public static void main(String[] s) throws Exception {        StringBuilder stringBuilder = new StringBuilder();//        stringBuilder.append("100000 1000000000 10001 100000 ");//        for (int i = 1; i < 100000; i++) {//            stringBuilder.append(" 10000 100000 ");//        }        if (stringBuilder.length() == 0) {            sc = new MyScanner(System.in);        } else {            sc = new MyScanner(new BufferedReader(new StringReader(stringBuilder.toString())));        }         out = new PrintWriter(new OutputStreamWriter(System.out));        initData();        solve();        out.flush();    }      private static void initData() {     }     private static void solve() throws IOException {        int a = sc.nextInt();        int b = sc.nextInt();        int l = sc.nextInt() - 1;        int r = sc.nextInt() - 1;        int s = r - l + 1;        for (char l1 = 'a'; l1 <= 'z'; l1++)            for (char l2 = 'a'; l2 <= 'z'; l2++)                for (char l3 = 'a'; l3 <= 'z'; l3++)                    s = Math.min(s, getS(a, b, l, r, new char[]{l1, l2, l3}));          out.println(s);        // abc        // cade     }     private static int getS(int a, int b, int l, int r, char[] m) {        char[] t = new char[3 * (a + b)];        for (int i = 0; i < 3; i++) {            System.arraycopy(na(t, i * (a + b), a), 0, t, i * (a + b), a);            Arrays.fill(t, i * (a + b) + a, (i + 1) * (a + b), m[i]);        }         int f = l % (a + b);        int len = r - l + 1;        t = Arrays.copyOfRange(t, f, t.length);        t = Arrays.copyOf(t, Math.min(t.length, len));            boolean[] sm = new boolean[26];         for (char x : t) {            sm[x - 'a'] = true;        }        int s = 0;        for (boolean rr : sm) {            if (rr) s++;        }        return s;    }     private static char[] na(char[] t, int i, int a) {        boolean[] ff = new boolean[26];        for (int f = i - 1; f >= 0 && f >= i - a; f--) {            ff[t[f] - 'a'] = true;        }        char[] l = new char[a];        char p = 'a';        int cr = 0;        while (cr < a) {            while (ff[p - 'a']) {                p++;            }            l[cr++] = p++;        }        return l;    }      static int[][] edge;     private static int[][] tr(int n) {        edge = new int[2][n - 1];        for (int i = 0; i < n - 1; i++) {            edge[0][i] = sc.nextInt() - 1;            edge[1][i] = sc.nextInt() - 1;        }        return pn(edge, n);    }     private static int[][] pn(int[][] x, int n) {        int[] ct = new int[n];        int[][] res = new int[n][];        for (int v : x[0]) {            ct[v]++;        }        for (int v : x[1]) {            ct[v]++;        }        for (int l = 0; l < n; l++) {            res[l] = new int[ct[l]];        }        for (int i = 0; i < x[0].length; i++) {            res[x[0][i]][--ct[x[0][i]]] = x[1][i];            res[x[1][i]][--ct[x[1][i]]] = x[0][i];        }        return res;    }      private static void solveT() throws IOException {        int t = sc.nextInt();        while (t-- > 0) {            solve();        }    }     private static long gcd(long l, long l1) {        if (l > l1) return gcd(l1, l);        if (l == 0) return l1;        return gcd(l1 % l, l);    }     private static long pow(long a, long b, long m) {        if (b == 0) return 1;        if (b == 1) return a;        long pp = pow(a, b / 2, m);        pp *= pp;        pp %= m;        return (pp * (b % 2 == 0 ? 1 : a)) % m;    }      static class MyScanner {        BufferedReader br;        StringTokenizer st;         MyScanner(BufferedReader br) {            this.br = br;        }         public MyScanner(InputStream in) {            this(new BufferedReader(new InputStreamReader(in)));        }         void findToken() {            while (st == null || !st.hasMoreTokens()) {                try {                    st = new StringTokenizer(br.readLine());                } catch (IOException e) {                    throw new RuntimeException(e);                }            }        }         String next() {            findToken();            return st.nextToken();        }         Integer[] nab(int n) {            Integer[] k = new Integer[n];            for (int i = 0; i < n; i++) {                k[i] = sc.fi();            }            return k;        }         int[] na(int n) {            int[] k = new int[n];            for (int i = 0; i < n; i++) {                k[i] = sc.fi();            }            return k;        }         long[] nl(int n) {            long[] k = new long[n];            for (int i = 0; i < n; i++) {                k[i] = sc.nextLong();            }            return k;        }         int nextInt() {            return Integer.parseInt(next());        }         int fi() {            String t = next();            int cur = 0;            boolean n = t.charAt(0) == '-';            for (int a = n ? 1 : 0; a < t.length(); a++) {                cur = cur * 10 + t.charAt(a) - '0';            }            return n ? -cur : cur;        }         long nextLong() {            return Long.parseLong(next());        }         double nextDouble() {            return Double.parseDouble(next());        }    }  }
