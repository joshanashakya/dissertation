import java.io.*;import java.util.*;import java.math.*;    public class Test{    static int tap = -1;     public static int maxFlow(ArrayList<ArrayList<Integer>> adj                                ,boolean[] visited                                ,int[] parent                                ,int n                                ,Queue<Integer> q                                ,int tank)    {          if(q.isEmpty())          {              return -1;          }          int i = q.poll();           if(i==n)          {              int min = adj.get(parent[i]).get(i);              while(i!=tank)              {                  int val = adj.get(parent[i]).get(i);                  if(val<min)                  {                      min = val;                  }                  i = parent[i];              }               return min;          }          ArrayList<Integer> list = adj.get(i);          for(Integer x : list)          {               if(x!=0)               {                   if(!visited[list.indexOf(x)])                   {                       visited[list.indexOf(x)] = true;                       parent[list.indexOf(x)] = i;                       q.add(list.indexOf(x));                   }               }          }          int min = maxFlow(adj, visited, parent, n, q,tank);                   return min;              }                     public static void dfs(ArrayList<ArrayList<Integer>> adj                          ,int n                          ,int i                          ,boolean[] dfsVis)    {         dfsVis[i] = true;         boolean atleast = false;         int in = -1;         for(Integer x : adj.get(i))         {              ++in;              if(x!=0 && !dfsVis[in])              {                   atleast = true;                   dfs(adj,n,in,dfsVis);              }         }         if(!atleast)         {              tap = i;         }    }    public static void process()throws IOException    {        int n = ni();        int p = ni();         ArrayList<ArrayList<Integer>> adj = new ArrayList<ArrayList<Integer>>();         HashSet<Integer> tankSet = new HashSet<Integer>();         for(int i=0;i<n;i++)         {             tankSet.add(i);             ArrayList<Integer> nList = new ArrayList<Integer>();             for(int j=0;j<n;j++){                 nList.add(0);             }             adj.add(nList);         }                 while(p-->0)         {             int u = sc.nextInt(); u--;             int v = sc.nextInt(); v--;             int w = sc.nextInt();             tankSet.remove(v);                         int val = adj.get(u).get(v);             adj.get(u).set(v, val+w);         }                  long Flow = 0;         StringBuilder sb = new StringBuilder("");         int count=0;         for(Integer tank : tankSet)         {              boolean[] dfsVis = new boolean[n];              tap=-1;              dfs(adj,n,tank,dfsVis);              // pn(tap);               if(tap!=tank){                count++;               long sum = 0;               int min = 0;               while(min!=-1)               {                   boolean visited[] = new boolean[n];                   visited[tank]=true;                   int parent[] = new int[n];                   Arrays.fill(parent,-1);                   Queue<Integer> q = new LinkedList<Integer>();                   q.add(tank);                   min = maxFlow(adj, visited, parent, tap, q,tank);                                     int x = tap;                    if(min!=-1)                    {                        sum+=min;                        while(x!=tank)                        {                            int val = adj.get(parent[x]).get(x);                            adj.get(parent[x]).set(x, val-min);                            adj.get(x).set(parent[x], val-min);                                                        x = parent[x];                                                    }                    }                                  }                // System.out.println(sum);                                sb.append(tank+1).append(" ").append(tap+1)                  .append(" ")                  .append(sum)                  .append("\n");              }           }         pn(count);         if(count>0)         pn(sb.toString().trim());                                }      static AnotherReader sc;    static PrintWriter out;    public static void main(String[]args)throws IOException    {        out = new PrintWriter(System.out);        sc=new AnotherReader();        boolean oj = true;         // oj = System.getProperty("ONLINE_JUDGE") != null;        // if(!oj) sc=new AnotherReader(100);         // long s = System.currentTimeMillis();        int t=1;        while(t-->0)            process();        out.flush();        // if(!oj)        //     System.out.println(System.currentTimeMillis()-s+"ms");        System.out.close();      }     static void pn(Object o){out.println(o);}    static void p(Object o){out.print(o);}    static void pni(Object o){out.println(o);System.out.flush();}    static int ni()throws IOException{return sc.nextInt();}    static long nl()throws IOException{return sc.nextLong();}    static double nd()throws IOException{return sc.nextDouble();}    static String nln()throws IOException{return sc.nextLine();}    static long gcd(long a, long b)throws IOException{return (b==0)?a:gcd(b,a%b);}    static int gcd(int a, int b)throws IOException{return (b==0)?a:gcd(b,a%b);}    static int bit(long n)throws IOException{return (n==0)?0:(1+bit(n&(n-1)));}    static boolean multipleTC=false;   /////////////////////////////////////////////////////////////////////////////////////////////////////////     static class AnotherReader{BufferedReader br; StringTokenizer st;    AnotherReader()throws FileNotFoundException{    br=new BufferedReader(new InputStreamReader(System.in));}    AnotherReader(int a)throws FileNotFoundException{    br = new BufferedReader(new FileReader("input.txt"));}    String next()throws IOException{    while (st == null || !st.hasMoreElements()) {try{    st = new StringTokenizer(br.readLine());}    catch (IOException  e){ e.printStackTrace(); }}    return st.nextToken(); } int nextInt() throws IOException{    return Integer.parseInt(next());}    long nextLong() throws IOException    {return Long.parseLong(next());}    double nextDouble()throws IOException { return Double.parseDouble(next()); }    String nextLine() throws IOException{ String str = ""; try{    str = br.readLine();} catch (IOException e){    e.printStackTrace();} return str;}}    /////////////////////////////////////////////////////////////////////////////////////////////////////////////}
