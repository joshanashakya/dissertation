# DEFINING SOME GOOD STUFFfrom math import *import threadingimport sysfrom collections import * mod = 10 ** 9inf = 10**15yes = 'YES'no = 'NO' # _______________________________________________________________# def npr(n, r):    return factorial(n) // factorial(n - r) if n >= r else 0def ncr(n,r):    return factorial(n)// ( factorial(r) * factorial(n-r)) if n >= r else 0def lower_bound(li, num):    answer = -1    start = 0    end = len(li) - 1     while (start <= end):        middle = (end + start) // 2        if li[middle] >= num:            answer = middle            end = middle - 1        else:            start = middle + 1    return answer  # min index where x is not less than numdef upper_bound(li, num):    answer = -1    start = 0    end = len(li) - 1     while (start <= end):        middle = (end + start) // 2         if li[middle] <= num:            answer = middle            start = middle + 1         else:            end = middle - 1    return answer  # max index where x is not greater than numdef abs(x):    return x if x >= 0 else -xdef binary_search(li, val, lb, ub):    # print(lb, ub, li)    ans = -1    while (lb <= ub):        mid = (lb + ub) // 2        # print('mid is',mid, li[mid])        if li[mid] > val:            ub = mid - 1        elif val > li[mid]:            lb = mid + 1        else:            ans = mid  # return index            break    return ansdef kadane(x):  # maximum sum contiguous subarray    sum_so_far = 0    current_sum = 0    for i in x:        current_sum += i        if current_sum < 0:            current_sum = 0        else:            sum_so_far = max(sum_so_far, current_sum)    return sum_so_fardef pref(li):    pref_sum = [0]    for i in li:        pref_sum.append(pref_sum[-1] + i)    return pref_sumdef SieveOfEratosthenes(n):    prime = [True for i in range(n + 1)]    p = 2    li = []    while (p * p <= n):        if (prime[p] == True):            for i in range(p * p, n + 1, p):                prime[i] = False        p += 1     for p in range(2, len(prime)):        if prime[p]:            li.append(p)    return lidef primefactors(n):    factors = []    while (n % 2 == 0):        factors.append(2)        n //= 2    for i in range(3, int(sqrt(n)) + 1, 2):  # only odd factors left        while n % i == 0:            factors.append(i)            n //= i    if n > 2:  # incase of prime        factors.append(n)    return factorsdef prod(li):    ans = 1    for i in li:        ans *= i    return ansdef dist(a,b):    d = abs(a[1]-b[1]) + abs(a[2]-b[2])    return ddef power_of_n(x, n):    cnt = 0    while(x%n == 0):        cnt += 1        x //= n    return cntdef ask(l,r):    if l == r:        return -1    print("?",l,r)    sys.stdout.flush()    return int(input())# _______________________________________________________________# import itertools sys.setrecursionlimit(300000)# threading.stack_size(10**5)  # remember it cause mle# def main(): for _ in range(1):# for _ in range(int(input()) if True else 1):    n = int(input())    # n, k = map(int, input().split())    # a = list(map(int, input().split()))    # b = list(map(int, input().split()))    #c = list(map(int, input().split()))    # s = list(input())    # c = list(map(int,input().split()))    # adj = graph(n,m)    # d = defaultdict(int)    ans = ['Sheldon', 'Leonard', 'Penny', 'Rajesh', 'Howard']    if n <= 5:        print(ans[n-1])    else:        now = 5        while n >= now:            n -= now            now *= 2         group = now//5        print(ans[n//group])                                                          '''		t = threading.Thread(target=main)t.start()t.join()'''
