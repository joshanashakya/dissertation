import timestartTimeProblem=time.time() import fileinput, sys, itertools, functools, mathfrom bisect import *from heapq import *from collections import *  MOD = 10**9+7 #isprimedef lcm(a, b):      return (a*b)/math.gcd(a, b) def precompute_binom(n,p):    facts = [0]*n    invfacts = [0]*n     facts[0] = 1    invfacts[0] = 1     for i in range(1,n):                facts[i] = (facts[i-1]*i)%p        invfacts[i] = pow(facts[i],p-2,p)     return facts, invfacts def binom_pre_computed(facts, invfacts, n, k, p):    # n! / (k!^(p-2) * (n-k)!^(p-2)) (mod p)    return (facts[n] * ((invfacts[k]*invfacts[n-k] % p))) % p class UnionFind:    def __init__(self, n):        self.link = [i for i in range(n)]        self.size = [i for i in range(n)]        def find(self, i):        while i!=self.link[i]:            i = self.link[i]        return i        def same(self, i, j):        return self.find(i) == self.find(j)        def unite(self, i, j):        i = self.find(i)        j = self.find(j)         if self.size[i] < self.size[j]:            i, j = j,i                size[i]+=size[j]        link[j] = i  class InputHelper:    def __init__(self):        self.myinput = fileinput.input()     def isLocal(self):        return not fileinput.isstdin()     def int(self):        return int(self.myinput.readline().rstrip())     def ints(self):        return [int(_) for _ in self.myinput.readline().rstrip().split()]     def str(self):        return self.myinput.readline().rstrip()     def strs(self):        return [_ for _ in self.myinput.readline().rstrip().split()] class OutputHelper:    def int(self, a):        print(a)         def ints(self, a):          print(" ".join([str(_) for _ in a]))        def intsNL(self, a):        for _ in a:            print(_)        def str(self, s):        print(s)     def strs(self, s):        print(" ".join([_ for _ in s]))     def strsNL(self, s):        for st in s:            print(st) class ListNode:    def __init__(self, val):        self.val = val        self.next = None        self.prev = None class SegmentTree:    def __init__(self, arr):                       self.n = 2**math.ceil(math.log2(len(arr)))        self.me = [0]*(self.n*2)                        for i in range(self.n, 2*self.n):            ct = i-self.n             if ct>=len(arr):                break             self.me[i] = arr[ct] if ct<len(arr) else 0                            for i in range(2*self.n-1, 0, -1):            self.me[i//2] += self.me[i]        def getFromToIncl(self, a, b):        """        O(log n)        """         a+=self.n        b+=self.n         s = 0         while a<=b:            if a%2==1:                s += self.me[a]                a+=1            if b%2==0:                s += self.me[b]                b-=1                        a//=2            b//=2         return s            def op(self, pos, val):        """        O(log n)        """        pos+=self.n        self.me[pos]+=val         pos//=2         while pos>=1:            self.me[pos] = self.me[2*pos]+self.me[2*pos+1]            pos//=2     In = InputHelper()Out = OutputHelper() ########################################sys.setrecursionlimit(10000) x0,y0,ax,ay,bx,by = In.ints() xs,ys,t = In.ints() nodes = [(x0,y0)] def manhat(node0, node1):    return abs(node0[0]-node1[0])+abs(node0[1]-node1[1]) for i in range(1, 100):    nextNode = (nodes[i-1][0]*ax+bx,nodes[i-1][1]*ay+by)     nodes.append(nextNode)     if manhat(nodes[i-1], nextNode)>10**16:        break def tryWith(idx):    myt = t     myt -= manhat(nodes[idx], (xs,ys))     if myt<0:        return 0        myans = 1     for j in range(len(nodes)):        if idx-j<0:            break        distLow=manhat(nodes[idx-j], nodes[idx])        locans = j+1        loct = myt-distLow         if loct<0:            break                 myans = max(myans, locans)         loct-=distLow         for i in range(idx+1, len(nodes)):            loct -= manhat(nodes[i], nodes[i-1])             if loct<0:                break             locans+=1                myans = max(myans, locans)        for j in range(len(nodes)):        if idx+j<len(nodes):            break        distLow=manhat(nodes[idx+j], nodes[idx])        locans = j+1        loct = myt-distLow         if loct<0:            break                 myans = max(myans, locans)         loct-=distLow         for i in range(idx-1, -1,-1):            loct -= manhat(nodes[i], nodes[i+1])             if loct<0:                break             locans+=1         myans = max(myans, locans)        return myans   ans = 0for i in range(len(nodes)):    ans = max(ans, tryWith(i)) Out.int(ans)  ###################################### if len(sys.argv)>2 and sys.argv[2]=="TIMEIT":    fin = (time.time()-startTimeProblem)*1000    print("{:.2f}".format(fin) + "ms")
