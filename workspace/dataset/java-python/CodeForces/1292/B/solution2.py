# def zip_sorted(a,b): # 	# sorted  by a# 	a,b = zip(*sorted(zip(a,b)))# 	# sorted by b# 	sorted(zip(a, b), key=lambda x: x[1]) # 	return a,b # import sys# input = sys.stdin.readline# I = lambda : list(map(int,input().split()))# S = lambda : list(map(str,input().split()))  # def solve(ax,bx,prev): # 	return ((ax*prev)+bx) # x0,y0,ax,ay,bx,by = I()# xs,ys,t   = I()# x = [x0]# y = [y0]# prevx = x0# prevy = y0# for i in range(101):# 	x.append(int(solve(ax,bx,prevx)))# 	prevx = x[-1]# 	y.append(int(solve(ay,by,prevy)))# 	prevy = y[-1]# min_idx = -1# min_val = 10**28# for i in range(101):# 	if min_val>=(abs(x[i]-xs)+abs(y[i]-ys)):# 		min_val = (abs(x[i]-xs)+abs(y[i]-ys))# 		min_idx = i# if min_val>t:# 	print(0)# else:# 	count = 1# 	t1 = t - min_val# 	curx = x[min_idx]# 	cury = y[min_idx]# 	dpup   = []# 	dpdown = []# 	for i in range(min_idx,100):# 		dpup.append(abs(x[i]-curx)+abs(y[i]-cury))# 	for i in range(min_idx,-1,-1):# 		dpdown.append(abs(x[i]-curx)+abs(y[i]-cury))# 	max_val = 0# 	for i in range(len(dpup)):# 		for j in range(len(dpdown)):# 			if ((2*dpup[i])+dpdown[j])<=t1:# 				max_val = max((i+j),max_val)# 			if (dpup[i]+(2*dpdown[j]))<=t1:# 				max_val = max((i+j),max_val)# 	print(max_val+count)   def zip_sorted(a,b): 	# sorted  by a	a,b = zip(*sorted(zip(a,b)))	# sorted by b	sorted(zip(a, b), key=lambda x: x[1]) 	return a,b import sysinput = sys.stdin.readlineI = lambda : list(map(int,input().split()))S = lambda : list(map(str,input().split()))  def solve(ax,bx,prev): 	return ((ax*prev)+bx) x0,y0,ax,ay,bx,by = I()xs,ys,t   = I()x = [x0]y = [y0]prevx = x0prevy = y0for i in range(101):	x.append(int(solve(ax,bx,prevx)))	prevx = x[-1]	y.append(int(solve(ay,by,prevy)))	prevy = y[-1]max_val2= 0 for i1 in range(100):	min_val = (abs(x[i1]-xs)+abs(y[i1]-ys))	min_idx = i1	if min_val>t:		continue	else:		count = 1		t1 = t - min_val		curx = x[min_idx]		cury = y[min_idx]		dpup   = []		dpdown = []		max_val = 0		for i in range(min_idx,100):			dpup.append(abs(x[i]-curx)+abs(y[i]-cury))		for i in range(min_idx,-1,-1):			dpdown.append(abs(x[i]-curx)+abs(y[i]-cury))		for i in range(len(dpup)):			for j in range(len(dpdown)):				if ((2*dpup[i])+dpdown[j])<=t1:					max_val = max((i+j),max_val)				if (dpup[i]+(2*dpdown[j]))<=t1:					max_val = max((i+j),max_val)				if (dpdown[j])<=t1:					max_val = max(j,max_val)				if (dpup[i])<=t1:					max_val = max(i,max_val)		max_val2 = max(max_val2,(max_val+count))print(max_val2)
