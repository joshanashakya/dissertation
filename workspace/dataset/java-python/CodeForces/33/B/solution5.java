import java.util.HashMap;import java.util.Map;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer; public class Main {    public static void main(String[] args) {        FastReader fs = new FastReader();         String line1 = fs.nextLine();        String line2 = fs.nextLine();         int n = fs.nextInt();         int graph[][] = new int[26][26];                // dicionario para mapear cada caracter a uma posicao num array        Map<Character, Integer> vertexId = new HashMap<>();        Map<Integer, Character> reversed = new HashMap<>();         char alph[] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',        'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',        'u', 'v', 'w' , 'x', 'y', 'z'};         for(int i = 0; i < 26; i++)        {            vertexId.put(alph[i], i);            reversed.put(i, alph[i]);        }                for(int i = 0; i < 26; i++)        {            for(int j = 0; j <26; j++)            {                if(i == j)                {                    graph[i][j] = 0;                } else {                    graph[i][j] = 1000000000;                }            }        }         for(int i = 0; i < n; i++)        {            // contruir matriz de adjacencia            String x = fs.next();            String y = fs.next();            int w = fs.nextInt();             char v = x.charAt(0), u = y.charAt(0);             /*if(graph[vertexId.get(v)][vertexId.get(u)] == 0 || w < graph[vertexId.get(v)][vertexId.get(u)])            {                graph[vertexId.get(v)][vertexId.get(u)] = w;              }*/             graph[vertexId.get(v)][vertexId.get(u)] = Math.min(graph[vertexId.get(v)][vertexId.get(u)], w);                    }         int dist[][] = new int[26][26];        int parent[][] = new int[26][26];         dist = graph;        for(int a = 0; a < 26; a++)        {            for(int b = 0; b < 26; b++)            {                if(a==b) {parent[a][b] = a;}                else if(dist[a][b]!=0 && dist[a][b] != 99999)                 {                    parent[a][b] = a;                } else {                    parent[a][b] = -1;                }            }        }         for(int k = 0; k < 26; k++)        {            for(int i = 0; i < 26; i++)            {                for(int j = 0; j < 26; j++)                {                    if(dist[i][k] + dist[k][j] < dist[i][j])                    {                        dist[i][j] = dist[i][k] + dist[k][j];                        parent[i][j] = parent[i][k];                    }                }            }        }         // verificar o menor caminho entre pares de letras de line1 e line2        int totalCost = -1;        StringBuilder finalString = new StringBuilder();        boolean pairFound = true;         if(line1.length() == line2.length())        {            totalCost = 0;            pairFound = true;             for(int x = 0; x < line1.length(); x++)            {                if(line1.charAt(x) != line2.charAt(x))                {                    int source = vertexId.get(line1.charAt(x));                    int dest = vertexId.get(line2.charAt(x));                     int parentChar = -1;                    int minDist = 1000000000;                     for(int y = 0; y < 26; y++)                    {                           int result1 = dist[source][y];                        int result2 = dist[dest][y];                         if(result1 != 1000000000 && result2 != 1000000000 && minDist > result1+result2)                        {                            minDist = result1 + result2;                            parentChar = y;                        }                    }                     if(minDist == 1000000000)                    {                        pairFound = false;                        totalCost = -1;                        break;                    } else {                         totalCost += minDist;                        finalString.append(reversed.get(parentChar));                    }                                                        } else {                    finalString.append(line1.charAt(x));                   }                            }        }         System.out.println(totalCost);        if(pairFound)        {            System.out.println(finalString);        }    } }  class FastReader {    BufferedReader br;    StringTokenizer st;     public FastReader ()    {        br = new BufferedReader(new InputStreamReader(System.in));     }     String next()    {        while  (st == null || !st.hasMoreElements())         {            try {                st = new StringTokenizer(br.readLine());                           } catch (IOException e) {                e.printStackTrace();            }        }        return st.nextToken();    }     int nextInt()     {        return Integer.parseInt(next());    }     long nextLong()    {        return Long.parseLong(next());    }     double nextDouble()    {        return Double.parseDouble(next());    }     String nextLine()    {        String str = "";         try {            str = br.readLine();        } catch (IOException e) {            e.printStackTrace();        }        return str;    }}   		 		 	  		    		 	  	    	  	
