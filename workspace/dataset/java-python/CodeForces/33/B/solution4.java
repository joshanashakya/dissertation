import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer; public class Main {    static class FastReader{        BufferedReader br;        StringTokenizer st;        public FastReader(){            br = new BufferedReader(new InputStreamReader(System.in));        }        public String next(){            while(st == null || !st.hasMoreElements()){                try {                    st = new StringTokenizer(br.readLine());                }catch (IOException e){                    e.printStackTrace();                }            }            return st.nextToken();        }        public int nextInt(){            return Integer.parseInt(next());        }    }    public static void main(String[] args) {        FastReader in = new FastReader();        Graph grafo = new Graph();        int respostaFinal = 0;        StringBuilder sentençaFinal = new StringBuilder();        String str1 = in.next();        String str2 = in.next();        if (str1.length() == str2.length()) {            for (int contador = in.nextInt(); contador > 0; contador--) {                String vertice1 = in.next();                String vertice2 = in.next();                int peso = in.nextInt();                grafo.setEdge(vertice1.charAt(0), vertice2.charAt(0), peso);            }             int[][] matriz = grafo.floydWarshall();             for (int contador = 0; contador < str1.length(); contador++){                //inicializando vertices, custo para trocar a letra e a letra que foi trocada                int vertice1 = str1.charAt(contador) - 97;                int vertice2 = str2.charAt(contador) - 97;                int custoLetra = matriz[vertice1][vertice2];                char novaLetra = (char) (vertice2 + 97);                 if (vertice1 != vertice2) {//verificando se o vertice1 e o vertice2 sao a mesma letra                    if (matriz[vertice2][vertice1] < custoLetra) {                        //verificando possib de menor custo                        custoLetra = matriz[vertice2][vertice1];                        novaLetra = (char) (vertice1 + 97);                    }for (int contadorInterno = 0; contadorInterno < 26; contadorInterno++) {                        //verificando outra possib de menor custo                        if (matriz[vertice2][contadorInterno] != 3000 && matriz[vertice1][contadorInterno] != 3000)                            if (matriz[vertice2][contadorInterno] + matriz[vertice1][contadorInterno] < custoLetra) {                                custoLetra = matriz[vertice2][contadorInterno] + matriz[vertice1][contadorInterno];                                novaLetra = (char) (contadorInterno + 97);                            }                    }                    if (custoLetra == 3000) {                        //Se o custo for 3000, essa variavel nunca foi trocada, logo nao e possivel                        //ter um resultado em comum entre vertice1 e vertice2                        respostaFinal = -1;                        contador = str1.length();                    } else {                        respostaFinal += custoLetra;                        sentençaFinal.append(novaLetra);                    }                }else //Adicionando a letra quando vertice1 e vertice2 sao iguais                    sentençaFinal.append(novaLetra);            }        }else            respostaFinal = -1;                System.out.println(respostaFinal);        if (respostaFinal != -1)            System.out.println(sentençaFinal.toString());     }    //novo problema com o sysout com string builder}class Graph {   private int[][] matriz;   private boolean[] mark;     public Graph(){       this.matriz = new int[26][26];       for (int contador = 0; contador < 26; contador++){           for (int contadorInterno = 0; contadorInterno < 26; contadorInterno++)                this.matriz[contador][contadorInterno] = 3000;       }       this.mark = new boolean[26];   }     public void setEdge(int vertice1, int vertice2, int peso){       if (this.matriz[vertice1-97][vertice2-97] > peso)            this.matriz[vertice1-97][vertice2-97] = peso;    }    public int[][] floydWarshall (){       for (int contadorMatriz = 0; contadorMatriz < 26; contadorMatriz++)           for (int contadorLinha = 0; contadorLinha < 26; contadorLinha++)               for (int contadorColuna = 0; contadorColuna < 26; contadorColuna++)                   if (this.matriz[contadorLinha][contadorColuna] > this.matriz[contadorLinha][contadorMatriz]                           + this.matriz[contadorMatriz][contadorColuna])                       this.matriz[contadorLinha][contadorColuna] = this.matriz[contadorLinha][contadorMatriz] +                               + this.matriz[contadorMatriz][contadorColuna];                   return this.matriz;    } } 	 		 	 			 		  					 	 	   	 	
