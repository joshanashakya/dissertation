import java.math.BigInteger;import java.util.*; public class PA {    public static void main(String[] args) {        new PA().run();    }     private void run() {        Scanner sc = new Scanner(System.in);         sc.nextLine();        String s = sc.nextLine();         Point pos = new Point(0, 0);        Map<Point, Integer> positions = new HashMap<>();        positions.put(pos, 1);        for (int i = 0; i < s.length(); i++) {            char command = s.charAt(i);            pos = pos.move(command);            positions.put(pos, positions.getOrDefault(pos, 0) + 1);        }         BigInteger r = BigInteger.ZERO;        for (Map.Entry<Point, Integer> entry : positions.entrySet()) {            Integer c = entry.getValue();            if (c == 1) continue;             r = r.add(factorial(c).divide((BigInteger.valueOf(2).multiply(factorial(c - 2)))));        }         System.out.println(r);    }     BigInteger factorial(int n) {        BigInteger r = BigInteger.ONE;        if (n == 0) return r;        for (int i = 1; i <= n; i++)            r = r.multiply(BigInteger.valueOf(i));        return r;    }     class Point {        private int x;        private int y;         public Point(int x, int y) {            this.x = x;            this.y = y;        }         public int getX() {            return x;        }         public void setX(int x) {            this.x = x;        }         public int getY() {            return y;        }         public void setY(int y) {            this.y = y;        }         public Point move(char command) {            switch (command) {                case 'U':                    return new Point(x, y + 1);                case 'R':                    return new Point(x + 1, y);                case 'D':                    return new Point(x, y - 1);                case 'L':                    return new Point(x - 1, y);            }            throw new IllegalArgumentException();        }         @Override        public boolean equals(Object o) {            if (this == o) return true;            if (o == null || getClass() != o.getClass()) return false;            Point point = (Point) o;            return x == point.x &&                    y == point.y;        }         @Override        public int hashCode() {            return Objects.hash(x, y);        }    }}
