from __future__ import division, print_functiondef get_ints(): return map(int, input().strip().split())def get_array(): return list(map(int, input().strip().split()))mod = 1000000007import collections, math, sys, bisectINF = sys.maxsizeMOD = 998244353  def main():    def check(a, b, arr):        for i in arr:            if i[0] != a and i[1] != b and i[0] != b and i[1] != a:                return False        return True     def solve():        n, m = get_ints()        arr = []        for i in range(m):            a, b = get_ints()            arr.append((a, b))        # flag = False        for x in arr[0]:            if check(x,-1,arr):                print('YES')                return            for i in range(1, len(arr)):                if arr[i][0] != x and arr[i][1] != x:                    if check(x, arr[i][0], arr) or check(x, arr[i][1], arr):                        print('YES')                        return                    break        print('NO')     solve()   # Region of fastio, don't change py2 = round(0.5)if py2:    from future_builtins import ascii, filter, hex, map, oct, zip     range = xrange import os, sysfrom io import IOBase, BytesIO BUFSIZE = 8192  class FastIO(BytesIO):    newlines = 0     def __init__(self, file):        self._file = file        self._fd = file.fileno()        self.writable = "x" in file.mode or "w" in file.mode        self.write = super(FastIO, self).write if self.writable else None     def _fill(self):        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))        self.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])        return s     def read(self):        while self._fill(): pass        return super(FastIO, self).read()     def readline(self):        while self.newlines == 0:            s = self._fill();            self.newlines = s.count(b"\n") + (not s)        self.newlines -= 1        return super(FastIO, self).readline()     def flush(self):        if self.writable:            os.write(self._fd, self.getvalue())            self.truncate(0), self.seek(0)  class IOWrapper(IOBase):    def __init__(self, file):        self.buffer = FastIO(file)        self.flush = self.buffer.flush        self.writable = self.buffer.writable        if py2:            self.write = self.buffer.write            self.read = self.buffer.read            self.readline = self.buffer.readline        else:            self.write = lambda s: self.buffer.write(s.encode('ascii'))            self.read = lambda: self.buffer.read().decode('ascii')            self.readline = lambda: self.buffer.readline().decode('ascii')  sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)input = lambda: sys.stdin.readline().rstrip('\r\n') if __name__ == '__main__':    main()
