import java.io.*;import java.util.*; public class B {     FastScanner scanner;    PrintWriter writer;     int n;    int m;    boolean[] bits;    Map<String, Integer> names;    List<Value> values;     void solve() throws IOException {        scanner = new FastScanner(System.in);        writer = new PrintWriter(System.out);        n = scanner.nextInt();        m = scanner.nextInt();         values = new ArrayList<>(n);        names = new HashMap<>(n);        bits = new boolean[n];         for (int i = 0; i < n; i++) {            String name = scanner.next();            names.put(name, i);            scanner.next();            String lhs = scanner.next();            Value value;            if (Character.isDigit(lhs.charAt(0))) {                value = new Constant(toBoolean(lhs));            } else {                String op = scanner.next();                String rhs = scanner.next();                value = new BinOp(lhs, rhs, op);            }            values.add(value);        }        boolean[] min = new boolean[m];        boolean[] max = new boolean[m];        for (int i = 0; i < m; i++) {            int zeroCount = count(i, false);            int oneCount = count(i, true);            if (zeroCount < oneCount) {                min[i] = false;                max[i] = true;            } else if (zeroCount > oneCount){                min[i] = true;                max[i] = false;            } else {                min[i] = max[i] = false;            }        }        writer.println(toString(min));        writer.println(toString(max));        writer.close();    }     int count(int d, boolean pVal) {        int c = 0;        for (int i = 0; i < n; i++) {            Value value = values.get(i);            boolean bit;            if (value instanceof Constant) {                bit = ((Constant) value).value[d];            } else {                BinOp binOp = (BinOp) value;                boolean lhs = resolve(binOp.lhsName, pVal);                boolean rhs = resolve(binOp.rhsName, pVal);                switch (binOp.op) {                    case "AND":                        bit = lhs & rhs;                        break;                    case "OR":                        bit = lhs | rhs;                        break;                    case "XOR":                        bit = lhs ^ rhs;                        break;                    default:                        throw new IllegalStateException();                }            }            bits[i] = bit;            if (bit) {                c++;            }        }        return c;    }     boolean resolve(String name, boolean pVal) {        if (name.equals("?")) {            return pVal;        } else {            int i = names.get(name);            return bits[i];        }    }     String toString(boolean[] b) {        StringBuilder sb = new StringBuilder(m);        for (int i = 0; i < m; i++) {            sb.append(b[i] ? '1' : '0');        }        return sb.toString();    }     boolean[] toBoolean(String s) {        boolean[] b = new boolean[m];        for (int i = 0; i < m; i++) {            b[i] = s.charAt(i) == '1';        }        return b;    }     interface Value {}     class Constant implements Value {        boolean[] value;         public Constant(boolean[] value) {            this.value = value;        }    }     class BinOp implements Value {        String lhsName;        String rhsName;        String op;         public BinOp(String lhsName, String rhsName, String op) {            this.lhsName = lhsName;            this.rhsName = rhsName;            this.op = op;        }    }      public static void main(String... args) throws IOException {        new B().solve();    }     static class FastScanner {         BufferedReader br;        StringTokenizer tokenizer;         FastScanner(String fileName) throws FileNotFoundException {            this(new FileInputStream(new File(fileName)));        }         FastScanner(InputStream is) {            br = new BufferedReader(new InputStreamReader(is));        }         String nextLine() throws IOException {            tokenizer = null;            return br.readLine();        }         String next() throws IOException {            if (tokenizer == null || !tokenizer.hasMoreTokens()) {                String line = br.readLine();                if (line == null) {                    return null;                }                tokenizer = new StringTokenizer(line);            }            return tokenizer.nextToken();        }         int nextInt() throws IOException {            return Integer.parseInt(next());        }         double nextDouble() throws IOException {            return Double.parseDouble(next());        }    }}
