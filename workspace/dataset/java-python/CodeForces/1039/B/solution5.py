n, k = map(int, raw_input().split())i_from = 1i_to = nq_limit = 4500-100 #WTF -1q_cnt = 0shoots_cnt = 0 from random import randomfrom sys import stdout, stderrdef answer(val):    print "%i" % val    stdout.flush()    quit() def test(a, b):    print "%i %i" % (a, b)    stdout.flush()    return (raw_input() == "Yes") working_with_up_bound = Falsewhile True:    print >> stderr, i_from, i_to    #if search-array is small enought    delta_l = i_to-i_from+1    next_delta_1 = delta_l/2    next_delta_2 = delta_l-next_delta_1    if next_delta_1 + 2*k >= delta_l or next_delta_2 + 2*k>= delta_l:        #random shoot        test_to = i_from + int((i_to+1-i_from)*random())        test_from = test_to    else:         #bisect-search        if working_with_up_bound:            test_from = i_from            test_to = i_from + (i_to-i_from)/2        else:            test_from = i_to - (i_to-i_from)/2            test_to = i_to     q_cnt += 1    if q_cnt > q_limit:        #FAILED        #DEBUG        answer(42)    if test_to == test_from:        shoots_cnt += 1            if test(test_from, test_to):        #founded        if test_from == test_to:            #after shoot YES!!!!            answer(test_from)        else:            #after search            i_from = test_from-k            i_to = test_to+k                else:        #not founded        if test_from == test_to:            #after shoot            i_from -= k            i_to += k        else:            #after search            if working_with_up_bound:                i_from = test_to + 1 - k                i_to = i_to + k            else:                i_from = i_from - k                i_to = test_from + k-1            #working_with_up_bound = not working_with_up_bound     if i_from < 1:        i_from = 1    if i_to > n:        i_to = n        #end while                    
