import java.util.*;import java.io.*;  public class gfg  {         public static void main(String[] args) throws IOException{        //Reader.init(System.in);        //PrintWriter out = new PrintWriter(System.out);        Reader.init(System.in);        int t = 1;//Reader.nextInt();        while(t-->0){           solve();        }            //out.close();    }        static ArrayList<Integer>[] graph;     //static ArrayList<Integer>[] set;    static int n=0;    static int m=0;    static boolean[] vis;    //static char[][] arr;    static long mod =1000000007;    static int min=-1;    //static ArrayList<int[]> list ;    static int[] count;    static boolean[] white;    static int[] dx = {0,0,-1,1};    static int[] dy = {1,-1,0,0};    static ArrayList<Integer> list = new ArrayList<>();    static int nodes=0;    static int edges = 0;      static void solve()throws IOException{        n = Reader.nextInt();        m = Reader.nextInt();        int k = Reader.nextInt();        int[] arr = new int[n+1];        for(int i=0;i<k;i++){            arr[i] = Reader.nextInt();        }        graph = new ArrayList[n+1];        for(int i=1;i<=n;i++)            graph[i]  = new ArrayList<Integer>();        vis = new boolean[n+1];        int total=0;        for(int i=1;i<=m;i++){            int a  = Reader.nextInt();            int b  = Reader.nextInt();            graph[a].add(b);            graph[b].add(a);        }        int sum=0;        int ans=0;        int max=0;        for(int i=0;i<k;i++){            int a = arr[i];            if(!vis[a]){                nodes=0;                edges=0;                dfs(a);                edges/=2;                total+=edges;                ans += (nodes*(nodes-1))/2 - edges ;                max  = Math.max(nodes,max);                sum+=nodes;            }        }        ans = ans+ ((n-sum)*(n-sum-1))/2 - (m-total) ;        ans += max*(n-sum);        //System.out.println(sum+" "+total+" "+max);        System.out.println(ans);     }     static void dfs(int a){ // u[ar = false means upar edge h;        vis[a] = true;        nodes++;        for(int i=0;i<graph[a].size();i++){            edges++;            int b = graph[a].get(i);            if(!vis[b]){                dfs(b);            }        }    }                       // ggratest common divisor    static int gcd(int a , int b){        if(b==0)            return a;        else            return gcd(b,a%b);    }     // least common multiple    static int lcm(int a, int b){        return (a*b)/gcd(a,b);    }        // a^b    static long fastpow(long a, long b){        long res = 1;a=a%mod;        while(b>0){            if(b%2==1)                res = (res*a)%mod;            a = (a*a)%mod;            b = b>>1;        }        return res;    }     }  class Reader {    static BufferedReader reader;    static StringTokenizer tokenizer;     /** call this method to initialize reader for InputStream */    static void init(InputStream input) {        reader = new BufferedReader(                     new InputStreamReader(input) );        tokenizer = new StringTokenizer("");    }     /** get next word */    static String next() throws IOException {        while ( ! tokenizer.hasMoreTokens() ) {            //TODO add check for eof if necessary            tokenizer = new StringTokenizer(                   reader.readLine() );        }        return tokenizer.nextToken();    }     static int nextInt() throws IOException {        return Integer.parseInt( next() );    }    static long nextLong() throws IOException {        return Long.parseLong( next() );    }        static double nextDouble() throws IOException {        return Double.parseDouble( next() );    }}class newcomparator implements Comparator<Integer>{    //@Override    public int compare(Integer a, Integer  b){        return a<=b?1:-1;    } }class node {    int a;    long b;// cost to rreach\    node(int s,long va){        a=s;        b=va;    }}class mergesort{    static void sort(int l, int h, int[] arr){        if(l<h){            int mid = (l+h)/2;                        sort(l,mid,arr);            sort(mid+1,h,arr);            merge(l,mid,h,arr);        }    }    static void merge(int l, int m , int h , int [] arr){         int[] left = new int[m-l+1];        int[] right = new int[h-m];        for(int i= 0 ;i< m-l+1;i++){            left[i] = arr[l+i];        }        for(int i=0;i<h-m;i++){            right[i] = arr[m+1+i];        }        //now left and right arrays are assumed to be sorted and we have tp merge them together         // int the original aaray.        int i=l;        int lindex = 0;        int rindex =  0;                while(lindex<m-l+1 && rindex<h-m){            if(left[lindex]<=right[rindex]){                arr[i]=left[lindex];                lindex++;                i++;            }            else{                arr[i]=right[rindex];                rindex++;                i++;            }        }        while(lindex<m-l+1){            arr[i]=left[lindex];            lindex++;            i++;        }        while(rindex<h-m){            arr[i]=right[rindex];            rindex++;            i++;        }    }    }  
