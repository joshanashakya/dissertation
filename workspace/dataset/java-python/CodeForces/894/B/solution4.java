import java.io.*;import java.util.*; public class Main {     static long res = 0;    static int n, m;     public static void main(String[] args) throws Exception {        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));        PrintWriter out = new PrintWriter(System.out);        //StringTokenizer st = new StringTokenizer(in.readLine());        /*for (n = 1; n < 6; n++) {            for (m = 1; m < 6; m++) {                for (int k = -1; k <= -1; k++) {                    if (k == 0) continue;                    res = 0;                    int[][] a = new int[n][m];                    recur(a, 0, 0, k);                    System.out.println("N=" + n + " M=" + m + " K=" + k + " Res=" + res+ "  res(normal: )" + solve(n, m, 1));                    System.out.println("SOLVE: " + solve(n, m, k));                    if (solve(n, m, k) == res) {                        System.out.println("CORRECT");                    } else {                        System.out.println("WRONG");                    }                }            }        }*/         StringTokenizer st = new StringTokenizer(in.readLine());        long n = Long.parseLong(st.nextToken());        long m = Long.parseLong(st.nextToken());        int k = Integer.parseInt(st.nextToken());        out.println(solve(n, m, k));        out.close();    }     static long solve(long n, long m, int k) {        long mod = 1000000007;        if (k == 1) {            if (m == 1 || n == 1) {                return 1;            }            long start = binpow(2, n-1, mod);            long extra = m-1;            long res = binpow(start, extra, mod);            return res;        } else {            if ((n % 2 == 0 && m % 2 == 1) || (n % 2 == 1 && m % 2 == 0)) {                return 0;            } else {                return solve(n, m, 1);            }        }    }     static void recur(int[][] a, int ip, int jp, int k) {        if (jp == m) {            for (int i = 0; i < n; i++) {                int prod = 1;                for (int j = 0; j < m; j++) {                    prod *= a[i][j];                }                if (prod != k) return;            }            for (int j = 0; j < m; j++) {                int prod = 1;                for (int i = 0; i < n; i++) {                    prod *= a[i][j];                }                if (prod != k) return;            }            res++;            return;        }        if (ip == n) {            recur(a, ip-n, jp+1, k);            return;        }        int[][] opt1 = new int[n][m];        int[][] opt2 = new int[n][m];        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                opt1[i][j] = a[i][j];                opt2[i][j] = a[i][j];            }        }         opt1[ip][jp] = 1;        opt2[ip][jp] = -1;        recur(opt1, ip+1, jp, k);        recur(opt2, ip+1, jp, k);    }     static long binpow(long a, long b, long m) {        a %= m;        long res = 1;        while (b > 0) {            if (b % 2 == 1)                res = res * a % m;            a = a * a % m;            b >>= 1;        }        return res;    }} /*  */
