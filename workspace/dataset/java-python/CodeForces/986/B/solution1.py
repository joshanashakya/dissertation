#Code by Sounak, IIESTS#------------------------------warmup---------------------------- import osimport sysimport mathfrom io import BytesIO, IOBasefrom fractions import Fractionimport collectionsfrom itertools import permutationsfrom collections import defaultdictfrom collections import dequeimport threading #sys.setrecursionlimit(300000)#threading.stack_size(10**8) BUFSIZE = 8192  class FastIO(IOBase):    newlines = 0        def __init__(self, file):        self._fd = file.fileno()        self.buffer = BytesIO()        self.writable = "x" in file.mode or "r" not in file.mode        self.write = self.buffer.write if self.writable else None         def read(self):        while True:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            if not b:                break            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines = 0        return self.buffer.read()     def readline(self):        while self.newlines == 0:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            self.newlines = b.count(b"\n") + (not b)            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines -= 1        return self.buffer.readline()     def flush(self):        if self.writable:            os.write(self._fd, self.buffer.getvalue())            self.buffer.truncate(0), self.buffer.seek(0)  class IOWrapper(IOBase):    def __init__(self, file):        self.buffer = FastIO(file)        self.flush = self.buffer.flush        self.writable = self.buffer.writable        self.write = lambda s: self.buffer.write(s.encode("ascii"))        self.read = lambda: self.buffer.read().decode("ascii")        self.readline = lambda: self.buffer.readline().decode("ascii")  sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)input = lambda: sys.stdin.readline().rstrip("\r\n") #-------------------------------------------------------------------------#mod = 9223372036854775807  class SegmentTree:    def __init__(self, data, default=-10**6, func=lambda a, b: max(a,b)):        """initialize the segment tree with data"""        self._default = default        self._func = func        self._len = len(data)        self._size = _size = 1 << (self._len - 1).bit_length()         self.data = [default] * (2 * _size)        self.data[_size:_size + self._len] = data        for i in reversed(range(_size)):            self.data[i] = func(self.data[i + i], self.data[i + i + 1])     def __delitem__(self, idx):        self[idx] = self._default     def __getitem__(self, idx):        return self.data[idx + self._size]     def __setitem__(self, idx, value):        idx += self._size        self.data[idx] = value        idx >>= 1        while idx:            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])            idx >>= 1     def __len__(self):        return self._len     def query(self, start, stop):        if start == stop:            return self.__getitem__(start)        stop += 1        start += self._size        stop += self._size         res = self._default        while start < stop:            if start & 1:                res = self._func(res, self.data[start])                start += 1            if stop & 1:                stop -= 1                res = self._func(res, self.data[stop])            start >>= 1            stop >>= 1        return res     def __repr__(self):        return "SegmentTree({0})".format(self.data)    class SegmentTree1:    def __init__(self, data, default=10**6, func=lambda a, b: min(a,b)):        """initialize the segment tree with data"""        self._default = default        self._func = func        self._len = len(data)        self._size = _size = 1 << (self._len - 1).bit_length()         self.data = [default] * (2 * _size)        self.data[_size:_size + self._len] = data        for i in reversed(range(_size)):            self.data[i] = func(self.data[i + i], self.data[i + i + 1])     def __delitem__(self, idx):        self[idx] = self._default     def __getitem__(self, idx):        return self.data[idx + self._size]     def __setitem__(self, idx, value):        idx += self._size        self.data[idx] = value        idx >>= 1        while idx:            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])            idx >>= 1     def __len__(self):        return self._len     def query(self, start, stop):        if start == stop:            return self.__getitem__(start)        stop += 1        start += self._size        stop += self._size         res = self._default        while start < stop:            if start & 1:                res = self._func(res, self.data[start])                start += 1            if stop & 1:                stop -= 1                res = self._func(res, self.data[stop])            start >>= 1            stop >>= 1        return res     def __repr__(self):        return "SegmentTree({0})".format(self.data)    MOD=10**9+7class Factorial:    def __init__(self, MOD):        self.MOD = MOD        self.factorials = [1, 1]        self.invModulos = [0, 1]        self.invFactorial_ = [1, 1]     def calc(self, n):        if n <= -1:            print("Invalid argument to calculate n!")            print("n must be non-negative value. But the argument was " + str(n))            exit()        if n < len(self.factorials):            return self.factorials[n]        nextArr = [0] * (n + 1 - len(self.factorials))        initialI = len(self.factorials)        prev = self.factorials[-1]        m = self.MOD        for i in range(initialI, n + 1):            prev = nextArr[i - initialI] = prev * i % m        self.factorials += nextArr        return self.factorials[n]     def inv(self, n):        if n <= -1:            print("Invalid argument to calculate n^(-1)")            print("n must be non-negative value. But the argument was " + str(n))            exit()        p = self.MOD        pi = n % p        if pi < len(self.invModulos):            return self.invModulos[pi]        nextArr = [0] * (n + 1 - len(self.invModulos))        initialI = len(self.invModulos)        for i in range(initialI, min(p, n + 1)):            next = -self.invModulos[p % i] * (p // i) % p            self.invModulos.append(next)        return self.invModulos[pi]     def invFactorial(self, n):        if n <= -1:            print("Invalid argument to calculate (n^(-1))!")            print("n must be non-negative value. But the argument was " + str(n))            exit()        if n < len(self.invFactorial_):            return self.invFactorial_[n]        self.inv(n)  # To make sure already calculated n^-1        nextArr = [0] * (n + 1 - len(self.invFactorial_))        initialI = len(self.invFactorial_)        prev = self.invFactorial_[-1]        p = self.MOD        for i in range(initialI, n + 1):            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p        self.invFactorial_ += nextArr        return self.invFactorial_[n]  class Combination:    def __init__(self, MOD):        self.MOD = MOD        self.factorial = Factorial(MOD)     def ncr(self, n, k):        if k < 0 or n < k:            return 0        k = min(k, n - k)        f = self.factorial        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MODmod=10**9+7omod=998244353#-------------------------------------------------------------------------prime = [True for i in range(200001)] pp=[0]*200001def SieveOfEratosthenes(n=200000):           # Create a boolean array "prime[0..n]" and initialize     #  all entries it as true. A value in prime[i] will     # finally be false if i is Not a prime, else true.         p = 2    while (p * p <= n):                   # If prime[p] is not changed, then it is a prime         if (prime[p] == True):                           # Update all multiples of p             for i in range(p * p, n+1, p):                 prime[i] = False        p += 1#---------------------------------running code------------------------------------------def mergeSort(arr, n):    # A temp_arr is created to store    # sorted array in merge function    temp_arr = [0]*n    return _mergeSort(arr, temp_arr, 0, n-1) # This Function will use MergeSort to count inversions def _mergeSort(arr, temp_arr, left, right):     # A variable inv_count is used to store    # inversion counts in each recursive call     inv_count = 0     # We will make a recursive call if and only if    # we have more than one elements     if left < right:         # mid is calculated to divide the array into two subarrays        # Floor division is must in case of python         mid = (left + right)//2         # It will calculate inversion         # counts in the left subarray         inv_count += _mergeSort(arr, temp_arr,                                     left, mid)         # It will calculate inversion         # counts in right subarray         inv_count += _mergeSort(arr, temp_arr,                                   mid + 1, right)         # It will merge two subarrays in         # a sorted subarray         inv_count += merge(arr, temp_arr, left, mid, right)    return inv_count # This function will merge two subarrays # in a single sorted subarraydef merge(arr, temp_arr, left, mid, right):    i = left     # Starting index of left subarray    j = mid + 1 # Starting index of right subarray    k = left     # Starting index of to be sorted subarray    inv_count = 0     # Conditions are checked to make sure that     # i and j don't exceed their    # subarray limits.     while i <= mid and j <= right:         # There will be no inversion if arr[i] <= arr[j]         if arr[i] <= arr[j]:            temp_arr[k] = arr[i]            k += 1            i += 1        else:            # Inversion will occur.            temp_arr[k] = arr[j]            inv_count += (mid-i + 1)            k += 1            j += 1     # Copy the remaining elements of left     # subarray into temporary array    while i <= mid:        temp_arr[k] = arr[i]        k += 1        i += 1     # Copy the remaining elements of right     # subarray into temporary array    while j <= right:        temp_arr[k] = arr[j]        k += 1        j += 1     # Copy the sorted subarray into Original array    for loop_var in range(left, right + 1):        arr[loop_var] = temp_arr[loop_var]             return inv_count n=int(input())a=list(map(int,input().split()))r=mergeSort(a, n)if r%2==(3*n)%2:    print("Petr")else:    print("Um_nik")
