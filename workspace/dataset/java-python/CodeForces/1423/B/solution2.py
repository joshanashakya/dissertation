import osimport

sysfrom
io
import BytesIO, \
    IOBase  # region fastioBUFSIZE = 8192class FastIO(IOBase):    newlines = 0     def __init__(self, file):        self._fd = file.fileno()        self.buffer = BytesIO()        self.writable = "x" in file.mode or "r" not in file.mode        self.write = self.buffer.write if self.writable else None     def read(self):        while True:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            if not b:                break            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines = 0        return self.buffer.read()     def readline(self):        while self.newlines == 0:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            self.newlines = b.count(b"\n") + (not b)            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines -= 1        return self.buffer.readline()     def flush(self):        if self.writable:            os.write(self._fd, self.buffer.getvalue())            self.buffer.truncate(0), self.buffer.seek(0)  class IOWrapper(IOBase):    def __init__(self, file):        self.buffer = FastIO(file)        self.flush = self.buffer.flush        self.writable = self.buffer.writable        self.write = lambda s: self.buffer.write(s.encode("ascii"))        self.read = lambda: self.buffer.read().decode("ascii")        self.readline = lambda: self.buffer.readline().decode("ascii")  sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)input = lambda: sys.stdin.readline().rstrip("\r\n") # ------------------------------ def RL(): return map(int, sys.stdin.readline().rstrip().split())def RLL(): return list(map(int, sys.stdin.readline().rstrip().split()))def N(): return int(input())def print_list(l):    print(' '.join(map(str,l)))# import sys# sys.setrecursionlimit(5010)# from heapq import *# from collections import deque as dq# from math import ceil,floor,sqrt,pow# import bisect as bs# from collections import Counterfrom collections import defaultdict as dc  def judge(last,key,d1,d2):    if key>last:        for (a,b,c) in data:            if last<c<=key:                d1[a].add(b)                d2[b].add(a)     else:        for (a,b,c) in data:            if key<c<=last:                d1[a].remove(b)                if not d1[a]:                    del d1[a]                d2[b].remove(a)                if not d2[b]:                    del d2[b]    if len(d1.keys())<n or len(d2.keys())<n:        return False     for a in d1:        lone = 0        for b in d1[a]:            if len(d2[b])==1:                lone+=1                if lone>1:                    return False    for b in d2:        lone = 0        for a in d2[b]:            if len(d1[a])==1:                lone+=1                if lone>1:                    return False             used = set()    for a in d1:        if a not in used:            s1,s2,now = {a},d1[a].copy(),d1[a].copy()            while now:                b = now.pop()                da = d2[b]-s1                 s1|=da                 for aa in da:                    db = d1[aa]-s2                    now|=db                    s2|=db            if len(s1)!=len(s2):                return False            used|=s1    return True  n,m = RL()data = []for _ in range(m):    data.append(tuple(map(int, sys.stdin.readline().split())))l,r = min(a[2] for a in data),max(a[2] for a in data)+1md = rlast = 0du = dc(set)dv = dc(set)while l<r:    key = (l+r)>>1    if judge(last,key,du,dv):        r = key    else:        l = key+1    last = keyif l>=md:    print(-1)else:    print(l)
