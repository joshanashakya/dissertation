import java.util.*;import java.io.*; public class CFA {  BufferedReader br;  PrintWriter out;  StringTokenizer st;  boolean eof;  private static final long MOD = 1000L * 1000L * 1000L + 7;  private static final int[] dx = {0, -1, 0, 1};  private static final int[] dy = {1, 0, -1, 0};  private static final String yes = "Yes";  private static final String no = "No";   void solve() {//    int T = nextInt();    int T = 1;    for (int i = 0; i < T; i++) {      helper();    }  }   // TODO: use Hopcroft–Karp Algorithm to find perfect matching.  int num;  int numPair;  int[] from;  int[] to;  int[] weight;  void helper() {    num = nextInt();    numPair = nextInt();    from = new int[numPair];    to = new int[numPair];    weight = new int[numPair];    List<Integer> ls = new ArrayList<>();    for (int i = 0; i < numPair; i++) {      from[i] = nextInt();      to[i] = nextInt();      weight[i] = nextInt();      ls.add(weight[i]);    }    Collections.sort(ls);    int low = 0;    int high = ls.size();    while (low < high) {      int mid = (low + high) / 2;      if (valid(ls.get(mid))) {        high = mid;      } else {        low = mid + 1;      }    }    outln(low == ls.size() ? -1 : ls.get(low));  }   boolean valid(long f) {    HopcroftKarp hk = new HopcroftKarp(num, num);    for (int i = 0; i < numPair; i++) {      if (weight[i] <= f) {        hk.addEdge(from[i] - 1, to[i] - 1);      }    }    return hk.maxMatching() == num;  }   public class HopcroftKarp {    private static final int MAX_N1 = 10 * 1000 + 10;    private static final int MAX_N2 = 10 * 1000 + 10;    private static final int MAX_EDGES = 100 * 1000 + 10;    int n1, n2, edges;    int[] last;    int[] prev;    int[] head;    int[] matching;    int[] dist;    int[] Q;    boolean[] used;    boolean[] vis;     HopcroftKarp(int n1, int n2) {      this.n1 = n1;      this.n2 = n2;      edges = 0;       last = new int[MAX_N1];      prev = new int[MAX_EDGES];      head = new int[MAX_EDGES];      matching = new int[MAX_N2];      dist = new int[MAX_N1];      Q = new int[MAX_N1];      used = new boolean[MAX_N1];      vis = new boolean[MAX_N1];      Arrays.fill(last, -1);    }    void addEdge(int u, int v) {      head[edges] = v;      prev[edges] = last[u];      last[u] = edges++;    }    void bfs() {      Arrays.fill(dist, -1);      int sizeQ = 0;      for (int u = 0; u < n1; ++u) {        if (!used[u]) {          Q[sizeQ++] = u;          dist[u] = 0;        }      }      for (int i = 0; i < sizeQ; i++) {        int u1 = Q[i];        for (int e = last[u1]; e >= 0; e = prev[e]) {          int u2 = matching[head[e]];          if (u2 >= 0 && dist[u2] < 0) {            dist[u2] = dist[u1] + 1;            Q[sizeQ++] = u2;          }        }      }    }     boolean dfs(int u1) {      vis[u1] = true;      for (int e = last[u1]; e >= 0; e = prev[e]) {        int v = head[e];        int u2 = matching[v];        if (u2 < 0 || !vis[u2] && dist[u2] == dist[u1] + 1 && dfs(u2)) {          matching[v] = u1;          used[u1] = true;          return true;        }      }      return false;    }     int maxMatching() {      Arrays.fill(used, false);      Arrays.fill(matching, -1);      for (int res = 0;;) {        bfs();        Arrays.fill(vis, false);        int f = 0;        for (int u = 0; u < n1; ++u) {          if (!used[u] && dfs(u)) {            f++;          }        }        if (f == 0) {          return res;        }        res += f;      }    }  }   void shuffle(int[] a) {    int n = a.length;    for(int i = 0; i < n; i++) {      int r = i + (int) (Math.random() * (n - i));      int tmp = a[i];      a[i] = a[r];      a[r] = tmp;    }  }   long gcd(long a, long b) {    while(a != 0 && b != 0) {      long c = b;      b = a % b;      a = c;    }    return a + b;  }  int gcd(int a, int b) {    while(a != 0 && b != 0) {      int c = b;      b = a % b;      a = c;    }    return a + b;  }  private void outln(Object o) {    out.println(o);  }  private void out(Object o) {    out.print(o);  }  private void formatPrint(double val) {    outln(String.format("%.9f", val));  }  public CFA() {    br = new BufferedReader(new InputStreamReader(System.in));    out = new PrintWriter(System.out);    solve();    out.close();  }  public static void main(String[] args) {    new CFA();  }  public long[] nextLongArr(int n) {    long[] res = new long[n];    for(int i = 0; i < n; i++)      res[i] = nextLong();    return res;  }  public int[] nextIntArr(int n) {    int[] res = new int[n];    for(int i = 0; i < n; i++)      res[i] = nextInt();    return res;  }  public String nextToken() {    while (st == null || !st.hasMoreTokens()) {      try {        st = new StringTokenizer(br.readLine());      } catch (Exception e) {        eof = true;        return null;      }    }    return st.nextToken();  }  public String nextString() {    try {      return br.readLine();    } catch (IOException e) {      eof = true;      return null;    }  }  public int nextInt() {    return Integer.parseInt(nextToken());  }  public long nextLong() {    return Long.parseLong(nextToken());  }  public double nextDouble() {    return Double.parseDouble(nextToken());  }}
