import java.io.*;import java.util.*;     public class Solution {    private static int[] a;    private static long[][] dp;    private static final int mod = 1000000007;        public static void main(String[] args) throws Exception{         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        PrintWriter out = new PrintWriter(System.out);                int n = Integer.parseInt(br.readLine());                StringTokenizer st = new StringTokenizer(br.readLine());        int[] from = new int[n-1];        int[] to = new int[n-1];                for(int i=0;i<n-1;i++){            int u = Integer.parseInt(st.nextToken());            from[i] = u;            to[i] = i+1;        }                 int[][] g =  construct(n,from,to);        // Arrays.stream(g).forEach(e->System.out.println(Arrays.toString(e)));                  a = new int[n];         dp = new long[n][2];                  st = new StringTokenizer(br.readLine());         for(int i=0;i<n;i++)            a[i] = Integer.parseInt(st.nextToken());                      DFS(g,0,-1);           out.println(dp[0][1]);           out.close();            }         private static void DFS(int[][] g, int u,int p){          if(g[u].length == 1 && u!=0){               if(a[u] == 1) dp[u][1] = 1;               else dp[u][0] = 1;               return;          }                       for(int v: g[u]){               if(v == p)continue;                              DFS(g,v,u);               if(a[u] == 0){                    long ways = (dp[v][0]+dp[v][1])%mod;                    if(dp[u][0] == 0)                        dp[u][0] = ways;                    else                       dp[u][0] = (dp[u][0]*ways)%mod;               }               else{                    long ways = (dp[v][0]+dp[v][1])%mod;                    if(dp[u][1] == 0) dp[u][1] = ways;                    else dp[u][1] = (dp[u][1]*ways)%mod;               }          }                              if(dp[u][0] == 0 || a[u] == 1)                  return;                                 long totalWays = dp[u][0];                              for(int v: g[u]){                  if(v == p)continue;                                    long div = (dp[v][0]+dp[v][1])%mod;                   div = modInverse(div,mod);                  long ways = (totalWays*dp[v][1])%mod;                  ways = (ways*div)%mod;                                      dp[u][1] = (dp[u][1]+ways)%mod;             }    }            private static long modInverse(long a, long m) 	{ 		long m0 = m; 		long y = 0, x = 1;  		if (m == 1) 			return 0;  		while (a > 1) 		{ 			long q = a / m; 			long t = m; 			m = a % m; 			a = t; 			t = y; 			y = x - q * y; 			x = t; 		}  		if (x < 0) 			x += m0;  		return x; 	}         private static int[][] construct(int n, int[] from, int[] to) {  // Graph construction		int[][] g = new int[n][];		int[] p = new int[n];		for (int f : from)			p[f]++;		for (int t : to)			p[t]++;		for (int i = 0; i < n; i++)			g[i] = new int[p[i]];		for (int i = 0; i < from.length; i++) {			g[from[i]][--p[from[i]]] = to[i];			g[to[i]][--p[to[i]]] = from[i];		}		return g;    }}
