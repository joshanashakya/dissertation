import java.io.*;import java.util.*;import java.math.*;   public class Main {       public void solve() throws IOException{         int n = in.nextInt();        List<List<Integer>> count = new ArrayList<>();        for(int i = 0; i <= 100; i++){            count.add(new ArrayList<>());        }         for(int i = 0; i < 2 * n; i++){            int num = in.nextInt();            count.get(num).add(i);        }          List<Set<Integer>> ls = new ArrayList<>();        ls.add(new HashSet<>());        ls.add(new HashSet<>());        int cur = 0;        int[] visited = new int[2 * n];        for(int i = 10; i <= 99; i++){            List<Integer> cnt = count.get(i);            if(cnt.size() >= 2){                int n1 = cnt.get(0);                int n2 = cnt.get(1);                ls.get(0).add(i);                ls.get(1).add(i);                visited[n1] = 1;                visited[n2] = 2;            }else if(cnt.size() == 1){                int n1 = cnt.get(0);                ls.get(cur).add(i);                visited[n1] = cur + 1;                cur = 1 - cur;            }        }         for(int i = 10; i <= 99; i++){            List<Integer> cnt = count.get(i);            for(int j = 0; j < cnt.size(); j++){                if(visited[cnt.get(j)] == 0){                    ls.get(cur).add(i);                    visited[cnt.get(j)] = cur + 1;                    cur = 1 - cur;                }            }        }                out.println(ls.get(0).size() * ls.get(1).size());        for(int i = 0; i < 2 * n; i++){            out.print(visited[i] + " ");        }        return;     }     public BigInteger gcdBigInt(BigInteger a, BigInteger b){         if(a.compareTo(BigInteger.valueOf(0L)) == 0){            return b;        }else{            return gcdBigInt(b.mod(a), a);        }     }      FastScanner in;    PrintWriter out;     static class FastScanner {         BufferedReader br;        StringTokenizer st;         FastScanner(InputStream in) {            br = new BufferedReader(new InputStreamReader(in));            st = null;        }         String next() throws IOException {            while (st == null || !st.hasMoreTokens())                st = new StringTokenizer(br.readLine());            return st.nextToken();        }         String nextLine() throws IOException {            if (st == null || !st.hasMoreTokens())                return br.readLine();            StringBuilder result = new StringBuilder(st.nextToken());            while (st.hasMoreTokens()) {                result.append(" ");                result.append(st.nextToken());            }            return result.toString();        }         int nextInt() throws IOException {            return Integer.parseInt(next());        }         long nextLong() throws IOException {            return Long.parseLong(next());        }         double nextDouble() throws IOException {            return Double.parseDouble(next());        }     }     void run() throws IOException {        in = new FastScanner(System.in);        out = new PrintWriter(System.out, false);        solve();        out.close();    }     public static void main(String[] args) throws IOException{        new Main().run();    }     public void printArr(int[] arr){        for(int i = 0; i < arr.length; i++){            out.print(arr[i] + " ");        }        out.println();    }     public long gcd(long a, long b){        if(a == 0) return b;        return gcd(b % a, a);    }     public boolean isPrime(long num){         if(num == 0 || num == 1){            return false;        }         for(int i = 2; i * i <= num; i++){            if(num % i == 0){                return false;            }        }         return true;    }     public class Pair<A, B>{        public A x;         public B y;         Pair(A x, B y){            this.x = x;            this.y = y;        }         @Override        public boolean equals(Object o) {            if (this == o) return true;            if (o == null || getClass() != o.getClass()) return false;            Pair<?, ?> pair = (Pair<?, ?>) o;            if (!x.equals(pair.x)) return false;            return y.equals(pair.y);        }         @Override        public int hashCode() {            int result = x.hashCode();            result = 31 * result + y.hashCode();            return result;        }     }     class Tuple{        int x; int y; int z;        Tuple(int ix, int iy, int iz){            x = ix;            y = iy;            z = iz;        }    }}
