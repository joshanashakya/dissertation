import sys, os, iodef rs(): return sys.stdin.readline().rstrip()def ri(): return int(sys.stdin.readline())def ria(): return list(map(int, sys.stdin.readline().split()))def ws(s): sys.stdout.write(s + '\n')def wi(n): sys.stdout.write(str(n) + '\n')def wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\n')import math,datetime,functools,itertools,operator,bisect,fractions,statisticsfrom collections import deque,defaultdict,OrderedDict,Counterfrom fractions import Fractionfrom decimal import Decimalfrom sys import stdoutfrom heapq import heappush, heappop, heapify ,_heapify_max,_heappop_max,nsmallest,nlargest# sys.setrecursionlimit(111111)  def main():      def rec(l,r):        pos=bisect.bisect(a,(a[r]+a[l])//2,l,r+1)        if l==r:            d[prefsum[r+1]-prefsum[l]]=1        else:            if l<r:                if pos<=r:                     rec(l,pos-1)                    rec(pos,r)                    d[prefsum[r+1]-prefsum[l]]=1    # mod=1000000007    # InverseofNumber(mod)    # InverseofFactorial(mod)    # factorial(mod)    starttime=datetime.datetime.now()    if(os.path.exists('input.txt')):        sys.stdin = open("input.txt","r")        sys.stdout = open("output.txt","w")             tc=ri()    for _ in range(tc):        n,x=ria()        s=rs()        n0=0        n1=0        cn0=[]        cn1=[]        ans=0        c=0        if 0==x:            ans+=1        for i in s:            if i=="0":                n0+=1            else:                n1+=1            cn0.append(n0)            cn1.append(n1)            if n0-n1==x:                c=1        delta=n0-n1        if delta==0:            if c==1:                wi(-1)            else:                wi(0)        elif delta!=0:            for i in range(n):                k=cn0[i]-cn1[i]                # k+delta*t==x                # t=(x-k)//delta                # delta should perfectly divide (x-k)                                if (x-k)%delta==0:                    t=(x-k)//delta                    if t>=0:                        ans+=1                            wi(ans)            continue                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #<--Solving Area Ends    endtime=datetime.datetime.now()    time=(endtime-starttime).total_seconds()*1000    if(os.path.exists('input.txt')):        print("Time:",time,"ms")                      class FastReader(io.IOBase):    newlines = 0     def __init__(self, fd, chunk_size=1024 * 8):        self._fd = fd        self._chunk_size = chunk_size        self.buffer = io.BytesIO()     def read(self):        while True:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size))            if not b:                break            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines = 0        return self.buffer.read()     def readline(self, size=-1):        while self.newlines == 0:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, self._chunk_size if size == -1 else size))            self.newlines = b.count(b"\n") + (not b)            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines -= 1        return self.buffer.readline()  class FastWriter(io.IOBase):     def __init__(self, fd):        self._fd = fd        self.buffer = io.BytesIO()        self.write = self.buffer.write     def flush(self):        os.write(self._fd, self.buffer.getvalue())        self.buffer.truncate(0), self.buffer.seek(0)  class FastStdin(io.IOBase):    def __init__(self, fd=0):        self.buffer = FastReader(fd)        self.read = lambda: self.buffer.read().decode("ascii")        self.readline = lambda: self.buffer.readline().decode("ascii")  class FastStdout(io.IOBase):    def __init__(self, fd=1):        self.buffer = FastWriter(fd)        self.write = lambda s: self.buffer.write(s.encode("ascii"))        self.flush = self.buffer.flush  if __name__ == '__main__':    sys.stdin = FastStdin()    sys.stdout = FastStdout()    main()    
