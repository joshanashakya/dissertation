#10Bdef solve():	# n requests, k rows and seats on each row    n, k = map(int, input().split())	# succesive seats    group = map(int, input().split())	# make map with available seats    available = [[k, 1][:] for i in range(k + 1)]    center = (k + 1) // 2	# for each request    for m in group:        closest, best_row, best_col = 10000, -1, -1		# search places in each row        for row in range(1, k + 1):            col = 0			# if didn't fit, skip row            if available[row][0] < m and k - available[row][1] + 1 < m:                continue							# if all empty choose center column            if available[row][0] == k:                col = center - m // 2			# else if fit in row, take seats            elif center - available[row][0] <= available[row][1] - center:                col = available[row][0] - m + 1            else:                col = available[row][1]							# compute distance to the screen            distance = calc_distance(center, row, col, m)            if distance < closest:                closest = distance                best_row = row                best_col = col						# if didn't found places        if closest == 10000:            print(-1)        else:            print(best_row, best_col, best_col + m - 1)            available[best_row][0] = min(available[best_row][0], best_col - 1)            available[best_row][1] = max(available[best_row][1], best_col + m)  def calc_distance(center, row, col, num):    end_col = col + num - 1    distance = abs(center - row) * num	    if col >= center:        distance += (col - center) * num + (num - 1) * num // 2    elif end_col <= center:        distance += (center - end_col) * num + (num - 1) * num // 2    else:        distance += ((center - col) * (center - col + 1) // 2 +                     (end_col - center) * (end_col - center + 1) // 2)    return distance  solve()
