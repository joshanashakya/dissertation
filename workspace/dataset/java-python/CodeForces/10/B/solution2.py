#10Bdef solve():	# n - requests, k - rows and seats on each row    n, k = map(int, input().split())	#We group succesive seats:    group = map(int, input().split())	#Now, we elaborate a map with available seats    available = [[k, 1][:] for i in range(k + 1)]    center = (k + 1) // 2	#For each request:    for m in group:        closest, best_row, best_col = 10000, -1, -1		#We look through seats in each row:        for row in range(1, k + 1):            col = 0			#If it doesn't fit the request, the program skips the row:            if available[row][0] < m and k - available[row][1] + 1 < m:                continue							#If all of them are empty, we choose the central column:            if available[row][0] == k:                col = center - m // 2			#Else, if the available seats in row match the request, we mark down the seats:            elif center - available[row][0] <= available[row][1] - center:                col = available[row][0] - m + 1            else:                col = available[row][1]							#We compute the distance to the screen:            distance = calc_distance(center, row, col, m)            if distance < closest:                closest = distance                best_row = row                best_col = col						#If we didn't find available seats:        if closest == 10000:            print(-1)        else:            print(best_row, best_col, best_col + m - 1)            available[best_row][0] = min(available[best_row][0], best_col - 1)            available[best_row][1] = max(available[best_row][1], best_col + m)  def calc_distance(center, row, col, num):    end_col = col + num - 1    distance = abs(center - row) * num	    if col >= center:        distance += (col - center) * num + (num - 1) * num // 2    elif end_col <= center:        distance += (center - end_col) * num + (num - 1) * num // 2    else:        distance += ((center - col) * (center - col + 1) // 2 +                     (end_col - center) * (end_col - center + 1) // 2)    return distance  solve()
