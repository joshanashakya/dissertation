import java.io.OutputStream;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.util.Arrays;import java.io.IOException;import java.io.InputStreamReader;import java.util.Stack;import java.util.List;import java.util.Vector;import java.util.StringTokenizer;import java.io.BufferedReader;import java.util.Comparator;import java.util.Collections;import java.io.InputStream; /** * Built using CHelper plug-in * Actual solution is at the top */public class Main {    public static void main(String[] args) {        InputStream inputStream = System.in;        OutputStream outputStream = System.out;        ReaderFastIO in = new ReaderFastIO(inputStream);        PrintWriter out = new PrintWriter(outputStream);        BPolygons solver = new BPolygons();        solver.solve(1, in, out);        out.close();    }     static class BPolygons {        public void solve(int testNumber, ReaderFastIO in, PrintWriter out) {             int n = in.nextInt();            List<Point2D> polygonA = new Vector<>();             for (int i = 0; i < n; i++) {                polygonA.add(new Point2D(in.nextInt(), in.nextInt()));            }             int m = in.nextInt();             List<Point2D> polygonB = new Vector<>();            for (int i = 0; i < m; i++) {                polygonB.add(new Point2D(in.nextInt(), in.nextInt()));            }             Vector<Point2D> polygonC = new Vector<>();             for (Point2D p : polygonB) {                if (p.onSegment(polygonA.get(0), polygonA.get(polygonA.size() - 1))) {                    polygonC.add(p);                } else if (p.onSegment(polygonA.get(0), polygonA.get(1))) {                    polygonC.add(p);                }            }             polygonB.addAll(polygonA);            GrahamScan gs = new GrahamScan(polygonB.toArray(new Point2D[]{}));             for (Point2D p : gs.hull()) {                polygonC.add(p);            }             if (polygonA.size() != polygonC.size()) {                out.println("NO");                return;            }             Collections.sort(polygonA, (x, y) -> x.compareTo(y));            Collections.sort(polygonC, (x, y) -> x.compareTo(y));             boolean ok = true;             for (int i = 0; i < n; i++) {                if (polygonA.get(i).equals(polygonC.get(i)) == false) {                    ok = false;                }            }             out.println(ok == true ? "YES" : "NO");        }     }     static class ReaderFastIO {        BufferedReader br;        StringTokenizer st;         public ReaderFastIO() {            br = new BufferedReader(new InputStreamReader(System.in));        }         public ReaderFastIO(InputStream input) {            br = new BufferedReader(new InputStreamReader(input));        }         public String next() {            while (st == null || !st.hasMoreElements()) {                try {                    st = new StringTokenizer(br.readLine());                } catch (IOException e) {                    e.printStackTrace();                }            }            return st.nextToken();        }         public int nextInt() {            return Integer.parseInt(next());        }     }     static class GrahamScan {        private Stack<Point2D> hull = new Stack<Point2D>();         public GrahamScan(Point2D[] points) {            if (points == null) throw new IllegalArgumentException("argument is null");            if (points.length == 0) throw new IllegalArgumentException("array is of length 0");             // defensive copy            int n = points.length;            Point2D[] a = new Point2D[n];            for (int i = 0; i < n; i++) {                if (points[i] == null)                    throw new IllegalArgumentException("points[" + i + "] is null");                a[i] = points[i];            }             // preprocess so that a[0] has lowest y-coordinate; break ties by x-coordinate            // a[0] is an extreme point of the convex hull            // (alternatively, could do easily in linear time)            Arrays.sort(a);             // sort by polar angle with respect to base point a[0],            // breaking ties by distance to a[0]            Arrays.sort(a, 1, n, a[0].polarOrder());             hull.push(a[0]);       // a[0] is first extreme point            hull.push(a[1]);             // Graham scan; note that a[n-1] is extreme point different from a[0]            for (int i = 2; i < n; i++) {                Point2D top = hull.pop();                 while (Point2D.ccw(hull.peek(), top, a[i]) < 0) {                     top = hull.pop();                 }                hull.push(top);                hull.push(a[i]);             }             assert isConvex();        }         public Iterable<Point2D> hull() {            Stack<Point2D> s = new Stack<Point2D>();            for (Point2D p : hull) s.push(p);            return s;        }         private boolean isConvex() {            int n = hull.size();            if (n <= 2) return true;             Point2D[] points = new Point2D[n];            int k = 0;            for (Point2D p : hull()) {                points[k++] = p;            }             for (int i = 0; i < n; i++) {                if (Point2D.ccw(points[i], points[(i + 1) % n], points[(i + 2) % n]) <= 0) {                    return false;                }            }            return true;        }     }     static final class Point2D implements Comparable<Point2D> {        private final double x;        private final double y;         public Point2D(double x, double y) {            if (Double.isInfinite(x) || Double.isInfinite(y))                throw new IllegalArgumentException("Coordinates must be finite");            if (Double.isNaN(x) || Double.isNaN(y))                throw new IllegalArgumentException("Coordinates cannot be NaN");            if (x == 0.0) this.x = 0.0;  // convert -0.0 to +0.0            else this.x = x;             if (y == 0.0) this.y = 0.0;  // convert -0.0 to +0.0            else this.y = y;        }         public static int ccw(Point2D a, Point2D b, Point2D c) {            double area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);            if (area2 < 0) return -1;            else if (area2 > 0) return +1;            else return 0;        }         public int compareTo(Point2D that) {            if (this.y < that.y) return -1;            if (this.y > that.y) return +1;            if (this.x < that.x) return -1;            if (this.x > that.x) return +1;            return 0;        }         public Comparator<Point2D> polarOrder() {            return new PolarOrder();        }         public boolean equals(Object other) {            if (other == this) return true;            if (other == null) return false;            if (other.getClass() != this.getClass()) return false;            Point2D that = (Point2D) other;            return this.x == that.x && this.y == that.y;        }         public String toString() {            return "(" + x + ", " + y + ")";        }         public int hashCode() {            int hashX = ((Double) x).hashCode();            int hashY = ((Double) y).hashCode();            return 31 * hashX + hashY;        }         public boolean onSegment(Point2D pi, Point2D pj) {             if (ccw(this, pi, pj) != 0) return false;             if (Math.min(pi.x, pj.x) <= x && x <= Math.max(pi.x, pj.x) && Math.min(pi.y, pj.y) <= y && y <= Math.max(pi.y, pj.y))                return true;             return false;        }         private class PolarOrder implements Comparator<Point2D> {            public int compare(Point2D q1, Point2D q2) {                double dx1 = q1.x - x;                double dy1 = q1.y - y;                double dx2 = q2.x - x;                double dy2 = q2.y - y;                 if (dy1 >= 0 && dy2 < 0) return -1;    // q1 above; q2 below                else if (dy2 >= 0 && dy1 < 0) return +1;    // q1 below; q2 above                else if (dy1 == 0 && dy2 == 0) {            // 3-collinear and horizontal                    if (dx1 >= 0 && dx2 < 0) return -1;                    else if (dx2 >= 0 && dx1 < 0) return +1;                    else return 0;                } else return -ccw(Point2D.this, q1, q2);     // both above or below                 // Note: ccw() recomputes dx1, dy1, dx2, and dy2            }         }     }} 
