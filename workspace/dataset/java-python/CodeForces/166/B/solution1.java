import java.io.*;import java.util.ArrayDeque;import java.util.Arrays;import java.util.StringTokenizer; public class Polygons {     public static void main(String[] args) throws IOException {         FastReader reader = new FastReader();        FastWriter writer = new FastWriter();        int n = reader.readSingleInt();         int[][] points = new int[n][2];        for(int i = 0; i<n; i++){            points[i] = reader.readIntArray(2);        }         int[][][] convexHullHalves = getConvexHull(points);         //for(int i = 0; i<convexHullHalves[1].length; i++){            //System.out.println(convexHullHalves[1][i][0] + " "+ convexHullHalves[1][i][1]);        //}        int m = reader.readSingleInt();        int[][] b = new int[m][2];        for(int i = 0; i<m; i++){            b[i] = reader.readIntArray(2);        }         boolean inside = true;        for(int i = 0; i<m; i++){            inside = checkInside(convexHullHalves, b[i]);            if(!inside){                break;            }        }        if(inside){            writer.writeString("YES");        } else{            writer.writeString("NO");        }     }     public static boolean checkInside(int[][][] convexHullHalves, int[] point) {         int[][] top = convexHullHalves[0];        int[][] bottom = convexHullHalves[1];         int l = binarySearch(bottom, point);        if (l >= bottom.length - 1 || point[0] <= bottom[0][0]) return false;        int[] a = bottom[l];        int[] b = bottom[l + 1];        int turn = turn(a, b, point);         if (turn == -1 || turn == 0) {            return false;        }          l = binarySearch(top, point);        if(l >= top.length -1 || point[0] <= top[0][0]) return false;        a = top[l];        b = top[l + 1];        turn = turn(a, b, point);         if(turn == 1 || turn == 0) {            return false;        }         return true;    }     public static int binarySearch(int[][] hull, int[] point){        //System.out.println(" aids " + point[0] +" "+ point[1]);        int l = 0, r = hull.length - 1;        int candidate = l;        while (l < r) {            int middle = l + (r - l) / 2;            if (hull[middle][0] < point[0]) {                candidate = middle;                l = middle + 1;            } else {                r = middle - 1;            }        }        //System.out.println(hull[l][0] + " a " + point[0] +" "+ point[1]);        if(hull[l][0] <= point[0]){            return l;        }        //System.out.println("c "+ candidate);        return candidate;    }      //No three points can be collinear for this.    public static int[][][] getConvexHull (int[][] points){        if (points.length <= 2) {            return new int[0][0][0];        }         Arrays.sort(points, (a, b) -> {            if (a[0] < b[0]) {                return -1;            } else if (a[0] == b[0]) {                return a[0] - b[0];            } else {                return 1;            }        });         ArrayDeque<int[]> stack = new ArrayDeque<>();         //Get the bottom half of the hull;        stack.addLast(points[0]);        stack.addLast(points[1]);         for (int i = 2; i < points.length; i++) {             int[] next = points[i];            int[] previous = stack.removeLast();            while (stack.peek() != null && turn(stack.peek(), previous, next) <= 0) {                previous = stack.removeLast();            }            stack.addLast(previous);            stack.addLast(next);        }         int[][] bottom = new int[stack.size()][2];        int stackSize = stack.size();        for (int i = 0; i < stackSize; i++) {            bottom[i] = stack.removeFirst();        }          //Get the top of the hull        stack.addLast(points[0]);        stack.addLast(points[1]);         for (int i = 2; i < points.length; i++) {             int[] next = points[i];            int[] previous = stack.removeLast();            while (stack.peek() != null && turn(stack.peek(), previous, next) >= 0) {                previous = stack.removeLast();            }            stack.addLast(previous);            stack.addLast(next);        }         int[][] top = new int[stack.size()][2];        stackSize = stack.size();        for (int i = 0; i < stackSize; i++) {            top[i] = stack.removeFirst();        }         return new int[][][]{top, bottom};     }      //[x][y]    public static int turn(int[] pA, int[] pB, int[] pC){        long area = (long)(pB[0]-pA[0])*(long)(pC[1]-pA[1]) - (long)(pB[1]-pA[1])*(long)(pC[0]-pA[0]);        //System.out.println("pA: " + pA[0] + " "+  pA[1] + " pB: " + pB[0] + " " + pB[1] + " pC: " + pC[0] + " "+ pC[1]);         if(area < 0) {            return -1; //Clockwise turn        }        if(area > 0) {            return 1; //Anti-clockwise turn;        }        //System.out.println("FUCKKKKKK");        return 0;    }        public static void mergeSort(int[] a, int n) {        if (n < 2) {            return;        }        int mid = n / 2;        int[] l = new int[mid];        int[] r = new int[n - mid];         for (int i = 0; i < mid; i++) {            l[i] = a[i];        }        for (int i = mid; i < n; i++) {            r[i - mid] = a[i];        }        mergeSort(l, mid);        mergeSort(r, n - mid);         merge(a, l, r, mid, n - mid);    }      public static void merge(int[] a, int[] l, int[] r, int left, int right) {         int i = 0, j = 0, k = 0;        while (i < left && j < right) {            if (l[i] <= r[j]) {                a[k++] = l[i++];            }            else {                a[k++] = r[j++];            }        }        while (i < left) {            a[k++] = l[i++];        }        while (j < right) {            a[k++] = r[j++];        }    }      public static class FastReader {         BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));        StringTokenizer tokenizer;          public int readSingleInt() throws IOException {            return Integer.parseInt(reader.readLine());        }         public int[] readIntArray(int numInts) throws IOException {            int[] nums = new int[numInts];            tokenizer = new StringTokenizer(reader.readLine());            for(int i = 0; i<numInts; i++){                nums[i] = Integer.parseInt(tokenizer.nextToken());            }            return nums;        }         public String readString() throws IOException {            return reader.readLine();        }     }       public static class FastWriter {         BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));          public void writeSingleInteger(int i) throws IOException {            writer.write(Integer.toString(i));            writer.newLine();            writer.flush();        }         public void writeSingleLong(long i) throws IOException {            writer.write(Long.toString(i));            writer.newLine();            writer.flush();        }         public void writeIntArrayWithSpaces(int[] nums) throws IOException {            for(int i = 0; i<nums.length; i++){                writer.write(nums[i] + " ");            }            writer.newLine();            writer.flush();        }         public void writeIntArrayWithoutSpaces(int[] nums) throws IOException {            for(int i = 0; i<nums.length; i++){                writer.write(Integer.toString(nums[i]));            }            writer.newLine();            writer.flush();        }         public void writeString(String s) throws IOException {            writer.write(s);            writer.newLine();            writer.flush();        }     }}
