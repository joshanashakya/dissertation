//    A Computer is Like a mischievous genie.//    It will give you exactly what you ask for,//    but not always what you want//    A code by Rahul Verma   import java.io.BufferedOutputStream;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Comparator;import java.util.HashMap;import java.util.HashSet;import java.util.LinkedList;import java.util.Queue;import java.util.Set; import java.util.Stack;import java.util.StringTokenizer;import java.util.TreeMap;   public class Main {     public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));   static class FastReader {     BufferedReader br;    StringTokenizer st;     public FastReader() {      br = new BufferedReader(new          InputStreamReader(System.in));    }     String next() {      while (st == null || !st.hasMoreElements()) {        try {          st = new StringTokenizer(br.readLine());        } catch (IOException e) {          e.printStackTrace();        }      }      return st.nextToken();    }     int nextInt() {      return Integer.parseInt(next());    }     long nextLong() {      return Long.parseLong(next());    }     double nextDouble() {      return Double.parseDouble(next());    }     String[] nextSArray() {      String sr[] = null;      try {        sr = br.readLine().trim().split(" ");      } catch (IOException e) {        e.printStackTrace();      }      return sr;    }     String nextLine() {      String str = "";      try {        str = br.readLine();      } catch (IOException e) {        e.printStackTrace();      }       return str;    }  }    static long powmodulo(long a, long p) {    if (p == 0)      return 1 % mod;    if (p == 1)      return a % mod;    long ans = 1;    while (p > 0) {      if ((p & 1) > 0) {        ans = (ans * a) % mod;      }      a = (a * a) % mod;      p = p >> 1;    }    return ans % mod;  }      static long mod = 1000000007;   static long gcd(long a,long b)  {    if(a==0)      return b;    return  gcd(b%a,a);  }   static long fast_powerNumbers(long a,long n)  {    if(n==1)      return a;    long ans=fast_powerNumbers(a,n/2);    if(n%2==0)      return (ans*ans);    else      return ((ans*ans)*(a));  }     static void dfs_helper(int [][] arr,int i,int j,int team,int n,int m)  {    arr[i][j]=team;    if(i-1>=0 && arr[i-1][j]==1)      dfs(arr,i-1,j,team,n,m);    if(j-1>=0 && arr[i][j-1]==1)      dfs(arr,i,j-1,team,n,m);    if(i+1< n && arr[i+1][j]==1)      dfs(arr,i+1,j,team,n,m);    if(j+1<m && arr[i][j+1]==1)      dfs(arr,i,j+1,team,n,m);   }   static void dfs(int [][] arr,int i,int j,int team,int n,int m)  {    dfs_helper(arr,i,j,team,n,m);   }     public static void merge(int arr1[], int arr2[], int n, int m) {    // code here     int last = arr1[n-1];    int b=m-1;    while(b>0 && arr2[b]>last)    {      --b;     }    for(int i=b;i>=0;--i)    {      last=arr1[n-1];      int j=n-2;      for(;j>=0;--j)      {        if(arr2[i]<arr1[j])        {          arr1[j+1]=arr1[j];        }        else          break;      }      if(j==-1)        arr1[0]=arr2[i];      else        arr1[j+1]=arr2[i];      arr2[i]=last;       //System.out.println(Arrays.toString(arr1));      //System.out.println(Arrays.toString(arr2));    }     }   public static boolean col(Point a,Point b,Point c)  {    long s1=(c.x-b.x)*(b.y-a.y) ;    long s2 = (c.y-b.y)*(b.x-a.x);    if(s1==s2)      return true;    else      return false;  } public static boolean cw(Point a,Point b,Point c){  long s1=(c.x-b.x)*(b.y-a.y) ;  long s2 = (c.y-b.y)*(b.x-a.x);  if(s1<=s2)    return false;  else    return true; }  public static boolean ccw(Point a,Point b,Point c)  {    long s1=(c.x-b.x)*(b.y-a.y) ;    long s2 = (c.y-b.y)*(b.x-a.x);    if(s1<s2)      return true;    else      return false;   }static boolean Fun(ArrayList<Point>al,ArrayList<Point>B){  if(al.size()<=2)    return false;  int n=al.size();  Point p1=al.get(0);  Point p2 = al.get(al.size()-1);  ArrayList<Point>up=new ArrayList<>();  ArrayList<Point>down=new ArrayList<>();  up.add(p1);  down.add(p1);   for (int i = 1; i <n ; i++) {    Point p=al.get(i);    if(i==n-1||!ccw(p1,al.get(i),p2))    {      while(up.size()>=2 &&  ccw(up.get(up.size()-2),up.get(up.size()-1),p))        up.remove(up.size()-1);      up.add(p);    }    if(i==n-1||!cw(p1,al.get(i),p2))    {      while(down.size()>=2 &&  cw(down.get(down.size()-2),down.get(down.size()-1),p))        down.remove(down.size()-1);      down.add(p);    }  }   Set<Point>setup=new HashSet<>(up);  Set<Point>setdown=new HashSet<>(down);    boolean ans=true;  for (int i = 0; i <B.size() ; i++) {        if(setup.contains(B.get(i))||setdown.contains(B.get(i)))        {          ans=false;          break;        }   }  return ans;}    public static void main(String[] args) throws Exception {    FastReader sc = new FastReader();  //    int t1=sc.nextInt();//      for (int t = 0; t < t1 ; t++) {////////      }out.close();    int n=sc.nextInt();    ArrayList<Point>al=new ArrayList<>();    ArrayList<Point>B=new ArrayList<>();    for (int i = 0; i < n; i++) {      Point p=new Point(sc.nextInt(),sc.nextInt());      al.add(p);    }    int m=sc.nextInt();    for (int i = 0; i < m; i++) {      Point p=new Point(sc.nextInt(),sc.nextInt());      al.add(p);      B.add(p);    }    Collections.sort(al, new Comparator<Point>() {      @Override      public int compare(Point o1, Point o2) {        if(o1.x==o2.x)          return Long.compare(o1.y,o2.y);        return Long.compare(o1.x,o2.x);      }    });    boolean ans=Fun(al,B);    if (ans)      System.out.println("YES");    else {      System.out.println("NO");    }   }}   class Point    {      long x,y;      Point(long x,long y)      {        this.x=x;        this.y=y;      }    }  class DSU{  int parent[],rank[];  DSU(int n)  {    parent=new int[n];    rank=new int[n];    for (int i = 0; i <n ; i++) {      parent[i]=-1;      rank[i]=1;    }  }   int find(int s1)  {    if(parent[s1]==-1)      return s1;     parent[s1]=find(parent[s1]);    return parent[s1];  }   void unite(int s1,int s2)  {     int p1 = find(s1);    int p2=find(s2);    if(rank[s1]>rank[s2])    {      parent[p2]=find(p1);      rank[p1]+=rank[p2];    }else    {      parent[p1]=p2;      rank[p2]+=rank[p1];    }  } } class Pair{  int a; int b;  Pair(int a,int b)  {    this.a=a;    this.b=b;  }}  class Graph{  HashMap<Integer,ArrayList<Integer>>hm;  Graph()  {    hm=new HashMap<>();  }  Graph(int n){     hm=new HashMap<>();    for (int i = 0; i <n ; i++) {      hm.put(i,new ArrayList<Integer>());    }  }  // function for adding an edge.................................................  public void addEdge(int a,int b,boolean isDir)  {    if(isDir)    {      if(hm.containsKey(a))      {        hm.get(a).add(b);      }      else      {        hm.put(a,new ArrayList<>(Arrays.asList(b)));      }    }    else    {      if(hm.containsKey(a))      {        hm.get(a).add(b);      }      else if(!hm.containsKey(a))      {        hm.put(a,new ArrayList<>(Arrays.asList(b)));      }       if(hm.containsKey(b))      {        hm.get(b).add(a);      }      else if(!hm.containsKey(b))      {        hm.put(b,new ArrayList<>(Arrays.asList(a)));      }    }  }   }   // out.println(al.toString().replaceAll("[\\[|\\]|,]",""));
