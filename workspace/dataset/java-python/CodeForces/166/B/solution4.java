import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.Map;import java.util.StringTokenizer;import java.util.TreeMap; /* * To change this license header, choose License Headers in Project Properties. * To change this template file, choose Tools | Templates * and open the template in the editor. *//** * * @author Andy Phan */public class b {     public static void main(String[] args) {        FS in = new FS(System.in);        PrintWriter out = new PrintWriter(System.out);         int n = in.nextInt();        VecL[] a = new VecL[n];                for(int i = 0; i < n; i++) a[i] = new VecL(in.nextInt(), in.nextInt());                TreeMap<Long, SegL> upper = new TreeMap<>();        TreeMap<Long, SegL> lower = new TreeMap<>();                for(int i = 0; i < n; i++) {            SegL seg = new SegL(a[i], a[(i+1)%n]);            if(a[i].x < a[(i+1)%n].x || (a[i].x == a[(i+1)%n].x && a[i].y > a[(i+1)%n].y)) upper.put(a[i].x, seg);            else lower.put(a[i].x, seg);        }                int m = in.nextInt();        for(int i = 0; i < m; i++) {            VecL vec = new VecL(in.nextInt(), in.nextInt());            Map.Entry<Long, SegL> upperE = upper.floorEntry(vec.x);            Map.Entry<Long, SegL> lowerE = lower.ceilingEntry(vec.x);            if(upperE == null || upperE.getValue().side(vec) != -1) {                System.out.println("NO");                return;            }            if(lowerE == null || lowerE.getValue().side(vec) != -1) {                System.out.println("NO");                return;            }        }                System.out.println("YES");         out.close();    }     static class SegL {         VecL from, to, dir;         public SegL(VecL from, VecL to) {            this.from = from;            this.to = to;            dir = to.sub(from);        }         //check if the segment contains the point        public boolean contains(VecL p) {            VecL d = p.sub(from);            if (d.cross(dir) != 0) {                return false;            }            long dot = d.dot(dir);            return dot >= 0 && dot <= dir.mag2();        }         //(assuming I go left to right)        //returns:        //	1 if point is above me        //	0 if point is on me        //	-1 if point is below me        public long side(VecL o) {            long cross = dir.cross(o.sub(from));            return cross == 0 ? 0 : cross / Math.abs(cross);        }         //returns true if this segl intersects the other, including at endpoints        //note: returns false if the two segments lie on the same line        public boolean intersects(SegL o) {            return side(o.from) != side(o.to) && o.side(from) != o.side(to);        }         public String toString() {            return from + " -> " + to;        }         //#        static long gcd(long a, long b) {            a = Math.abs(a);            b = Math.abs(b);            return b == 0 ? a : gcd(b, a % b);        }        //$         //returns the lattice point of intersection or null if it is nonlattice or does not exist         public VecL latticeIntersect(SegL o) {            if (!intersects(o)) {                return null;            }            long dirGCD = gcd(dir.x, dir.y), oDirGCD = gcd(o.dir.x, o.dir.y);            VecL va= new VecL(dir.x / dirGCD, dir.y / dirGCD), vb = new VecL(o.dir.x / oDirGCD, o.dir.y / oDirGCD);            if (va.x < 0 && va.y < 0) {                va.x *= -1;                va.y *= -1;            }            if (vb.x < 0 && vb.y < 0) {                vb.x *= -1;                vb.y *= -1;            }            if (va.equals(vb)) {                return null;            }            long bottomScalar = va.x / gcd(va.x, va.y);            long topScalar = va.y / gcd(va.x, va.y);            long t2Scalar = -bottomScalar * vb.y + topScalar * vb.x;            long t2Ans = bottomScalar * (o.from.y - from.y) - topScalar * (o.from.x - from.x);            if (t2Ans % t2Scalar != 0) {                return null;            }            long t2 = t2Ans / t2Scalar;            return new VecL(t2 * vb.x + o.from.x, t2 * vb.y + o.from.y);        }    }     static class VecL implements Comparable<VecL> {         long x, y;         public VecL(long x, long y) {            this.x = x;            this.y = y;        }         public VecL add(VecL o) {            return new VecL(x + o.x, y + o.y);        }         public VecL sub(VecL o) {            return new VecL(x - o.x, y - o.y);        }         public VecL scale(long s) {            return new VecL(x * s, y * s);        }         public long dot(VecL o) {            return x * o.x + y * o.y;        }         public long cross(VecL o) {            return x * o.y - y * o.x;        }         public long mag2() {            return dot(this);        }         public VecL rot90() {            return new VecL(-y, x);        }         public VecL rot270() {            return new VecL(y, -x);        }         public String toString() {            return "(" + x + ", " + y + ")";        }         public int hashCode() {            return Long.hashCode(x << 13 ^ (y * 57));        }         public boolean equals(Object oo) {            VecL o = (VecL) oo;            return x == o.x && y == o.y;        }         public int compareTo(VecL o) {            if (x != o.x) {                return Long.compare(x, o.x);            }            return Long.compare(y, o.y);        }         //origin->q1, axes-> quadrant in ccw direction        public int quadrant() {            if (x == 0 || y == 0) {                if (y == 0) {                    if (x >= 0) {                        return 1;                    } else {                        return 3;                    }                } else if (y >= 0) {                    return 2;                } else {                    return 4;                }            }            if (x > 0) {                if (y > 0) {                    return 1;                } else {                    return 4;                }            } else if (y > 0) {                return 2;            } else {                return 3;            }        }         public int radialCompare(VecL o) {            if (quadrant() == o.quadrant()) {                return -Long.signum(cross(o));            }            return Integer.compare(quadrant(), o.quadrant());        }    }     static class FS {         BufferedReader in;        StringTokenizer token;         public FS(InputStream str) {            in = new BufferedReader(new InputStreamReader(str));        }         public String next() {            if (token == null || !token.hasMoreElements()) {                try {                    token = new StringTokenizer(in.readLine());                } catch (IOException ex) {                }                return next();            }            return token.nextToken();        }         public int nextInt() {            return Integer.parseInt(next());        }    }}
