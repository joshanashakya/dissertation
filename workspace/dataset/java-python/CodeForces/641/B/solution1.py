import itertoolsimport bisectimport mathfrom collections import *import osimport sysfrom io import BytesIO, IOBase ii = lambda: int(input())lmii = lambda: list(map(int, input().split()))li = lambda: list(input())mii = lambda: map(int, input().split())msi = lambda: map(str, input().split())  def main():    n,m,q=mii()    qq=[]    for test in range(q):        pp=lmii()        qq.append(pp)    qq.reverse()    mat=[]    for i in range(n):        mat.append([0]*m)    for i in range(q):        lst = qq[i]        if lst[0] == 3:            mat[lst[1]-1][lst[2]-1] = lst[3]        elif lst[0] == 2:            d = deque([])            for k in range(n):                d.append(mat[k][lst[1]-1])            d.appendleft(d.pop())            for k in range(n):                mat[k][lst[1]-1]=d[k]        else:            d = deque([])            for k in range(m):                d.append(mat[lst[1]-1][k])            d.appendleft(d.pop())            for k in range(m):                mat[lst[1]-1][k] = d[k]    for i in range(n):        print(*mat[i])    pass  BUFSIZE = 8192  class FastIO(IOBase):    newlines = 0     def __init__(self, file):        self._fd = file.fileno()        self.buffer = BytesIO()        self.writable = "x" in file.mode or "r" not in file.mode        self.write = self.buffer.write if self.writable else None     def read(self):        while True:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            if not b:                break            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines = 0        return self.buffer.read()     def readline(self):        while self.newlines == 0:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            self.newlines = b.count(b"\n") + (not b)            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines -= 1        return self.buffer.readline()     def flush(self):        if self.writable:            os.write(self._fd, self.buffer.getvalue())            self.buffer.truncate(0), self.buffer.seek(0)  class IOWrapper(IOBase):    def __init__(self, file):        self.buffer = FastIO(file)        self.flush = self.buffer.flush        self.writable = self.buffer.writable        self.write = lambda s: self.buffer.write(s.encode("ascii"))        self.read = lambda: self.buffer.read().decode("ascii")        self.readline = lambda: self.buffer.readline().decode("ascii")  sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)input = lambda: sys.stdin.readline().rstrip("\r\n") if __name__ == "__main__":    main()
