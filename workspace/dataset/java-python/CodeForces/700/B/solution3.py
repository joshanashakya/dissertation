WHITE = 0GRAY = 1BLACK = 2 def dfs_iter(G,u=0):    stack = []    stack.append({"u":u,"v":0,"started": False})    while len(stack) != 0 :        current = stack[len(stack)-1]        u = current["u"]        v_index = current["v"]        started = current["started"]        if started:            ##despues de que se llama recursivo:            s_v[u]+=s_v[G[u][v_index]] #osea a s_v[u] le suma el valor de su vertice adyacente que se calculo despues de la recursividad#            ##            current["v"] += 1            current["started"] = False            continue        if v_index == len(G[u]):            stack.pop()            color[u] = BLACK            continue         color[u] =GRAY         v=G[u][v_index]        ## to do:        if color[v] == WHITE:            s = {"u":v, "v":0, "started":False}            current["started"] = True            stack.append(s)            continue        ###         current["v"]+=1    def dfs_calc_s(G,u = 0):    color[u] = GRAY    s_v[u] = 1 if uni[u] else 0    for v in G[u]:        if color[v] == WHITE:            dfs_calc_s(G,v)            s_v[u] += s_v[v] def solution(G, k):    sol = 0    for v in range(len(G)):        sol += min(s_v[v], 2*k - s_v[v])    return soldef main():    s = input().split(" ")    n = int(s[0])    k = int(s[1])        global uni, color, s_v    uni = [False for i in range(n)]    color = [0] * n    s_v = [0] * n    s = input().split(" ")    for v in s:        a = int(v)-1        uni[a] = True        s_v[a] = 1    G = [[] for _ in range(n)]    for _ in range(n-1):        s = input().split(" ")        a = int(s[0])-1        b = int(s[1])-1        G[a].append(b)        G[b].append(a)     dfs_iter(G)     print(solution(G,k)) try:    main()except Exception as e:    print(str(e).replace(" ","_"))
