import java.util.*; import java.io.*; public class Main {    public static void main(String[] args) throws IOException {        FastScanner in = new FastScanner(System.in);        PrintWriter out = new PrintWriter(System.out);        new Main().run(in, out);        out.close();    }     public static long mod = 17352642619633L;     void run(FastScanner in, PrintWriter out) {         // centroid decomp?        // connect two furthest that are on opposite sides        // then move on         // instead of standard centroid decomp, split when the number of marked on both sides is half         N = in.nextInt();        K = in.nextInt();        adj = new List[N+1];        for (int i = 0; i < N+1; i++) adj[i] = new ArrayList<>();        marked = new boolean[N+1];        for (int i = 0; i < 2*K; i++) marked[in.nextInt()] = true;        for (int i = 0; i < N-1; i++) {            int u = in.nextInt();            int v = in.nextInt();            adj[u].add(v);            adj[v].add(u);         }         // prune(1, -1);         d = new int[N+1];        visited = new boolean[N+1];        numChildren = new int[N+1];         int centroid = findCentroid(1);        work(centroid);        out.println(ret);    }     int prune(int u, int p) {        int numMarked = (marked[u] ? 1 : 0);        Set<Integer> removed = new HashSet<>();        for (int v : adj[u]) {            if (v == p) continue;            int nm = prune(v, u);            numMarked += nm;            if (nm == 0) removed.add(v);        }         if (numMarked == 0) return 0;         for (int v : removed) adj[u].remove((Integer) v);        return numMarked;    }     long ret = 0;    void work(int u) {         visited[u] = true;         for (int v : adj[u]) {            if (visited[v]) continue;            // since each side has half, it will be the distance from            // mark to root centroid            dfs(v, u, 1);        }     }     void dfs(int u, int p, int d) {        for (int v : adj[u]) {            if (v == p || visited[v]) continue;            dfs(v, u, d+1);        }        if (marked[u]) ret += d;    }     int N, K;    List<Integer>[] adj;    boolean[] visited;    boolean[] marked;    int[] d;    int[] numChildren;    int findCentroid(int u) {        Arrays.fill(numChildren, 0);        dfs1(u, -1);        return dfs2(u, -1, numChildren[u]);    }     int dfs2(int u, int p, int total) {        for (int v : adj[u]) {            if (v == p || visited[u]) continue;            if (numChildren[v]*2 > total) return dfs2(v, u, total);            dfs2(v, u, total);        }        return u;    }     void dfs1(int u, int p) {        if (visited[u]) return;        int sz = (marked[u] ? 1 : 0);        for (int v : adj[u]) {            if (v == p) continue;            dfs1(v, u);            sz += numChildren[v];        }        numChildren[u] = sz;    }     static class FastScanner {        BufferedReader br;        StringTokenizer st;         public FastScanner(InputStream in) {            br = new BufferedReader(new InputStreamReader(in));            st = null;        }         String next() {            while (st == null || !st.hasMoreElements()) {                try {                    st = new StringTokenizer(br.readLine());                } catch (IOException e) {                    e.printStackTrace();                }            }            return st.nextToken();        }         int nextInt() {            return Integer.parseInt(next());        }         long nextLong() {            return Long.parseLong(next());        }    }}
