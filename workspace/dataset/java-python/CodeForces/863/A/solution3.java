import java.util.*;import java.util.Map.Entry;import java.util.regex.Pattern;  import java.util.*; import java.io.*; public class GFG {    	long left;    	long right;    	double divide;    	public GFG(long a,long b,double divide){    		this.left=a;    		this.right=b;    		this.divide=divide;    	}    	static class FastReader  extends Thread{    		BufferedReader br;    		StringTokenizer st;         		public FastReader() {    			br = new BufferedReader(new InputStreamReader(System.in));         		}         		String next() {    			while (st == null || !st.hasMoreElements()) {    				try {    					st = new StringTokenizer(br.readLine());    				} catch (IOException e) {    					e.printStackTrace();    				}    			}    			return st.nextToken();    		}         		int nextInt() {    			return Integer.parseInt(next());    		}         		long nextLong() {    			return Long.parseLong(next());    		}         		double nextDouble() {    			return Double.parseDouble(next());    		}         		String nextLine() {    			String str = "";    			try {    				str = br.readLine();    			} catch (IOException e) {    				e.printStackTrace();    			}    			return str;    		}    	}    	    	 static int power(int a,int b){    		 if(b==0){    			 return 1;    		 }    		 int temp=0;    		    		 if (b%2 == 0) {    			 temp=power(a,b/2);    		 return temp*temp;    		 }     	     else{    		   temp=power(a,b/2);    		   return a*temp*temp;    		     		 }         		 }    	     	    	static int binary(int a[],int start,int end,int number){    		start=0;    		end=a.length-1;    		int mid=0;         		while(start<=end){    			mid=end+(end-start)/2;    			if(a[mid]==number){    				return mid;    			}    			else    			if(a[mid]<number){                   start=mid+1;    			}    			else    			end=mid-1;    		}    		return 0;    		    	}              	static void swap(int a[], int i, int j) {    		int temp = a[i];    		a[i] = a[j];    		a[j] = temp;    	}         	static void fill(int start, int end, int a[]) {    		for (int i = 0; i < end; ++i) {    			a[i] = scan.nextInt();    		}    	}    	static int bl[]=new int[100+1];    	static void PrimeFactorisation(){    	int max=1000;    	    	for(int i=4;i<=max;i+=2){    	 bl[i]=2;//Factor of the two    	    	}    	for(int i=3;i<=Math.sqrt(max);++i){    	if(bl[i]==i){    	for(int j=i*i;j<=max;j+=i){    	if(bl[j]==j){    	bl[j]=i;    	}    	    	}    	}    	}    	}    	static void factors(int x){    	while(x!=1){    	System.out.println(bl[x]);    	x=x/bl[x];    	    	}    	}    	    	        static FastReader sc=new FastReader();    	static FastReader scan = new FastReader();    	private static boolean add;    	static long power(long a,long b){    		return (long)(Math.log(a)/Math.log(b));    	}    	static boolean isPowerOfTwo(long n,long m)    	{    		if(n==0)    		return false;    	     	return (int)(Math.ceil((Math.log(n) / Math.log(m)))) ==     		   (int)(Math.floor(((Math.log(n) / Math.log(m)))));    	}    	/*H.entrySet().stream().sorted(HashMap.Entry.<Long,Long>comparingByValue().reversed()).forEach(e->{    		long k=e.getKey();    		System.out.print(k+" ");    		  });;-*/    		      	 /*static long pow(long n){                      while(n>0){    				 n>>=1;         			 }    	 }*/    	 //counting total bits    	 static long countBits(long number)     	 {      		       		 // log function in base 2      		 // take only integer part     		 return (long)(Math.log(number) /      					  Math.log(2) + 1);     				    	 }    	 static int gcd(int a,int b){    		 if(b==0){    			 return a;     		 }    		 return gcd(a,b%a);    	 }    static void reverse(char a[],int start,int end){    	while(start<=end){    	 char temp=a[start];    	 a[start]=a[end];    	 a[end]=temp;    	 ++start;    	 --end;    	}    }         static void sieve(int a[],int n){    boolean bl[]=new boolean[4000001];    bl[0]=true;    bl[1]=true;    for (int i = 2; i < bl.length; i++) {    bl[i]=false;    }    for (int i = 2; i <=Math.sqrt(10000); i++) {    if(bl[i]==false){    for (int j = i*i ;j <=10000; j=j+i) {     bl[j]=true;         }              }         }         }    static int check(String num){    	int n = num.length();                      int sum = 0;         for(int i = 0; i < n; i++)         sum += (int)(num.charAt(i));              if (sum % 3 == 0)             return 0;              if (n == 1)             return -1;                     for (int i = 0; i < n; i++)             if (sum % 3 == (num.charAt(i) - '0') % 3)                 return 1;                     if (n == 2)             return -1;                     return 2;          }    static int check(Queue<Integer>I,Queue<Integer>M,int power,String m){    	int count=0;    while(M.size()!=0&&I.size()!=0){    	int start=Math.min(I.peek(),M.peek());    	int end=Math.max(I.peek(),M.peek());    	//count the sheild in between    	int shield=0;    	for(int i=start;i<=end;++i){     if(m.charAt(i)==':')++shield;         	}    	int first=I.peek();    	int second=M.peek();         if(power-Math.abs(first-second)-shield>0){       ++count;       M.remove();       I.remove();    }else{    	if(I.peek()<M.peek()){    		I.remove();    	}    	else{    		M.remove();    	}         }         	         }    return count;                       }    static int check(TreeSet<Character>T){    	 Iterator <Character>It=T.iterator();       String ans="";       while(It.hasNext()){    ans+=It.next();            }     return ans.compareTo("acef");    }    static Node root;    static class Node{    int data;    Node left;    Node right;    Node(int data){    	this.data=data;    	    }    }    //preorder Transversal using stack    static void printt(Node root) {    	if (root == null) {    		return;    	}    	Stack<Node> S = new Stack<>();    	S.add(root);    	System.out.print(root.data + " ");    	if (root.right != null) {    		S.add(root.right);    	}    	if (root.left != null) {    		S.add(root.left);    	}    	while (S.size() != 1) {    		Node peek = S.peek();    		S.pop();    		System.out.print(peek.data + " ");    		if (peek.right != null) {    			S.add(peek.right);    		}    		if (peek.left != null) {    			S.add(peek.left);    		}         	}    }    static void check(long a){    	if(a<0)    	a=-a;         }    static int check(int a,int b){    	if(b==0){    		return 1;    	}    	int temp=1;    	 if(b%2==0){    		  temp=check(a,b/2);    		 return temp*temp;    	 }    	 else{    		 temp=check(a,b/2);            return  a*temp*temp;    	 }         }         static void printy(Node head){    	if(head==null){    		return ;    	}    	printy(head.left);    	System.out.println(head.data);    	printy(head.right);    }    //print the  path of the node    static ArrayList<Integer>A=new ArrayList<>();         static boolean printpath(Node head,int element){    	if(root==null){    		return false;    	}    	A.add(head.data);    	if(head.data==element){    		return true;    	}    	if(printpath(head.left,element)||printpath(head.right,element)){    		System.out.println(A);       A.remove(A.size()-1);      return true;    	    	}    	else{    	A.remove(A.size()-1);    	return false;    	}         }    static int check1(int n){    	int r=0;    	int sum=0;    	while(n!=0){      r=n%10;      sum+=r;      n=n/10;         	}    	return sum;    }    static void print(Long arr[]){     for(int i=0;i<arr.length;++i){    	 System.out.print(arr[i]+" ");	 }}	 static int count(int n,int a,int b,int c){		  if(n==0){			  return 1;		  }		  else             		  if(n<0){			  return 0;		  }		int first=count(n-a,a,b,c)+1;		int second=count(n-b,a,b,c)+1;		int third=count(n-c,a,b,c)+1;				return Math.max(Math.max(first,second),third);		  	 }	 static int sum=0;	 static int check(int a[],int index,int sum){	   if(sum==-1){		   return 0;	   }     if(index>=a.length){		 return 0;	 }	return Math.max(a[index]+check(a,++index,--sum),check(a,++index,sum));   		  		 	 } static void join(ArrayList<ArrayList<Integer>>V,int start,int end){V.get(start).add(end);V.get(end).add(start);}	 static void DFS(ArrayList<ArrayList<Integer>>adj,int start,int end){Stack<Integer>S=new Stack<>();   }static void printDFS(ArrayList<ArrayList<Integer>>adj,boolean bl[],int number){	if(bl[number]==false){		System.out.println(number);		bl[number]=true;	}	for(int data:adj.get(number)){         if(bl[data]==false){			 printDFS(adj, bl, data);		 }	}  }static void print(ArrayList<ArrayList<Integer>>adj,int number ,boolean bl[]){     printDFS(adj,bl,0);}static boolean check(int number){	return Math.floor((float)Math.sqrt(number))==Math.ceil((float)Math.sqrt(number));}static int search(int temp,int a[]){ //search the elementint low=0;int high=a.length-1;while(low<=high){	int mid=low+(high-low)/2;	if(a[mid]==temp){		return mid;	}	else	if(mid+1<a.length&&a[mid]<temp&&a[mid+1]>temp){      return mid+1;	}	else	if(mid-1>=0&&a[mid-1]<temp&&a[mid]>temp){		return mid-1;	}	else	if(a[mid]>temp){      high=mid-1;	}	else	if(a[mid]<temp){    low=mid+1;	}}return 0;  } static int search(int key,ArrayList<Integer>A){	int low=0;	int high=A.size()-1;	int ans=-1; while(low<=high){	 int mid=low+(high-low)/2;	 if(A.get(mid)==key){ 		 high=mid-1;	 }	 else	 if(A.get(mid)<key){		 ans=mid;		 low=mid+1;	 }	 else{		 high=mid-1;	 }	   } return ans;  }static int check(char ch){	switch(ch){		case'I': return 1;		case 'V':return 5;		case 'X':return 10;		case 'L':return 50;		case'C':return 100;		case'D':return 500;		case'M':return 1000; 	}	return 0;  }static int check(char a,char b){	ArrayList<Character>A=new ArrayList<>();	A.add('I');	A.add('V');	A.add('X');	A.add('L');	A.add('C');	A.add('D');	A.add('M');	if(A.indexOf(a)<A.indexOf(b)){		return -1;	}	else	if(A.indexOf(a)>A.indexOf(b)){	   return 1;	}	return 1;	 }static int solve(ArrayList<Integer>A,int n,int k) {	Collections.sort(A);	System.out.println(A);	//First some	ArrayList<Integer>First=new ArrayList<>(); 	int sum=0;	int temp=0;	int ans1=0;		/*while(sum<k&&A.size()!=0) {		First.add(A.size()-1);		System.out.println(First);		sum+=A.get(A.size()-1);		A.remove(A.size()-1);	   	   		if(A.contains(sum-k)) {			ans.add(sum-k);			A.remove(A.indexOf(sum-k));			break;		}			}*/	ans1=First.size();	sum=0;	System.out.println(ans1+" "+First);		/*while(sum<k&&A.size()!=0) {		   temp=A.get(A.size()-1);		   ans.add(temp);		   sum+=temp;			if(A.contains(sum-k)) {				ans.add(temp);				A.remove(A.indexOf(sum-k));				break;			}			A.remove(A.size()-1);		}*/	return 0;	}static int sum(ArrayList<Integer>A,int k) {	int sum=0;		int index=0;System.out.println(A);	while(A.size()!=0&&sum<k) {		sum+=A.get(A.size()-1);		++index; A.remove(A.get(A.size()-1));		if(sum>=k) {			break;		}		//two condition		if(A.contains(Math.abs(k-sum))) {		 sum+=Math.abs(k-sum);		 A.remove(A.get(k-sum));		 ++index;		 break;					}		else			if(A.size()!=0&&Math.abs(k-sum)<=A.get(0)){				sum+=A.get(0);				++index;				A.remove(0);				break;							}	 	  	    		}		if(sum<k) {		return -1;	}	return index;}static boolean isSubsetSum(int arr[], int n, int sum){        if (sum == 0)        return true;    if (n == 0 && sum != 0)        return false;         if (arr[n - 1] > sum)        return isSubsetSum(arr, n - 1, sum);        return isSubsetSum(arr, n - 1, sum)           || isSubsetSum(arr, n - 1, sum - arr[n - 1]);}static int sum(int number[],int count,int index){	  if(count==0){	      return -1;	  } 	    if(count<0){	        return -1; 	    }	    if(index>=number.length){	        return number.length;	    }	    	    int left=1+sum(number,count-number[index],++index);	 	    int rigt=sum(number,count,++index);	   	    return Math.min(left,rigt); 	}//if we change the hill what will be cnahstatic int changehill(int a[],int i) {	if(i>0&&i<a.length-1) {if(a[i-1]<a[i]&&a[i]>a[i-1]) {return 1;		}return 0;	}	return 0;}static int changevalley(int a[],int i) {	if(i>0&&i<a.length-1) {	if(a[i-1]>a[i]&&a[i]<a[i+1]) {		return 1;}	else {		return 0;	}} return 0;}	public static void main(String[] args) throws NumberFormatException, IOException, ClassNotFoundException { 	String m=scan.next();String ans="";int check=0;int left=0;int check1=0;int right=m.length()-1;while(left<=right) {	if(m.charAt(right)=='0'&&m.charAt(left)!='0'&&check1==0){		--right;		continue;	}	else	if(m.charAt(left)!=m.charAt(right)) {		check=1;		break;	}	++left;	--right;	check1=1;} if(check==1) {	System.out.println("NO");}else {	System.out.println("YES");}							}					  }	  				 	    				   	  	      			     	              	          	                                                                                                      
