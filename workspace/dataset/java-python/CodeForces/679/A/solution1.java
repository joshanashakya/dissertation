import java.util.*; import java.io.*; import java.math.*;public class Main{	static void solve(){//Here is the main function 	}	//Method addition frame start static HashSet<Integer> sieveOfEratos(int val){  HashSet<Integer> primes = new HashSet<>();  HashSet<Integer> nums = new HashSet<>();  int[] used = {2, 3, 5, 7, 11};  int underPrime = 13;  if(val <= 1){    return nums;  }  for(int i = 0; i < used.length; i++){    if(used[i] <= val){      nums.add(used[i]);    }  }  for(int i = underPrime; i <= val; i += 2){    boolean continued = false;    for(int j = 0; j < used.length; j++){      if(i % used[j] == 0){        continued = true;        break;      }    }    if(continued){      continue;    }    nums.add(i);  }  int i = 2;  while(i <= Math.sqrt(val)){    if(!nums.contains(i)){      if(i == 2){        i++;      }else{        i += 2;      }      continue;    }    int count = 1;    while(i * count <= val){      if(i <= 11 && Arrays.asList(used).contains(i)){        break;      }      if(count == 1){        primes.add(i);      }      nums.remove(i * count);      count++;    }    if(i == 2){      i++;    }else{      i += 2;    }  }  Iterator<Integer> it = primes.iterator();  while(it.hasNext()){    nums.add(it.next());  }  return nums;} 	//Method addition frame end 	//Don't have to see. start------------------------------------------	static class InputIterator{		ArrayList<String> inputLine = new ArrayList<>(1024);		int index = 0; int max; String read;		InputIterator(){			BufferedReader br = new BufferedReader(new InputStreamReader(System.in));			try{				while((read = br.readLine()) != null){					inputLine.addAll(Arrays.asList(read.split(" ")));				}			}catch(IOException e){}			max = inputLine.size();		}		boolean hasNext(){return (index < max);}		String next(){			if(hasNext()){				return inputLine.get(index++);			}else{				throw new IndexOutOfBoundsException("There is no more input");			}		}	}	static HashMap<Integer, String> CONVSTR = new HashMap<>();	static InputIterator ii = null;//new InputIterator();//This class cannot be used in reactive problem.	static PrintWriter out = new PrintWriter(System.out);	static void flush(){out.flush();}	static void myout(Object t){out.println(t);}	static void myerr(Object t){System.err.print("debug:");System.err.println(t);}	static String next(){return ii.next();}	static boolean hasNext(){return ii.hasNext();}	static int nextInt(){return Integer.parseInt(next());}	static long nextLong(){return Long.parseLong(next());}	static double nextDouble(){return Double.parseDouble(next());}	static ArrayList<String> nextCharArray(){return myconv(next(), 0);}	static ArrayList<String> nextStrArray(int size){		ArrayList<String> ret = new ArrayList<>(size);		for(int i = 0; i < size; i++){			ret.add(next());		}		return ret;	}	static ArrayList<Integer> nextIntArray(int size){		ArrayList<Integer> ret = new ArrayList<>(size);		for(int i = 0; i < size; i++){			ret.add(Integer.parseInt(next()));		}		return ret;	}	static ArrayList<Long> nextLongArray(int size){		ArrayList<Long> ret = new ArrayList<>(size);		for(int i = 0; i < size; i++){			ret.add(Long.parseLong(next()));		}		return ret;	}	@SuppressWarnings("unchecked")	static String myconv(Object list, int no){//only join		String joinString = CONVSTR.get(no);		if(list instanceof String[]){			return String.join(joinString, (String[])list);		}else if(list instanceof ArrayList){			return String.join(joinString, (ArrayList)list);		}else{			throw new ClassCastException("Don't join");		}	}	static ArrayList<String> myconv(String str, int no){//only split		String splitString = CONVSTR.get(no);		return new ArrayList<String>(Arrays.asList(str.split(splitString)));	}	public static void main(String[] args){		CONVSTR.put(8, " "); CONVSTR.put(9, "\n"); CONVSTR.put(0, "");		//solve();flush();				HashSet<Integer> s = sieveOfEratos(100);		TreeSet<Integer> set = new TreeSet(s);		myerr(set);		HashSet<Integer> used = new HashSet<>();		Iterator<Integer> it = set.iterator();		int count = 0;		while(it.hasNext() && count < 20){			int v = it.next();			myout(v);			flush();			count++;			Scanner sc = new Scanner(System.in);			String res = sc.next();			if(res.equals("yes")){				if(used.size() > 0){					myout("composite");					flush();					return;				}else{					used.add(v);				}				if(v * v <= 100){					myout(v * v);					flush();					count++;					Scanner scc = new Scanner(System.in);					String res2 = scc.next();					if(res2.equals("yes")){						myout("composite");						flush();						return;					}				}							}		}		myout("prime");		flush();	}	//Don't have to see. end------------------------------------------}
