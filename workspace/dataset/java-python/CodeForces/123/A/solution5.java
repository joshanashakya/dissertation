import java.io.OutputStream;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.util.HashMap;import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.ArrayList;import java.io.InputStream; /** * Built using CHelper plug-in * Actual solution is at the top * * @author Washoum */public class Main {    public static void main(String[] args) {        InputStream inputStream = System.in;        OutputStream outputStream = System.out;        inputClass in = new inputClass(inputStream);        PrintWriter out = new PrintWriter(outputStream);        EPrimePermutation solver = new EPrimePermutation();        solver.solve(1, in, out);        out.close();    }     static class EPrimePermutation {        static EPrimePermutation.Subset[] subsets;         static int find(int i) {            if (subsets[i].parent != i)                subsets[i].parent = find(subsets[i].parent);            return subsets[i].parent;        }         static void union(int x, int y) {            int xroot = find(x);            int yroot = find(y);             if (subsets[xroot].rank < subsets[yroot].rank) {                subsets[xroot].parent = yroot;            } else if (subsets[yroot].rank < subsets[xroot].rank) {                subsets[yroot].parent = xroot;            } else {                subsets[xroot].parent = yroot;                subsets[yroot].rank++;            }        }         public void solve(int testNumber, inputClass sc, PrintWriter out) {            String s = sc.nextLine();            int n = s.length();            char[] ch = new char[26];            for (int i = 0; i < n; i++) {                ch[s.charAt(i) - 'a']++;            }            int nb = 0;            ArrayList<Integer> primes = new ArrayList<>();            for (int i = 2; i <= n; i++) {                boolean b = false;                for (int j = 2; j * j <= i; j++) {                    if (i % j == 0) {                        b = true;                    }                }                if (!b) {                    nb++;                    primes.add(i);                }            }            subsets = new EPrimePermutation.Subset[nb];            for (int i = 0; i < nb; i++) {                subsets[i] = new EPrimePermutation.Subset();                subsets[i].parent = i;                subsets[i].rank = 0;                subsets[i].size = 0;            }            for (int i = 2; i <= n; i++) {                ArrayList<Integer> a = new ArrayList<>();                for (int j = 0; j < primes.size(); j++) {                    if (i % primes.get(j) == 0) {                        a.add(j);                    }                }                if (a.size() > 1) {                    for (int j = 1; j < a.size(); j++) {                        if (find(a.get(0)) != a.get(j))                            union(a.get(0), a.get(j));                    }                }            }            for (int i = 2; i <= n; i++) {                for (int j = 0; j < primes.size(); j++) {                    if (i % primes.get(j) == 0) {                        int g = find(j);                        subsets[g].size++;                        break;                    }                }            }            HashMap<Integer, ArrayList<Integer>> map = new HashMap<>();            for (int i = 0; i < nb; i++) {                int g = find(i);                map.putIfAbsent(g, new ArrayList<>());                map.get(g).add(i);            }            char[] ans = new char[s.length()];            for (int i = 0; i < nb; i++) {                int g = find(i);                int need = subsets[g].size;                if (subsets[g].size <= 0)                    continue;                int max = 0;                int idx = -1;                for (int j = 0; j < 26; j++) {                    if (ch[j] >= max) {                        max = ch[j];                        idx = j;                    }                }                if (max >= need) {                    ArrayList<Integer> p = map.get(g);                    for (int k : p) {                        for (int j = 2; j <= n; j++) {                            if (j % primes.get(k) == 0) {                                ans[j - 1] = (char) (idx + 'a');                                subsets[g].size--;                            }                        }                    }                    ch[idx] -= need;                } else {                    out.println("NO");                    return;                }            }            int max = 0;            int idx = -1;            for (int j = 0; j < 26; j++) {                if (ch[j] >= max) {                    max = ch[j];                    idx = j;                }            }            if (max == 1) {                ans[0] = (char) (idx + 'a');            } else {                out.println("NO");                return;            }            out.println("YES");            for (char i : ans) {                out.print(i);            }         }         static class Subset {            int parent;            int rank;            int size;         }     }     static class inputClass {        BufferedReader br;         public inputClass(InputStream in) {             br = new BufferedReader(new InputStreamReader(in));        }         public String nextLine() {            String str = "";            try {                str = br.readLine();            } catch (IOException e) {                e.printStackTrace();            }            return str;        }     }} 
