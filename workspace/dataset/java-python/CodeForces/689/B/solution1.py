#BFS (Shortest path and Search)from collections import dequedef bfs(start,graph):    explored = set()    queue = deque([start])    levels = {}    levels[start]= 0    visited = {start}    while queue:        node = queue.popleft()        explored.add(node)        neighbours = graph[node]        for neighbour in neighbours:            if neighbour not in visited:                queue.append(neighbour)                visited.add(neighbour)                levels[neighbour]= levels[node]+1     return levels  n = int(input())l = list(map(int,input().split()))graph = {}for i in range(n):    x = l[i]    if i+1 in graph:        graph[i+1].append(x)     else:        graph[i+1] = [x]     if i != n-1:        if i + 1 in graph:            graph[i + 1].append(i+2)         else:            graph[i + 1] = [i+2]         if i + 2 in graph:            graph[i + 2].append(i+1)         else:            graph[i + 2] = [i+1] e = bfs(1,graph)# print(e)ans = []for i in range(1,n+1):    # print(i,e[i])    ans.append(e[i]) print(*ans)
