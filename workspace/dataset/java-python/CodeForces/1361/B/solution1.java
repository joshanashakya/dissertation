import java.io.*;import java.util.*;         public class Solution {      private static final int mod = 1000000007;      private static int max = 1000001;          public static void main(String[] args) throws Exception    {         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        PrintWriter out = new PrintWriter(System.out);                int t = Integer.parseInt(br.readLine());                while(t > 0){        	t--;        StringTokenizer st = new StringTokenizer(br.readLine());                  int n = Integer.parseInt(st.nextToken());          int p = Integer.parseInt(st.nextToken());                    if(p == 1){               out.println((n %2 == 0) ? 0 : 1);               st = new StringTokenizer(br.readLine());               continue;          }          Map<Integer,Integer> map = new HashMap();                    st = new StringTokenizer(br.readLine());                     for(int i=0;i<n;i++){               int key = Integer.parseInt(st.nextToken());               map.put(key,map.getOrDefault(key,0)+1);           }                      int[] a = getArray(map);         //  System.out.println(Arrays.toString(a));           n = a.length;           long ans = 0;           for(int i=0;i<a.length;i++){                if(map.get(a[i]) %2 == 0)continue;                int need = 1;                boolean found = false;                                for(int j=i+1;j<n;j++){                     int required = findRequired(need,a[j-1]-a[j],p);                     if(required == -1) break;                     else if(required <= map.get(a[j])){                          int val = map.get(a[j]);                          map.put(a[j],val-required);                          i = j-1;                          found = true;                          break;                     }                     else{                          required-=map.get(a[j]);                          need=required;                     }                }                if(!found){                     ans+=(findModExp(a[i],p)+mod)%mod;                     for(int j=i+1;j<n;j++){                          ans = (ans-(map.get(a[j])*findModExp(a[j],p))%mod)%mod;                          ans = (ans+mod)%mod;                     }                     break;                }           }           out.println(ans);        }        out.close();    }        private static int[] getArray(Map<Integer,Integer> map){         int[] a = new int[map.size()];         int i=0;         for(Map.Entry<Integer,Integer>entry : map.entrySet()){              int key = entry.getKey();              a[i++] = key;         }         Arrays.sort(a);         reverse(a);         return a;    }        private static void reverse(int[] a){         int low =0, high = a.length-1;                  while(low<high){              int temp = a[low];              a[low++] = a[high];              a[high--] = temp;         }             }        private static int findRequired(int need, int left, int p){         long required = need;                  for(int i=0;i<left;i++){              if(required*p > max) return -1;              required = required*p;         }         return required > max ? -1 : (int)required;    }        private static long findModExp(int val, long p){         long ans = 1;                  while(val > 0){            if(val %2 == 1) ans = (ans*p)%mod;            p = (p*p)%mod;            val>>=1;         }         return ans;    }       }
