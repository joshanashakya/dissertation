import org.omg.PortableInterceptor.SUCCESSFUL; import java.io.*;import java.util.ArrayList;import java.util.List;import java.util.StringTokenizer; public class SolverB {     StringTokenizer stok;    BufferedReader br;    PrintWriter pw;     String nextToken() throws IOException {        while (stok == null || !stok.hasMoreTokens()) {            stok = new StringTokenizer(br.readLine());        }        return stok.nextToken();    }     int nextInt() throws IOException {        return Integer.parseInt(nextToken());    }     double nextDouble() throws IOException {        return Double.parseDouble(nextToken());    }     long nextLong() throws IOException {        return Long.parseLong(nextToken());    }     private void run() throws IOException {//        br = new BufferedReader(new FileReader("input.txt"));//        pw = new PrintWriter("output.txt");        br = new BufferedReader(new InputStreamReader(System.in));        pw = new PrintWriter(new OutputStreamWriter(System.out));        solve();        pw.flush();        pw.close();    }     public static void main(String[] args) throws IOException {        new SolverB().run();    }     class Node {        boolean hasBlack = false;        boolean hasWhite = false;        Node[] childs = new Node[2];    }     class Subnet {        long addr;        int mask;         public Subnet() {         }         public Subnet(String str) {            String[] parts = str.split("/");            String address = parts[0];            if (parts.length == 1) {                mask = 32;            } else {                mask = Integer.parseInt(parts[1]);            }            String[] octets = address.split("\\.");            for (int i = 0; i<4; i++) {                addr = addr * 256 + Long.parseLong(octets[i]);            }        }         @Override        public String toString() {            int[] octets = new int[4];            long address = addr;            for (int i=3; i>=0; i--) {                octets[i] = (int) (address % 256);                address /= 256;            }            StringBuilder sb = new StringBuilder();            for (int i=0; i<4; i++) {                sb.append(octets[i]);                if (i<3) {                    sb.append(".");                }            }            sb.append("/");            sb.append(mask);            return sb.toString();        }    }     int n;    Node root = new Node();    String[] list;    List<Subnet> resultList = new ArrayList<>();     private void addBlack(Node node, Subnet subnet, int dep) {        if (subnet.mask == dep) {            node.hasBlack = true;            return;        }         int ind = Long.compare(subnet.addr & (1l << (31 - dep)), 0);        if (node.childs[ind] == null) {            node.childs[ind] = new Node();        }        addBlack(node.childs[ind], subnet, dep + 1);    }     private boolean addWhite(Node node, Subnet subnet, int dep) {        if (node == null) {            return true;        }        if (node.hasBlack) {            return false;        }         node.hasWhite = true;        if (subnet.mask == dep) {            return node.childs[0] == null && node.childs[1] == null;        }        int ind = Long.compare(subnet.addr & (1l << (31 - dep)), 0);        return addWhite(node.childs[ind], subnet, dep + 1);    }     private Subnet findResult(Node node, int dep, long curAddr) {        if (node == null) {            return null;        }         Subnet res1 = findResult(node.childs[0], dep + 1, curAddr);        Subnet res2 = findResult(node.childs[1], dep + 1, curAddr + (1L << (31 - dep)));        Subnet result = null;        if (res1 != null || res2 != null) {            if (node.hasWhite) {                if (res1 != null) {                    resultList.add(res1);                }                if (res2 != null) {                    resultList.add(res2);                }                return null;            } else {                result = new Subnet();                result.mask = dep;                result.addr = curAddr;            }        }        if (result == null && node.hasBlack) {            result = new Subnet();            result.mask = dep;            result.addr = curAddr;        }        return result;    }     private void solve() throws IOException {        n = nextInt();        list = new String[n];        for (int i=0; i<n; i++) {            list[i] = br.readLine();        }        for (int i=0; i<n; i++) {            if (list[i].startsWith("-")) {                Subnet subnet = new Subnet(list[i].substring(1));                addBlack(root, subnet, 0);            }        }         for (int i=0; i<n; i++) {            if (list[i].startsWith("+")) {                Subnet subnet = new Subnet(list[i].substring(1));                if (!addWhite(root, subnet, 0)) {                    pw.println(-1);                    return;                }            }        }         Subnet subnet = findResult(root, 0, 0);        if (subnet != null) {            resultList.add(subnet);        }        pw.println(resultList.size());        for (Subnet subnet1 : resultList) {            pw.println(subnet1);        }    }}
