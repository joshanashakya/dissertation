 ######      ###      #######    #######    ##      #     #####        ###     #####  #     #    #   #          #        #       # #     #    #     #      #   #     ###   #     #   #     #        #         #       #  #    #   #       #    #     #    ###   ######   #########      #          #       #   #   #   #           #########    #    ######   #########     #           #       #    #  #   #           #########    #    #     #  #       #    #            #       #     # #   #    ####   #       #    #    #     #  #       #   #             #       #      ##   #    #  #   #       #         ######   #       #  #######     #######    #       #    #####  #   #       #    #    # from __future__ import print_function # for PyPy2from collections import Counter, OrderedDictfrom itertools import permutations as permfrom fractions import Fractionfrom collections import dequefrom sys import stdinfrom bisect import *from heapq import *from math import * g   = lambda : stdin.readline().strip()gl  = lambda : g().split()gil = lambda : [int(var) for var in gl()]gfl = lambda : [float(var) for var in gl()]gcl = lambda : list(g())gbs = lambda : [int(var) for var in g()]mod = int(1e9)+7inf = float("inf")                        n, k = gil()a = gil()pre = a[:]for i in reversed(range(n-1)):	pre[i] += pre[i+1]  seg = []m = n-k+1 i = 0while i+k-1 < n:	seg.append(pre[i] - (pre[i+k] if i+k < n else 0))	i += 1 maxSeg = [i for i in range(m)] for i in reversed(range(m-1)):	if seg[i] < seg[maxSeg[i+1]]:		maxSeg[i] = maxSeg[i+1] # print(seg)# print(maxSeg)l, r = 0, k i = 0while i+k < m:	if seg[i] + seg[maxSeg[i+k]] > seg[l] + seg[r]:		l, r = i, maxSeg[i+k]	i += 1 print(l+1, r+1)
