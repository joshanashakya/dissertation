A = input()B = input()virus = input() # DP[i][j][k] maximum length of common subsquence you can construct with A[i:], B[j:], having exactly k letter of the virus so far# DP[0][0][0] piTable = [0] * len(virus)# ERROR 1 : this error though :(((j = 0for i in range(1, len(virus)):    while (virus[i] != virus[j] and j != 0):        j = piTable[j - 1]    if virus[i] == virus[j]:        piTable[i] = j + 1        j += 1    else:        piTable[i] = 0 memo = {}parent = {}  def dp(i, j, k):    # print(i, j, k)    if k == len(virus):        return -10000    if i == len(A):        return 0    if j == len(B):        return 0     if (i, j, k) in memo:        return memo[(i, j, k)]    choices = [dp(i + 1, j, k), dp(i, j + 1, k)]    new_k = k    if A[i] == B[j]:        if A[i] == virus[k]:            choices.append(dp(i + 1, j + 1, k + 1) + 1)            new_k = k + 1        else:            # A[i] = j            # k=6, virus=abcjabcxxxxx virus[k]=x            # A[i] != virus[k]            while (A[i] != virus[new_k] and new_k != 0):                new_k = piTable[new_k - 1]            if A[i] == virus[new_k]:                # ERROR 2 : messed up with new_k and k, as well forgot updating new_k ...                new_k += 1                choices.append(dp(i + 1, j + 1, new_k) + 1)            else:                choices.append(dp(i + 1, j + 1, 0) + 1)     memo[(i, j, k)] = max(choices)    index = choices.index(memo[(i, j, k)])    if index == 0:        parent[(i, j, k)] = (i + 1, j, k)    elif index == 1:        parent[(i, j, k)] = (i, j + 1, k)    else:        parent[(i, j, k)] = (i + 1, j + 1, new_k)     # print(i,j,k)    return memo[(i, j, k)]  max_size_subsequence = dp(0, 0, 0)if max_size_subsequence == 0:    print(0)else:    # construct answer    ANSWER = ""    current_state = (0, 0, 0)    next_state = None     while current_state != None:        next_state = parent[current_state] if current_state in parent else None        if next_state is None:            break        # (i,j,k) -> (i+1,j+1,k')        if next_state[0] == current_state[0] + 1 and next_state[1] == current_state[1] + 1:            ANSWER += A[current_state[0]]        current_state = next_state    print(ANSWER)
