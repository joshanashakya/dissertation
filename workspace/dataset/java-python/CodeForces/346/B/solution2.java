import java.io.OutputStream;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.util.Arrays;import java.util.StringTokenizer;import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.InputStream; /** * Built using CHelper plug-in * Actual solution is at the top */public class Main {    public static void main(String[] args) {        InputStream inputStream = System.in;        OutputStream outputStream = System.out;        Scanner in = new Scanner(inputStream);        PrintWriter out = new PrintWriter(outputStream);        BLuckyCommonSubsequence solver = new BLuckyCommonSubsequence();        solver.solve(1, in, out);        out.close();    }     static class BLuckyCommonSubsequence {        int[] pi;        char[] first;        char[] second;        char[] virus;        StringBuilder sb;        int[][][] memo;         void prefixFunction(char[] s) {            int n = s.length;            pi = new int[n];            for (int i = 1, j = 0; i < n; ++i)        //j = pi[i-1] at the beginning of every iteration            {                while (j > 0 && s[i] != s[j])                    j = pi[j - 1];                if (s[i] == s[j])                    ++j;                pi[i] = j;            }        }         public void solve(int testNumber, Scanner sc, PrintWriter pw) {            first = sc.next().toCharArray();            second = sc.next().toCharArray();            virus = sc.next().toCharArray();            prefixFunction(virus);            memo = new int[first.length][second.length][virus.length];            for (int[][] x : memo)                for (int[] y : x)                    Arrays.fill(y, -1);            sb = new StringBuilder();            if (dp(0, 0, 0) > 0) {                trace(0, 0, 0);                pw.println(sb);            } else                pw.println("0");        }         private void trace(int i, int j, int comm) {            if (i == first.length || j == second.length)                return;            int opt = dp(i, j, comm);            if (first[i] == second[j]) {                if (virus[comm] == first[i]) {                    if (opt == 1 + dp(i + 1, j + 1, comm + 1)) {                        sb.append(first[i]);                        trace(i + 1, j + 1, comm + 1);                        return;                    }                } else {                    if (comm == 0 && opt == 1 + dp(i + 1, j + 1, 0)) {                        sb.append(first[i]);                        trace(i + 1, j + 1, 0);                        return;                    } else {                        int next = comm;                        while (next != 0 && virus[next] != first[i])                            next = pi[next - 1];                        if (virus[next] == first[i])                            next++;                        if (1 + dp(i + 1, j + 1, next) == opt) {                            sb.append(first[i]);                            trace(i + 1, j + 1, next);                            return;                        }                    }                }            }            if (opt == dp(i + 1, j, comm)) {                trace(i + 1, j, comm);            } else                trace(i, j + 1, comm);        }         private int dp(int i, int j, int comm) {            if (comm == virus.length)                return -(int) 1e9;            if (i == first.length || j == second.length)                return 0;            if (memo[i][j][comm] != -1)                return memo[i][j][comm];            int max = Integer.MIN_VALUE;            if (first[i] == second[j]) {                if (virus[comm] == first[i]) {                    max = 1 + dp(i + 1, j + 1, comm + 1);                } else {                    if (comm == 0) {                        max = 1 + dp(i + 1, j + 1, 0);                    } else {                        int next = comm;                        while (next != 0 && virus[next] != first[i])                            next = pi[next - 1];                        if (virus[next] == first[i])                            next++;                        max = 1 + dp(i + 1, j + 1, next);                    }                }            }            max = Math.max(max, Math.max(dp(i + 1, j, comm), dp(i, j + 1, comm)));            return memo[i][j][comm] = max;        }     }     static class Scanner {        StringTokenizer st;        BufferedReader br;         public Scanner(InputStream s) {            br = new BufferedReader(new InputStreamReader(s));        }         public String next() {            try {                while (st == null || !st.hasMoreTokens())                    st = new StringTokenizer(br.readLine());                return st.nextToken();            } catch (Exception e) {                throw new RuntimeException(e);            }        }     }} 
