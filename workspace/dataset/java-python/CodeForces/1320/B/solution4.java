import java.util.*;import java.io.*; public class Main {    public static void main(String[] args) throws IOException {        FastScanner in = new FastScanner(System.in);        PrintWriter out = new PrintWriter(System.out);        new Main().run(in, out);        out.close();    }     int N;    List<Integer>[] adj;    List<Integer>[] radj;    int M;    int[] dist;    int[] distCount;     int K;    int[] path;    void run(FastScanner in, PrintWriter out) {         N = in.nextInt();        adj = new List[N+1];        radj = new List[N+1];        dist = new int[N+1];        multipleOptionsForShortestPath = new boolean[N+1];        distCount = new int[N+1];        for (int i = 0; i <= N; i++) {            adj[i] = new ArrayList<>();            radj[i] = new ArrayList<>();        }         M = in.nextInt();        for (int i = 0; i < M; i++) {            int u = in.nextInt();            int v = in.nextInt();             adj[u].add(v);            radj[v].add(u);        }         K = in.nextInt();        path = new int[K];        for (int i = 0; i < K; i++) path[i] = in.nextInt();          bfs(path[K-1]);         int min = 0;        int max = 0;         for (int i = 1; i < K; i++) {            int prevDist = dist[path[i-1]];            int currDist = dist[path[i]];            if (prevDist-1 != currDist) {                min++; max++;            } else {                // we are on a shortest path                if (multipleOptionsForShortestPath[path[i-1]]) {                    max++;                }            }        }        out.println(String.format("%d %d", min, max));     }     boolean[] multipleOptionsForShortestPath;    void bfs(int start) {        LinkedList<int[]> q = new LinkedList<>();        q.add(new int[] {start, 0});         while (!q.isEmpty()) {            int[] top = q.pollFirst();            int u = top[0];            int d = top[1];             // if multiple nodes are reaching me with the same distance            // we have multiple options going outward on the way down            if (dist[u] != 0) {                if (d == dist[u]) multipleOptionsForShortestPath[u] = true;                continue;            }            dist[u] = d;            distCount[d]++;             for (int v : radj[u]) {                if (dist[v] != 0 || v == start) continue;                q.add(new int[] {v, d+1});            }        }     }     static class FastScanner {        BufferedReader br;        StringTokenizer st;         public FastScanner(InputStream in) {            br = new BufferedReader(new InputStreamReader(in));            st = null;        }         String next() {            while (st == null || !st.hasMoreElements()) {                try {                    st = new StringTokenizer(br.readLine());                } catch (IOException e) {                    e.printStackTrace();                }            }            return st.nextToken();        }         int nextInt() {            return Integer.parseInt(next());        }         long nextLong() {            return Long.parseLong(next());        }    }}
