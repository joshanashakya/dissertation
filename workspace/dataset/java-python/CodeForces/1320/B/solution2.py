from types import GeneratorType INF = 1e10  def bootstrap(f, stack=[]):    def wrappedfunc(*args, **kwargs):        if stack:            return f(*args, **kwargs)        else:            to = f(*args, **kwargs)            while True:                if type(to) is GeneratorType:                    stack.append(to)                    to = next(to)                else:                    stack.pop()                    if not stack:                        break                    to = stack[-1].send(to)            return to     return wrappedfunc  class Graph:     def __init__(self, V):        self.V = V        self.adj = [[] for i in range(V)]     def addEdge(self, v, w):        self.adj[v].append(w)  import sys input = sys.stdin.readlinen, m = list(map(int, input().split()))G = Graph(n)G_transpose = Graph(n)for _ in range(m):    u, v = list(map(int, input().split()))    G.addEdge(u - 1, v - 1)    G_transpose.addEdge(v - 1, u - 1)minimums = [0 for _ in range(n)]mini = [0 for _ in range(n)] from collections import dequedef BFS_SP(graph, start):    explored = set()    queue = deque([start])    dz = set()     while queue:        node = queue.popleft()         if node not in explored:            neighbours = graph.adj[node]            # print(neighbours)            # print(sd)            for neighbour in neighbours:                 if neighbour not in dz:                    sd[neighbour] = sd[node] + 1                    minimums[neighbour] = sd[node] + 1                    mini[neighbour] = 1                    dz.add(neighbour)                    queue.append(neighbour)                else:                    # print(node,neighbour,sd[node],minimums[neighbour])                    if sd[node] + 1 == minimums[neighbour]:                        mini[neighbour] += 1                 explored.add(node)  k = int(input())path = list(map(int, input().split())) sd = [INF for _ in range(n)] sd[path[-1] - 1] = 0BFS_SP(G_transpose, path[-1] - 1) ans_min = 0ans_max = 0 # print(distances,child_distances_from_goal)# print(path)for i in range(0, len(path) - 1):    # print(i)     next_dist = sd[path[i + 1] - 1]    # print(all_distances)    if sd[path[i] - 1] == sd[path[i + 1] - 1] + 1:         if mini[path[i] - 1] > 1:            ans_max += 1    else:        ans_min += 1        ans_max += 1    # print(ans_min, ans_max) print(ans_min - 1, ans_max - 1) #
