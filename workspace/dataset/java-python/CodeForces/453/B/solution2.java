import java.util.*; import java.io.*; public class Main {    public static void main(String[] args) throws IOException {        FastScanner in = new FastScanner(System.in);        PrintWriter out = new PrintWriter(System.out);        new Main().run(in, out);        out.close();    }      // the max cost is moving everything to 1    // since all 1s will be coprime    // thus, since the bound of numbers is 30, we will always be in the range from 1-60     // get prime factors of numbers from 0-70    static int[] factorMask = new int[61];    static int primeIdx = 0;     static {        HashMap<Integer, Integer> primeId = new HashMap<>();        LinkedList<Integer> primes = new LinkedList<>();        boolean[] isPrime = new boolean[61];        Arrays.fill(isPrime, true);        for (int i = 2; i < isPrime.length; i++) {            if (isPrime[i]) {                primes.add(i);                for (int p = i*i; p < isPrime.length; p += i) isPrime[p] = false;            }        }         for (int i = 2; i < factorMask.length; i++) {            int n = i;            for (int p : primes) {                if (n%p == 0) {                    if (!primeId.containsKey(p)) primeId.put(p, primeIdx++);                    factorMask[i] |= 1 << primeId.get(p);                }                while (n%p == 0) n /= p;                if (n == 1) break;            }        }     }     int N;    int[] a;     void run(FastScanner in, PrintWriter out) {         N = in.nextInt();        a = new int[N];        for (int i = 0; i < N; i++) a[i] = in.nextInt();         // bitmask dp on (number of items in sequence, used primes)        int maxMask = 1 << primeIdx;        int[][] dp = new int[N+1][maxMask];        for (int[] d : dp) Arrays.fill(d, 987654321);        Arrays.fill(dp[0], 0);         int[][] currValue = new int[N+1][maxMask];         for (int i = 0; i < N; i++) {            int n = a[i];            for (int next = 1; next < 60; next++) {                // cost to move to this number                int c = Math.abs(n-next);                // get factor mask                int mask = factorMask[next];                int x = (~mask) & (maxMask-1);                 // partition mask such that the 0s (representing our factors) will stay 0s                for (int prevMask = x; ; prevMask = (prevMask-1)&x) {                     int newCost = dp[i][prevMask] + c;                    if (newCost < dp[i+1][prevMask|mask]) {                        dp[i+1][prevMask|mask] = newCost;                        currValue[i+1][prevMask|mask] = next;                    }                    if (prevMask == 0) break;                }            }        }         // backtrack        LinkedList<Integer> ret = new LinkedList<>();        int min = Integer.MAX_VALUE;        int minMask = 0;        for (int mask = 0; mask < maxMask; mask++) {            if (dp[N][mask] < min) {                min = dp[N][mask];                minMask = mask;            }        }         for (int i = N; i >= 1; i--) {            ret.offerFirst(currValue[i][minMask]);            int cv = currValue[i][minMask];            minMask = (minMask & (~factorMask[cv]));        }         for (int num : ret) out.print(num + " ");        out.println();    }     static class FastScanner {        BufferedReader br;        StringTokenizer st;         public FastScanner(InputStream in) {            br = new BufferedReader(new InputStreamReader(in));            st = null;        }         String next() {            while (st == null || !st.hasMoreElements()) {                try {                    st = new StringTokenizer(br.readLine());                } catch (IOException e) {                    e.printStackTrace();                }            }            return st.nextToken();        }         int nextInt() {            return Integer.parseInt(next());        }         long nextLong() {            return Long.parseLong(next());        }    }}
