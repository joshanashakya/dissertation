import java.io.*;import java.math.BigDecimal;import java.math.BigInteger;import java.math.RoundingMode;import java.util.*;import java.util.concurrent.LinkedBlockingDeque; import java.util.ArrayList;import java.util.HashMap;import java.util.LinkedList;  // graph, dfs,bfs, get connected components,iscycle, isbipartite, dfs on trees   public class scratch_25 {    static class Graph{         public static class Vertex{            HashMap<Integer,Integer> nb= new HashMap<>();     // for neighbours of each vertex        }         public static HashMap<Integer,Vertex> vt;   // for vertices(all)         public Graph(){            vt= new HashMap<>();        }         public static int numVer(){            return vt.size();        }         public static boolean contVer(int ver){            return vt.containsKey(ver);        }         public static void addVer(int ver){            Vertex v= new Vertex();            vt.put(ver,v);        }              public static void addEdge(int ver1, int ver2, int weight){            if(!vt.containsKey(ver1) || !vt.containsKey(ver2)){                return;            }            Vertex v1= vt.get(ver1);            Vertex v2= vt.get(ver2);            v1.nb.put(ver2,weight);                                 // if previously there is an edge, then this replaces that edge            v2.nb.put(ver1,weight);        }         public static void delEdge(int ver1, int ver2){             if(!vt.containsKey(ver1) || !vt.containsKey(ver2)){                return;            }            vt.get(ver1).nb.remove(ver2);            vt.get(ver2).nb.remove(ver1);        }        public static void delVer(int ver){            if(!vt.containsKey(ver)){                return;            }            Vertex v1= vt.get(ver);            ArrayList<Integer> arr= new ArrayList<>(v1.nb.keySet());            for (int i = 0; i <arr.size() ; i++) {                int s= arr.get(i);                vt.get(s).nb.remove(ver);            }            vt.remove(ver);        }           static boolean done[];            static int parent[];            static ArrayList<Integer>vals= new ArrayList<>();          public static boolean isCycle(int i){            Stack<Integer>stk= new Stack<>();             stk.push(i);            while(!stk.isEmpty()){                int x= stk.pop();                vals.add(x);             //   System.out.print("current="+x+" stackinit="+stk);                if(!done[x]){                    done[x]=true;                }                else if(done[x] ){                    return true;                }                 ArrayList<Integer>ar= new ArrayList<>(vt.get(x).nb.keySet());                for (int j = 0; j <ar.size() ; j++) {                   if(parent[x]!=ar.get(j)){                       parent[ar.get(j)]=x;                    stk.push(ar.get(j));                   }                }               // System.out.println(" stackfin="+stk);            }            return false;        }        static int distance[];       // static ArrayList<Integer>ans= new ArrayList<>();        static int color[];        public static void bfs(int v, int pco,int cmax,int cco){          ArrayList<Integer>ar= new ArrayList<>(vt.get(v).nb.keySet());          color[v]=cco;          done[v]=true;          int num=1;            for (int i = 0; i <ar.size() ; i++) {                int x= ar.get(i);                if(!done[x]){                    while(num==cco || num==pco){                        num++;                    }                    bfs(x,cco,cmax,num);                    num++;                }            }        }            }    static class DisjointSet{        HashMap<Integer,Node> mp= new HashMap<>();         public static class Node{            int data;            Node parent;            int rank;        }          public void create(int val){            Node nn= new Node();            nn.data=val;            nn.parent=nn;            nn.rank=0;            mp.put(val,nn);        }         public int findparent(int val){             return findparentn(mp.get(val)).data;         }          public Node findparentn(Node n){            if(n==n.parent){                return n;            }            Node rr= findparentn(n.parent);            n.parent=rr;            return rr;        }           public void union(int val1, int val2){                                                                               // can also be used to check cycles             Node n1= findparentn(mp.get(val1));            Node n2= findparentn(mp.get(val2));              if(n1.data==n2.data) {                return;            }               if(n1.rank<n2.rank){                n1.parent=n2;            }             else if(n2.rank<n1.rank){                n2.parent=n1;            }             else {                n2.parent=n1;                n1.rank++;            }         }    }    static class Pair implements Comparable<Pair>{        long x;        long y;        public Pair(long x,long y){            this.x=x;            this.y=y;        }        @Override        public int compareTo(Pair o){            return (int)this.y-(int)o.y;          }        @Override        public boolean equals(Object me) {            Pair binMe = (Pair)me;            if(this.x==binMe.x && this.y==binMe.y)                return true;            else                return false;        }         @Override        public int hashCode() {            return (int)this.x + (int)this.y;        }         @Override        public String toString() {            return x+" "+y;        }      }       // int count=0;    //static long count=0;    static class Reader {        static BufferedReader reader;        static StringTokenizer tokenizer;         /**         * call this method to initialize reader for InputStream         */        static void init(InputStream input) {            reader = new BufferedReader(                    new InputStreamReader(input));            tokenizer = new StringTokenizer("");        }         /**         * get next word         */        static String next() throws IOException {            while (!tokenizer.hasMoreTokens()) {                //TODO add check for eof if necessary                tokenizer = new StringTokenizer(                        reader.readLine());            }            return tokenizer.nextToken();        }         static int nextInt() throws IOException {            return Integer.parseInt(next());        }         static double nextDouble() throws IOException {            return Double.parseDouble(next());        }         static long nextLong() throws IOException {            return Long.parseLong(next());        }    }        // After writing solution, quick scan for:    //   array out of bounds    //   special cases e.g. n=1?    //    // Big numbers arithmetic bugs:    //   int overflow    //   sorting, or taking max, or negative after MOD    public static void main(String[] args)  throws IOException {        Reader.init(System.in);        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));        int t= Reader.nextInt();        for (int tt = 0; tt <t ; tt++) {            int n= Reader.nextInt();            long cap= Reader.nextLong();            long dif= Reader.nextLong();            long arr[]= new long[n];            for (int i = 0; i <n ; i++) {                arr[i]= Reader.nextLong();            }            boolean b=true;            for (int i = 0; i <n-1 ; i++) {                long x1= arr[i];                long x2= arr[i+1];                if(x1>=x2){                    cap=Math.min(cap+(x1-x2)+dif,cap+x1);                }                else if(x1<x2){                    if((x2-x1<=dif)){                        long g= dif-(x2-x1);                        cap+=Math.min(g,x1);                    }                    else if(x1+cap<x2-dif){                        b=false;                        break;                    }                    else{                       cap=cap-((x2-x1)-dif);                    }                }            }            //System.out.println(cap);            out.append(b?"YES":"NO");            out.append("\n");                           }                   out.flush();        out.close();     }    static boolean isSubSequence(String str1, String str2, int m, int n)    {        // Base Cases        if (m == 0)            return true;        if (n == 0)            return false;         // If last characters of two strings are matching        if (str1.charAt(m-1) == str2.charAt(n-1))            return isSubSequence(str1, str2, m-1, n-1);         // If last characters are not matching        return isSubSequence(str1, str2, m, n-1);    }        static long modExp(long a, long b, long mod) {        //System.out.println("a is " + a + " and b is " + b);        if (a==1) return 1;        long ans = 1;        while (b!=0) {            if (b%2==1) {                ans = (ans*a)%mod;            }            a = (a*a)%mod;            b/=2;        }        return ans;    }      public static long modmul(long a, long b, long mod) {        return b == 0 ? 0 : ((modmul(a, b >> 1, mod) << 1) % mod + a * (b & 1)) % mod;    }     static long sum(long n){        //   System.out.println("lol="+ (n*(n-1))/2);        return (n*(n+1))/2;    }          public static ArrayList<Integer> Sieve(int n) {        boolean arr[]= new boolean [n+1];        Arrays.fill(arr,true);        arr[0]=false;        arr[1]=false;        for (int i = 2; i*i <=n ; i++) {            if(arr[i]){                for (int j = 2; j <=n/i ; j++) {                    int u= i*j;                    arr[u]=false;                }}        }        ArrayList<Integer> ans= new ArrayList<>();        for (int i = 0; i <n+1 ; i++) {            if(arr[i]){                ans.add(i);            }        }        return ans;    }        static long power( long x, long y, long p)    {         long res = 1;          x = x % p;         if (x == 0) return 0;         while (y > 0)        {             if((y & 1)==1)                res = (res * x) % p;              y = y >> 1;            x = (x * x) % p;        }        return res;    }     public static long ceil_div(long a, long b){        return (a+b-1)/b;    }     static long gcd(long a, long b)    {        if (a == 0)            return b;        return gcd(b % a, a);    }     static long lcm(long a, long b)    {        return (a*b)/gcd(a, b);    } }
