import java.io.*;import java.math.*;import java.util.*;  /** * * @author Saju * */ public class Main {     private static int dx[] = { 1, 0, -1, 0 };    private static int dy[] = { 0, -1, 0, 1 };     private static final long INF = Long.MAX_VALUE;    private static final int INT_INF = Integer.MAX_VALUE;    private static final long NEG_INF = Long.MIN_VALUE;    private static final int NEG_INT_INF = Integer.MIN_VALUE;    private static final double EPSILON = 1e-10;     private static final int MAX = 2000007;        private static final long MOD = 1000000007;     private static final int MAXN = 100007;    private static final int MAXA = 10000009;    private static final int MAXLOG = 22; 	public static void main(String[] args) throws IOException { 		InputReader in = new InputReader(System.in);//		Scanner in = new Scanner(System.in);		PrintWriter out = new PrintWriter(System.out); //         InputReader in = new InputReader(new FileInputStream("src/test.in"));//         PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("src/test.out"))); 				/* 4 4WWBWWBBBBBBBWBBW 4 4WBBWWBBWWBWWWBBW */				int n = in.nextInt();		int m = in.nextInt();		char[][] grid = new char[n][m];				for(int i = 0; i < n; i++) {			grid[i] = in.next().toCharArray();		}				List<Pair> list = new ArrayList<>();				for(int i = 0; i < n; i++) {			for(int j = 0; j < m; j++) {				if(grid[i][j] == 'B') {					list.add(new Pair(i, j));				}			}		}		boolean ok = true;		int black = list.size();		for(int i = 0; i < black - 1; i++) {			for(int j = i + 1; j < black; j++) {				if(!ok(list.get(i), list.get(j), grid)) {					ok = false;					break;				}			}		}				if(ok) {			out.println("YES");		}		else {			out.println("NO");		}				in.close();		out.flush();		out.close();		System.exit(0);	}		private static boolean ok(Pair src, Pair dest, char[][] grid) {				if(src.r == dest.r) {			if(src.c < dest.c) {				return righttOk(src, dest, grid);			}			else {				return leftOk(src, dest, grid);			}		}		else if(src.c == dest.c) {			if(src.r < dest.r) {				return bottomOk(src, dest, grid);			}			else {				return topOk(src, dest, grid);			}		}				if (src.r < dest.r) {			if (src.c < dest.c) {				// 4				return (righttOk(src, new Pair(src.r, dest.c), grid) 						&& bottomOk(new Pair(src.r, dest.c), dest, grid))						|| (bottomOk(src, new Pair(dest.r, src.c), grid)								&& righttOk(new Pair(dest.r, src.c), dest, grid));			} else {				// 3				return (leftOk(src, new Pair(src.r, dest.c), grid) 						&& bottomOk(new Pair(src.c, dest.c), dest, grid))						|| (bottomOk(src, new Pair(dest.r, src.c), grid)								&& leftOk(new Pair(dest.r, src.c), dest, grid)); 			}		} else {			if (src.c < dest.c) {				// 2				return (righttOk(src, new Pair(src.r, dest.c), grid) 						&& topOk(new Pair(src.r, dest.c), dest, grid))						|| (topOk(src, new Pair(dest.r, src.c), grid) 								&& righttOk(new Pair(dest.r, src.c), dest, grid));			} else {				// 1				return (leftOk(src, new Pair(src.r, dest.c), grid) 						&& topOk(new Pair(src.r, dest.c), dest, grid))						|| (topOk(src, new Pair(dest.r, src.c), grid) 								&& leftOk(new Pair(dest.r, src.c), dest, grid));			}		}	} 	private static boolean leftOk(Pair src, Pair dest, char[][] grid) {		for(int j = src.c; j >= dest.c; j--) {			if(grid[src.r][j] == 'W') {				return false;			}		}		return true;	}		private static boolean righttOk(Pair src, Pair dest, char[][] grid) {		for(int j = src.c; j <= dest.c; j++) {			if(grid[src.r][j] == 'W') {				return false;			}		}		return true;	}		private static boolean topOk(Pair src, Pair dest, char[][] grid) {		for(int i = src.r; i >= dest.r; i--) {			if(grid[i][src.c] == 'W') {				return false;			}		}		return true;	}		private static boolean bottomOk(Pair src, Pair dest, char[][] grid) {		for(int i = src.r; i <= dest.r; i++) {			if(grid[i][src.c] == 'W') {				return false;			}		}		return true;	}		private static class Pair{		int r;		int c;		Pair(int r, int c){			this.r = r;			this.c = c;		}	}		private static boolean isPalindrome(String str) {		StringBuilder sb = new StringBuilder();		sb.append(str);		String str1 = sb.reverse().toString();		return str.equals(str1);	} 	private static String getBinaryStr(int n, int j) {		String str = Integer.toBinaryString(n);		int k = str.length();		for (int i = 1; i <= j - k; i++) {			str = "0" + str;		} 		return str;	}		private static String getBinaryStr(long n, int j) {		String str = Long.toBinaryString(n);		int k = str.length();		for (int i = 1; i <= j - k; i++) {			str = "0" + str;		} 		return str;	}		private static long bigMod(long n, long k, long m) {         long ans = 1;        while (k > 0) {            if ((k & 1) == 1) {                ans = (ans * n) % m;            }            n = (n * n) % m;            k >>= 1;        }        return ans;    }    	private static long ceil(long n, long x) {		long div = n / x;        if(div * x != n) {            div++;        }        return div;	}	    private static int ceil(int n, int x) {        int div = n / x;        if(div * x != n) {            div++;        }        return div;    }     private static class Point {        double x;        double y;         Point(double x, double y) {            this.x = x;            this.y = y;        }         double getDistance(Point p2) {            Point p1 = this;            double dx = p1.x - p2.x;            double dy = p1.y - p2.y;             return Math.sqrt((dx * dx) + (dy * dy));        }    }     private static int abs(int x) {        if (x < 0) {            return -x;        }        return x;    }     private static long abs(long x) {        if(x < 0) {            return -x;        }        return x;    }     private static int lcm(int a, int b) {        return (a * b) / gcd(a, b);    }     private static int gcd(int a, int b) {        if (a == 0)            return b;        return gcd(b % a, a);    }     private static int log(long x, int base) {        return (int) (Math.log(x) / Math.log(base));    }     private static long min(long a, long b) {        if (a < b) {            return a;        }        return b;    }     private static int min(int a, int b) {        if (a < b) {            return a;        }        return b;    }     private static long max(long a, long b) {        if (a < b) {            return b;        }        return a;    }     private static int max(int a, int b) {        if (a < b) {            return b;        }        return a;    }     private static class InputReader {        public BufferedReader reader;        public StringTokenizer tokenizer;         public InputReader(InputStream stream) {            reader = new BufferedReader(new InputStreamReader(stream));            tokenizer = null;        }         public String next() {            try {                while (tokenizer == null || !tokenizer.hasMoreTokens()) {                    tokenizer = new StringTokenizer(reader.readLine());                 }            } catch (IOException e) {                return null;            }            return tokenizer.nextToken();        }         public String nextLine() {            String line = null;            try {                tokenizer = null;                line = reader.readLine();            } catch (IOException e) {                throw new RuntimeException(e);            }            return line;        }         public int nextInt() {            return Integer.parseInt(next());        }         public double nextDouble() {            return Double.parseDouble(next());        }         public long nextLong() {            return Long.parseLong(next());        }         public boolean hasNext() {            try {                while (tokenizer == null || !tokenizer.hasMoreTokens()) {                    tokenizer = new StringTokenizer(reader.readLine());                }            } catch (Exception e) {                return false;            }            return true;        }                public int[] nextIntArr(int n) {        	int arr[] = new int[n];    		for(int i = 0; i < n; i++) {    			arr[i] = nextInt();    		}    		return arr;        }                public long[] nextLongArr(int n) {        	long arr[] = new long[n];    		for(int i = 0; i < n; i++) {    			arr[i] = nextLong();    		}    		return arr;        }                public int[] nextIntArr1(int n) {        	int arr[] = new int[n + 1];    		for(int i = 1; i <= n; i++) {    			arr[i] = nextInt();    		}    		return arr;        }                public long[] nextLongArr1(int n) {        	long arr[] = new long[n + 1];    		for(int i = 1; i <= n; i++) {    			arr[i] = nextLong();    		}    		return arr;        }               public void close() {        	try {        		if(reader != null) {        			reader.close();        		}        	}        	catch(Exception e) {        		        	}        	        	        }    } }
