import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.Arrays;import java.util.HashSet;import java.util.StringTokenizer; public class B {	static PrintWriter out = new PrintWriter(System.out); 		public static void main(String[] args) {		FS in = new FS();		char c[] = in.next().toCharArray();		int N = c.length;				HashSet<Character> hs = new HashSet<Character>();		for(int i = 0; i < N/2; i++) hs.add(c[i]);		for(int i = N/2 + 1; i < N; i++) hs.add(c[i]);				if(hs.size() <= 1) {			out.println("Impossible");			out.close();			return;		}				int res = 2;		HarmeyerHash hh = new HarmeyerHash();		HarmeyerHash[] fw = hh.getPrefixHashes(c);		for(int i = 0; i < N/2; i++) {			char tmp = c[i];			c[i] = c[c.length-i-1];			c[c.length-i-1] = tmp;		}		HarmeyerHash[] bw = hh.getPrefixHashes(c);				HarmeyerHash whole = hh.substringHash(fw, 0, N);		for(int sp = 0; sp < N-1; sp++) {			HarmeyerHash b1 = hh.substringHash(fw, sp+1, N);			b1.append(hh.substringHash(fw, 0, sp+1));						HarmeyerHash b2 = hh.substringHash(fw, N-sp-1, N);			b2.append(hh.substringHash(bw, 0, N-sp-1));						if(b1.equals(b2) && !b1.equals(whole)) res = 1; 		}				out.println(res);		out.close();	}	 	static class HarmeyerHash implements Comparable<HarmeyerHash> {		static final long m1=8675309, m2=1_000_000_007;		long v1=0, v2=0; int l=0;			static final long s1=257, s2=619;		static long[] s1Pow, s2Pow;		static boolean precomped=false;				void add(char o) {			v1=(v1*s1+o)%m1;			v2=(v2*s2+o)%m2;			l++;		}				public int compareTo(HarmeyerHash o) {			if (v1!=o.v1)				return Long.compare(v1, o.v1);				return Long.compare(v2, o.v2);		}				public boolean equals(Object o) {			return compareTo((HarmeyerHash)o)==0;		} 		public int hashCode() {			return (int)v1;		}				public HarmeyerHash clone() {			HarmeyerHash toReturn=new HarmeyerHash();			toReturn.v1=v1;			toReturn.v2=v2;			toReturn.l=l;			return toReturn;		} 		static void precomp() {			if (precomped) return;			precomped=true;			s1Pow=new long[1000_000];			s2Pow=new long[1000_000];			s1Pow[0]=s2Pow[0]=1;			for (int i=1; i<s1Pow.length; i++)				s1Pow[i]=(s1Pow[i-1]*s1)%m1;			for (int i=1; i<s2Pow.length; i++)				s2Pow[i]=(s2Pow[i-1]*s2)%m2;		} 		//need fastPow if o can be longer than 10^6		void append(HarmeyerHash o) {			precomp();			v1=(v1*s1Pow[o.l]+o.v1)%m1;			v2=(v2*s2Pow[o.l]+o.v2)%m2;			l+=o.l;		}				public static HarmeyerHash[] getPrefixHashes(char[] word) {			precomp();			int n=word.length;			HarmeyerHash[] toReturn=new HarmeyerHash[n+1];			toReturn[0]=new HarmeyerHash();			for (int i=1; i<=n; i++) {				toReturn[i]=toReturn[i-1].clone();				toReturn[i].add(word[i-1]);			}			return toReturn;		}				//inclusive, exclusive		public static HarmeyerHash substringHash(HarmeyerHash[] prefixHashes, int from, int to) {			if (from==to)				return new HarmeyerHash();			HarmeyerHash old=prefixHashes[to].clone(), toSub=prefixHashes[from];			int diff=to-from;			old.v1=(old.v1-(toSub.v1*s1Pow[diff])%m1+m1)%m1;			old.v2=(old.v2-(toSub.v2*s2Pow[diff])%m2+m2)%m2;			old.l=to-from;			return old;		}			}		static class FS{		BufferedReader br;		StringTokenizer st;		public FS() {			br = new BufferedReader(new InputStreamReader(System.in));		}		String next() {			while(st == null || !st.hasMoreElements()) {				try {st = new StringTokenizer(br.readLine());}				catch(Exception e) { throw null;}			}			return st.nextToken();		}		int nextInt() { return Integer.parseInt(next());}		double nextDouble() { return Double.parseDouble(next());}		long nextLong() { return Long.parseLong(next());}		int[] NIA(int n) {			int r[] = new int[n];			for(int i = 0; i < n; i++) r[i] = nextInt();			return r;		}		long[] NLA(int n) {			long r[] = new long[n];			for(int i = 0; i < n; i++) r[i] = nextLong();			return r;		}		char[][] grid(int r, int c){			char res[][] = new char[r][c];			for(int i = 0; i < r; i++) {				char l[] = next().toCharArray();				for(int j = 0; j < c; j++) {					res[i][j] = l[j];				}			}			return res;		}	}	}
