import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException; import java.io.InputStreamReader; import java.util.Scanner; import java.util.StringTokenizer; import java.util.*;import java.io.*;public class codeforces {    static class Student{       int x;       long y;//z;        Student(int x,long y){            this.x=x;            this.y=y;            //this.z=z;        }    }    static int prime[];    static void sieveOfEratosthenes(int n)     {         // Create a boolean array "prime[0..n]" and initialize         // all entries it as true. A value in prime[i] will         // finally be false if i is Not a prime, else true.         int pos=0;        prime= new int[n+1];         for(int p = 2; p*p <=n; p++)         {             // If prime[p] is not changed, then it is a prime             if(prime[p] == 0)            {                 // Update all multiples of p                prime[p]=p;                for(int i = p*p; i <= n; i += p)                    if(prime[i]==0)                    prime[i] = p;             }         }     }static  class Sortbyroll implements Comparator<Student> {     // Used for sorting in ascending order of     // roll number     public int compare(Student c, Student b)     {        if(c.y>b.y)            return 1;        return -1;    } } static class FastReader     {         BufferedReader br;         StringTokenizer st;           public FastReader()         {             br = new BufferedReader(new                     InputStreamReader(System.in));         }           String next()         {             while (st == null || !st.hasMoreElements())             {                 try                {                     st = new StringTokenizer(br.readLine());                 }                 catch (IOException  e)                 {                     e.printStackTrace();                 }             }             return st.nextToken();         }           int nextInt()         {             return Integer.parseInt(next());         }           long nextLong()         {             return Long.parseLong(next());         }           double nextDouble()         {             return Double.parseDouble(next());         }           String nextLine()         {             String str = "";             try            {                 str = br.readLine();             }             catch (IOException e)             {                 e.printStackTrace();             }             return str;         }     }      static class Edge{        int a,b;        Edge(int a,int b){            this.a=a;            this.b=b;        }    }    static class Trie{        HashMap<Character,Trie>map;         int c;        Trie(){            map=new HashMap<>();            //z=null;            //o=null;            c=0;        }    }    //static long ans;    static int parent[];    static int rank[];    static int bo[][];    static int h[];    static int ho[][];    static int seg[][];    //static int pos;    //static long mod=1000000000+7;    //static int dp[][];    static HashMap<String,Integer>map;    static PriorityQueue<Student>q=new PriorityQueue<>();    //static Stack<Integer>st;   // static ArrayList<Character>ans;    static ArrayList<ArrayList<Integer>>adj;    //static ArrayList<ArrayList<Integer>>tr;    static ArrayList<HashMap<Long,Student>>map1;    static ArrayList<HashMap<Long,Long>>map2;    //static long ans;    static int pos;    static Trie root;    static long fac[];    static int s,d;    static int gw,gb;    static long mod=(long)(998244353);    static long ans1;    static long ans2;    static void solve()throws IOException{        FastReader sc=new FastReader();        int n,m,st,e,mid,i,x,y,j;        long tx,z;        n=sc.nextInt();        m=sc.nextInt();        ArrayList<ArrayList<Student>>a=new ArrayList<>();        for(i=0;i<n;i++)            a.add(new ArrayList<Student>());        for(i=0;i<m;i++){            x=sc.nextInt()-1;            y=sc.nextInt()-1;            z=sc.nextLong();            a.get(x).add(new Student(y,z));            a.get(y).add(new Student(x,z));        }        ArrayList<ArrayList<Integer>>t=new ArrayList<>();        for(i=0;i<n;i++){            x=sc.nextInt();            t.add(new ArrayList<>());            for(j=0;j<x;j++)                t.get(i).add(sc.nextInt());        }        long dp[]=new long[n];        dp[0]=(long)0;        for(i=1;i<n;i++)            dp[i]=Long.MAX_VALUE;        PriorityQueue<Student>p=new PriorityQueue<>(n,new Sortbyroll());        p.add(new Student(0,(long)0));        for(i=1;i<n;i++)            p.add(new Student(i,Long.MAX_VALUE));        HashMap<Integer,Integer>map=new HashMap<>();        Student s;        while(!p.isEmpty()){            s=p.poll();            if(map.containsKey(s.x))                continue;            map.put(s.x,1);            tx=dp[s.x];            st=0;            e=t.get(s.x).size()-1;            mid=(st+e)/2;            y=t.get(s.x).size();            while(st<=e&&mid<t.get(s.x).size()){                if(t.get(s.x).get(mid)<=dp[s.x]){                    tx=Math.max(t.get(s.x).get(mid)+(long)1,tx);                    y=mid+1;                    st=mid+1;                }                else                    e=mid-1;                mid=(st+e)/2;            }            while(y<t.get(s.x).size()){                if((long)t.get(s.x).get(y)==tx){                    tx+=(long)1;                    ++y;                }                else                    break;            }            for(i=0;i<a.get(s.x).size();i++){                if(map.containsKey(a.get(s.x).get(i).x))                    continue;                dp[a.get(s.x).get(i).x]=Math.min(dp[a.get(s.x).get(i).x],tx+a.get(s.x).get(i).y);                p.add(new Student(a.get(s.x).get(i).x,dp[a.get(s.x).get(i).x]));            }        }        if(dp[n-1]==Long.MAX_VALUE||dp[n-1]<(long)0)            System.out.println(-1);        else            System.out.println(dp[n-1]);    }    static void update(int s,int e,int l,int r,int in,int i,int a[]){        if(s>e||l>e||s>r)            return;        if(s==e){            seg[in][0]=i;            seg[in][1]=a[i];            return;        }        int mid=(s+e)/2;        update(s,mid,l,r,2*in+1,i,a);        update(mid+1,e,l,r,2*in+2,i,a);        if(seg[2*in+1][1]>seg[2*in+2][1])        {            seg[in][1]=seg[2*in+1][1];            seg[in][0]=seg[2*in+1][0];        }        else{            seg[in][1]=seg[2*in+2][1];            seg[in][0]=seg[2*in+2][0];        }    }    static int query(int s,int e,int l,int r,int in){        if(s>e||l>e||s>r)            return -1;        if(s==e){            return (int)seg[in][0];        }       int mid=(s+e)/2;        return Math.max(query(s,mid,l,r,2*in+1),        query(mid+1,e,l,r,2*in+2));     }    static void dfs2(int p,int c,long dp1[][],long dp[]){        for(Integer x: adj.get(c)){            if(x==p)                continue;            dfs2(c,x,dp1,dp);            dp[c]=Math.max(dp[c],dp[x]);            if(dp1[c][0]==Long.MIN_VALUE)                dp1[c][0]=dp[x];            else if(dp1[c][0]<=dp[x]){                dp1[c][1]=dp1[c][0];                dp1[c][0]=dp[x];            }            else                dp1[c][1]=Math.max(dp1[c][1],dp[x]);        }    }    static void dfs(int p,int c,int a[],long dp[]){        dp[c]=a[c];        for(Integer x: adj.get(c)){            if(x==p)                continue;            dfs(c,x,a,dp);            dp[c]+=dp[x];        }    }    static void dfs(int x,int y,char f[][],int n,int m){        f[x][y]='u';        if(x+1<n){            if(f[x+1][y]=='*')                ++pos;            if(f[x+1][y]=='.')                dfs(x+1,y,f,n,m);        }        if(x-1>=0){            if(f[x-1][y]=='*')                ++pos;            if(f[x-1][y]=='.')                dfs(x-1,y,f,n,m);        }        if(y+1<m){            if(f[x][y+1]=='*')                ++pos;            if(f[x][y+1]=='.')                dfs(x,y+1,f,n,m);        }        if(y-1>=0){            if(f[x][y-1]=='*')                ++pos;            if(f[x][y-1]=='.')                dfs(x,y-1,f,n,m);        }    }    static void fill(int x,int y,char f[][],int dp[][],int n,int m){        dp[x][y]=pos;        f[x][y]='*';           if(x+1<n){            if(f[x+1][y]=='u')                fill(x+1,y,f,dp,n,m);        }        if(x-1>=0){            if(f[x-1][y]=='u')                fill(x-1,y,f,dp,n,m);        }        if(y+1<m){            if(f[x][y+1]=='u')                fill(x,y+1,f,dp,n,m);        }        if(y-1>=0){            if(f[x][y-1]=='u')                fill(x,y-1,f,dp,n,m);        }    }    static boolean check(String s){        int i=0,j=s.length()-1;        while(i<j){            if(s.charAt(i)!=s.charAt(j))                return false;            ++i;            --j;        }        return true;    }   /* static void update(int s,int e,int l,int r,int in,int v){        if(s>e||s>r||l>e)            return;        if(s>=l&&e<=r){            seg[in]=v;            return;        }        int mid=(s+e)/2;        update(s,mid,l,r,2*in+1,v);        update(mid+1,e,l,r,2*in+2,v);        seg[in]=Math.max(seg[2*in+1],seg[2*in+2]);    }        static int query(int s,int e,int l,int r,int in){        if(s>e||s>r||l>e)            return 0;        if(s>=l&&e<=r){            return seg[in];                    }        int mid=(s+e)/2;        return Math.max(query(s,mid,l,r,2*in+1),        query(mid+1,e,l,r,2*in+2));        //seg[in]=Math.max(seg[2*in+1],seg[2*in+2]);    }*/    static double dist(long x,long y,long z,long w){        return Math.sqrt((x-y)*(x-y)+(z-w)*(z-w));    }    static void add(int x,int y,Queue<Integer>q,Queue<Integer>v,int b[][]){        q.add(x);        v.add(y);        b[x][y]=1;    }    static long nCr(long n, long r,                                     long p)     {         return (fac[(int)n]* modInverse(fac[(int)r], p)                 % p * modInverse(fac[(int)(n-r)], p)                                     % p) % p;     }     //static int prime[];    //static int dp[];    public static void main(String[] args){        //long sum=0;        try {                codeforces.solve();                } catch (Exception e) {                    e.printStackTrace();                }    }       static long modInverse(long n, long p)     {         return power(n, p-(long)2,p);     }  static long power(long x, long y, long p) {     long res = 1;      // Initialize result       x = x % p;  // Update x if it is more than or                  // equal to p       while (y > 0)     {         // If y is odd, multiply x with result         if (y %(long)2!=0)             res = (res*x) % p;           // y must be even now         y = y>>1; // y = y/2         x = (x*x) % p;       }     return res%p; }    /*public static long power(long x,long a) {		if(a==0) return 1;		if(a%2==1)return (x*1L*power(x,a-1))%mod;		return (power((int)((x*1L*x)%mod),a/2))%mod;	}*/   static int find(int x)     {         // Finds the representative of the set         // that x is an element of         while(parent[x]!=x)         {             // if x is not the parent of itself             // Then x is not the representative of             // his set,            x=parent[x];              // so we recursively call Find on its parent             // and move i's node directly under the             // representative of this set         }           return x;     }    static void union(int x, int y)     {         // Find representatives of two sets         int xRoot = find(x), yRoot = find(y);           // Elements are in the same set, no need         // to unite anything.         if (xRoot == yRoot)             return;            // If x's rank is less than y's rank         if (rank[xRoot] < rank[yRoot])               // Then move x under y  so that depth             // of tree remains less             parent[xRoot] = yRoot;           // Else if y's rank is less than x's rank         else if (rank[yRoot] < rank[xRoot])               // Then move y under x so that depth of             // tree remains less             parent[yRoot] = xRoot;           else // if ranks are the same         {             // Then move y under x (doesn't matter             // which one goes where)             parent[yRoot] = xRoot;               // And increment the the result tree's             // rank by 1             rank[xRoot] = rank[xRoot] + 1;         }     }     static long gcd(long a, long b)     {         if (a == 0){              //ans+=b;            return b;        }        return gcd(b % a, a);     }}
