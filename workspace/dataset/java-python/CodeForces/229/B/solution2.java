import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.PrintWriter;import java.math.BigInteger;import java.util.*; /** * @author Mubtasim Shahriar */ public class Planets {     public static void main(String[] args) {         InputStream inputStream = System.in;        OutputStream outputStream = System.out;        InputReader sc = new InputReader(inputStream);        PrintWriter out = new PrintWriter(outputStream);        Solver solver = new Solver();//		int t = sc.nextInt();        int t = 1;        while (t-- != 0) {            solver.solve(sc, out);        }        out.close();     }     static class Solver {        public void solve(InputReader sc, PrintWriter out) {            int n = sc.nextInt();            int m = sc.nextInt();            ArrayList<long[]>[] gp = new ArrayList[n];            for (int i = 0; i < n; i++) {                gp[i] = new ArrayList<>();            }            for(int i = 0; i < m; i++) {                int u = sc.nextInt()-1;                int v = sc.nextInt()-1;                long dis = sc.nextLong();                gp[u].add(new long[] {v,dis});                gp[v].add(new long[] {u,dis});            }            Seg[] segs = new Seg[n];            for(int i = 0; i < n; i++) {                int have = sc.nextInt();                if(have==0) continue;                long[] now = sc.nextLongArray(have);                segs[i] = new Seg(0,have-1,now);            }            PriorityQueue<long[]> pq = new PriorityQueue(new Comparator<long[]>() {                @Override                public int compare(long[] o1, long[] o2) {                    return Long.compare(o1[1],o2[1]);                }            });            long[] dists = new long[n];            boolean[] marked = new boolean[n];            long nowTime = getSeg(segs[0],0);            Arrays.fill(dists,Long.MAX_VALUE);            dists[0] = nowTime;            pq.add(new long[] {0l,nowTime});            while (!pq.isEmpty()) {                long[] now = pq.poll();                int ver = (int) now[0];                if (marked[ver]) continue;                long dist = dists[ver];                marked[ver] = true;                if(ver==n-1) break;                for(long[] v : gp[ver]) {                    int vs = (int)v[0];                    if(marked[vs]) continue;                    long time = v[1];                    long reach = dist+time;                    if(vs!=n-1) {//                        while (taken[vs].contains(reach)) reach++;                        reach = getSeg(segs[vs],reach);                    }                    if(reach<dists[vs]) {                        dists[vs] = reach;                        pq.add(new long[] {vs,reach});                    }                }            }            out.println(dists[n-1]!=Long.MAX_VALUE ? dists[n-1] : -1);        }         private long getSeg(Seg seg, long at) {            if(seg==null) return at;            long[] now = seg.arr;            int n = now.length;            int low = -1;            int l = 0;            int r = n-1;            while(l<=r) {                int mid = (l+r)>>1;                if(now[mid]>at) {                    low = mid;                    r = mid-1;                } else {                    l = mid+1;                }            }            if(low==-1) return Math.max(now[n-1]+1,at);            if(low==0) return at;            if(now[low]-now[low-1]>1) return Math.max(now[low-1]+1,at);            l = low;            r = n-1;            int att = -1;            while(l<=r) {                int mid = (l+r)>>1;                boolean haveGap = seg.rangeQu(low,mid);                if(haveGap) {                    r = mid-1;                    att = mid;                } else {                    l = mid+1;                }            }            if(att==-1) throw new RuntimeException();            return now[att]+1;        }    }     static void sort(int[] arr) {        Random rand = new Random();        int n = arr.length;        for (int i = 0; i < n; i++) {            int idx = rand.nextInt(n);            if (idx == i) continue;            arr[i] ^= arr[idx];            arr[idx] ^= arr[i];            arr[i] ^= arr[idx];        }        Arrays.sort(arr);    }     static class Seg {        int left, right, mid;        boolean leaf, haveGap;        Seg lchild, rchild;        long[] arr;         Seg(int l, int r, long[] arr) {            this.arr = arr;            left = l;            right = r;            leaf = l==r;            mid = (l+r)>>1;            if(leaf) {                if(r==arr.length-1) haveGap = true;                else haveGap = arr[l+1]-arr[l]>1;            } else {                lchild = new Seg(l,mid,arr);                rchild = new Seg(mid+1,r,arr);                haveGap = lchild.haveGap || rchild.haveGap;            }        }         boolean rangeQu(int l, int r) {            if(r<l) return false;            if(left>r || right<l) return false;            if(l<=left && right<=r) return haveGap;            return lchild.rangeQu(l,r) || rchild.rangeQu(l,r);        }    }     static void sort(long[] arr) {        Random rand = new Random();        int n = arr.length;        for (int i = 0; i < n; i++) {            int idx = rand.nextInt(n);            if (idx == i) continue;            arr[i] ^= arr[idx];            arr[idx] ^= arr[i];            arr[i] ^= arr[idx];        }        Arrays.sort(arr);    }     static void sortDec(int[] arr) {        Random rand = new Random();        int n = arr.length;        for (int i = 0; i < n; i++) {            int idx = rand.nextInt(n);            if (idx == i) continue;            arr[i] ^= arr[idx];            arr[idx] ^= arr[i];            arr[i] ^= arr[idx];        }        Arrays.sort(arr);        int l = 0;        int r = n - 1;        while (l < r) {            arr[l] ^= arr[r];            arr[r] ^= arr[l];            arr[l] ^= arr[r];            l++;            r--;        }    }     static void sortDec(long[] arr) {        Random rand = new Random();        int n = arr.length;        for (int i = 0; i < n; i++) {            int idx = rand.nextInt(n);            if (idx == i) continue;            arr[i] ^= arr[idx];            arr[idx] ^= arr[i];            arr[i] ^= arr[idx];        }        Arrays.sort(arr);        int l = 0;        int r = n - 1;        while (l < r) {            arr[l] ^= arr[r];            arr[r] ^= arr[l];            arr[l] ^= arr[r];            l++;            r--;        }    }     static class InputReader {        private boolean finished = false;         private InputStream stream;        private byte[] buf = new byte[1024];        private int curChar;        private int numChars;        private SpaceCharFilter filter;         public InputReader(InputStream stream) {            this.stream = stream;        }         public int read() {            if (numChars == -1) {                throw new InputMismatchException();            }            if (curChar >= numChars) {                curChar = 0;                try {                    numChars = stream.read(buf);                } catch (IOException e) {                    throw new InputMismatchException();                }                if (numChars <= 0) {                    return -1;                }            }            return buf[curChar++];        }         public int peek() {            if (numChars == -1) {                return -1;            }            if (curChar >= numChars) {                curChar = 0;                try {                    numChars = stream.read(buf);                } catch (IOException e) {                    return -1;                }                if (numChars <= 0) {                    return -1;                }            }            return buf[curChar];        }         public int nextInt() {            int c = read();            while (isSpaceChar(c)) {                c = read();            }            int sgn = 1;            if (c == '-') {                sgn = -1;                c = read();            }            int res = 0;            do {                if (c < '0' || c > '9') {                    throw new InputMismatchException();                }                res *= 10;                res += c - '0';                c = read();            } while (!isSpaceChar(c));            return res * sgn;        }         public long nextLong() {            int c = read();            while (isSpaceChar(c)) {                c = read();            }            int sgn = 1;            if (c == '-') {                sgn = -1;                c = read();            }            long res = 0;            do {                if (c < '0' || c > '9') {                    throw new InputMismatchException();                }                res *= 10;                res += c - '0';                c = read();            } while (!isSpaceChar(c));            return res * sgn;        }         public String nextString() {            int c = read();            while (isSpaceChar(c)) {                c = read();            }            StringBuilder res = new StringBuilder();            do {                if (Character.isValidCodePoint(c)) {                    res.appendCodePoint(c);                }                c = read();            } while (!isSpaceChar(c));            return res.toString();        }         public boolean isSpaceChar(int c) {            if (filter != null) {                return filter.isSpaceChar(c);            }            return isWhitespace(c);        }         public static boolean isWhitespace(int c) {            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;        }         private String readLine0() {            StringBuilder buf = new StringBuilder();            int c = read();            while (c != '\n' && c != -1) {                if (c != '\r') {                    buf.appendCodePoint(c);                }                c = read();            }            return buf.toString();        }         public String readLine() {            String s = readLine0();            while (s.trim().length() == 0) {                s = readLine0();            }            return s;        }         public String readLine(boolean ignoreEmptyLines) {            if (ignoreEmptyLines) {                return readLine();            } else {                return readLine0();            }        }         public BigInteger readBigInteger() {            try {                return new BigInteger(nextString());            } catch (NumberFormatException e) {                throw new InputMismatchException();            }        }         public char nextCharacter() {            int c = read();            while (isSpaceChar(c)) {                c = read();            }            return (char) c;        }         public double nextDouble() {            int c = read();            while (isSpaceChar(c)) {                c = read();            }            int sgn = 1;            if (c == '-') {                sgn = -1;                c = read();            }            double res = 0;            while (!isSpaceChar(c) && c != '.') {                if (c == 'e' || c == 'E') {                    return res * Math.pow(10, nextInt());                }                if (c < '0' || c > '9') {                    throw new InputMismatchException();                }                res *= 10;                res += c - '0';                c = read();            }            if (c == '.') {                c = read();                double m = 1;                while (!isSpaceChar(c)) {                    if (c == 'e' || c == 'E') {                        return res * Math.pow(10, nextInt());                    }                    if (c < '0' || c > '9') {                        throw new InputMismatchException();                    }                    m /= 10;                    res += (c - '0') * m;                    c = read();                }            }            return res * sgn;        }         public boolean isExhausted() {            int value;            while (isSpaceChar(value = peek()) && value != -1) {                read();            }            return value == -1;        }         public String next() {            return nextString();        }         public SpaceCharFilter getFilter() {            return filter;        }         public void setFilter(SpaceCharFilter filter) {            this.filter = filter;        }         public interface SpaceCharFilter {            public boolean isSpaceChar(int ch);        }         public int[] nextIntArray(int n) {            int[] array = new int[n];            for (int i = 0; i < n; ++i) array[i] = nextInt();            return array;        }         public int[] nextSortedIntArray(int n) {            int array[] = nextIntArray(n);            Arrays.sort(array);            return array;        }         public int[] nextSumIntArray(int n) {            int[] array = new int[n];            array[0] = nextInt();            for (int i = 1; i < n; ++i) array[i] = array[i - 1] + nextInt();            return array;        }         public long[] nextLongArray(int n) {            long[] array = new long[n];            for (int i = 0; i < n; ++i) array[i] = nextLong();            return array;        }         public long[] nextSumLongArray(int n) {            long[] array = new long[n];            array[0] = nextInt();            for (int i = 1; i < n; ++i) array[i] = array[i - 1] + nextInt();            return array;        }         public long[] nextSortedLongArray(int n) {            long array[] = nextLongArray(n);            Arrays.sort(array);            return array;        }    }  }
