import java.io.*;import java.util.*; public class CF715B{	static final boolean _DEBUG = true; 	static class MyScanner {		BufferedReader br;		StringTokenizer st; 		public MyScanner(BufferedReader _br) {			br = _br;		} 		String next() {			while (st == null || !st.hasMoreElements()) {				try {					st = new StringTokenizer(br.readLine());				} catch (Exception e) {					e.printStackTrace();					return "";				}			}			return st.nextToken();		} 		int nextInt() {			return Integer.parseInt(next());		} 		long nextLong() {			return Long.parseLong(next());		} 		double nextDouble() {			return Double.parseDouble(next());		} 		String nextLine() {			String str = "";			try {				str = br.readLine();			} catch (IOException e) {				e.printStackTrace();			}			return str;		} 	} 	static MyScanner   scan;	static PrintWriter out; 	static int debugCount = 0;	static void debug(String msg) {		if (_DEBUG && debugCount < 200) {			out.println(msg);			out.flush();			debugCount++;		}	}	    public static void main (String args[]) throws IOException {//    	scan = new MyScanner(new BufferedReader(new FileReader("test.in")));    	scan = new MyScanner(new BufferedReader(new InputStreamReader(System.in)));    	out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));        CF715B inst = new CF715B();        inst.execute();        out.close();    }        class MyCmp implements Comparator<Integer>{    	    	long[] dist;    	    	public MyCmp(long[] _dist) {    		dist = _dist;    	}    			@Override		public int compare(Integer o1, Integer o2) {			if (dist[o1] < dist[o2]) {				return -1;			} else if (dist[o1] > dist[o2]) {				return 1;			} else {				return o1 - o2;							}		}    	    }        static final long INF = 1_000_000_000_000_000_000L;    int n, m, L, s, t;        class Edge {    	int a, b;    	long wt;    	public Edge(int _a, int _b, int _wt) {    		a = _a;    		b = _b;    		wt = _wt;    	}    }        LinkedList<Integer>[] nbs;    Edge[] edges;        boolean[] visited;        void dijkstra(int root, long[] dist) {    	Arrays.fill(dist, INF);    	TreeSet<Integer> queue = new TreeSet<Integer>(new MyCmp(dist));    	queue.add(root);    	dist[root] = 0;    	while(!queue.isEmpty()) {    		int cur = queue.pollFirst();    		if (visited[cur]) continue;    		visited[cur] = true;    		for (int nb : nbs[cur]) {    			Edge edge = edges[nb];    			int next = edge.a == cur ? edge.b : edge.a;    			if (!visited[next] && edge.wt != 0) {    				long nwt = dist[cur] + edge.wt;    				if (nwt < dist[next]) {    					queue.remove(next);    					dist[next] = nwt;    					queue.add(next);    				}    			}    		}    	}    }    //    long[] dist1;    long[] dist2;    long[] dist3;     boolean run () {    	Arrays.fill(visited, false);   	    	int root = s;    	Arrays.fill(dist3, INF);    	TreeSet<Integer> queue = new TreeSet<Integer>(new MyCmp(dist3));    	queue.add(root);    	dist3[root] = 0;    	while(!queue.isEmpty()) {    		int cur = queue.pollFirst();    		long wt = dist3[cur];    		if (visited[cur]) continue;    		visited[cur] = true;    		for (int nb : nbs[cur]) {    			Edge edge = edges[nb];    			int next = edge.a == cur ? edge.b : edge.a;    			if (!visited[next]) {    				if (edge.wt == 0) {    					if (dist2[next] != INF) {    						if (dist2[next] + dist3[cur] < L) {    							edge.wt = L - (dist2[next] + dist3[cur]);    							return true;    						} else {    							edge.wt = 1;    						}    					} else {    						edge.wt = 1;    					}    				}    				long nwt = wt + edge.wt;    				if (nwt < dist3[next]) {    					queue.remove(next);    					dist3[next] = nwt;    					queue.add(next);    					dist3[next] = nwt;    				}    			}    		}    	}    	    	return dist3[t] == L;  	    }            void execute() throws IOException {    	n = scan.nextInt();    	m = scan.nextInt();    	L = scan.nextInt();    	s = scan.nextInt();    	t = scan.nextInt();    	    	nbs = new LinkedList[n];    	for (int i = 0; i < n; i++) {    		nbs[i] = new LinkedList<Integer>();    	}    	edges = new Edge[m];    	for (int i = 0; i < m; i++) {    		int a = scan.nextInt();    		int b = scan.nextInt();    		edges[i] = new Edge(a, b, scan.nextInt());    		nbs[a].add(i);    		nbs[b].add(i);    	}//        dist1 = new long[n];        dist2 = new long[n];        dist3 = new long[n];            	visited = new boolean[n];//    	dijkstra(s, dist1);//    	//    	Arrays.fill(visited, false);    	dijkstra(t, dist2);    	if (dist2[s] < L) {    		out.println("NO");    		return;    	} else if (dist2[s] == L) {    		out.println("YES");  		    	} else {    		if (run()) {        		out.println("YES");  		  			    		} else {        		out.println("NO");        		return;			    		}    	}    	for (Edge edge: edges) {    		out.println(edge.a + " " + edge.b + " " + (edge.wt == 0 ? INF : edge.wt));    	}    }}
