import java.io.*;import java.util.*; public class Main{	static final boolean _DEBUG = false; 	private static class MyScanner {		BufferedReader br;		StringTokenizer st; 		public MyScanner(BufferedReader _br) {			br = _br;		} 		String next() {			while (st == null || !st.hasMoreElements()) {				try {					st = new StringTokenizer(br.readLine());				} catch (Exception e) {					e.printStackTrace();					return "";				}			}			return st.nextToken();		} 		int nextInt() {			return Integer.parseInt(next());		} 		long nextLong() {			return Long.parseLong(next());		} 		double nextDouble() {			return Double.parseDouble(next());		} 		String nextLine() {			String str = "";			try {				str = br.readLine();			} catch (IOException e) {				e.printStackTrace();			}			return str;		} 	} 	static MyScanner   scan;	static PrintWriter out; 	static int debugCount = 0;	static void debug(String msg) {		if (_DEBUG && debugCount < 200) {			out.println(msg);			out.flush();			debugCount++;		}	}	    public static void main (String args[]) throws IOException {//    	scan = new MyScanner(new BufferedReader(new FileReader("test.in")));    	scan = new MyScanner(new BufferedReader(new InputStreamReader(System.in)));    	out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));        Main inst = new Main();        inst.execute();        out.close();    }//    //    class Edge implements Comparable<Edge> {//    	int id;//    	int node1;//    	int node2;//    	long weight;//    	long totalWeight;//    	//    	public Edge(int id, int node1, int node2, int weight) {//    		this.id = id;//    		this.node1 = node1;//    		this.node2 = node2;//    		this.weight = weight;//    		totalWeight = Long.MAX_VALUE;//    	}//    	//    	public int getOther(int node) {//    		if (node1 == node) {//    			return node2;//    		} else if (node == node2) {//    			return node1;//    		} else {//    			return -1;//    		}//    	}//    	//		public int compareTo(Edge o) {//			if (this.totalWeight == o.totalWeight) {//				if (this.weight > o.weight) {//					return 1;//				} else if (this.weight < o.weight) {//					return -1;//				} else {//					return 0;//				}//			}//			if (this.totalWeight > o.totalWeight) {//				return 1;//			} else {//				return -1;//			}//		}//		//		public String toString() {//			String weight = "10000000000000000";//			if (this.weight>0) {//				weight = this.weight+"";//			}//			return node1+" "+node2+" "+weight;//		}//    }//    //    int N, M, L, S, T;//    int[] checks;//    long[] totalWeights, endWeights;//    Edge[] edges;//    ArrayList<Edge>[] connected;//    PriorityQueue<Edge> queue;//    //    void execute() {//    	N = scan.nextInt();//    	M = scan.nextInt();//    	L = scan.nextInt();//    	S = scan.nextInt();//    	T = scan.nextInt();//    	checks = new int[N];//    	totalWeights = new long[N];//    	endWeights = new long[N];//    	edges = new Edge[M];//    	connected = new ArrayList[N];//    	queue = new PriorityQueue<Edge>();//    	for (int i = 0; i < N; i++) {//    		totalWeights[i] = Long.MAX_VALUE;//    		endWeights[i] = Long.MAX_VALUE;//    		connected[i] = new ArrayList<Edge>();//    	}//    	for (int i = 0; i < M; i++) {//    		edges[i] = new Edge(i, scan.nextInt(), scan.nextInt(), scan.nextInt());//    		connected[edges[i].node1].add(edges[i]);//    		connected[edges[i].node2].add(edges[i]);//    	}//    	totalWeights[S] = 0;//    	checks[S] = 1;//    	for (Edge edge : connected[S]) {//    		if (edge.weight == 0) {//    			continue;//    		}//    		int child = edge.getOther(S);//    		edge.totalWeight = edge.weight;//    		if (totalWeights[child] > edge.weight) {//    			totalWeights[child] = edge.weight;//    			queue.add(edge);//    		}//    	}//    	while (!queue.isEmpty()) {//    		Edge cur = queue.poll();//    		int parent = -1;//    		int curNode = -1;//    		if (checks[cur.node1] != 1) {//    			parent = cur.node2;//    			curNode = cur.node1;//    		} else if (checks[cur.node2] != 1) {//    			parent = cur.node1;//    			curNode = cur.node2;//    		} else {//    			continue;//    		}//    		checks[curNode] = 1;//    		for (Edge tar : connected[curNode]) {//    			int child = tar.getOther(curNode);//    			if (tar.weight != 0 && checks[child] == 0) {//        			tar.totalWeight = tar.weight + totalWeights[curNode];//	    			if (totalWeights[child] > tar.totalWeight) {//	    				totalWeights[child] = tar.totalWeight;//	    				queue.add(tar);//	    			}//    			}//    		}//    	}////    	System.out.println(Arrays.toString(totalWeights));//    	if (totalWeights[T] < L) {//    		out.println("NO");//    		return;//    	} else if (totalWeights[T] == L) {//    		out.println("YES");//    		for (Edge edge : edges) {//    			out.println(edge.toString());//    		}//    		return;//    	}//    	endWeights[T] = 0;//    	checks[T] = 2;//    	boolean got = false;//    	for (Edge tar : connected[T]) {//			int child = tar.getOther(T);//			long tat = totalWeights[child];//			if (tar.weight == 0) {//				if (tat < L && endWeights[T]+tat < L) {//					tar.weight = L-(endWeights[T]+tat);//					got = true;//					break;//				} else {//					tar.weight = 1;//				}//			}//			tar.totalWeight = tar.weight + endWeights[T];//			if (endWeights[child] > tar.totalWeight) {//				endWeights[child] = tar.totalWeight;//				queue.add(tar);//			}//    	}//    	while (!queue.isEmpty() && !got) {//    		Edge cur = queue.poll();//    		int parent = -1;//    		int curNode = -1;//    		if (checks[cur.node1] != 2) {//    			parent = cur.node2;//    			curNode = cur.node1;//    		} else if (checks[cur.node2] != 2) {//    			parent = cur.node1;//    			curNode = cur.node2;//    		} else {//    			continue;//    		}//    		checks[curNode] = 2;//    		for (Edge tar : connected[curNode]) {//    			int child = tar.getOther(curNode);//    			if (checks[child] == 2) {//    				continue;//    			}//    			long tat = totalWeights[child];//    			if (tar.weight == 0) {//    				if (tat < L && endWeights[curNode]+tat < L) {//    					tar.weight = L-(endWeights[curNode]+tat);//    					got = true;//    					break;//    				} else {//    					tar.weight = 1;//    				}//    			}//    			tar.totalWeight = tar.weight + endWeights[curNode];//				if (endWeights[child] > tar.totalWeight) {//					endWeights[child] = tar.totalWeight;//					queue.add(tar);//				}//        	}//    	}//    	if (got) {//    		out.println("YES");//    		for (Edge edge : edges) {//    			out.println(edge.toString());//    		}//    	} else {//    		out.println("NO");//    	}        class NodeComparator implements Comparator<Integer> {    	long[] dist;    	public NodeComparator(long[] _dist) {    		dist = _dist;    	}    			public int compare(Integer o1, Integer o2) {			if (dist[o1] == dist[o2]) {				return Integer.compare(o1, o2);			}			return Long.compare(dist[o1], dist[o2]);		}    }        	class Edge {		int id;		int node1;		int node2;		long weight;				public Edge(int id, int node1, int node2, int weight) {			this.id = id;			this.node1 = node1;			this.node2 = node2;			this.weight = weight;		}				public int getOther(int node) {			if (node1 == node) {				return node2;			} else if (node == node2) {				return node1;			} else {				return -1;			}		}				public String toString() {			String weight = "10000000000000000";			if (this.weight > 0) {				weight = this.weight + "";			}			return node1 + " " + node2 + " " + weight;		}	}		int N, M, L, S, T;	int[] checks;	long[] totalWeights, endWeights;	Edge[] edges;	ArrayList<Edge>[] connected;	TreeSet<Integer> queue;		void execute() {		N = scan.nextInt();		M = scan.nextInt();		L = scan.nextInt();		S = scan.nextInt();		T = scan.nextInt();		checks = new int[N];		totalWeights = new long[N];		endWeights = new long[N];		edges = new Edge[M];		connected = new ArrayList[N];		queue = new TreeSet<Integer>(new NodeComparator(totalWeights));		for (int i = 0; i < N; i++) {			totalWeights[i] = Long.MAX_VALUE;			endWeights[i] = Long.MAX_VALUE;			connected[i] = new ArrayList<Edge>();		}		for (int i = 0; i < M; i++) {			edges[i] = new Edge(i, scan.nextInt(), scan.nextInt(), scan.nextInt());			connected[edges[i].node1].add(edges[i]);			connected[edges[i].node2].add(edges[i]);		}		totalWeights[S] = 0;		checks[S] = 1;		queue.add(S);		while (!queue.isEmpty()) {			int curNode = queue.pollFirst();			checks[curNode] = 1;			for (Edge tar : connected[curNode]) {				int child = tar.getOther(curNode);				if (tar.weight != 0 && checks[child] == 0) {					long totalWeight = tar.weight + totalWeights[curNode];					if (totalWeights[child] > totalWeight) {						queue.remove(child);						totalWeights[child] = totalWeight;						queue.add(child);					}				}			}		}//  	System.out.println(Arrays.toString(totalWeights));		if (totalWeights[T] < L) {			out.println("NO");			return;		} else if (totalWeights[T] == L) {			out.println("YES");			for (Edge edge : edges) {				out.println(edge.toString());			}			return;		}		endWeights[T] = 0;		checks[T] = 2;		queue = new TreeSet<Integer>(new NodeComparator(endWeights));		boolean got = false;		queue.add(T);		while (!queue.isEmpty() && !got) {			int curNode = queue.pollFirst();//			checks[curNode] = 2;			for (Edge tar : connected[curNode]) {				int child = tar.getOther(curNode);//				if (checks[child] == 2) {//					continue;//				}				long tat = totalWeights[child];				if (tar.weight == 0) {					if (tat < L && endWeights[curNode] + tat < L) {						tar.weight = L - (endWeights[curNode] + tat);						got = true;						break;					} else {						tar.weight = 1;					}				}				long totalWeight = tar.weight + endWeights[curNode];				if (endWeights[child] > totalWeight) {					queue.remove(child);					endWeights[child] = totalWeight;					queue.add(child);				}			}		}		if (got) {			out.println("YES");			for (Edge edge : edges) {				out.println(edge.toString());			}		} else {			out.println("NO");		}	}}
