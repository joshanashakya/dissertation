//package codeforces.practice.oneVone.Oct22_2020; import java.io.*;import java.util.*; public class A553 {    static InputReader in;    static PrintWriter out;     public static void main(String[] args) {        //initReaderPrinter(true);        initReaderPrinter(false);        //solve(in.nextInt());        solve(1);    }     static void solve(int testCnt) {        for (int testNumber = 0; testNumber < testCnt; testNumber++) {            int k = in.nextInt();            int sum = 0;            long mod = (long)1e9 + 7;            int[] c = new int[k];            for(int i = 0; i < k; i++) {                c[i] = in.nextInt();                sum += c[i];            }             long[] factor = new long[sum];            factor[0] = 1;            for(int i = 1; i < sum; i++) {                factor[i] = factor[i - 1] * i % mod;            }            long ans = 1, currSum = c[0];            for(int i = 1; i < k; i++) {                currSum += c[i];                ans = ans * modularMulInverse(factor, currSum - 1, c[i] - 1, mod) % mod;            }            out.println(ans);        }        out.close();    }     static long modularMulInverse(long[] factor, long n, long k, long mod) {        return factor[(int)n] * modInv_EEA(factor[(int)k], mod) % mod                * modInv_EEA(factor[(int)(n - k)], mod) % mod;    }     static long modInv_EEA(long a, long mod) {        long[] res = solveGcdEquation(a, mod);        if(res[2] != 1) {            // a and m are not coprime, modular inverse of a by m does not exist.            return -1;        }        return (res[0] + mod) % mod;    }     static long[] solveGcdEquation(long a, long b) {        if(b == 0) {            return new long[]{1, 0, a};        }        long[] res = solveGcdEquation(b, a % b);        return new long[]{res[1], res[0] - (a / b) * res[1], res[2]};    }     static void initReaderPrinter(boolean test) {        if (test) {            try {                in = new InputReader(new FileInputStream("src/input.in"));                out = new PrintWriter(new FileOutputStream("src/output.out"));            } catch (IOException e) {                e.printStackTrace();            }        } else {            in = new InputReader(System.in);            out = new PrintWriter(System.out);        }    }     static class InputReader {        BufferedReader br;        StringTokenizer st;         InputReader(InputStream stream) {            try {                br = new BufferedReader(new InputStreamReader(stream), 32768);            } catch (Exception e) {                e.printStackTrace();            }        }         String next() {            while (st == null || !st.hasMoreTokens()) {                try {                    st = new StringTokenizer(br.readLine());                } catch (IOException e) {                    e.printStackTrace();                }            }            return st.nextToken();        }         int nextInt() {            return Integer.parseInt(next());        }         long nextLong() {            return Long.parseLong(next());        }         double nextDouble() {            return Double.parseDouble(next());        }         String nextLine() {            String str = "";            try {                str = br.readLine();            } catch (IOException e) {                e.printStackTrace();            }            return str;        }         Integer[] nextIntArray(int n) {            Integer[] a = new Integer[n];            for (int i = 0; i < n; i++) {                a[i] = nextInt();            }            return a;        }         Long[] nextLongArray(int n) {            Long[] a = new Long[n];            for (int i = 0; i < n; i++) {                a[i] = nextLong();            }            return a;        }    }}  
