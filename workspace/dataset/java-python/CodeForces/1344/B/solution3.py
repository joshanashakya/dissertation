class UnionFind:    def __init__(self, n):        self.parent = list(range(n))    def find(self, a): #return parent of a. a and b are in same set if they have same parent        acopy = a        while a != self.parent[a]:            a = self.parent[a]        while acopy != a: #path compression            self.parent[acopy], acopy = a, self.parent[acopy]        return a    def union(self, a, b): #union a and b        self.parent[self.find(b)] = self.find(a)###Usage: (note that all index references are 0-indexed)#n=100 #number of items, indexed from 0 to n-1#uf=UnionFind(n)#assert uf.find(85)!=uf.find(4)#uf.union(85,4)#assert uf.find(85)==uf.find(4) def convertCoordToInt(i,j,n,m): #for union find    return i*m+j def main():        #Put a South on every '#'    #Use DSU to check how many groups of connected '#' there are,    #And ensure that it is impossible to reach all '.'    #If there is an empty row, there must be at least 1 empty column to put South at intersection.    #Same logic for empty column, unless there are no '#'.        n,m=readIntArr()    arr=[]    for _ in range(n):        arr.append(input())        rows=[[None,None] for _ in range(n)] #[earliest '#' column, latest '#' column]    columns=[[None,None] for _ in range(m)]        southCnt=0    for i in range(n):        for j in range(m):            if arr[i][j]=='#':                southCnt+=1                if rows[i][0]==None:                    rows[i]=[j,j]                else:                    rows[i][0]=min(rows[i][0],j)                    rows[i][1]=max(rows[i][1],j)                if columns[j][0]==None:                    columns[j]=[i,i]                else:                    columns[j][0]=min(columns[j][0],i)                    columns[j][1]=max(columns[j][1],i)        if southCnt==0: #no '#' so no need any Norths        print(0)        return        #Unoccupied row and column counts check    uRowCnts=0    uColCnts=0    for i in range(n):        if rows[i][0]==None:            uRowCnts+=1    for j in range(m):        if columns[j][0]==None:            uColCnts+=1#    print(uRowCnts,uColCnts)##    if not ((uRowCnts==0 and uColCnts==0) or (uRowCnts!=0 and uColCnts!=0)): #1 of them is 0        print(-1)        return        uf=UnionFind(n*m)    for i in range(n):        for j in range(m):            if arr[i][j]=='#':                coord1=convertCoordToInt(i,j,n,m)                parent=uf.find(coord1)                #dfs                st=[[i,j]]#                print('next stack')####                while st:                    ii,jj=st.pop()                    minCol,maxCol=rows[ii]                    minRow,maxRow=columns[jj]                                        #####                    print('ii:{} jj:{} minCol:{} maxCol:{} minRow:{} maxRow:{}'.format(ii,jj,minCol,maxCol,minRow,maxRow))                                        possibleCoords=[]                    if minRow<ii:                        possibleCoords.append([ii-1,jj])                    if maxRow>ii:                        possibleCoords.append([ii+1,jj])                    if minCol<jj:                        possibleCoords.append([ii,jj-1])                    if maxCol>jj:                        possibleCoords.append([ii,jj+1])                                        #####                    print('possibleCoords:{}'.format(possibleCoords))                                        for iii,jjj in possibleCoords:                        if arr[iii][jjj]=='#':                            coord2=convertCoordToInt(iii,jjj,n,m)                            parent2=uf.find(coord2)                            if parent!=parent2: #iii,jjj is not yet visited                                uf.union(coord1,coord2)                                st.append([iii,jjj])                                parent=uf.find(coord1)#                                print('({}) {} ({}) {}'.format((i,j),uf.find(convertCoordToInt(i,j,n,m)),#                                        (iii,jjj),uf.find(convertCoordToInt(iii,jjj,n,m)))) ####                        else: #'.' impossible                            print(-1)                            return    groups=set()    for i in range(n):        for j in range(m):            if arr[i][j]=='#':                groups.add(uf.find(convertCoordToInt(i,j,n,m)))    print(len(groups))        #####    print('uRowCnts:{} uColCnts:{}'.format(uRowCnts,uColCnts)) #####    print('rows:{}\ncols:{}'.format(rows,columns))#    group2=[[-1 for _ in range(n)] for __ in range(m)]#    for i in range(n):#        for j in range(m):#            if arr[i][j]=='#':#                group2[i][j]=uf.find(convertCoordToInt(i,j,n,m))#    multiLineArrayOfArraysPrint(group2)        return #import sys#input=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)import sysinput=lambda: sys.stdin.readline().rstrip("\r\n") #FOR READING STRING/TEXT INPUTS. def oneLineArrayPrint(arr):    print(' '.join([str(x) for x in arr]))def multiLineArrayPrint(arr):    print('\n'.join([str(x) for x in arr]))def multiLineArrayOfArraysPrint(arr):    print('\n'.join([' '.join([str(x) for x in y]) for y in arr])) def readIntArr():    return [int(x) for x in input().split()] inf=float('inf')MOD=10**9+7 main()
