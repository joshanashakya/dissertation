import java.io.BufferedReader;import java.io.DataInputStream;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;import java.util.*;   /** * *****Virtual contest div1 participate and up solve, cover 3-5 questions. * You need to do that for 30 plus such contests before 30 June. Till then only codeforces.*****  * ****Use pen and paper************* check few examples analyze them, some not given in sample also analyze then code * Use pen and paper. Solve on paper then code. * If there is some reasoning e.g. sequence/paths, try printing first 100 elements or 100 answers using brute and observe. * *********Read question with extreme caution. Mistake is happening here which costs time, WA and easy problem not getting solved.********* * Sometimes we make question complex due to misunderstanding. * Prefix sum and suffix sum is highly usable concept, look for it. * Think of cleanest approach. If too many if else are coming then its indication of WA. * Solve 1-2 more questions than you solved during contest. */public class Codeforces { 	public static void main(String args[]) throws IOException {//		Reader in = new Reader();		FastReader in = new FastReader();		int n = in.nextInt(), m = in.nextInt();		char c[][] = new char[n][m];		boolean hasBlankRow = false;		for (int i=0;i<n;i++) {			String s = in.next();			int cnt = 0;			for (int j=0;j<m;j++) {				c[i][j] = s.charAt(j);				if (c[i][j] == '.') cnt++;			}			if (cnt == m) hasBlankRow = true;		}				//assure if it has blank row then there is blank column		//and if it doesn't have blank row then now blank column(blank means white)		if (hasBlankRow && !hasBlankColumn(c, n, m)) {			System.out.println(-1);			return;		}				if (!hasBlankRow && hasBlankColumn(c, n, m)) {			System.out.println(-1);			return;		}				//assure all rows and all columns have one segment of black cells		for (int i=0;i<n;i++) {			boolean found = false;			for (int j=0;j<m;j++) {				if (c[i][j] == '#' && found) {					System.out.println(-1);					return;				}				if (c[i][j] == '#') {					while (j<m && c[i][j] == '#') j++;					found = true;				}			}		}				for (int i=0;i<m;i++) {			boolean found = false;			for (int j=0;j<n;j++) {				if (c[j][i] == '#' && found) {					System.out.println(-1);					return;				}				if (c[j][i] == '#') {					while(j<n && c[j][i] == '#') j++;					found = true;				}			}		}				boolean vis[][] = new boolean[n][m];		for (int i=0;i<n;i++) Arrays.fill(vis[i], false);		int ans = 0;		//find number of connected components		for (int i=0;i<n;i++) {			for (int j=0;j<m;j++) {				if (!vis[i][j] && c[i][j] == '#') {					ans++;					dfs(c,vis,i,j,n,m);				}			}		}		System.out.println(ans);		in.close();	} 	private static void dfs(char[][] c, boolean[][] vis, int i, int j, int n, int m) {		if (i<0 || i>=n) return;		if (j<0 || j>=m) return;		if (vis[i][j]) return;		if (c[i][j] == '.') return;				vis[i][j] = true;		dfs(c,vis,i+1,j,n,m);		dfs(c,vis,i-1,j,n,m);		dfs(c,vis,i,j+1,n,m);		dfs(c,vis,i,j-1,n,m);	} 	private static boolean hasBlankColumn(char[][] c, int n, int m) {		for (int i=0;i<m;i++) {			int cnt = 0;			for (int j=0;j<n;j++) {				if (c[j][i] == '.') cnt++;			}			if (cnt == n) return true;		}		return false;	} 	static class Pair {		Long x;		Long y;		private Pair(long x, long y) {			this.x = x;			this.y = y;		}				@Override		public boolean equals(Object o) {			if (o == null || !(o instanceof Pair))				return false;			Pair cor = (Pair)o;			return x.equals(cor.x) && y.equals(cor.y);		}				@Override		public int hashCode() {			int result = 17;			return result;		}				static class PairComparatorX implements Comparator<Pair> { 			@Override			public int compare(Pair o1, Pair o2) {				return o1.x.compareTo(o2.x);			}					} 		static class PairComparatorY implements Comparator<Pair> { 			@Override			public int compare(Pair o1, Pair o2) {				return o1.y.compareTo(o2.y);			}					} 	}		static class Reader     {         final private int BUFFER_SIZE = 1 << 16;         private DataInputStream din;         private byte[] buffer;         private int bufferPointer, bytesRead;          public Reader()         {             din = new DataInputStream(System.in);             buffer = new byte[BUFFER_SIZE];             bufferPointer = bytesRead = 0;         }           public Reader(String file_name) throws IOException         {             din = new DataInputStream(new FileInputStream(file_name));             buffer = new byte[BUFFER_SIZE];             bufferPointer = bytesRead = 0;         }           public String readLine() throws IOException         {             byte[] buf = new byte[64]; // line length             int cnt = 0, c;             while ((c = read()) != -1)             {                 if (c == '\n')                     break;                 buf[cnt++] = (byte) c;             }             return new String(buf, 0, cnt);         }           public int nextInt() throws IOException         {             int ret = 0;             byte c = read();             while (c <= ' ')                 c = read();             boolean neg = (c == '-');             if (neg)                 c = read();             do            {                 ret = ret * 10 + c - '0';             }  while ((c = read()) >= '0' && c <= '9');               if (neg)                 return -ret;             return ret;         }           public long nextLong() throws IOException         {             long ret = 0;             byte c = read();             while (c <= ' ')                 c = read();             boolean neg = (c == '-');             if (neg)                 c = read();             do {                 ret = ret * 10 + c - '0';             }             while ((c = read()) >= '0' && c <= '9');             if (neg)                 return -ret;             return ret;         }           public double nextDouble() throws IOException         {             double ret = 0, div = 1;             byte c = read();             while (c <= ' ')                 c = read();             boolean neg = (c == '-');             if (neg)                 c = read();               do {                 ret = ret * 10 + c - '0';             }             while ((c = read()) >= '0' && c <= '9');               if (c == '.')             {                 while ((c = read()) >= '0' && c <= '9')                 {                     ret += (c - '0') / (div *= 10);                 }             }               if (neg)                 return -ret;             return ret;         }           private void fillBuffer() throws IOException         {             bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);             if (bytesRead == -1)                 buffer[0] = -1;         }           private byte read() throws IOException         {             if (bufferPointer == bytesRead)                 fillBuffer();             return buffer[bufferPointer++];         }           public void close() throws IOException         {             if (din == null)                 return;             din.close();         }             } 		private static class FastReader {		BufferedReader br;		StringTokenizer st; 		public FastReader() {			br = new BufferedReader(new InputStreamReader(System.in));		} 		public void close() {			// TODO Auto-generated method stub					} 		String next() {			while (st == null || !st.hasMoreElements()) {				try {					st = new StringTokenizer(br.readLine());				} catch (IOException e) {					e.printStackTrace();				}			}			return st.nextToken();		} 		int nextInt() {			return Integer.parseInt(next());		} 		long nextLong() {			return Long.parseLong(next());		} 		double nextDouble() {			return Double.parseDouble(next());		} 		String nextLine() {			String str = "";			try {				str = br.readLine();			} catch (IOException e) {				e.printStackTrace();			}			return str;		}	} }
