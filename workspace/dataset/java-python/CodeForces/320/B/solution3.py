n = int(input())  class Graph:     def __init__(self, V):        self.V = V        self.adj = [[] for i in range(V)]     def DFSUtil(self, temp, v,y, visited):         visited[v] = True        if v==y:            return True         # temp.append(v)         for i in self.adj[v]:            if visited[i] == False:                temp = self.DFSUtil(temp, i,y, visited)                if temp==True:                    return True        return False     def addEdge(self, v, w):        self.adj[v].append(w)        # self.adj[w].append(v)     def connectedComponents(self):        visited = []        cc = []        for i in range(self.V):            visited.append(False)        for v in range(self.V):            if visited[v] == False:                temp = []                cc.append(self.DFSUtil(temp, v, visited))        return cc  node_values = [[0,0]]G=Graph(1)cpunter=1for i in range(0, n):    q, a, b = list(map(lambda x: int(x), input().split()))     if q == 1:         G.adj.append([])         for k in range(1,len(node_values)):             if a<node_values[k][0]<b or a<node_values[k][1]<b:                 G.addEdge(k,G.V)            if node_values[k][0]<a<node_values[k][1] or node_values[k][0]<b<node_values[k][1]:                G.addEdge(G.V,k)        node_values.append((a,b))        G.V += 1    else:        visited=[False for _ in range(n)]        if G.DFSUtil(False,a,b,visited):            print("YES")        else:            print("NO")
