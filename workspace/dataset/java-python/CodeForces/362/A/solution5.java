import java.io.OutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.PrintWriter;import java.io.BufferedWriter;import java.io.Writer;import java.io.OutputStreamWriter;import java.util.InputMismatchException;import java.io.IOException;import java.io.InputStream; /** * Built using CHelper plug-in * Actual solution is at the top * * @author Morgrey */public class Main {	public static void main(String[] args) {		InputStream inputStream = System.in;		OutputStream outputStream = System.out;		InputReader in = new InputReader(inputStream);		OutputWriter out = new OutputWriter(outputStream);		TaskA solver = new TaskA();		solver.solve(1, in, out);		out.close();	} 	static class TaskA {		int[][] canBeFirst;		int[][] canBeSecond;		char[][] field; 		public void solve(int testNumber, InputReader in, OutputWriter out) {			int t = in.readInt();			for (int test = 0; test < t; test++) {				canBeFirst = new int[8][8];				canBeSecond = new int[8][8];				field = IOUtils.readTable(in, 8, 8);				int x1 = 0, y1 = 0, x2 = 0, y2 = 0;				int count = 0;				for (int i = 0; i < 8; i++) {					for (int i1 = 0; i1 < 8; i1++) {						if (field[i][i1] == 'K') {							if (count == 0) {								x1 = i;								y1 = i1;								count++;							} else {								x2 = i;								y2 = i1;							}						}					}				} 				if (x1 + 2 < 8 && y1 + 2 < 8) {					canBeFirst[x1 + 2][y1 + 2] = 1;				}				if (x1 + 2 < 8 && y1 - 2 > -1) {					canBeFirst[x1 + 2][y1 - 2] = 1;				} 				if (x1 - 2 > -1 && y1 - 2 > -1) {					canBeFirst[x1 - 2][y1 - 2] = 1;				} 				if (x1 - 2 > -1 && y1 + 2 < 8) {					canBeFirst[x1 - 2][y1 + 2] = 1;				}  				if (x2 + 2 < 8 && y2 + 2 < 8) {					canBeSecond[x2 + 2][y2 + 2] = 1;				}				if (x2 + 2 < 8 && y2 - 2 > -1) {					canBeSecond[x2 + 2][y2 - 2] = 1;				} 				if (x2 - 2 > -1 && y2 - 2 > -1) {					canBeSecond[x2 - 2][y2 - 2] = 1;				} 				if (x2 - 2 > -1 && y2 + 2 < 8) {					canBeSecond[x2 - 2][y2 + 2] = 1;				}				boolean ok = false;				for (int i = 0; i < 8; i++) {					for (int i1 = 0; i1 < 8; i1++) {						if (canBeSecond[i][i1] == 1 && canBeFirst[i][i1] == 1) {							ok = true;						}					}				}				if (ok) {					out.printLine("YES");				} else {					out.printLine("NO");				}			}		} 	} 	static class InputReader {		private InputStream stream;		private byte[] buf = new byte[1024];		private int curChar;		private int numChars;		private SpaceCharFilter filter; 		public InputReader(InputStream stream) {			this.stream = stream;		} 		public int read() {			if (numChars == -1)				throw new InputMismatchException();			if (curChar >= numChars) {				curChar = 0;				try {					numChars = stream.read(buf);				} catch (IOException e) {					throw new InputMismatchException();				}				if (numChars <= 0)					return -1;			}			return buf[curChar++];		} 		public int readInt() {			int c = read();			while (isSpaceChar(c))				c = read();			int sgn = 1;			if (c == '-') {				sgn = -1;				c = read();			}			int res = 0;			do {				if (c < '0' || c > '9')					throw new InputMismatchException();				res *= 10;				res += c - '0';				c = read();			} while (!isSpaceChar(c));			return res * sgn;		} 		public boolean isSpaceChar(int c) {			if (filter != null)				return filter.isSpaceChar(c);			return isWhitespace(c);		} 		public static boolean isWhitespace(int c) {			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;		} 		public char readCharacter() {			int c = read();			while (isSpaceChar(c))				c = read();			return (char) c;		} 		public interface SpaceCharFilter {			public boolean isSpaceChar(int ch); 		} 	} 	static class IOUtils {		public static char[] readCharArray(InputReader in, int size) {			char[] array = new char[size];			for (int i = 0; i < size; i++)				array[i] = in.readCharacter();			return array;		} 		public static char[][] readTable(InputReader in, int rowCount, int columnCount) {			char[][] table = new char[rowCount][];			for (int i = 0; i < rowCount; i++)				table[i] = readCharArray(in, columnCount);			return table;		} 	} 	static class OutputWriter {		private final PrintWriter writer; 		public OutputWriter(OutputStream outputStream) {			writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));		} 		public OutputWriter(Writer writer) {			this.writer = new PrintWriter(writer);		} 		public void print(Object... objects) {			for (int i = 0; i < objects.length; i++) {				if (i != 0)					writer.print(' ');				writer.print(objects[i]);			}		} 		public void printLine(Object... objects) {			print(objects);			writer.println();		} 		public void close() {			writer.close();		} 	}}
