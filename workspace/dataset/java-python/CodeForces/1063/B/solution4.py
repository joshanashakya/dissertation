import sysimport mathfrom collections import defaultdictfrom collections import deque MAXNUM = math.infMINNUM = -1 * math.infASCIILOWER = 97ASCIIUPPER = 65  def getInt():    return int(sys.stdin.readline().rstrip())  def getInts():    return map(int, sys.stdin.readline().rstrip().split(" "))  def getString():    return sys.stdin.readline().rstrip()  def printOutput(ans):    sys.stdout.write()    pass  def successors(grid, curPos, moves):    r, c = curPos    x, y = moves     succStates = []    for a, b in [(1, 0), (-1, 0)]:        if (            0 <= r + a < len(grid)            and 0 <= c + b <= len(grid[0])            and grid[r + a][c + b] != "*"        ):            succStates.append(((r + a, c + b), moves))     # move left    if x > 0 and 0 <= c - 1 and grid[r][c - 1] != "*":        succStates.append(((r, c - 1), (moves[0] - 1, moves[1])))    # move right    if y > 0 and len(grid[0]) > c + 1 and grid[r][c + 1] != "*":        succStates.append(((r, c + 1), (moves[0], moves[1] - 1)))     return succStates  def solve(grid, start, moves):    visited = [[0 for _ in range(len(grid[0]))] for _ in range(len(grid))]     comp = lambda x: x[0] + x[1]     total = 0     frontier = deque()    frontier.append((start, moves))    while frontier:        path, moves = frontier.popleft()        if visited[path[0]][path[1]]:            continue         visited[path[0]][path[1]] = 1         for nextPath, nextMoves in successors(grid, path, moves):            r2, c2 = nextPath            if moves == nextMoves:                frontier.appendleft((nextPath, nextMoves))            else:                frontier.append((nextPath, nextMoves))     #for line in visited:        #print(line)    for line in visited:        total += sum(line)    print(total)  def readinput():    n, m = getInts()    r, c = getInts()    r, c = r - 1, c - 1    x, y = getInts()    grid = []    for _ in range(n):        grid.append(getString())     solve(grid, (r, c), (x, y))  readinput()
