import java.util.*;import java.io.*; public class Main { 	public static void main(String[] args) throws IOException,InterruptedException{		Scanner sc=new Scanner(System.in);//		int t=sc.nextInt();//		while(t-->0) {			int n=sc.nextInt();			int m=sc.nextInt();			int s=sc.nextInt();			pair[] arr1=new pair[m];			int[] arr2=new int[n];			int[] arr3=new int[n];			int max=0;			boolean f=false;			for (int i = 0; i < m; i++) {				int bg=sc.nextInt();				max=Math.max(max,bg);				arr1[i]=new pair(bg,i+1);			}			for (int i = 0; i < n; i++) {				arr2[i]=sc.nextInt();			}for (int i = 0; i < n; i++) {				arr3[i]=sc.nextInt();			}			for (int i = 0; i < n; i++) {				if (arr2[i]>=max) {					if(arr3[i]<=s) {						f=true;						break;					}				}			}			for (int i = 0; i < n; i++) {				pQueue.add(new tuble(arr2[i],arr3[i],i+1));			}			if (f) {				pw.println("YES");				PriorityQueue<pair> pp=new PriorityQueue<>(Collections.reverseOrder());				for (int i = 0; i < m; i++) {					pp.add(arr1[i]);				}				for (int i = 0; i < m; i++) {					arr1[i]=pp.poll();				}//				pw.println(Arrays.toString(arr1));				solve(n,m,s,arr1);//				pw.println(sol+" "+ans);				PriorityQueue<pair> answer=new PriorityQueue<>();				int p=0;				for (tuble k : sol) {					int z=k.z;					for (int j = p; j < ans+p; j++) {						if(j>=m) break; 						answer.add(new pair(arr1[j].y,z));					}					p+=ans;				}//				pw.println(answer);				for (int i = 0; i < m; i++) {					pw.print(answer.poll().y+" ");				}			}else {				pw.println("NO");			}//		}		pw.close();    }	static PriorityQueue<tuble> pQueue=new PriorityQueue<>(Collections.reverseOrder());	static ArrayList<tuble> sol=new ArrayList<>(); 	static int ans=-1;	static void solve(int n,int m,int s,pair[] arr) {		PriorityQueue<Integer> ts=new PriorityQueue<Integer>();//		int ind1=m-1;//		int ind2=n-1;//		long sum=0;//		boolean T=true;//		//		while(ind1>-1) {//			while(ind2>-1&&bugs[ind1].x<=students[ind2].x) {//				ts.add(students[ind2].y);//				ind2--;//			}//			//pw.println(ts);//			if(ts.isEmpty()) {//				T=false;//				break;//			}//			//			sum+=ts.poll();//			ind1-=mid;//		}//		if(!T||sum>s) {//			start=mid;//		}else {//			end=mid;//		}//		mid=(start+end)/2;		int start=0,end=m+1;		while (start<=end) {			int mid=(start+end)/2;			int i=0,cost=s;			PriorityQueue<tuble> ll=new PriorityQueue<>(Collections.reverseOrder());			for (tuble j : pQueue) {				ll.add(j);			}			ArrayList<tuble> arrayList = new ArrayList<>();			PriorityQueue<tuble> pq=new PriorityQueue<>();			for (; i < m; i+=mid) {				int p=0;				while(!ll.isEmpty()) {					tuble k=ll.poll();					if(k.x>=arr[i].x) {						if(cost>=k.y) pq.add(new tuble(k.y,p,k.z));					}else {						ll.add(k);						break;					}				}//				pw.println(pq+" "+ll+" "+mid);				if(pq.isEmpty()) break;				tuble chosen=pq.poll();				cost-=chosen.x;				if(cost<0) break;				arrayList.add(chosen);			}			if (cost<0||i<m) {				start=mid+1;			}else {//				if (arrayList.size()>sol.size()) {					sol=(ArrayList<tuble>)arrayList.clone();					ans=mid;//				}				end=mid-1;			}		}	}		static PrintWriter pw=new PrintWriter(System.out);	static long pow(int a,int b) {		long r=1l;		for (int i = 0; i < b; i++) {			r*=a;		}		return r;	}	static int[]lp;	static void sieveLinear(int N){		ArrayList<Integer> primes = new ArrayList<Integer>();		lp = new int[N + 1];								//lp[i] = least prime divisor of i		for(int i = 2; i <= N; ++i){			if(lp[i] == 0){				primes.add(i);				lp[i] = i;			}			int curLP = lp[i];			for(int p: primes)//all primes smaller than or equal my lowest prime divisor				if(p > curLP || p * 1l * i > N)					break;				else					lp[p * i] = p;		}	}	static long gcd(int x,int y) {		while (x!=y) {			if(Math.max(x,y)/Math.min(x,y)==(double)(Math.max(x,y))/Math.min(x,y)) return Math.min(x,y);			if(lp.length!=0) {				if(lp[x]==x) {					if(y/x==y/(double)x) return x;					else return 1;				}else if (lp[y]==y) {					if(x/y==x/(double)y) return y;					else return 1;				}				}			if(x>y) x-=y;			else y-=x;		}		return x;	}	static class pair implements Comparable<pair> {		int x;		int y; 		public pair(int x, int y) {			this.x = x;			this.y = y;		} 		public String toString() {			return x + " " + y;		}		public boolean equals(Object o) {            if (o instanceof pair) {                pair p = (pair)o;                return p.x == x && p.y == y;            }            return false;        }        public int hashCode() {            return new Double(x).hashCode() * 31 + new Double(y).hashCode();        }        public int compareTo(pair other) {        	if(this.x==other.x) {        		return Long.compare(this.y, other.y);        	}			return Long.compare(this.x, other.x);		}	}	static class tuble implements Comparable<tuble> {		int x;		int y;		int z; 		public tuble(int x, int y, int z) {			this.x = x;			this.y = y;			this.z = z;		} 		public String toString() {			return x + " " + y + " " + z;		} 		public int compareTo(tuble other) {			if (this.x == other.x) {				if(this.y==other.y) return this.z - other.z;				else return this.y - other.y;			} else {				return this.x - other.x;			}		}	} 	static class Scanner {		StringTokenizer st;		BufferedReader br; 		public Scanner(InputStream s) {			br = new BufferedReader(new InputStreamReader(s));		} 		public boolean hasNext() {			// TODO Auto-generated method stub			return false;		} 		public String next() throws IOException {			while (st == null || !st.hasMoreTokens())				st = new StringTokenizer(br.readLine());			return st.nextToken();		} 		public int nextInt() throws IOException {			return Integer.parseInt(next());		} 		public long nextLong() throws IOException {			return Long.parseLong(next());		} 		public String nextLine() throws IOException {			return br.readLine();		} 		public double nextDouble() throws IOException {			String x = next();			StringBuilder sb = new StringBuilder("0");			double res = 0, f = 1;			boolean dec = false, neg = false;			int start = 0;			if (x.charAt(0) == '-') {				neg = true;				start++;			}			for (int i = start; i < x.length(); i++)				if (x.charAt(i) == '.') {					res = Long.parseLong(sb.toString());					sb = new StringBuilder("0");					dec = true;				} else {					sb.append(x.charAt(i));					if (dec)						f *= 10;				}			res += Long.parseLong(sb.toString()) / f;			return res * (neg ? -1 : 1);		} 		public boolean ready() throws IOException {			return br.ready();		} 	} }
