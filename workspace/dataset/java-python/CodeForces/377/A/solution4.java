import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.*; public class Main {     public static final long mod = 1000000007l;    public static final int[] dx = {1, 0, -1, 0};    public static final int[] dy = {0, 1, 0, -1};     public static void main (String[] args) throws IOException {        InputStreamReader r=new InputStreamReader(System.in);        BufferedReader br=new BufferedReader(r);        String[] sn = br.readLine().split(" ");        int n = Integer.parseInt(sn[0]), m = Integer.parseInt(sn[1]), k = Integer.parseInt(sn[2]);        char[][] mat = new char[n][m];        int sx = -1, sy = -1, freecell = 0;        for (int i=0; i<n; i++) {            mat[i] = br.readLine().toCharArray();            for (int j=0; j<m; j++) {                if (mat[i][j] == '.') {                    sx = i;                    sy = j;                    freecell++;                }            }        }        Queue<GenericPair> q = new LinkedList<>();        q.add(new GenericPair(sx, sy));        int count = 0;        boolean[][] visited = new boolean[n][m];        while (!q.isEmpty()) {            if ((freecell - count) == k) {                break;            }            GenericPair gp = q.poll();            if (!visited[gp.x][gp.y]) {                visited[gp.x][gp.y] = true;                count++;            }            for (int i=0; i<4; i++) {                int u = gp.x + dx[i], v = gp.y + dy[i];                if (isValid(u, v, visited, mat, n, m, freecell, k, count)) {                    visited[u][v] = true;                    q.add(new GenericPair(u, v));                    count++;                }            }        }        for (int i=0; i<n; i++) {            for (int j=0; j<m; j++) {                if (mat[i][j] == '.' && !visited[i][j]) {                    mat[i][j] = 'X';                }                System.out.print(mat[i][j]);            }            System.out.println();        }    }     static boolean isValid(int x, int y, boolean[][] visited, char[][] mat, int n, int m, int freecell, int k, int count) {        return x >= 0 && x < n && y >= 0 && y < m && mat[x][y] == '.' && !visited[x][y] && (freecell-count) != k;    }     static class SegmentTree {        int leftIndex;        int rightIndex;        long val;        SegmentTree leftChild;        SegmentTree rightChild;         public SegmentTree(int li, int ri, long[] vals) {            leftIndex = li;            rightIndex = ri;            if (li == ri) {                val = vals[li];            } else {                int mid = li + (ri-li)/2;                leftChild = new SegmentTree(li, mid, vals);                rightChild = new SegmentTree(mid+1, ri, vals);                if (Integer.numberOfTrailingZeros(rightIndex - leftIndex + 1) % 2 == 0) {                    val = leftChild.val ^ rightChild.val;                } else {                    val = leftChild.val | rightChild.val;                }            }        }         public void update(int index, int newVal) {            if (leftIndex == rightIndex) {                val = newVal;            } else {                int mid = leftIndex + (rightIndex - leftIndex) / 2;                if (index <= mid) {                    leftChild.update(index, newVal);                } else {                    rightChild.update(index, newVal);                }                if (Integer.numberOfTrailingZeros(rightIndex - leftIndex + 1) % 2 == 0) {                    val = leftChild.val ^ rightChild.val;                } else {                    val = leftChild.val | rightChild.val;                }            }        }    }     static String getParentPath(int[] parent, int source, int dest) {        ArrayList<Integer> orderedParents = new ArrayList<>();        orderedParents.add(dest);        if (parent[dest] == 0) {            return "-1";        }        while (parent[dest] != -1) {            orderedParents.add(parent[dest]);            dest = parent[dest];        }        StringBuilder sb = new StringBuilder();        for (int i = orderedParents.size()-1; i>=0; i--) {            sb.append(orderedParents.get(i) + " ");        }        return sb.toString();    }     static int bfs(ArrayList<Pair>[] adj, int n, int source, int destination, int[] parent) {        Queue<Integer> q = new LinkedList<>();        int[] distances = new int[n+1];        Arrays.fill(distances, Integer.MAX_VALUE);        q.add(source);        distances[source] = 0;        parent[source] = -1;        while (!q.isEmpty()) {            int u = q.poll();            if (adj[u] == null) continue;            for (Pair p : adj[u]) {                int v = p.v, d = p.d;                if ((distances[u] + d) < distances[v]) {                    distances[v] = distances[u] + d;                    parent[v] = u;                    q.add(v);                }            }        }        if (distances[destination] < Integer.MAX_VALUE) {            return distances[destination];        }        return -1;    }     static class Pair {        int v;        int d;        public Pair(int vv, int dd) {            v = vv;            d = dd;        }    }     static class GenericPair {        int x;        int y;        public GenericPair(int xx, int yy) {            x = xx;            y = yy;        }    } }
