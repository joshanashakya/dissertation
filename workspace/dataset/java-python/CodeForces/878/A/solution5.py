## necessary imports import sysinput = sys.stdin.readlinefrom bisect import bisect_left;from bisect import bisect_right;from math import ceil, factorial; def ceil(x):    if x != int(x):        x = int(x) + 1;    return x;    # swap_array functiondef swaparr(arr, a,b):    temp = arr[a];    arr[a] = arr[b];    arr[b] = temp; ## gcd functiondef gcd(a,b):    if b == 0:        return a;    return gcd(b, a % b); ## nCr function efficient using Binomial Cofficientdef nCr(n, k):     if(k > n - k):         k = n - k;     res = 1;    for i in range(k):         res = res * (n - i);        res = res / (i + 1);     return int(res); ## prime factorizationdef primefs(n):    ## if n == 1    ## calculating primes    primes = {}    while(n%2 == 0 and n > 0):        primes[2] = primes.get(2, 0) + 1        n = n//2    for i in range(3, int(n**0.5)+2, 2):        while(n%i == 0 and n > 0):            primes[i] = primes.get(i, 0) + 1            n = n//i    if n > 2:        primes[n] = primes.get(n, 0) + 1    ## prime factoriazation of n is stored in dictionary    ## primes and can be accesed. O(sqrt n)    return primes ## MODULAR EXPONENTIATION FUNCTIONdef power(x, y, p):     res = 1    x = x % p      if (x == 0) :         return 0    while (y > 0) :         if ((y & 1) == 1) :             res = (res * x) % p         y = y >> 1              x = (x * x) % p     return res  ## DISJOINT SET UNINON FUNCTIONSdef swap(a,b):    temp = a    a = b    b = temp    return a,b; # find function with path compression included (recursive)# def find(x, link):#     if link[x] == x:#         return x#     link[x] = find(link[x], link);#     return link[x]; # find function with path compression (ITERATIVE)def find(x, link):    p = x;    while( p != link[p]):        p = link[p];        while( x != p):        nex = link[x];        link[x] = p;        x = nex;    return p;  # the union function which makes union(x,y)# of two nodes x and ydef union(x, y, link, size):    x = find(x, link)    y = find(y, link)    if size[x] < size[y]:        x,y = swap(x,y)    if x != y:        size[x] += size[y]        link[y] = x ## returns an array of boolean if primes or not USING SIEVE OF ERATOSTHANESdef sieve(n):     prime = [True for i in range(n+1)]     p = 2    while (p * p <= n):         if (prime[p] == True):             for i in range(p * p, n+1, p):                prime[i] = False        p += 1    return prime #### PRIME FACTORIZATION IN O(log n) using Sieve ####MAXN = int(1e5 + 5)def spf_sieve():    spf[1] = 1;    for i in range(2, MAXN):        spf[i] = i;    for i in range(4, MAXN, 2):        spf[i] = 2;    for i in range(3, ceil(MAXN ** 0.5), 2):        if spf[i] == i:            for j in range(i*i, MAXN, i):                if spf[j] == j:                    spf[j] = i;    ## function for storing smallest prime factors (spf) in the array ################## un-comment below 2 lines when using factorization ################## spf = [0 for i in range(MAXN)]# spf_sieve();def factoriazation(x):    ret = {};    while x != 1:        ret[spf[x]] = ret.get(spf[x], 0) + 1;        x = x//spf[x]    return ret;    ## this function is useful for multiple queries only, o/w use    ## primefs function above. complexity O(log n) ## taking integer array inputdef int_array():    return list(map(int, input().strip().split())); def float_array():    return list(map(float, input().strip().split())); ## taking string array inputdef str_array():    return input().strip().split(); #defining a couple constantsMOD = int(1e9)+7;CMOD = 998244353;INF = float('inf'); NINF = -float('inf'); ################### ---------------- TEMPLATE ENDS HERE ---------------- ################### n = int(input()); first = 0; last = 1023;for _ in range(n):    i = input().split();    if i[0] == '|':        first = first | int(i[1]);        last  = last | int(i[1]);    elif i[0] == '&':        first = first & int(i[1]);        last  = last & int(i[1]);    else:        first = first ^ int(i[1]);        last  = last ^ int(i[1]); a = bin(first).replace('0b', '');b = bin(last).replace('0b', '');a = '0' * (10 - len(a)) + a;b = '0' * (10 - len(b)) + b;a = list(map(int, list(a)));b = list(map(int, list(b))); _xor = []; _or = []; for i in range(10):    if a[i] == b[i]:        if a[i] == 0:            _xor.append(1);            _or.append(1);        else:            _xor.append(0);            _or.append(1);    elif a[i] == 1:        _xor.append(1);        _or.append(0);    else:        _xor.append(0);        _or.append(0); x = y = 0;for i in range(10):    y += _xor[i] * ( 2 ** (9 - i));    x += _or[i] * ( 2 ** (9 - i)); print(2);print('| ', x);print('^ ', y);
