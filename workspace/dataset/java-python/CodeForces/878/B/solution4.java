import java.io.*;import java.math.BigDecimal;import java.util.*; import static java.util.stream.Collectors.toList; public class Solution {      static MyScanner sc;    private static PrintWriter out;    static long M2 = 1_000_000_000L + 7;     private static HashMap<Long, Long>[] mods;     public static void main(String[] s) throws Exception {        StringBuilder stringBuilder = new StringBuilder();//        stringBuilder.append(" 4 0 3 2 1 0 3 2 1 ");        if (stringBuilder.length() == 0) {            sc = new MyScanner(System.in);        } else {            sc = new MyScanner(new BufferedReader(new StringReader(stringBuilder.toString())));        }         out = new PrintWriter(new OutputStreamWriter(System.out));          initData();        solve();        out.flush();    }     private static void initData() {    }     static int k;     private static void solve() throws IOException {         int n = sc.nextInt();        k = sc.nextInt();        long m = sc.nextInt();        List<Type> types = new ArrayList<>();         int rm = n;        for (int i = 0; i < n; i++) {            int cur = sc.nextInt();            if (types.size() == 0 || types.get(types.size() - 1).v != cur) {                types.add(new Type(cur));            }            types.get(types.size() - 1).c++;            if (types.get(types.size() - 1).c == k) {                types.remove(types.size() - 1);                rm -= k;            }        }         int l = 0;         long d1 = rm;        while (l < types.size()) {            if (types.get(l).v != types.get(types.size() - l - 1).v) {                break;            }            if (types.get(l).c + types.get(types.size() - l - 1).c >= k) {                d1 -= k;            }             if (types.get(l).c + types.get(types.size() - l - 1).c != k) {                break;            }            l++;        }        if (l == types.size()) {            if (m % 2 == 0) {                out.println(0);            } else {                out.println(rm);            }            return;        }        if (types.size() % 2 == 1 && l == types.size() / 2) {            long rx = types.get(types.size() / 2).c;            long total = rx * m;            total %= k;            if (total == 0) {                out.println(0);                return;            }            long r1 = total;            r1 += rm - rx;            out.println(r1);            return;        }        out.println(d1 * (m - 1) + rm);     }      private static final class Type {        int v;         public Type(int v) {            this.v = v;        }         int c;         public Type(int v, int c) {            this.v = v;            this.c = c;        }         public Type copy() {            return new Type(v, c);         }    }     private static class Col {     }     private static int get(int i, int i1) {//        int[] nn = new int[]{6, 7, 4, 5, 0, 1, 8, 9, 2, 3};//        int[] rr = new int[nn.length];//        for (int k = 0; k < nn.length; k++) {//            rr[nn[k]] = k;//        }//        return nn[i] ^ rr[i1];//        out.println("? " + i + " " + i1);        out.flush();        return sc.nextInt();    }     private static boolean solve(int n, int p, int p1, int i) {        return false;    }      private static boolean isset(long i, int k) {        return (i & (1 << k)) > 0;    }     private static void solveT() throws IOException {        int t = sc.nextInt();        while (t-- > 0) {            solve();        }    }      private static long gcd(long l, long l1) {        if (l > l1) return gcd(l1, l);        if (l == 0) return l1;        return gcd(l1 % l, l);    }     private static long pow(long a, long b, long m) {        if (b == 0) return 1;        if (b == 1) return a;        long pp = pow(a, b / 2, m);        pp *= pp;        pp %= m;        return (pp * (b % 2 == 0 ? 1 : a)) % m;    }      static class MyScanner {        BufferedReader br;        StringTokenizer st;         MyScanner(BufferedReader br) {            this.br = br;        }         public MyScanner(InputStream in) {            this(new BufferedReader(new InputStreamReader(in)));        }         void findToken() {            while (st == null || !st.hasMoreTokens()) {                try {                    st = new StringTokenizer(br.readLine());                } catch (IOException e) {                    throw new RuntimeException(e);                }            }        }         String next() {            findToken();            return st.nextToken();        }         Integer[] nab(int n) {            Integer[] k = new Integer[n];            for (int i = 0; i < n; i++) {                k[i] = sc.fi();            }            return k;        }         int[] na(int n) {            int[] k = new int[n];            for (int i = 0; i < n; i++) {                k[i] = sc.fi();            }            return k;        }         long[] nl(int n) {            long[] k = new long[n];            for (int i = 0; i < n; i++) {                k[i] = sc.nextLong();            }            return k;        }         int nextInt() {            return Integer.parseInt(next());        }         int fi() {            String t = next();            int cur = 0;            boolean n = t.charAt(0) == '-';            for (int a = n ? 1 : 0; a < t.length(); a++) {                cur = cur * 10 + t.charAt(a) - '0';            }            return n ? -cur : cur;        }         long nextLong() {            return Long.parseLong(next());        }         double nextDouble() {            return Double.parseDouble(next());        }    }  }
