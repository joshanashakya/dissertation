import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.StringTokenizer;import java.util.*; public class Q443B {		BufferedReader reader;    StringTokenizer tokenizer;    PrintWriter out;    	public void solve() throws IOException {						int N = nextInt();		int K = nextInt();		int M = nextInt();     int[] inputs = new int[N];    for (int i = 0; i < N; i++) {      inputs[i] = nextInt();    }    int[] seq = trim(inputs, K);     // int[] seq = buildSeq(N, K);     int curStart = 0;    int curEnd = seq.length-1;    boolean allSame = false;     while (true) {      int size = curEnd - curStart + 1;      if (size == 0) break;      if (seq[curStart] != seq[curEnd]) break;      int a = seq[curStart];       int countStart = 1;      while (curStart+countStart <= curEnd && seq[curStart + countStart] == a) {        countStart++;      }       if (countStart == size) { // all same        allSame = true;        break;      }       int countEnd = 1;      while (seq[curEnd - countEnd] == a) {        countEnd++;      }      int total = countStart + countEnd;      if (total < K) break;       curStart = curStart + countStart;      curEnd = curEnd - (K - countStart);    }     long size = curEnd - curStart + 1;    if (allSame) {      long sumCount = size * M;      long remain = sumCount % K;       ArrayList<Integer> finalSeq = new ArrayList<Integer>();      for (int i = 0; i < curStart; i++) {        finalSeq.add(seq[i]);      }      for (int i = 0; i < remain; i++) {        finalSeq.add(seq[curStart]);      }      for (int i = curEnd+1; i < seq.length; i++) {        finalSeq.add(seq[i]);      }      int[] finalSeqArr = new int[finalSeq.size()];      for (int i = 0; i < finalSeq.size(); i++) {        finalSeqArr[i] = finalSeq.get(i);      }      int[] trimed = trim(finalSeqArr, K);      out.println(trimed.length);    } else {      long cut = seq.length - size;      long allCut = cut * (M-1);      long ans = (long) seq.length * M - allCut;      out.println(ans);    }    //out.println( Arrays.toString(seq));	}   public int[] trim(int[] arr, int K) {    Stack<int[]> counts = new Stack<int[]>();    for (int i = 0; i < arr.length; i++) {      if (counts.size() == 0) {        counts.push(new int[] {arr[i], 1});      } else {        int[] last = counts.peek();        if (last[0] == arr[i]) {          counts.pop();          last[1]++;          counts.push(last);        } else {          counts.push(new int[] {arr[i], 1});        }      }       while (true) {        if (counts.size() == 0) break;        int[] last = counts.peek();        if (last[1] == K) {          counts.pop();        } else {          break;        }      }    }    ArrayList<Integer> seq = new ArrayList<Integer>();    while (counts.size() > 0) {      int[] last = counts.pop();      for (int i = 0; i < last[1]; i++) {        seq.add(last[0]);      }    }     int[] ret = new int[seq.size()];    for (int i = 0; i < ret.length; i++) {      ret[i] = seq.get(ret.length-1-i);    }    return ret;  }		/**	 * @param args	 */	public static void main(String[] args) {		new Q443B().run();	}		public void run() {        try {            reader = new BufferedReader(new InputStreamReader(System.in));            tokenizer = null;            out = new PrintWriter(System.out);            solve();            reader.close();            out.close();        } catch (Exception e) {            e.printStackTrace();            System.exit(1);        }    }     int nextInt() throws IOException {        return Integer.parseInt(nextToken());    }     long nextLong() throws IOException {        return Long.parseLong(nextToken());    }     double nextDouble() throws IOException {        return Double.parseDouble(nextToken());    }     String nextToken() throws IOException {        while (tokenizer == null || !tokenizer.hasMoreTokens()) {            tokenizer = new StringTokenizer(reader.readLine());        }        return tokenizer.nextToken();    } }  
