import java.io.IOException;import java.io.InputStream;import java.util.Comparator;import java.util.HashMap;import java.util.InputMismatchException; public class Main {		static int[] points = {25, 18, 15, 12, 10, 8, 6, 4, 2, 1};		public static void main(String[] args) {		FastScanner input = new FastScanner(System.in);				int T = input.nextInt();				HashMap<String, Driver> map = new HashMap<>();				for (int t = 0; t < T; t++) {			int N = input.nextInt();						for (int i = 0; i < N; i++) {				String name = input.next();				if (!map.containsKey(name))					map.put(name, new Driver(name));				Driver driver = map.get(name);				if (i < 10) 					driver.points += points[i];				driver.places[i]++;			}		}				Comparator<Driver> cmp1 = new Comparator<Driver>() {			@Override			public int compare(Driver a, Driver b) {				if (a.points == b.points)					for (int i = 0; i < 50; i++)						if (a.places[i] != b.places[i])							return a.places[i] - b.places[i];				return a.points - b.points;			}		};				Comparator<Driver> cmp2 = new Comparator<Driver>() {			@Override			public int compare(Driver a, Driver b) {				if (a.places[0] == b.places[0] && a.points == b.points)					for (int i = 1; i < 50; i++)						if (a.places[i] != b.places[i])							return a.places[i] - b.places[i];				if (a.places[0] == b.places[0])					return a.points - b.points;				return a.places[0] - b.places[0];			}		};				Driver c1 = null;		Driver c2 = null;				for (Driver driver : map.values()) {			if (c1 == null || cmp1.compare(c1, driver) < 0)				c1 = driver;			if (c2 == null || cmp2.compare(c2, driver) < 0)				c2 = driver;		}				System.out.println(c1.name);		System.out.println(c2.name);	}		static class Driver {		String name;		int points;		int[] places = new int[50];				Driver(String name) { this.name = name; }				@Override		public int hashCode() { return name.hashCode(); }	}		// Matt Fontaine's Fast IO	static class FastScanner {		private InputStream stream;		private byte[] buf = new byte[1024];		private int curChar;		private int numChars; 		public FastScanner(InputStream stream) {			this.stream = stream;		} 		int read() {			if (numChars == -1)				throw new InputMismatchException();			if (curChar >= numChars) {				curChar = 0;				try {					numChars = stream.read(buf);				} catch (IOException e) {					throw new InputMismatchException();				}				if (numChars <= 0)					return -1;			}			return buf[curChar++];		} 		boolean isSpaceChar(int c) {			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;		} 		boolean isEndline(int c) {			return c == '\n' || c == '\r' || c == -1;		} 		int nextInt() {			return Integer.parseInt(next());		} 		long nextLong() {			return Long.parseLong(next());		} 		double nextDouble() {			return Double.parseDouble(next());		} 		String next() {			int c = read();			while (isSpaceChar(c))				c = read();			StringBuilder res = new StringBuilder();			do {				res.appendCodePoint(c);				c = read();			} while (!isSpaceChar(c));			return res.toString();		} 		String nextLine() {			int c = read();			while (isEndline(c))				c = read();			StringBuilder res = new StringBuilder();			do {				res.appendCodePoint(c);				c = read();			} while (!isEndline(c));			return res.toString();		}	}}
