import java.io.*;import java.util.*; import static java.lang.Math.min;  /** * Created by Katushka on 11.03.2020. */public class C {     public static final Comparator<int[]> COMPARATOR = Comparator.comparingInt(o -> o[0]);     static int[] readArray(int size, InputReader in) {        int[] a = new int[size];        for (int i = 0; i < size; i++) {            a[i] = in.nextInt();        }        return a;    }     static long[] readLongArray(int size, InputReader in) {        long[] a = new long[size];        for (int i = 0; i < size; i++) {            a[i] = in.nextLong();        }        return a;    }     public static void main(String[] args) {        InputReader in = new InputReader(System.in);        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));         int n = in.nextInt();        int m = in.nextInt();        int k = in.nextInt();        int maxD = 0;        List<int[]> toFlights = new ArrayList<>();        List<int[]> fromFlights = new ArrayList<>();        for (int i = 0; i < m; i++) {            int d = in.nextInt();            int f = in.nextInt();            int t = in.nextInt();            int c = in.nextInt();            maxD = Math.max(d, maxD);            if (f == 0) {                fromFlights.add(new int[]{d, t, c});            } else {                toFlights.add(new int[]{d, f, c});            }        }        toFlights.sort(Comparator.comparingInt(o -> o[0]));        fromFlights.sort(Comparator.comparingInt(o -> o[0]));         Map<Integer, Integer> toBestFlights = new HashMap<>();        int startFlights = 0;        int startToTime = -1;        long[] bestToSum = new long[maxD + 1];        long sum = 0;        int oldD = -1;        long oldSum = 0;        for (int i = 0; i < toFlights.size(); i++) {            int[] toFlight = toFlights.get(i);             if (!toBestFlights.containsKey(toFlight[1])) {                if (startFlights == n - 1) {                    startToTime = toFlight[0];                }                startFlights++;                toBestFlights.put(toFlight[1], toFlight[2]);                sum = sum + toFlight[2];            } else {                sum -= toBestFlights.get(toFlight[1]);                toBestFlights.put(toFlight[1], min(toBestFlights.get(toFlight[1]), toFlight[2]));                sum = sum + toBestFlights.get(toFlight[1]);            }             if (startFlights == n) {                for (int j = oldD + 1; j < toFlight[0]; j++) {                    bestToSum[j] = oldSum;                }                bestToSum[toFlight[0]] = sum;            }            oldD = toFlight[0];            oldSum = sum;        }         if (startFlights == n) {            for (int j = oldD + 1; j < maxD + 1; j++) {                bestToSum[j] = oldSum;            }        }         Map<Integer, Integer> fromBestFlights = new HashMap<>();        startFlights = 0;        int startFromTime = -1;        long[] bestFromSum = new long[maxD + 1];        sum = 0;        oldD = maxD + 1;        oldSum = 0;        for (int i = fromFlights.size() - 1; i >= 0; i--) {            int[] fromFlight = fromFlights.get(i);            if (!fromBestFlights.containsKey(fromFlight[1])) {                if (startFlights == n - 1) {                    startFromTime = fromFlight[0];                }                startFlights++;                fromBestFlights.put(fromFlight[1], fromFlight[2]);                sum = sum + fromFlight[2];            } else {                sum -= fromBestFlights.get(fromFlight[1]);                fromBestFlights.put(fromFlight[1], min(fromBestFlights.get(fromFlight[1]), fromFlight[2]));                sum = sum + fromBestFlights.get(fromFlight[1]);             }            if (startFlights == n) {                for (int j = oldD - 1; j > fromFlight[0]; j--) {                    bestFromSum[j] = oldSum;                }                bestFromSum[fromFlight[0]] = sum;            }            oldD = fromFlight[0];            oldSum = sum;        }         if (startFlights == n) {            for (int j = oldD - 1; j >= 0; j--) {                bestFromSum[j] = oldSum;            }        }         if (startToTime == -1 || startFromTime == -1 || startFromTime - startToTime - 1 < k) {            out.println(-1);            out.close();            return;        }           long ans = Long.MAX_VALUE;        for (int i = startToTime; i + k < startFromTime; i++) {            ans = min(ans, bestFromSum[i + k + 1] + bestToSum[i]);        }        out.println(ans);         out.close();    }     private static void outputArray(List<Integer> ans, PrintWriter out) {        StringBuilder str = new StringBuilder();        for (int an : ans) {            str.append(an).append(" ");        }        out.println(str);    }     private static class InputReader {        public BufferedReader reader;        public StringTokenizer tokenizer;         public InputReader(InputStream stream) {            reader = new BufferedReader(new InputStreamReader(stream), 32768);            tokenizer = null;        }         public String next() {            while (tokenizer == null || !tokenizer.hasMoreTokens()) {                try {                    tokenizer = new StringTokenizer(reader.readLine());                } catch (IOException e) {                    throw new RuntimeException(e);                }            }            return tokenizer.nextToken();        }         public String nextString() {            try {                return reader.readLine();            } catch (IOException e) {                throw new RuntimeException(e);            }        }         public int nextInt() {            return Integer.parseInt(next());        }         public long nextLong() {            return Long.parseLong(next());        }         public char nextChar() {            return next().charAt(0);        }    }}
