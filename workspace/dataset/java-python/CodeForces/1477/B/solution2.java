import java.util.*;import java.io.*;import java.text.*;public class Solution implements Runnable {    FastScanner sc;    PrintWriter pw;        final class FastScanner {        BufferedReader br;        StringTokenizer st;         public FastScanner() {            try {                br = new BufferedReader(new InputStreamReader(System.in));                st = new StringTokenizer(br.readLine());            } catch (Exception e) {                e.printStackTrace();            }        }         public long nlo() {            return Long.parseLong(next());        }         public String next() {            if (st.hasMoreTokens()) return st.nextToken();            try {                st = new StringTokenizer(br.readLine());            } catch (Exception e) {                e.printStackTrace();            }            return st.nextToken();        }         public int ni() {            return Integer.parseInt(next());        }         public String nli() {            String line = "";            if (st.hasMoreTokens()) line = st.nextToken();            else try {                return br.readLine();            } catch (IOException e) {                e.printStackTrace();            }            while (st.hasMoreTokens()) line += " " + st.nextToken();            return line;        }         public double nd() {            return Double.parseDouble(next());        }    }    public static void main(String[] args) throws Exception    {        new Thread(null,new Solution(),"codeforces",1<<28).start();    }    public void run()    {        sc=new FastScanner();        pw=new PrintWriter(System.out);        try{            solve();        }        catch(Exception e)        {            pw.println(e);        }        pw.flush();        pw.close();    }    public long gcd(long a,long b)    {        return b==0L?a:gcd(b,a%b);    }    public long ppow(long a,long b,long mod)    {        if(b==0L)        return 1L;        long tmp=1;        while(b>1L)        {            if((b&1L)==1L)            tmp*=a;            a*=a;            a%=mod;            tmp%=mod;            b>>=1;        }        return (tmp*a)%mod;    }    public long pow(long a,long b)    {        if(b==0L)        return 1L;        long tmp=1;        while(b>1L)        {            if((b&1L)==1)            tmp*=a;            a*=a;            b>>=1;        }        return (tmp*a);    }    public  int gcd(int x,int y)    {        return y==0?x:gcd(y,x%y);    }       //////////////////////////////////    /////////////  LOGIC  ///////////    ////////////////////////////////    public void solve() throws Exception{        int t=sc.ni();        while(t-->0){            int n=sc.ni();            int q=sc.ni();            char[] s=sc.next().toCharArray();            char[] f=sc.next().toCharArray();            int[][] qrr=new int[q][2];            for(int i=0;i<q;i++){                qrr[i][0]=sc.ni()-1;                qrr[i][1]=sc.ni()-1;            }            char[] segVal=new char[4*n+1];            int[] segCount=new int[4*n+1];            Arrays.fill(segVal,'@');            boolean res = true;            fill(segVal,segCount,1,0,n-1,f);            for(int i=q-1;i>=0;i--){                int length = qrr[i][1]-qrr[i][0]+1;                int one = query(segCount,segVal,qrr[i][0],qrr[i][1],1,0,n-1);                int zero = length-one;                if(one <= (length-1)/2){                    if(one>0)                        segFill(segVal,segCount,qrr[i][0],qrr[i][1],'0',1,0,n-1);                }                else if(zero<= (length-1)/2){                    if(zero>0)                        segFill(segVal,segCount,qrr[i][0],qrr[i][1],'1',1,0,n-1);                }                else                    res=false;            }            for(int i=0;i<n;i++){                int one = s[i]=='1'?1:0;                if(query(segCount,segVal,i,i,1,0,n-1)!=one)                res=false;            }            if(res)            pw.println("YES");            else            pw.println("NO");        }    }    public void segFill(char[] seg,int[] segCount,int l,int r,char ch, int ind,int st,int end){        if(l>end||r<st)            return;        l=Math.max(l,st);        r=Math.min(r,end);        if(l==st&&r==end){            seg[ind]=ch;            if(ch=='0')                segCount[ind]=0;            else                segCount[ind]=r-l+1;            return;        }        if(seg[ind]!='@'){            seg[2*ind]=seg[ind];            seg[2*ind+1]=seg[ind];            if(seg[ind]=='1'){                segCount[2*ind]=(st+end)/2-st+1;                segCount[2*ind+1]=end-(st+end)/2;            }            else                segCount[2*ind]=segCount[2*ind+1]=0;            seg[ind]='@';        }        segFill(seg,segCount,l,r,ch,2*ind,st,(st+end)/2);        segFill(seg,segCount,l,r,ch,2*ind+1,(st+end)/2+1,end);        segCount[ind]=segCount[2*ind]+segCount[2*ind+1];    }    public void fill(char[] segVal,int[] segCount,int ind,int l,int r,char[] arr){        if(l>r)        return;        if(l==r){            segVal[ind]=arr[l];            if(arr[l]=='1')                segCount[ind]=1;            else                segCount[ind]=0;            return;        }        fill(segVal,segCount,2*ind,l,(l+r)/2,arr);        fill(segVal,segCount,2*ind+1,(l+r)/2+1,r,arr);        segCount[ind]=segCount[2*ind]+segCount[2*ind+1];    }    public int query(int[] seg,char[] segVal,int l,int r,int ind,int st,int end){        if(l>end||r<st)            return 0;        l=Math.max(l,st);        r=Math.min(r,end);        if(segVal[ind]!='@'){            if(segVal[ind]=='1')            return r-l+1;            return 0;        }        if(l<=st&&r>=end)            return seg[ind];        return query(seg,segVal,l,r,2*ind,st,(st+end)/2)+query(seg,segVal,l,r,2*ind+1,(st+end)/2+1,end);    }}
