import java.util.*;import java.util.Map.Entry; import java.math.*;import java.io.*; public class Main {	public static void main(String[] args) throws FileNotFoundException {		InputReader in = new InputReader(System.in);		// Scanner in = new Scanner(System.in);		// Scanner in = new Scanner(new BufferedReader(new		// InputStreamReader(System.in)));		PrintWriter out = new PrintWriter(System.out);		// InputReader in = new InputReader(new		// File("ethan_traverses_a_tree.txt"));		// PrintWriter out = new PrintWriter(new		// File("ethan_traverses_a_tree-output.txt")); 		int pi = in.nextInt();		for (int qi = 0; qi < pi; qi++) {			int n = in.nextInt();			int q = in.nextInt();			String start = in.next();			String end = in.next(); 			int[] a = new int[n];			for (int i = 0; i < n; i++) {				a[i] = end.charAt(i) - '0';			} 			SegmentTree st = new SegmentTree(n, a); 			int[][] qdata = new int[q][2];			for (int i = 0; i < q; i++) {				qdata[i][0] = in.nextInt();				qdata[i][1] = in.nextInt();			} 			boolean ans = true; 			for (int i = q - 1; i >= 0; i--) {				int left = qdata[i][0];				int right = qdata[i][1]; 				int length = right - left + 1;				int count1 = st.querySum(left, right);				int count0 = length - count1; 				if (count0 == count1) {					ans = false;					break;				} else if (count0 < count1) {					st.set(left, right, 1);				} else {					st.set(left, right, 0);				}			} 			for (int i = 0; i < n; i++) {				if (st.querySum(i + 1, i + 1) != start.charAt(i) - '0') {					ans = false;					break;				}			} 			if (ans == true) {				out.printf("YES\n");			} else {				out.printf("NO\n");			}		} 		out.close();	} 	static class SegmentTree {		private int n; 		// [1, n] is valid		private int[] dataMin;		private int[] dataMax;		private int[] dataSum; 		private int[] incrVal;		private int[] setVal;		private boolean[] isSet; 		static final int INF = 1 << 30; 		public SegmentTree(int m) {			this.n = 1;			while (this.n < m) {				this.n = this.n * 2;			} 			int nn = this.n * 2; 			this.dataMin = new int[nn];			this.dataMax = new int[nn];			this.dataSum = new int[nn]; 			this.incrVal = new int[nn];			this.setVal = new int[nn];			this.isSet = new boolean[nn];		} 		public SegmentTree(int m, int[] a) { // a[0] .. a[m-1] is valid			this(m); 			for (int i = n; i < 2 * n; i++) {				int aIndex = i - n;				if (aIndex >= m) {					dataMin[i] = dataMax[i] = dataSum[i] = 0;				} else {					dataMin[i] = dataMax[i] = dataSum[i] = incrVal[i] = a[aIndex];				}			}			for (int i = n - 1; i >= 1; i--) {				int leftChild = this.getLeftChild(i);				int rightChild = this.getRightChild(i); 				dataMin[i] = Math.min(dataMin[leftChild], this.dataMin[rightChild]);				dataMax[i] = Math.max(dataMax[leftChild], this.dataMax[rightChild]);				dataSum[i] = dataSum[leftChild] + dataSum[rightChild];			} 			for (int i = 1; i < 2 * n; i++) {				// System.out.println(i + " " + dataSum[i]);			}		} 		private int getLeftChild(int nowIndex) {			return nowIndex * 2;		} 		private int getRightChild(int nowIndex) {			return nowIndex * 2 + 1;		} 		public int querySum(int y1, int y2) {			SegmentTreeResult result = this.queryAll(y1, y2);			return result.sum;		} 		public int queryMin(int y1, int y2) {			SegmentTreeResult result = this.queryAll(y1, y2);			return result.min;		} 		public int queryMax(int y1, int y2) {			SegmentTreeResult result = this.queryAll(y1, y2);			return result.max;		} 		public SegmentTreeResult queryAll(int y1, int y2) {			SegmentTreeResult result = this._query(y1, y2, 1, 1, this.n, 0);			return result;		} 		private SegmentTreeResult _query(int y1, int y2, int nowIndex, int leftBound, int rightBound, int tmpIncr) { 			SegmentTreeResult result = new SegmentTreeResult();			int realLen = Math.min(y2, rightBound) - Math.max(y1, leftBound) + 1; 			if (this.isSet[nowIndex]) {				int allIncr = tmpIncr + incrVal[nowIndex]; 				result.min = setVal[nowIndex] + allIncr;				result.max = setVal[nowIndex] + allIncr;				result.sum = (setVal[nowIndex] + allIncr) * realLen; 				// System.out.println("isset " + nowIndex + " " + result.sum);				return result;			} 			if (y1 <= leftBound && y2 >= rightBound) {				result.min = dataMin[nowIndex] + tmpIncr;				result.max = dataMax[nowIndex] + tmpIncr;				result.sum = dataSum[nowIndex] + tmpIncr * realLen; 				// System.out.println("cover " + nowIndex + " " + result.sum);				return result;			} 			int leftChild = this.getLeftChild(nowIndex);			int rightChild = this.getRightChild(nowIndex); 			result.min = SegmentTree.INF;			result.max = -SegmentTree.INF;			result.sum = 0; 			int mid = leftBound + (rightBound - leftBound) / 2; 			if (y1 <= mid) {				SegmentTreeResult leftResult = this._query(y1, y2, leftChild, leftBound, mid,						tmpIncr + incrVal[nowIndex]); 				result.min = Math.min(result.min, leftResult.min);				result.max = Math.max(result.max, leftResult.max);				result.sum += leftResult.sum;			}			if (y2 > mid) {				SegmentTreeResult rightResult = this._query(y1, y2, rightChild, mid + 1, rightBound,						tmpIncr + incrVal[nowIndex]);				result.min = Math.min(result.min, rightResult.min);				result.max = Math.max(result.max, rightResult.max);				result.sum += rightResult.sum;			}			// System.out.println("nomal " + nowIndex + " " + result.sum);			return result;		} 		public void incr(int y1, int y2, int val) {			this._incr(y1, y2, val, 1, 1, n);		} 		private void _incr(int y1, int y2, int val, int nowIndex, int leftBound, int rightBound) {			if (y1 <= leftBound && y2 >= rightBound) {				incrVal[nowIndex] += val;				this.maintain(nowIndex, leftBound, rightBound);				return;			} 			boolean isPushDown = false;			if (isSet[nowIndex]) {				isPushDown = true;				this.pushdown(nowIndex, leftBound, rightBound);			} 			int leftChild = this.getLeftChild(nowIndex);			int rightChild = this.getRightChild(nowIndex);			int mid = leftBound + (rightBound - leftBound) / 2; 			if (y1 <= mid) {				this._incr(y1, y2, val, leftChild, leftBound, mid);			} else if (isPushDown) {				this.maintain(leftChild, leftBound, mid);			} 			if (y2 > mid) {				this._incr(y1, y2, val, rightChild, mid + 1, rightBound);			} else if (isPushDown) {				this.maintain(rightChild, mid + 1, rightBound);			} 			this.maintain(nowIndex, leftBound, rightBound);		} 		public void set(int y1, int y2, int val) {			this._set(y1, y2, val, 1, 1, n);		} 		private void _set(int y1, int y2, int val, int nowIndex, int leftBound, int rightBound) {			if (y1 <= leftBound && y2 >= rightBound) {				isSet[nowIndex] = true;				setVal[nowIndex] = val;				incrVal[nowIndex] = 0;				this.maintain(nowIndex, leftBound, rightBound);				return;			} 			boolean isPushDown = false;			if (isSet[nowIndex] || incrVal[nowIndex] != 0) {				isPushDown = true;				this.pushdown(nowIndex, leftBound, rightBound);			} 			int leftChild = this.getLeftChild(nowIndex);			int rightChild = this.getRightChild(nowIndex);			int mid = leftBound + (rightBound - leftBound) / 2; 			if (y1 <= mid) {				this._set(y1, y2, val, leftChild, leftBound, mid);			} else if (isPushDown) {				this.maintain(leftChild, leftBound, mid);			} 			if (y2 > mid) {				this._set(y1, y2, val, rightChild, mid + 1, rightBound);			} else if (isPushDown) {				this.maintain(rightChild, mid + 1, rightBound);			} 			this.maintain(nowIndex, leftBound, rightBound);		} 		private void maintain(int nowIndex, int leftBound, int rightBound) {			int nn = rightBound - leftBound + 1;			if (isSet[nowIndex]) {				dataMin[nowIndex] = setVal[nowIndex] + incrVal[nowIndex];				dataMax[nowIndex] = setVal[nowIndex] + incrVal[nowIndex];				dataSum[nowIndex] = (setVal[nowIndex] + incrVal[nowIndex]) * nn;				return;			} 			if (rightBound > leftBound) {				int leftChild = this.getLeftChild(nowIndex);				int rightChild = this.getRightChild(nowIndex); 				dataMin[nowIndex] = Math.min(dataMin[leftChild], dataMin[rightChild]) + incrVal[nowIndex];				dataMax[nowIndex] = Math.max(dataMax[leftChild], dataMax[rightChild]) + incrVal[nowIndex];				dataSum[nowIndex] = dataSum[leftChild] + dataSum[rightChild] + incrVal[nowIndex] * nn;			} else { // last row(range [n, 2*n-1]) has not children				dataMin[nowIndex] = dataMax[nowIndex] = dataSum[nowIndex] = incrVal[nowIndex];			}		} 		private void pushdown(int nowIndex, int leftBound, int rightBound) {			if (rightBound > leftBound) {				int leftChild = this.getLeftChild(nowIndex);				int rightChild = this.getRightChild(nowIndex); 				if (isSet[nowIndex]) {					setVal[leftChild] = setVal[nowIndex];					incrVal[leftChild] = incrVal[nowIndex];					isSet[leftChild] = true; 					setVal[rightChild] = setVal[nowIndex];					incrVal[rightChild] = incrVal[nowIndex];					isSet[rightChild] = true;				} else {					incrVal[leftChild] += incrVal[nowIndex];					incrVal[rightChild] += incrVal[nowIndex];				} 				isSet[nowIndex] = false;				incrVal[nowIndex] = 0;				setVal[nowIndex] = 0;			}		}	} 	static class SegmentTreeResult {		public int min;		public int max;		public int sum;	} 	static class InputReader {		BufferedReader br;		StringTokenizer st; 		public InputReader(File f) {			try {				br = new BufferedReader(new FileReader(f));			} catch (FileNotFoundException e) {				e.printStackTrace();			}		} 		public InputReader(InputStream in) {			br = new BufferedReader(new InputStreamReader(in));		} 		public String next() {			while (st == null || !st.hasMoreTokens()) {				try {					st = new StringTokenizer(br.readLine());				} catch (IOException e) {					e.printStackTrace();				}			}			return st.nextToken();		} 		public boolean hasNext() {			while (st == null || !st.hasMoreTokens()) {				String s = null;				try {					s = br.readLine();				} catch (IOException e) {					e.printStackTrace();				}				if (s == null)					return false;				st = new StringTokenizer(s);			}			return true;		} 		public int nextInt() {			return Integer.parseInt(next());		} 		public long nextLong() {			return Long.parseLong(next());		} 		public double nextDouble() {			return Double.parseDouble(next());		}	}}
