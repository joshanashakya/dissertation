import java.io.OutputStream;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.util.InputMismatchException;import java.io.IOException;import java.io.InputStream; /** * Built using CHelper plug-in * Actual solution is at the top * * @author Pranay2516 */public class Main {    public static void main(String[] args) {        InputStream inputStream = System.in;        OutputStream outputStream = System.out;        FastReader in = new FastReader(inputStream);        PrintWriter out = new PrintWriter(outputStream);        AGregAndArray solver = new AGregAndArray();        solver.solve(1, in, out);        out.close();    }     static class AGregAndArray {        public void solve(int testNumber, FastReader in, PrintWriter out) {            int n = in.nextInt(), m = in.nextInt(), k = in.nextInt();            long[] a = new long[n];            long[] b = new long[n];            long[] cnt = new long[m];            for (int i = 0; i < n; ++i) {                a[i] = in.nextLong();            }            Pair<Pair<Integer, Integer>, Integer>[] p = new Pair[m];            for (int i = 0; i < m; ++i) {                int l = in.nextInt() - 1, r = in.nextInt() - 1, d = in.nextInt();                p[i] = new Pair<>(new Pair<>(l, r), d);            }            for (int i = 0; i < k; ++i) {                int l = in.nextInt() - 1, r = in.nextInt() - 1;                cnt[l]++;                if (r + 1 < m) cnt[r + 1]--;            }            for (int i = 1; i < m; ++i) {                cnt[i] += cnt[i - 1];            }            for (int i = 0; i < m; ++i) {                if (cnt[i] > 0) {                    int l = p[i].x.x, r = p[i].x.y, d = p[i].y;                    b[l] += d * cnt[i];                    if (r + 1 < n) b[r + 1] -= d * cnt[i];                }            }            for (int i = 1; i < n; ++i) {                b[i] += b[i - 1];            }            for (int i = 0; i < n; ++i) {                out.print((a[i] + b[i]) + " ");            }        }     }     static class FastReader {        private InputStream stream;        private byte[] buf = new byte[1024];        private int curChar;        private int numChars;        private FastReader.SpaceCharFilter filter;         public FastReader(InputStream stream) {            this.stream = stream;        }         public int read() {            if (numChars == -1) throw new InputMismatchException();            if (curChar >= numChars) {                curChar = 0;                try {                    numChars = stream.read(buf);                } catch (IOException e) {                    throw new InputMismatchException();                }                if (numChars <= 0) return -1;            }            return buf[curChar++];        }         public int nextInt() {            int c = read();            while (isSpaceChar(c)) c = read();            int sgn = 1;            if (c == '-') {                sgn = -1;                c = read();            }            int res = 0;            do {                if (c < '0' || c > '9') throw new InputMismatchException();                res *= 10;                res += c - '0';                c = read();            }            while (!isSpaceChar(c));            return res * sgn;        }         public long nextLong() {            int c = read();            while (isSpaceChar(c)) c = read();            int sgn = 1;            if (c == '-') {                sgn = -1;                c = read();            }            long res = 0;            do {                if (c < '0' || c > '9') throw new InputMismatchException();                res *= 10;                res += c - '0';                c = read();            } while (!isSpaceChar(c));            return res * sgn;        }         public boolean isSpaceChar(int c) {            if (filter != null) return filter.isSpaceChar(c);            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;        }         public interface SpaceCharFilter {            public boolean isSpaceChar(int ch);         }     }     static class Pair<U, V> implements Comparable<Pair<U, V>> {        public U x;        public V y;         public Pair(U x, V y) {            this.x = x;            this.y = y;        }         public int compareTo(Pair<U, V> o) {            int value = ((Comparable<U>) x).compareTo(o.x);            if (value != 0) return value;            return ((Comparable<V>) y).compareTo(o.y);        }     }} 
