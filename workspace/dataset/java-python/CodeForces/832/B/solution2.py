from collections import defaultdict, deque, Counterfrom sys import stdin, stdoutfrom heapq import heappush, heappopimport mathimport ioimport osimport mathimport bisect #?############################################################  def isPrime(x):    for i in range(2, x):        if i*i > x:            break        if (x % i == 0):            return False    return True #?############################################################  def ncr(n, r, p):    num = den = 1    for i in range(r):        num = (num * (n - i)) % p        den = (den * (i + 1)) % p    return (num * pow(den, p - 2, p)) % p  #?############################################################ def primeFactors(n):    l = []    while n % 2 == 0:        l.append(2)        n = n / 2    for i in range(3, int(math.sqrt(n))+1, 2):        while n % i == 0:            l.append(int(i))            n = n / i    if n > 2:        l.append(n)    return list(set(l))  #?############################################################ def power(x, y, p):    res = 1    x = x % p    if (x == 0):        return 0    while (y > 0):        if ((y & 1) == 1):            res = (res * x) % p        y = y >> 1        x = (x * x) % p    return res #?############################################################  def sieve(n):    prime = [True for i in range(n+1)]    p = 2    while (p * p <= n):        if (prime[p] == True):            for i in range(p * p, n+1, p):                prime[i] = False        p += 1    return prime  #?############################################################ def digits(n):    c = 0    while (n > 0):        n //= 10        c += 1    return c #?############################################################  def ceil(n, x):    if (n % x == 0):        return n//x    return n//x+1 #?############################################################  def mapin():    return map(int, input().split()) #?############################################################def check2(a, b):     for i in a:        if(b[ord(i)-97]!=0):            return 1     return 0 def check(b, c, l):    i = 0    j = 0    # print(l)    if(len(b)!=len(c)):        return 1    while(i < len(b) and j < len(c)):        # print(i, j)        if(b[i] == c[j]):            i += 1            j += 1        else:            if(b[i] == '?'):                if(l[ord(c[j])-97] == 1):                    i += 1                    j += 1                else:                    return 1            else:                # print("jodsjpf")                return 1    # print(i, j, "jak")    return 0 # input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline# python3 15.py<in>opa = input() b = input() n = int(input()) l = [0]*26 for x in a:    l[ord(x)-97] = 1for _ in range(n):    err = 0    c = input()    if('*' not in b):        err = check(b, c, l)    else:        tt = b.find('*')        if(len(c)< len(b)-1):            err = 1        else:            err = 0            s1 = c[:tt]            s2 = c[len(c)-(len(b)-tt-1):len(c)]             s3 = c[tt:len(c)-(len(b)-tt-1)]            s4 = b[:tt]            s5 = b[tt+1:]            # print(s1, s4, len(s1), len(s4))            # print()            # print(tt)            # print(s1, s2, s3, s4, s5)            # print(check(s4, s1, l), check(s5, s2, l),check2(s3, l))            if(check(s4, s1, l) == 0 and check(s5, s2, l) == 0 and check2(s3, l) == 0):                err = 0                # print("dsfskanlk")            else:                err = 1                                   # print(i, j)    # print(len(b), len(c))    if(err == 1):        print("NO")    else:        print("YES")
