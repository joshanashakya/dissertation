import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.Arrays;import java.util.StringTokenizer; public class Main {	public static void main(String[] args) throws FileNotFoundException, IOException {		InputReader in = new InputReader(new BufferedInputStream(System.in));		PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));		TaskB solver = new TaskB();//		long t1 = System.currentTimeMillis();		solver.solve(1, in, out);		out.flush();//		long t2 = System.currentTimeMillis();//		System.err.println(t2 - t1);		out.close(); 	}} class Pos implements Comparable<Pos> {	int x;	int y;	long val; 	public Pos(int x, int y, long val) {		this.x = x;		this.y = y;		this.val = val;	} 	public int compareTo(Pos p) {		if (val == p.val) {			if (x == p.x)				return Integer.compare(y, p.y);			return Integer.compare(x, p.x);		}		return Long.compare(val, p.val);	} } class Pair implements Comparable<Pair> {	int fir;	int sec; 	Pair(int fir, int sec) {		this.fir = fir;		this.sec = sec;	} 	public int compareTo(Pair p) {		return Integer.compare(sec, p.sec);	}} class TaskB { 	int INF = (int) 1e9;	int id[];	int sz[];	int sup[]; 	void solve(int testNumber, InputReader in, PrintWriter pw) throws IOException {		int n = in.nextInt();		for (int i = 0; i < n; ++i)			in.nextInt();		int m = in.nextInt();		int min[] = new int[n];		Arrays.fill(min, INF);		for (int i = 0; i < m; ++i) {			int u = in.nextInt() - 1;			int v = in.nextInt() - 1;			int w = in.nextInt();			min[v] = Math.min(min[v], w);		}		boolean root = false;		long ans = 0;		for (int i = 0; i < n; ++i) {			if (min[i] == INF) {				if (root) {					pw.println(-1);					return;				} else {					root = true;				}			} else {				ans += min[i];			}		}		pw.println(ans);	} 	int find(int x) {		int p = x;		while (id[p] != p) {			p = id[p];		}		int par = p;		p = x;//		 path compression		while (id[p] != p) {			int tmp = id[p];			id[p] = par;			p = tmp;		}		return par;	} 	boolean union(int p, int q) {		int root1 = find(p);		int root2 = find(q);		if (sup[root1] > 0 && sup[root2] > 0)			return false;		if (root1 == root2)			return false;		if (sz[root1] < sz[root2]) {			sz[root2] += sz[root1];			id[root1] = root2;			sup[root1]++;		} else {			sz[root1] += sz[root2];			id[root2] = root1;			sup[root2]++;		}		return true;	} 	long gcd(long x, long y) {		if (y == 0)			return x;		return gcd(y, x % y);	} 	long pow(int n, int m) {		if (m == 0)			return 1;		long ans = pow(n, m / 2);		ans = (ans * ans);		if (m % 2 == 1) {			ans = (ans * n);		}		return ans;	} 	double pow(double n, int m) {		if (m == 0)			return 1;		double ans = pow(n, m / 2);		ans = (ans * ans);		if (m % 2 == 1) {			ans = (ans * n);		}		return ans;	}} class InputReader {	BufferedReader br;	StringTokenizer st; 	public InputReader(InputStream in) {		br = new BufferedReader(new InputStreamReader(in));		st = null;	} 	public String next() {		while (st == null || !st.hasMoreTokens()) {			try {				st = new StringTokenizer(br.readLine());			} catch (IOException e) {				throw new RuntimeException(e);			}		}		return st.nextToken();	} 	public int nextInt() {		return Integer.parseInt(next());	} 	public long nextLong() {		return Long.parseLong(next());	} 	public double nextDouble() {		return Double.parseDouble(next());	}}
