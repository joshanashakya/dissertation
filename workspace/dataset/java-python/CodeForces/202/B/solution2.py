import itertools  def count_inversions(enumerate_seq):    tmp = list(enumerate_seq[:])    result = 0    for i in range(len(tmp)):        for j in range(len(tmp) - 1):            if tmp[j][0] > tmp[j + 1][0]:                result += 1                tmp[j], tmp[j + 1] = tmp[j + 1], tmp[j]    return result  def sub_seq(a, b):    i, j = 0, 0    while i < len(a) and j < len(b):        if a[i] == b[j]:            i += 1        j += 1    return i == len(a)  n = int(input())A = input().split() B = [] m = int(input())for _ in range(m):    B += [input().split()[1:]]     brand_new = True    best_perms = 0best_seq = []best_ind = -1 for i, b in enumerate(B):    for tmp in itertools.permutations(enumerate(A)):        if sub_seq([x for y, x in tmp], b):            brand_new = False            inversions = count_inversions(tmp)            similarity = n * (n - 1) // 2 - inversions + 1            if best_perms < similarity:                best_perms = similarity                best_seq = [x for y, x in tmp]                best_ind = i if not brand_new:    print(best_ind + 1)    print('[:' + '|' * best_perms + ':]')else:    print("Brand new problem!")
