import java.util.Scanner;import java.util.HashMap;import java.util.HashSet;import java.util.Iterator;import java.util.PriorityQueue;import java.util.Queue;import java.util.Stack;import java.util.StringTokenizer;import java.util.TreeMap;import java.util.Vector;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Comparator;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.lang.StringBuilder;import java.math.BigInteger; public class idk {	static Scanner scn = new Scanner(System.in);	static int mod = 1000000007; 	public static void main(String args[]) { 		long n=scn.nextLong(),m=scn.nextLong(),k=scn.nextLong(),l=scn.nextLong();		if(m>n)			System.out.println("-1");		else		{			long y=(m+k+l-1)/m;			if(m*y>n)				System.out.println("-1");			else				System.out.println(y);		} 	} 	public static int binarysearch(Long arr[], int l, int r, int key) {		int mid, ans = r;		while (l <= r) {			mid = l + (r - l) / 2;			if (arr[mid] == key) {				l = mid + 1;				ans = mid;			} else if (arr[mid] > key) {				r = mid - 1;				ans = r;			} else {				l = mid + 1;			} 		} 		return ans;	} 	public static boolean word(String arr[], String str, String ori, HashMap<String, Integer> map, int i, int j) {		if (j == str.length()) { // System.out.println(str);			if (str.length() == 0)				return true;			else				return false;		} 		String re = ori.substring(i, j);		System.out.println(re);		if (map.containsKey(re)) {			String res = ori.substring(j); 			return word(arr, str, ori, map, j, j);		} 		return word(arr, str, ori, map, i, j + 1); 	} 	public static int decode(String str, int i, int[] memo) {		if (i == 0) {			return 1;		}		int ind = str.length() - i;		if (str.charAt(ind) == '0')			return 0;		if (memo[i] != -1)			return memo[i];		int res = decode(str, i - 1, memo);		if (i >= 2 && Integer.parseInt(str.substring(ind, ind + 2)) <= 26) {			res += decode(str, i - 2, memo);		}		memo[i] = res;		return res;	} 	public static long gcd(long a, long b) {		if (a == 0)			return  b;		return  gcd(b % a, a);	} 	public static String factorial(int n) {		BigInteger fac = new BigInteger("1");		for (int i = 1; i <= n; i++) {			fac = fac.multiply(BigInteger.valueOf(i));		}		return fac.toString();	} } class pair {	int a;	int b; 	pair(int x, int y) {		this.a = x;		this.b = y;	}} class sorting implements Comparator<pair> { 	@Override	public int compare(pair o1, pair o2) {		// TODO Auto-generated method stub		int x = o1.a - o2.a, y = o1.b - o2.b;		if (y == 0) {			if (x >= 0)				return -1;			else				return 1;		} else if (y > 0)			return -1;		else			return 1;	} }
