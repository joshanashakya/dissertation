import java.io.*;import java.util.*; public class Main {      static boolean[] isPrime;    static ArrayList<Integer> primes;    public static void sieve(){        isPrime = new boolean[1000_051];        primes = new ArrayList<>();        Arrays.fill(isPrime, true); isPrime[1] = isPrime[0] = false;        for (int i = 2; i <= 1000_050; i++) {            if(isPrime[i]){                primes.add(i);                for (int j = i*i; j <= 1000_050 && j > 0; j += i) {                    isPrime[j] = false;                }            }        }    }     static int[] spf;    public static void spf(){        spf = new int[3000+1];        spf[1] = 1;        for (int i = 2; i <= 3000; i++) {            if(spf[i] == 0){                spf[i] = i;                for (int j = i * i; j <= 3000; j += i) {                    if(spf[j] == 0) spf[j] = i;                }            }        }    }     public static int getPrimeFactors(int x){         HashSet<Integer> set = new HashSet<>();        while(spf[x] != 1){            set.add(spf[x]);            x /= spf[x];        }        return set.size();    }    static int[] d;    public static int numOfDivisors(int x){        if(d[x] != 0) return d[x];        int cnt = 0;        for (int i = 1; i*i <= x; i++) {            if(x%i == 0) {                if(i*i != x) cnt += 2;                else cnt++;            }        }        return d[x] = cnt;    }     public static int lowerBound(int target){        int l = 0; int r = primes.size()-1;        while(l < r){            int mid = l + (r-l)/2;             if(primes.get(mid) > target){                r = mid;            }            else l = mid+1;        }        return primes.get(r);    }     public static void main(String[] args) throws IOException, InterruptedException {        sieve(); //        pw.println(lowerBound(1823));        int n = sc.nextInt(); int m = sc.nextInt();        int[][] grid = new int[n][m];        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                grid[i][j] = sc.nextInt();            }        }         long ans = Long.MAX_VALUE;         for (int i = 0; i < n; i++) {            long currAns = 0;            for (int j = 0; j < m; j++) {                int val = grid[i][j];                if(!isPrime[val]){                    currAns += lowerBound(val) - val;                }            }            ans = Math.min(currAns, ans);        }        for (int j = 0; j < m; j++) {            long currAns = 0;            for (int i = 0; i < n; i++) {                int val = grid[i][j];                if(!isPrime[val]){                    currAns += lowerBound(val) - val;                }            }//            pw.println(currAns);            ans = Math.min(currAns, ans);        }        pw.println(ans);        pw.close();    }     public static void pairSort(Pair[] arr) {        ArrayList<Pair> l = new ArrayList<>();        Collections.addAll(l, arr);        Collections.sort(l);        for (int i = 0; i < arr.length; i++) {            arr[i] = l.get(i);        }    }    public static void longSort(long[] arr) {        ArrayList<Long> l = new ArrayList<>();        for (long i : arr) l.add(i);        Collections.sort(l);        for (int i = 0; i < arr.length; i++) {            arr[i] = l.get(i);        }    }    public static void intSort(int[] arr) {        ArrayList<Integer> l = new ArrayList<>();        for (int i : arr) l.add(i);        Collections.sort(l);        for (int i = 0; i < arr.length; i++) {            arr[i] = l.get(i);        }    }     static class Scanner {        StringTokenizer st;        BufferedReader br;         public Scanner(InputStream s) {            br = new BufferedReader(new InputStreamReader(s));        }         public String next() throws IOException {            while (st == null || !st.hasMoreTokens())                st = new StringTokenizer(br.readLine());            return st.nextToken();        }         public int nextInt() throws IOException {            return Integer.parseInt(next());        }         public long nextLong() throws IOException {            return Long.parseLong(next());        }         public String nextLine() throws IOException {            return br.readLine();        }         public double nextDouble() throws IOException {            String x = next();            StringBuilder sb = new StringBuilder("0");            double res = 0, f = 1;            boolean dec = false, neg = false;            int start = 0;            if (x.charAt(0) == '-') {                neg = true;                start++;            }            for (int i = start; i < x.length(); i++)                if (x.charAt(i) == '.') {                    res = Long.parseLong(sb.toString());                    sb = new StringBuilder("0");                    dec = true;                } else {                    sb.append(x.charAt(i));                    if (dec)                        f *= 10;                }            res += Long.parseLong(sb.toString()) / f;            return res * (neg ? -1 : 1);        }         public boolean ready() throws IOException {            return br.ready();        }         public int[] nextIntArr(int n) throws IOException {            int[] arr = new int[n];            for (int i = 0; i < n; i++) {                arr[i] = Integer.parseInt(next());            }            return arr;        }         public long[] nextLongArr(int n) throws IOException {            long[] arr = new long[n];            for (int i = 0; i < n; i++) {                arr[i] = Long.parseLong(next());            }            return arr;        }     }    static class Pair implements Comparable<Pair>{        int first; int second; int length;        public Pair(int first, int second){            this.first = first; this.second = second; this.length = second-first+1;        }         @Override        public int compareTo(Pair p2) {            if(first == p2.first) return second - p2.second;            else return first - p2.first;        }         @Override        public String toString() { return "("+ first + "," + second + ')'; }     }    static class Triple implements Comparable<Triple> {        double x, y, z, sum;         Triple(double a, double b, double c) { x = a; y = b; z = c; sum = x + y + z; }          public int compareTo(Triple t)        {            if(Math.abs(sum - t.sum) < 1e-9) return x > t.x ? 1 : -1;            return sum > t.sum ? 1 : -1;        }        public String toString()        {            return x + " " + y  + " " + z;        }    }     static PrintWriter pw = new PrintWriter(System.out);    static Scanner sc = new Scanner(System.in);    static Random random = new Random();    static final long MOD = 1073741824;}					   		 			 	   		  			 		
