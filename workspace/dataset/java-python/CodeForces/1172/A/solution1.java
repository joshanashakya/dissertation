import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.ArrayDeque;import java.util.Arrays;import java.util.StringTokenizer; public class A { 	public static void main(String[] args) {		FS in = new FS();		int N = in.nextInt();		int hand[] = new int[N+1];		int deck[] = new int[N];		int posInDeck[] = new int[N+1];		Arrays.fill(posInDeck, -1);		for(int i = 0; i < N; i++) hand[in.nextInt()]++;		for(int i = 0; i < N; i++) {			deck[i] = in.nextInt();			posInDeck[deck[i]] = i;		}				int res = 2*N;				// Cant we do it without picking up the 1 ?		int oid = -1;		for(int i = 0; i < N; i++) if(deck[i] == 1) oid = i;		if(oid != -1) {			boolean suffixGood = true;			for(int i = oid, target = 1; i < N; i++, target++) {				if(deck[i] != target) suffixGood = false;			}			if(suffixGood) {				boolean canMake = true;				int look = (N - oid + 1);				for(int turn = 0; look <= N; look++, turn++) {					int turnsTilAvailable = hand[look] > 0 ? 0 : posInDeck[look] + 1;					if(turnsTilAvailable > turn) canMake = false;				}				if(canMake) {					System.out.println(oid);					return;				}			}		}				// We have to pick up the one. Binary search number of extra moves before placing 1		int toPickOne = hand[1] > 0 ? 0 : posInDeck[1] + 1;		int lo = 0, hi = 2*N, best = 2*N;		while(lo <= hi) {			int mid = (lo+hi)/2;			boolean works = true;						for(int look = 2; look <= N; look++) {				int turnsTilNeed = toPickOne + mid + (look-1);				int turnsTilAvailable = hand[look] > 0 ? 0 : posInDeck[look] + 1;				if(turnsTilAvailable > turnsTilNeed) works = false;			}									if(works) {				best = Math.min(best, mid);				hi = mid-1;			}			else {				lo = mid+1;			}		}				System.out.println(toPickOne + best + N);	}						static class FS{		BufferedReader br;		StringTokenizer st;		public FS() {			br = new BufferedReader(new InputStreamReader(System.in));		}		String next() {			while(st == null || !st.hasMoreElements()) {				try {st = new StringTokenizer(br.readLine());}				catch(Exception e) {}			}			return st.nextToken();		}		int nextInt() {			return Integer.parseInt(next());		}	} }
