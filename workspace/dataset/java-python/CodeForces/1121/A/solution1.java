import java.io.*;import java.math.BigDecimal;import java.math.BigInteger;import java.math.RoundingMode;import java.util.*;import java.util.concurrent.LinkedBlockingDeque;  public class scratch_25 {    // int count=0;    //static long count=0;    static class Reader {        static BufferedReader reader;        static StringTokenizer tokenizer;         /**         * call this method to initialize reader for InputStream         */        static void init(InputStream input) {            reader = new BufferedReader(                    new InputStreamReader(input));            tokenizer = new StringTokenizer("");        }         /**         * get next word         */        static String next() throws IOException {            while (!tokenizer.hasMoreTokens()) {                //TODO add check for eof if necessary                tokenizer = new StringTokenizer(                        reader.readLine());            }            return tokenizer.nextToken();        }         static int nextInt() throws IOException {            return Integer.parseInt(next());        }         static double nextDouble() throws IOException {            return Double.parseDouble(next());        }         static long nextLong() throws IOException {            return Long.parseLong(next());        }    }         static class Pair implements Comparable<Pair>{        long x;        long y;        public Pair(long x,long y){            this.x=x;            this.y=y;        }        @Override        public int compareTo(Pair o){            return (int)this.y-(int)o.y;          }        @Override        public boolean equals(Object me) {            Pair binMe = (Pair)me;            if(this.x==binMe.x && this.y==binMe.y)                return true;            else                return false;        }         @Override        public int hashCode() {            return (int)this.x + (int)this.y;        }         @Override        public String toString() {            return x+" "+y;        }      }           public static void main(String[] args)  throws IOException {        Reader.init(System.in);        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));        int n= Reader.nextInt();        int school= Reader.nextInt();        int chosen= Reader.nextInt();        HashMap<Integer, ArrayList<Pair>>map= new HashMap<>();        int a1[]= new int[n];        int a2[]= new int[n];        for (int i = 0; i <n ; i++) {            a1[i]= Reader.nextInt();        }        for (int i = 0; i <n ; i++) {            a2[i]= Reader.nextInt();        }        for (int i = 0; i <n ; i++) {            if(!map.containsKey(a2[i])){                ArrayList<Pair>ar= new ArrayList<>();                ar.add(new Pair(i+1,a1[i]));                map.put(a2[i],ar);            }            else{                ArrayList<Pair>ar=map.get(a2[i]);                ar.add(new Pair(i+1,a1[i]));                map.put(a2[i],ar);            }        }        ArrayList<Integer>ar= new ArrayList<>(map.keySet());        for (int i = 0; i <ar.size() ; i++) {            int x= ar.get(i);            ArrayList<Pair>arr= map.get(x);            Collections.sort(arr);            map.put(x,arr);        }        int ans=0;      //  System.out.println(map);        ArrayList<Integer>a= new ArrayList<>(map.keySet());        for (int i = 0; i <chosen ; i++) {            int val= Reader.nextInt();            int scho=a2[val-1];            ArrayList<Pair>q= map.get(scho);            if(q.get(q.size()-1).x!=val){                ans++;            }        }        out.append(ans+"\n");                                      out.flush();        out.close();       }      public static void bfs(int x,int y, int n,char [][]ar,int done[][]){        LinkedList<int[]>stk= new LinkedList<>();        int a[]={x,y};        stk.addFirst(a);        while(!stk.isEmpty()){            int b[]=stk.removeFirst();            if(done[b[0]][b[1]]==1){                continue;            }            done[b[0]][b[1]]=1;            int arr[][]={{1,0},{-1,0},{0,1},{0,-1}};            for (int i = 0; i <arr.length ; i++) {                if(!(b[0]+arr[i][0]>=n || b[1]+arr[i][1]>=n || b[0]+arr[i][0]<0 || b[1]+arr[i][1]<0 ||  ar[b[0]+arr[i][0]][b[1]+arr[i][1]]=='1')){                    int r[]= {b[0]+arr[i][0], b[1]+arr[i][1]};                    stk.addFirst(r);                    // continue;                }            }        }    }                                public static ArrayList<Integer> Sieve(int n) {        boolean arr[]= new boolean [n+1];        Arrays.fill(arr,true);        arr[0]=false;        arr[1]=false;        for (int i = 2; i*i <=n ; i++) {            if(arr[i]){                for (int j = 2; j <=n/i ; j++) {                    int u= i*j;                    arr[u]=false;                }}        }        ArrayList<Integer> ans= new ArrayList<>();        for (int i = 0; i <n+1 ; i++) {            if(arr[i]){                ans.add(i);            }        }        return ans;    }        static long power( long x, long y, long p)    {         long res = 1;          x = x % p;         if (x == 0) return 0;         while (y > 0)        {             if((y & 1)==1)                res = (res * x) % p;              y = y >> 1;            x = (x * x) % p;        }        return res;    }     public static long ceil_div(long a, long b){        return (a+b-1)/b;    }     static long gcd(long a, long b)    {        if (a == 0)            return b;        return gcd(b % a, a);    }     static long lcm(long a, long b)    {        return (a*b)/gcd(a, b);    } }
