import java.io.OutputStream;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.util.StringTokenizer;import java.util.Collection;import java.io.IOException;import java.io.BufferedReader;import java.util.Deque;import java.util.ArrayDeque;import java.io.InputStreamReader;import java.io.InputStream; /** * Built using CHelper plug-in * Actual solution is at the top * * @author kamel */public class Main {    public static void main(String[] args) {        InputStream inputStream = System.in;        OutputStream outputStream = System.out;        InputReader in = new InputReader(inputStream);        PrintWriter out = new PrintWriter(outputStream);        TaskA solver = new TaskA();        int testCount = Integer.parseInt(in.next());        for (int i = 1; i <= testCount; i++)            solver.solve(i, in, out);        out.close();    }     static class TaskA {        public void solve(int testNumber, InputReader in, PrintWriter out) {            int INIT = -1;            int n = in.nextInt();            int[] values = new int[n];            for (int i = 0; i < n; i++) {                values[i] = in.nextInt();            }             Deque<Integer> dq = new ArrayDeque<>();            BIT bit = new BIT(n + 1);            for (int i = 0; i < n; i++) {                TaskA.Data last = bit.query(values[i]);                 while (!dq.isEmpty() && values[dq.peekLast()] < values[i]) {                    dq.pollLast();                }                int lastLarger = dq.isEmpty() ? INIT : dq.peekLast();                dq.addLast(i);                 int delta = 0;                 if (lastLarger > last.index) {                    delta = 1;                }                int candidate = last.value + 1 + delta;                bit.update(values[i], new TaskA.Data(candidate, i));            }            out.println(bit.query(n).value);        }         static class Data {            int value;            int index;            static TaskA.Data SMALL = new TaskA.Data(0, -1);             public Data(int value, int index) {                this.value = value;                this.index = index;            }             static TaskA.Data max(TaskA.Data left, TaskA.Data right) {                if (left == null) {                    return right;                }                if (right == null) {                    return left;                }                 if (left.value != right.value) {                    return left.value > right.value ? left : right;                } else {                    return left.index < right.index ? left : right;                }            }         }         class BIT {            int n;            TaskA.Data[] data;             BIT(int n) {                this.n = n;                this.data = new TaskA.Data[n];            }             TaskA.Data query(int right) {                TaskA.Data result = TaskA.Data.SMALL;                while (right > 0) {                    TaskA.Data left = data[right];                    result = TaskA.Data.max(left, result);                    right -= lowBit(right);                }                return result;            }             void update(int index, TaskA.Data v) {                while (index < n) {                    data[index] = TaskA.Data.max(data[index], v);                    index += lowBit(index);                }            }             int lowBit(int x) {                return x & (-x);            }         }     }     static class InputReader {        public BufferedReader reader;        public StringTokenizer tokenizer;         public InputReader(InputStream stream) {            reader = new BufferedReader(new InputStreamReader(stream), 32768);            tokenizer = null;        }         public String next() {            while (tokenizer == null || !tokenizer.hasMoreTokens()) {                try {                    tokenizer = new StringTokenizer(reader.readLine());                } catch (IOException e) {                    throw new RuntimeException(e);                }            }            return tokenizer.nextToken();        }         public int nextInt() {            return Integer.parseInt(next());        }     }} 
