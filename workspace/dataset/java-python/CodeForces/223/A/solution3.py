import sysfrom math import gcd,sqrt,ceil,log2from collections import defaultdict,Counter,dequefrom bisect import bisect_left,bisect_rightimport mathimport heapqfrom itertools import permutations # input=sys.stdin.readline# def print(x):#     sys.stdout.write(str(x)+"\n") # sys.stdin = open('input.txt', 'r')# sys.stdout = open('output.txt', 'w')import osimport sysfrom io import BytesIO, IOBase BUFSIZE = 8192  class FastIO(IOBase):    newlines = 0     def __init__(self, file):        self._fd = file.fileno()        self.buffer = BytesIO()        self.writable = "x" in file.mode or "r" not in file.mode        self.write = self.buffer.write if self.writable else None     def read(self):        while True:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            if not b:                break            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines = 0        return self.buffer.read()     def readline(self):        while self.newlines == 0:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            self.newlines = b.count(b"\n") + (not b)            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines -= 1        return self.buffer.readline()     def flush(self):        if self.writable:            os.write(self._fd, self.buffer.getvalue())            self.buffer.truncate(0), self.buffer.seek(0)  class IOWrapper(IOBase):    def __init__(self, file):        self.buffer = FastIO(file)        self.flush = self.buffer.flush        self.writable = self.buffer.writable        self.write = lambda s: self.buffer.write(s.encode("ascii"))        self.read = lambda: self.buffer.read().decode("ascii")        self.readline = lambda: self.buffer.readline().decode("ascii")  sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)input = lambda: sys.stdin.readline().rstrip("\r\n") # import sys# import io, os# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readlinedef get_sum(bit,i):    s = 0     i+=1    while i>0:        s+=bit[i]        i-=i&(-i)     return s def update(bit,n,i,v):    i+=1     while i<=n:        bit[i]+=v        i+=i&(-i)  def modInverse(b,m):    g = math.gcd(b, m)    if (g != 1):        return -1    else:        return pow(b, m - 2, m) def primeFactors(n):     sa = set()    sa.add(n)    while n % 2 == 0:        sa.add(2)        n = n // 2      for i in range(3,int(math.sqrt(n))+1,2):          while n % i== 0:            sa.add(i)            n = n // i     # sa.add(n)    return sa  def seive(n):     pri = [True]*(n+1)    p = 2    while p*p<=n:         if pri[p] == True:             for i in range(p*p,n+1,p):                pri[i] = False         p+=1     return pri def check_prim(n):     if n<0:        return False    for i in range(2,int(sqrt(n))+1):        if n%i == 0:            return False     return True  def getZarr(string, z):    n = len(string)     # [L,R] make a window which matches    # with prefix of s    l, r, k = 0, 0, 0    for i in range(1, n):         # if i>R nothing matches so we will calculate.        # Z[i] using naive way.        if i > r:            l, r = i, i             # R-L = 0 in starting, so it will start            # checking from 0'th index. For example,            # for "ababab" and i = 1, the value of R            # remains 0 and Z[i] becomes 0. For string            # "aaaaaa" and i = 1, Z[i] and R become 5            while r < n and string[r - l] == string[r]:                r += 1            z[i] = r - l            r -= 1        else:             # k = i-L so k corresponds to number which            # matches in [L,R] interval.            k = i - l             # if Z[k] is less than remaining interval            # then Z[i] will be equal to Z[k].            # For example, str = "ababab", i = 3, R = 5            # and L = 2            if z[k] < r - i + 1:                z[i] = z[k]                 # For example str = "aaaaaa" and i = 2,            # R is 5, L is 0            else:                 # else start from R and check manually                l = i                while r < n and string[r - l] == string[r]:                    r += 1                z[i] = r - l                r -= 1 def search(text, pattern):     # Create concatenated string "P$T"    concat = pattern + "$" + text    l = len(concat)      z = [0] * l    getZarr(concat, z)     ha = []    for i in range(l):          if z[i] == len(pattern):            ha.append(i - len(pattern) - 1)      return ha  # n,k = map(int,input().split())# l = list(map(int,input().split())) ## n = int(input())# l = list(map(int,input().split()))## hash = defaultdict(list)# la = []## for i in range(n):#     la.append([l[i],i+1])## la.sort(key = lambda x: (x[0],-x[1]))# ans = []# r = n# flag = 0# lo = []# ha = [i for i in range(n,0,-1)]# yo = []# for a,b in la:##    if a == 1:#        ans.append([r,b])#        # hash[(1,1)].append([b,r])#        lo.append((r,b))#        ha.pop(0)#        yo.append([r,b])#        r-=1##    elif a == 2:#        # print(yo,lo)#        # print(hash[1,1])#        if lo == []:#            flag = 1#            break#        c,d = lo.pop(0)#        yo.pop(0)#        if b>=d:#            flag = 1#            break#        ans.append([c,b])#        yo.append([c,b])####    elif a == 3:##            if yo == []:#                flag = 1#                break#            c,d = yo.pop(0)#            if b>=d:#                flag = 1#                break#            if ha == []:#                flag = 1#                break##            ka = ha.pop(0)##            ans.append([ka,b])#            ans.append([ka,d])#            yo.append([ka,b])## if flag:#     print(-1)# else:#     print(len(ans))#     for a,b in ans:#         print(a,b)def mergeIntervals(arr):     # Sorting based on the increasing order    # of the start intervals    arr.sort(key = lambda x: x[0])     # array to hold the merged intervals    m = []    s = -10000    max = -100000    for i in range(len(arr)):        a = arr[i]        if a[0] > max:            if i != 0:                m.append([s,max])            max = a[1]            s = a[0]        else:            if a[1] >= max:                max = a[1]     #'max' value gives the last point of    # that particular interval    # 's' gives the starting point of that interval    # 'm' array contains the list of all merged intervals     if max != -100000 and [s, max] not in m:        m.append([s, max])    return ms = input()n = len(s)stack = []i = 0ans = []pre = [0]for i in s:    if i == '[':        pre.append(pre[-1]+1)    else:        pre.append(pre[-1])i = 0while i<n:     if s[i] == '(' or s[i] == '[':        stack.append(i)     elif stack!=[] and s[i] == ')' and s[stack[-1]] == '(':        z = stack.pop()        ans.append((z,i))    elif stack!=[] and s[i] == ')' and s[stack[-1]] == '[':        stack = []    elif stack!=[] and s[i] == ']' and s[stack[-1]] == '[':        z = stack.pop()        ans.append((z,i))     elif stack!=[] and s[i] == ']' and s[stack[-1]] == '(':        stack = []    i+=1 ans.sort() x,y = -1,-1maxi = 0lo = []i = 1# print(ans)ans = mergeIntervals(ans)if ans == []:    print(0)    print()    exit()a,b = ans[i-1]lo.append([a,b])# print(ans)while i<=len(ans):    a,b = ans[i-1]    while i<len(ans) and ans[i][0]-ans[i-1][1] == 1:        i+=1     lo.append([a,ans[i-1][1]])    i+=1 ans = lo # print(lo)for i in range(len(ans)):    a,b = ans[i]    a+=1    b+=1    z = pre[b] - pre[a-1]    if z>maxi:        maxi = z        a-=1        b-=1        x,y = a,b if ans == []:    print(0)    print()else:     print(maxi)    print(s[x:y+1])      
