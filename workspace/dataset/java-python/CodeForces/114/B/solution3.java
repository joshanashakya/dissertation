import java.util.*; import javafx.util.Pair;public class PFAST {	// Discovered it's a complete search problem		static List<List<String>> comb=new ArrayList<>();	static void combination(int index,List<String> people,LinkedList<String> result) {		if(index==people.size()) {			comb.add(new LinkedList<>(result));			return;		}		result.add(people.get(index)); 		combination(index+1,people,result);		result.removeLast(); 		combination(index+1,people,result);	}	static boolean check(List<String> list,List<Pair<String,String>> not) {		for(int i=0;i<list.size();i++) {			for(int j=0;j<not.size();j++) {				String s="";				if(list.get(i).equals(not.get(j).getKey()))					s=not.get(j).getValue();				else if(list.get(i).equals(not.get(j).getValue()))					s=not.get(j).getKey();				else continue;				for(int f=0;f<list.size();f++)					if(list.get(f).equals(s)) 						return false;			}		}		return true;	}	public static void main(String[] args) {		Scanner in = new Scanner(System.in);		List<String> result=new LinkedList<>();		List<String> people=new ArrayList<>();		List<Pair<String,String>> not=new ArrayList<>();		//reading input		int n=in.nextInt();		int m=in.nextInt();		for(int i=0;i<n;i++)			people.add(in.next());		for(int i=0;i<m;i++) 			not.add(new Pair<String,String>(in.next(),in.next()));		combination(0,people,new LinkedList<String>());		// Check for everyone in the comb list		for(int i=0;i<comb.size();i++) {			List<String> turn=comb.get(i);			if(check(turn,not)) {				if(turn.size()>result.size())					result=turn;			}		}				/// print in the end 		Collections.sort(result);		System.out.println(result.size());		for(String str:result)			System.out.println(str);	} }          //HashMap<String,List<String>> map=new HashMap<>();//int n=in.nextInt();//int m=in.nextInt();//for(int i=0;i<n;i++) //	map.put(in.next(), new LinkedList<String>());//for(int i=0;i<m;i++) {//	String f=in.next(),s=in.next();//	List<String> first=map.get(f);//	List<String> second=map.get(s);//	first.add(s);//	second.add(f);//	map.put(f, first);//	map.put(s,second);//}//List<Entry<String,List<String>>> list=new LinkedList<>(map.entrySet());//Collections.sort(list, new Comparator<Entry<String,List<String>>>() {//	@Override//	public int compare(Entry<String, List<String>> o1, Entry<String, List<String>> o2) {//		Integer size1=o1.getValue().size(),size2=o2.getValue().size();//		return size1.compareTo(size2);//	}//});////	HashMap<String,Integer> intMap=new HashMap<>();//for(int i=0;i<list.size();i++) {//	Entry<String, List<String>> entry=list.get(i);//	List<String> inList=entry.getValue();//	for(String str:inList) {//		for(int j=0;j<list.size();j++) {//			Entry<String, List<String>> secEntry=list.get(j);//			String str2=secEntry.getKey();//			if(str.equals(str2))//				list.remove(secEntry);//		}//	}//		////	if(intMap.containsKey(entry.getKey()))////		list.remove(entry);////	List<String> curr=new LinkedList<>();////	curr=entry.getValue();////	for(String str:curr)////		intMap.put(str, 1);//}//Collections.sort(list,new Comparator<Entry<String,List<String>>>() {//	@Override//	public int compare(Entry<String, List<String>> o1, Entry<String, List<String>> o2) {//		return o1.getKey().compareTo(o2.getKey());//	}	//});
