fast=lambda:stdin.readline().strip()zzz=lambda:[int(i) for i in fast().split()]z,zz=input,lambda:list(map(int,z().split()))szz,graph,mod,szzz=lambda:sorted(zz()),{},10**9+7,lambda:sorted(zzz())from re import *from sys import *from math import *from heapq import *from queue import *from bisect import *from string import *from itertools import *from collections import *from math import factorial as ffrom bisect import bisect as bsfrom bisect import bisect_left as bslfrom collections import Counter as ccfrom itertools import accumulate as acdef lcd(xnum1,xnum2):return (xnum1*xnum2//gcd(xnum1,xnum2))def output(answer):stdout.write(str(answer))###########################---Test-Case---#################################"""   If you Know me , Then you probably don't know me !  """###########################---START-CODING---############################## n=int(z()) lst=[]t1=-1t2=-1ans=[]ind=-1for i in range( n ):    arr=zzz()    if arr.count(0):        t1=sum(arr)        idx=(i,arr.index(0))    else:        t2=sum(arr)        ans.append(t2)            lst.append(arr)  if n==1:    exit(print(1))if len(set(ans))==1 and ans[0]-t1>0:    t=ans[0]-t1    lst[idx[0]][idx[1]]=t    res=set()    ma=0    mi=0    for i in range(n):        row,col=0,0        for j in range(n):            row+=lst[i][j]            col+=lst[j][i]        ma+=lst[i][i]        mi+=lst[i][n-i-1]                        res.add(row)        res.add(col)            res.add(mi)    res.add(ma)    if len(set(res))==1:        print(t)    else:        print(-1)                    else:    print(-1)        
