#include<bits/stdc++.h>using namespace std;#define lli long long int#define pb push_back#define mem0(a) memset(a,0,sizeof(a))#define mem_1(a) memset(a,-1,sizeof(a))#define mem1(a) memset(a,1,sizeof(a))#define memf(a) memset(a,false,sizeof(a))#define all(v) v.begin(),v.end()#define ff first#define ss second#define PI 3.1415926536#define INF 10000000000000#define mod1 1000000007#define endl "\n"#define PI 3.1415926536//#define INF 2e18#define endl "\n"#define rep0(i,n) for(lli i=0;i<n;i++)#define rep1(i,n) for(lli i=1;i<=n;i++)#define tr(container,it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++)#define fastIO ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);#define vi vector<int>#include<numeric>#define vp vector< pair<int,int> > // it store the smallest prime factor of particular number that divide the a number n// this will help us for the better optimising the concept of sieve and better time complexity for calculation lli gcd( lli a, lli b){  if (b == 0)    return a;  return gcd(b, a % b);}lli lcm(lli a, lli b){    return (a / gcd(a, b)) * b;}int min3(int a,int b,int c){    if(a<b)    {        if(a<c) return a;        else return c;    }    else    {        if(b<c) return b;        else return c;    }}int max3(int a,int b,int c){    if(a>b)    {        if(a>c) return a;        else return c;    }    else    {        if(b>c) return b;        else return c;    }} lli no_of_div(lli n){    int cnt=0;    rep1(i,(lli)sqrt(n))    {        if(n%i==0)        {            cnt+=2;            if(i*i==n)                cnt--;        }    }    return cnt;} // ////////// SIEVEvector<bool> is_prime(10000000,true);vector<lli>prime;void sieve(){lli n=10000000;is_prime[0] = is_prime[1] = false;for (lli i = 2; i <= n; i++) {    if(is_prime[i])       prime.pb(i);    if (is_prime[i] && i * i <= n) {        for (lli j = i * i; j <= n; j += i)            is_prime[j] = false;    }}}  /////// STF sievelli spf[15000001];void spf_sieve(){   lli n=15000001;   mem_1(spf);   spf[0]=spf[1]=0;   bool arr[15000001];   mem1(arr);   for(lli i=2;i*i<=n;i++)   {       if(arr[i])       {           for(lli j=i;j*i<=n;j++)           {               spf[i*j]=i;               arr[i*j]=0;           }       }   }}//// no of prime no till the number  n;int prime_n[10000000];void prime_till_N(){ prime_n[0]=prime_n[1]=0; int cnt=0; for(int i=0;i<10000000;i++) {  if(is_prime[i])  {      prime_n[i]=++cnt;  }  else    prime_n[i]=cnt; }} ////// pascal triangle approach for the calculation of the nCr since some time fit into lli but value if n! cann't so we use this concept for thatlli pascal[31][31];void pascal_tri(){   pascal[0][0]=1;//pascal[1][0]=pascal[1][1]=1;    for(lli i=1;i<=30;i++)    {        for(lli j=0;j<=30;j++)        {            if(j==0||j==i)                pascal[i][j]=1;            else                pascal[i][j]=pascal[i-1][j]+pascal[i-1][j-1];        }    }} // finding the binomial coeffient the in O(k)lli binomial_coeff(lli n,lli k){  if(k>n||n<0||k<0)    return 0;  if(k>n-k)    k=n-k;  lli ans=1;  for(int i=0;i<k;i++)  {    ans+=(n-i);    ans/=(i+1);  }  return ans;} ////// modified sieve approach for the calculation sub of proper divisor of a numberslli div_sum[1000000];void divsum_sieve(){const  lli n=500000+5;div_sum[1]=-1;for(lli i=2;i<=n;i++){    for(lli j=i*2;j<=n;j+=i)    {        div_sum[j]+=i;    }}} //////////// for the finding  all the subset of given array  and it element sum   void fun(vector<int>&arr,vector<vector<int> >&res,vector<int>&subset,int cur)   {       res.push_back(subset);       for(int i=cur;i<arr.size();i++)       {           subset.push_back(arr[i]);           fun(arr,res,subset,i+1);           subset.pop_back();       }       return;   }    vector<int> subsetSums(vector<int> arr, int N)    {       int cur=0;       vector<vector<int> >res;       vector<int>subset;       fun(arr,res,subset,cur);        vector<int> ans;      for(int i=0;i<res.size();i++)      {          int sum=0;          if(res.empty())          {              ans.push_back(sum);              continue;          }          for(auto x:res[i])          {            sum+=x;          }          ans.push_back(sum);      }      return ans;    }////////////////////bool isgood(string str){    int x=0,y=0;    for(int i=0;i<str.size();i++)    {       if(str[i]=='1')          x++;       else          y++;       if(x>0&&str[i]=='0')          return false;    }    return true;} // finding the root using the binary search lli findroot(lli n){    lli l=0,r=1e9;    lli ans=1;    while(l<=r)    {        lli mid=l+(r-l)/2;        if(mid*mid<=n)        {            ans=mid;            l=mid+1;        }        else         {            r=mid-1;        }    }    return ans;} ///// find the power of numberlli find_power(lli a,lli n){  lli res=1;  while(n>0)  {    if(n&1)    {      res*=a;      n--;    }    else    {      a*=a;       n/=2;    }  }  return res;}//  calculation of nth catlan number this is just like the fibonacci number that we have lli catlan[10005];void find_cat(){catlan[0]=1;catlan[1]=1;for(int i=2;i<1005;i++){  catlan[i]=0;  for(int j=0;j<i;j++)  {     catlan[i]+=catlan[j]*catlan[i-1-j];  }}}  // compare funtion for the sorting of an vector of pairbool cmp(pair<lli,lli> a,pair<lli,lli>b){    return a.ff<b.ff||(a.ff==b.ff&&(a.ss<b.ss));} ///// just have some funbool allvisited(vector<bool>&check){  for(int i=0;i<check.size();i++)  {    if(check[i]==false)      return false;  }  return true;}  /// solve funtion for the various function call and initilizationvoid solve(){ int n; cin>>n; int a[n],b[n]; rep0(i,n)cin>>a[i]; vector<pair<int,int> >p(n); rep0(i,n) {  int x;  cin>>x;  p[i].ff=x;  p[i].ss=i; } sort(a,a+n); sort(p.begin(),p.end()); for(int i=n-1;i>=0;i--) {  b[p[i].ss]=a[n-i-1]; } rep0(i,n) cout<<b[i]<<' '; }int main(){    fastIO    int t=1;    //cin>>t;       // sieve(); //   spf_sieve(); //  divsum_sieve();    //prime_till_N();// pascal_tri();        while(t--)    {    solve();    }    return 0;}   // /// lets implement // // let we have 3 2d vector of string // vector<vector<string> > b1,b2,combo;// b1[0]=empty// b1[1]=()// b1[2]=()(),(()); // // calculatie the next value and store it into vector// =>similarly // b2[0]=empty// b2[1]={}// b2[2]={},{{}} // combo[0]= empty// combo[1][0]=()// combo[0][1]={}// combo[1][2]=// this will be calcuated from above via partision and fixing like first fixed ()  consider all the case // // and then fixed {} and consider all the differnet case  // // simelarly we calculate all the privious and after that final one  
