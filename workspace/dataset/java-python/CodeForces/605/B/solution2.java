    import java.util.*;    import java.io.*;         public class albaaaai{     	    	static ArrayList<point> adj[];    	static boolean visited[];    	static int distance[][];    	    	static int n;    	public static void Bfs(int nn)    	{    		visited = new boolean[n];    		Queue<Integer> q = new LinkedList<Integer>();    		q.add(nn);    		visited[nn] = true;    		while(!q.isEmpty())    		{    			int node = q.poll();    			for(int i = 0 ; i < adj[node].size();i++)    			{    				if(!visited[adj[node].get(i).x])    				{    					visited[adj[node].get(i).x] = true;    					distance[nn][adj[node].get(i).x] = distance[nn][node] + adj[node].get(i).y;    					//System.err.println(Arrays.toString(distance[nn]));    					q.add(adj[node].get(i).x);    					    				}    			}    		}    	}       	public static void main(String[]args)throws IOException{    		    		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    		PrintWriter out = new PrintWriter(System.out);    		    		StringTokenizer st1 = new StringTokenizer(br.readLine());    		int n = Integer.parseInt(st1.nextToken());    		int m = Integer.parseInt(st1.nextToken());    		ArrayList<triple> arr = new ArrayList<>();    		for(int i = 0 ; i < m ; i++)    		{    			st1 = new StringTokenizer(br.readLine());    			arr.add(new triple(Integer.parseInt(st1.nextToken()) , Integer.parseInt(st1.nextToken()),i));    		}    		Collections.sort(arr);    		//out.println(arr);    		point res[] = new point[m];    		    		int currNode = 1;    		boolean flag = true;    		int l = 1 , r = -1;    		//out.println(arr);    		for(triple p: arr)    		{    			//out.println(Arrays.toString(res));    			if(p.y == 1)    			{    				res[p.ind] = new point(currNode , ++currNode);    				//out.println(res);    			}    			else    			{    				if(currNode-2 > 0)    				{    					    					if(r == -1)    					{    						r = 3;    						res[p.ind] = new point(Math.min(l, r),Math.max(l, r));    						    					}    					else    					{    						if(r-(l+1) >= 2)    						{    							l += 1;    							res[p.ind] = new point(Math.min(l, r),Math.max(l, r));    						}    						else    						{    							if(r+1 <= currNode)    							{    								r += 1;    								l = 1;    								res[p.ind] = new point(Math.min(l, r),Math.max(l, r));    							}    							else    							{    								flag = false;    								break;    							}    						}    					}    					    				}    				else    				{    					flag = false;    					break;    				}    			}    		}    		if(flag)    		{    			for(point p:res)    				out.println(p);    		}    		else    		{    			out.println(-1);    		}    			    		    		out.flush();    		out.close();    	}    	static class triple implements Comparable{    		int x,y,ind;    		public triple(int x , int y , int ind)    		{    			this.x = x;    			this.y = y;    			this.ind = ind;    		} 			@Override			public int compareTo(Object o) {				triple p = (triple)o;				if(this.x > p.x)					return 1;				if(this.x < p.x)					return -1;				if(this.y > p.y)					return -1;				if(this.y < p.y)					return 1;				return this.ind-p.ind;							}			public String toString()			{				return  this.x + " " + this.y;			}    		    	}    	static class UnionFind {                                                  		int[] p, rank;     		UnionFind(int N)     		{    			p = new int[N];    			rank = new int[N];    			for (int i = 0; i < N; i++)     				p[i] = i;    		}     		int findSet(int x) { return p[x] == x ? x : (p[x] = findSet(p[x])); }     		boolean union(int x, int y)     		{     			x = findSet(x);    			y = findSet(y);    			if(x == y)    				return false;     			if (rank[x] > rank[y])     				p[y] = x;    			else    			{	    				p[x] = y;    				if(rank[x] == rank[y])    					++rank[y];     			}     			return true;    		}    	}     	static class point implements Comparable{    		int x;    		int y;    		public point(int x , int y)    		{    			this.x = x;    			this.y = y;    			    		}			@Override			public int compareTo(Object o) {				point p = (point)o;				if(this.x > p.x)					return 1;				if(this.x < p.x)					return -1;				if(this.y > p.y)					return -1;				if(this.y < p.y)					return 1;				return 0;							}			public String toString()			{				return  this.x + " " + this.y;			}			    	}    	    }
