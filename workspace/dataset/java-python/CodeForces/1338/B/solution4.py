from types import GeneratorTypedef bootstrap(f, stack=[]):    def wrappedfunc(*args, **kwargs):        if stack:            return f(*args, **kwargs)        else:            to = f(*args, **kwargs)            while True:                if type(to) is GeneratorType:                    stack.append(to)                    to = next(to)                else:                    stack.pop()                    if not stack:                        break                    to = stack[-1].send(to)            return to    return wrappedfuncÂ def main():        # ans=[]    # import itertools    # n=6    # for c in itertools.combinations_with_replacement(range(1,40),n):    #     temp=0    #     for x in c:    #         temp^=x    #     if temp==0 and len(set(c))>len(set(ans)):    #         ans=c    # print(ans)            # For minimum, if any pair of leaves have odd edge counts between them,    # ans is 3. Else if all even edge counts, ans is 1.    # For maximum, every edge can contribute, except for nodes connected to    # more than 1 leaf. Only 1 leaf-edge can be used.        n=int(input())    adj=[[] for _ in range(n+1)]    for _ in range(n-1):        a,b=readIntArr()        adj[a].append(b)        adj[b].append(a)        #Root the tree at a non-leaf    for node in range(1,n+1):        if len(adj[node])>1:            root=node            break        @bootstrap    def dfs(node,parent): #return [has oddParity, has evenParity]        ret=[False,False]        if len(adj[node])==1: #leaf, length is 0 so even.            ret[1]=True        else:            for node2 in adj[node]:                if node2!=parent:                    childHasOdd,childHasEven=(yield dfs(node2,node))                    ret[0]=childHasEven or ret[0] #swap even/odd every level                    ret[1]=childHasOdd or ret[1]        yield ret        hasOdd,hasEven=dfs(root,-1)    if hasOdd and hasEven: #if at any node there is both odd and even distances from 2 leaves, then the 2 leaves have odd edges between them        minAns=3    else:        minAns=1        allLeaves=[]    for node in range(1,n+1):        if len(adj[node])==1:            allLeaves.append(node)    nodeLeafConnections=[0 for _ in range(n+1)]    for leaf in allLeaves:        nodeLeafConnections[adj[leaf][0]]+=1        maxAns=n-1    for cnt in nodeLeafConnections:        maxAns-=max(0,cnt-1)        print('{} {}'.format(minAns,maxAns))        return    #import sys#input=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)import sysinput=lambda: sys.stdin.readline().rstrip("\r\n") #FOR READING STRING/TEXT INPUTS. def oneLineArrayPrint(arr):    print(' '.join([str(x) for x in arr]))def multiLineArrayPrint(arr):    print('\n'.join([str(x) for x in arr]))def multiLineArrayOfArraysPrint(arr):    print('\n'.join([' '.join([str(x) for x in y]) for y in arr])) def readIntArr():    return [int(x) for x in input().split()] inf=float('inf')MOD=10**9+7 main()
