import java.io.OutputStream;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.util.StringTokenizer;import java.io.IOException;import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.InputStream; /** * Built using CHelper plug-in * Actual solution is at the top */public class Main {    public static void main(String[] args) {        InputStream inputStream = System.in;        OutputStream outputStream = System.out;        InputReader in = new InputReader(inputStream);        PrintWriter out = new PrintWriter(outputStream);        TaskA solver = new TaskA();        solver.solve(1, in, out);        out.close();    }     static class TaskA {        long MOD = (int) (1e9 + 7);        long[] choose;         public void solve(int testNumber, InputReader in, PrintWriter out) {            int N = in.nextInt();            if (N == 1) {                out.println(in.nextInt());                return;            }            long[] arr = new long[N];            for (int i = 0; i < N; i++) {                arr[i] = in.nextInt();            }            long beforeFinal = (((N - 1) * (N)) / 2) % 2;            if (N % 2 == 1) {                long[] saveArr = arr;                arr = new long[--N];                for (int i = 0; i < N; i++) {                    if (i % 2 == 0) {                        arr[i] = saveArr[i] + saveArr[i + 1];                    } else {                        arr[i] = saveArr[i] - saveArr[i + 1];                    }                }            }            choose = new long[N / 2];            genChoose(N / 2 - 1);            long resEven = 0;            long resOdd = 0;            for (int i = 0; i < N / 2; i++) {                resEven += (arr[2 * i] * choose[i]);                resOdd += (arr[2 * i + 1] * choose[i]);                resEven = MathUtils.mod(resEven, MOD);                resOdd = MathUtils.mod(resOdd, MOD);            }            if (beforeFinal == 0) {                out.println(MathUtils.mod(resEven - resOdd, MOD));            } else {                out.println(MathUtils.mod(resEven + resOdd, MOD));            }        }         void genChoose(int N) {            long last = 1;            choose[0] = 1;            for (int i = 1; i <= N; i++) {                last *= N - (i - 1);                last %= MOD;                last = MathUtils.modFraction(last, i, MOD);                choose[i] = last;            }        }     }     static class InputReader {        public BufferedReader reader;        public StringTokenizer tokenizer;         public InputReader(InputStream stream) {            reader = new BufferedReader(new InputStreamReader(stream), 32768);            tokenizer = null;        }         public String next() {            while (tokenizer == null || !tokenizer.hasMoreTokens()) {                try {                    tokenizer = new StringTokenizer(reader.readLine());                } catch (IOException e) {                    throw new RuntimeException(e);                }            }            return tokenizer.nextToken();        }         public int nextInt() {            return Integer.parseInt(next());        }     }     static class MathUtils {        public static long inverse(long a, long mod) {            long[] inv = extended_gcd(a, mod);            if (inv[0] != 1) {                return 0;            } else {                return (inv[1] + 2 * mod) % mod;            }        }         public static long modFraction(long a, long b, long mod) {            //a is numerator, b is denominator            long invB = inverse(b, mod);            if (invB == 0) {                return -1;            } else {                return (invB * a) % mod;            }        }         public static long[] extended_gcd(long a, long b) {            //three numbers, first is gcd, second is x, third is y            if (a == 0) {                return new long[]{b, 0, 1};            }            long[] next = extended_gcd(b % a, a);            long tempX = next[1];            next[1] = next[2] - (b / a) * next[1];            next[2] = tempX;            return next;        }         public static long mod(long a, long mod) {            return (a + (Math.abs(a) + mod - 1) / mod * mod) % mod;        }     }} 
