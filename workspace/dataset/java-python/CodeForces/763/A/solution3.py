import osimport sysfrom io import BytesIO, IOBasefrom types import GeneratorTypefrom collections import defaultdictBUFSIZE = 8192  class FastIO(IOBase):    newlines = 0     def __init__(self, file):        self._fd = file.fileno()        self.buffer = BytesIO()        self.writable = "x" in file.mode or "r" not in file.mode        self.write = self.buffer.write if self.writable else None     def read(self):        while True:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            if not b:                break            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines = 0        return self.buffer.read()     def readline(self):        while self.newlines == 0:            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))            self.newlines = b.count(b"\n") + (not b)            ptr = self.buffer.tell()            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)        self.newlines -= 1        return self.buffer.readline()     def flush(self):        if self.writable:            os.write(self._fd, self.buffer.getvalue())            self.buffer.truncate(0), self.buffer.seek(0)  class IOWrapper(IOBase):    def __init__(self, file):        self.buffer = FastIO(file)        self.flush = self.buffer.flush        self.writable = self.buffer.writable        self.write = lambda s: self.buffer.write(s.encode("ascii"))        self.read = lambda: self.buffer.read().decode("ascii")        self.readline = lambda: self.buffer.readline().decode("ascii") sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)input = lambda: sys.stdin.readline().rstrip("\r\n")sys.setrecursionlimit(2*10**5)  def bootstrap(f, stack=[]):    def wrappedfunc(*args, **kwargs):        if stack:            return f(*args, **kwargs)        else:            to = f(*args, **kwargs)            while True:                if type(to) is GeneratorType:                    stack.append(to)                    to = next(to)                else:                    stack.pop()                    if not stack:                        break                    to = stack[-1].send(to)            return to    return wrappedfunc    @bootstrapdef dfs(u,p,v):    if v!=col[u-1]:        global f1        global f2        f1=0        f2=0     if p==0:        for j in adj[u]:            if j!=p:                yield dfs(j,u,col[j-1])     else:        for j in adj[u]:            if j != p:                yield dfs(j, u, col[u-1])      yield                   n=int(input())adj=[[] for i in range(n+1)]res=[]for j in range(n-1):    u,v=map(int,input().split())    res.append([u,v])    adj[u].append(v)    adj[v].append(u)col=list(map(int,input().split()))v1,v2=0,0for j in res:    if col[j[0]-1]!=col[j[1]-1]:        v1,v2=j[0],j[1] if v1==0 and v2==0:    print("YES")    print(1) else:    f1=1    f2=1     dfs(v1,0,col[v1-1])    if f1==1:        print("YES")        print(v1)     else:        f2=1        dfs(v2,0,col[v2-1])        if f2==1:            print('YES')            print(v2)         else:            print("NO")       
