import java.io.*;import java.math.BigDecimal;import java.math.BigInteger;import java.math.RoundingMode;import java.util.*;import java.util.concurrent.LinkedBlockingDeque; import java.util.ArrayList;import java.util.HashMap;import java.util.LinkedList;  // graph, dfs,bfs, get connected components,iscycle, isbipartite, dfs on trees   public class scratch_25 {    static class Graph{         public static class Vertex{            HashMap<Integer,Integer> nb= new HashMap<>();     // for neighbours of each vertex        }         public static HashMap<Integer,Vertex> vt;   // for vertices(all)         public Graph(){            vt= new HashMap<>();        }         public static int numVer(){            return vt.size();        }         public static boolean contVer(int ver){            return vt.containsKey(ver);        }         public static void addVer(int ver){            Vertex v= new Vertex();            vt.put(ver,v);        }              public static void addEdge(int ver1, int ver2, int weight){            if(!vt.containsKey(ver1) || !vt.containsKey(ver2)){                return;            }            Vertex v1= vt.get(ver1);            Vertex v2= vt.get(ver2);            v1.nb.put(ver2,weight);                                 // if previously there is an edge, then this replaces that edge            v2.nb.put(ver1,weight);        }         public static void delEdge(int ver1, int ver2){             if(!vt.containsKey(ver1) || !vt.containsKey(ver2)){                return;            }            vt.get(ver1).nb.remove(ver2);            vt.get(ver2).nb.remove(ver1);        }        public static void delVer(int ver){            if(!vt.containsKey(ver)){                return;            }            Vertex v1= vt.get(ver);            ArrayList<Integer> arr= new ArrayList<>(v1.nb.keySet());            for (int i = 0; i <arr.size() ; i++) {                int s= arr.get(i);                vt.get(s).nb.remove(ver);            }            vt.remove(ver);        }           static boolean done[];            static int parent[];            static ArrayList<Integer>vals= new ArrayList<>();          public static boolean isCycle(int i){            Stack<Integer>stk= new Stack<>();             stk.push(i);            while(!stk.isEmpty()){                int x= stk.pop();                vals.add(x);             //   System.out.print("current="+x+" stackinit="+stk);                if(!done[x]){                    done[x]=true;                }                else if(done[x] ){                    return true;                }                 ArrayList<Integer>ar= new ArrayList<>(vt.get(x).nb.keySet());                for (int j = 0; j <ar.size() ; j++) {                   if(parent[x]!=ar.get(j)){                       parent[ar.get(j)]=x;                    stk.push(ar.get(j));                   }                }               // System.out.println(" stackfin="+stk);            }            return false;        }        static int distance[];        static ArrayList<Integer>ans= new ArrayList<>();        public static boolean dfs1(int p, int col[], int pcol){             Stack<Integer>stk= new Stack<>();            stk.add(p);            while(!stk.isEmpty()){                int x= stk.pop();             //   System.out.println("x="+x);                if(!done[x]){                    done[x]=true;                }                if(col[x]!=pcol){                    return false;                }                ArrayList<Integer>v= new ArrayList<>(vt.get(x).nb.keySet());                for (int i = 0; i <v.size() ; i++) {                    int c= v.get(i);                    if(!done[c]){                    stk.add(c);                    }                }            }            return true;        }        public static boolean dfs(int v, int[]col){            done[v]=true;            ArrayList<Integer>ar=new ArrayList<>(vt.get(v).nb.keySet());            for (int i = 0; i <ar.size() ; i++) {                int x= ar.get(i);                if(!done[x]){                    done[x]=true;                  //  System.out.println("x="+x);                    boolean d= dfs1( x,col,col[x]);                    //System.out.println("x="+x+"d="+d);                    if(!d){                        return false;                    }                }            }            return true;        }              }    static class Pair implements Comparable<Pair>{        long x;        long y;        public Pair(long x,long y){            this.x=x;            this.y=y;        }        @Override        public int compareTo(Pair o){            return (int)this.y-(int)o.y;          }        @Override        public boolean equals(Object me) {            Pair binMe = (Pair)me;            if(this.x==binMe.x && this.y==binMe.y)                return true;            else                return false;        }         @Override        public int hashCode() {            return (int)this.x + (int)this.y;        }         @Override        public String toString() {            return x+" "+y;        }      }       // int count=0;    //static long count=0;    static class Reader {        static BufferedReader reader;        static StringTokenizer tokenizer;         /**         * call this method to initialize reader for InputStream         */        static void init(InputStream input) {            reader = new BufferedReader(                    new InputStreamReader(input));            tokenizer = new StringTokenizer("");        }         /**         * get next word         */        static String next() throws IOException {            while (!tokenizer.hasMoreTokens()) {                //TODO add check for eof if necessary                tokenizer = new StringTokenizer(                        reader.readLine());            }            return tokenizer.nextToken();        }         static int nextInt() throws IOException {            return Integer.parseInt(next());        }         static double nextDouble() throws IOException {            return Double.parseDouble(next());        }         static long nextLong() throws IOException {            return Long.parseLong(next());        }    }        // After writing solution, quick scan for:    //   array out of bounds    //   special cases e.g. n=1?    //    // Big numbers arithmetic bugs:    //   int overflow    //   sorting, or taking max, or negative after MOD    public static void main(String[] args)  throws IOException {        Reader.init(System.in);        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));        int n= Reader.nextInt();        Graph g= new Graph();        for (int i = 1; i <=n ; i++) {            g.addVer(i);        }        Set<Pair>set= new HashSet<>();        for (int i = 0; i <n-1 ; i++) {            int x= Reader.nextInt();            int y= Reader.nextInt();            set.add(new Pair(x,y));            g.addEdge(x,y,1);        }        int col[]= new int[n+1];        for (int i = 1; i <=n ; i++) {            col[i]= Reader.nextInt();        }        boolean b=true;        long ans=0;        for (Pair s: set) {            if(col[(int)s.x]!=col[(int)s.y]){               // System.out.println(s.x+" "+s.y);                g.done= new boolean[n+1];                boolean b1=false;                 b1=g.dfs((int)s.x,  col);                g.done= new boolean[n+1];                boolean b2= g.dfs((int)s.y,col);              //  System.out.println(b2);                 if(b1 ){                    ans=s.x;                    break;                }                if(b2){                    ans=s.y;                    break;                }                else if(!b1 && !b2){                    b=false;                    break;                }            }        }         if(b && ans==0){            out.append("YES"+"\n");            out.append(1+"\n");        }        if(b && ans!=0){            out.append("YES"+"\n");            out.append(ans+"\n");        }        if(!b){            out.append("NO"+"\n");        }                                  out.flush();        out.close();     }       static long modExp(long a, long b, long mod) {        //System.out.println("a is " + a + " and b is " + b);        if (a==1) return 1;        long ans = 1;        while (b!=0) {            if (b%2==1) {                ans = (ans*a)%mod;            }            a = (a*a)%mod;            b/=2;        }        return ans;    }      public static long modmul(long a, long b, long mod) {        return b == 0 ? 0 : ((modmul(a, b >> 1, mod) << 1) % mod + a * (b & 1)) % mod;    }     static long sum(long n){        //   System.out.println("lol="+ (n*(n-1))/2);        return (n*(n+1))/2;    }          public static ArrayList<Integer> Sieve(int n) {        boolean arr[]= new boolean [n+1];        Arrays.fill(arr,true);        arr[0]=false;        arr[1]=false;        for (int i = 2; i*i <=n ; i++) {            if(arr[i]){                for (int j = 2; j <=n/i ; j++) {                    int u= i*j;                    arr[u]=false;                }}        }        ArrayList<Integer> ans= new ArrayList<>();        for (int i = 0; i <n+1 ; i++) {            if(arr[i]){                ans.add(i);            }        }        return ans;    }        static long power( long x, long y, long p)    {         long res = 1;          x = x % p;         if (x == 0) return 0;         while (y > 0)        {             if((y & 1)==1)                res = (res * x) % p;              y = y >> 1;            x = (x * x) % p;        }        return res;    }     public static long ceil_div(long a, long b){        return (a+b-1)/b;    }     static long gcd(long a, long b)    {        if (a == 0)            return b;        return gcd(b % a, a);    }     static long lcm(long a, long b)    {        return (a*b)/gcd(a, b);    } }
