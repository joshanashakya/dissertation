import math,sys,bisect,heapq,osfrom collections import defaultdict,Counter,dequefrom itertools import groupby,accumulatefrom functools import lru_cache#sys.setrecursionlimit(200000000)int1 = lambda x: int(x) - 1def input(): return sys.stdin.readline().rstrip('\r\n')#input = iter(sys.stdin.buffer.read().decode().splitlines()).__next__aj = lambda: list(map(int, input().split()))def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]#MOD = 1000000000 + 7def Y(c):  print(["NO","YES"][c])def y(c):  print(["no","yes"][c])def Yy(c):  print(["No","Yes"][c]) def solve():		G = defaultdict(list)			def addEdge(a,b):			G[a].append(b)			G[b].append(a)			def dfs(node,p):			d = deque()			d.append(node)			vis[node] = True			while d:				x = d.pop()				for i in G.get(x,[]):					if not vis[i] and i != p:						vis[i] = True						d.append(i)						if C[node-1] != C[i-1]:							return False			return True			n, =aj()		m = n-1		vis = [False]*(n+1)		edges = set()		for i in range(m):		    u,v = aj()		    addEdge(u,v)		    edges.add((u,v))		C = aj()		if len(set(C)) == 1:			Y(1)			print(1)			exit(0)		u=v = None		for i,j in edges:			if C[i-1] != C[j-1]:				u = i				v = j				break		vis = [False]*(n+1)		if all([dfs(i,u) for i in G.get(u,[])]):			Y(1)			print(u)			exit(0)		vis = [False]*(n+1)		if all([dfs(i,v) for i in G.get(v,[])]):			Y(1)			print(v)			exit(0)		Y(0)      try:	#os.system("online_judge.py")	sys.stdin = open('input.txt', 'r') 	sys.stdout = open('output.txt', 'w')except:	pass solve()
