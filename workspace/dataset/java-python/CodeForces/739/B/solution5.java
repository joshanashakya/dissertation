import java.util.*;import java.io.*; public class AlyonaAndTree{		static int n;	static int[] a;	static ArrayList<Edge>[] tree; 	static int[][] lift;	static long[] depth;	static int d;		static int[] add;	static int[] low;	static int[] hig;		static int[] ans; 	public static void main(String[] args)	{		JS scan = new JS();		PrintWriter out = new PrintWriter(System.out);		n = scan.nextInt();		a = new int[n];		tree = new ArrayList[n];		add = new int[n];		low = new int[n];		hig = new int[n];		for(int i = 0; i < n; i++) { 			a[i] = scan.nextInt();			tree[i] = new ArrayList<Edge>();		}				d = Integer.numberOfTrailingZeros(Integer.highestOneBit(n))+1;		depth = new long[n];		lift = new int[d][n];		for(int k = 0; k < d; k++) Arrays.fill(lift[k], -1);				for(int i = 1; i < n; i++) {			int p = scan.nextInt()-1;			int w = scan.nextInt();			tree[p].add(new Edge(i, w));		}		dfs(0);		for(int k = 1; k < d; k++) 			for(int i = 0; i < n; i++) 				if(lift[k-1][i] != -1)					lift[k][i] = lift[k-1][lift[k-1][i]];				for(int i = 0; i < n; i++) {			int lo = 0;			int hi = d-1;			int at = i;			int count = 0; // how many nodes control me? <- cool programming problem on its own			while(lo <= hi) {				int mid = (lo+hi)/2;				int pappy = lift[mid][at];				if(pappy == -1) {					hi = mid-1;					continue;				}				long dist = depth[i]-depth[pappy];				if(dist > a[i]) hi = mid-1;				else {					at = pappy;					count += (1 << mid);					lo = 0;					hi = d-1;				}			}			add[at]--;			add[i]++;		}		ans = new int[n];		compute(0);		for(int i = 0; i < n; i++) out.print(ans[i]+" ");		out.println();		out.flush();	}		static int cur;		static int compute(int curr) {		for(Edge e : tree[curr]) ans[curr] += compute(e.to);		return ans[curr]+add[curr];	}		static void dfs(int curr) {		low[curr] = cur;		for(Edge e : tree[curr]) {			lift[0][e.to] = curr;			depth[e.to] = depth[curr]+e.w;			cur++;			dfs(e.to);		}		hig[curr] = cur;	}		static class Edge{				int to;		int w;				public Edge(int to, int w) {			this.to = to;			this.w = w;		}	} 	static class JS{		public int BS = 1<<16;		public char NC = (char)0;		byte[] buf = new byte[BS];		int bId = 0, size = 0;		char c = NC;		double num = 1;		BufferedInputStream in; 		public JS() {			in = new BufferedInputStream(System.in, BS);		} 		public JS(String s) throws FileNotFoundException {			in = new BufferedInputStream(new FileInputStream(new File(s)), BS);		} 		public char nextChar(){			while(bId==size) {				try {					size = in.read(buf);				}catch(Exception e) {					return NC;				}								if(size==-1)return NC;				bId=0;			}			return (char)buf[bId++];		} 		public int nextInt() {			return (int)nextLong();		} 		public long nextLong() {			num=1;			boolean neg = false;			if(c==NC)c=nextChar();			for(;(c<'0' || c>'9'); c = nextChar()) {				if(c=='-')neg=true;			}			long res = 0;			for(; c>='0' && c <='9'; c=nextChar()) {				res = (res<<3)+(res<<1)+c-'0';				num*=10;			}			return neg?-res:res;		} 		public double nextDouble() {			double cur = nextLong();			return c!='.' ? cur:cur+nextLong()/num;		} 		public String next() {			StringBuilder res = new StringBuilder();			while(c<=32)c=nextChar();			while(c>32) {				res.append(c);				c=nextChar();			}			return res.toString();		} 		public String nextLine() {			StringBuilder res = new StringBuilder();			while(c<=32)c=nextChar();			while(c!='\n') {				res.append(c);				c=nextChar();			}			return res.toString();		} 		public boolean hasNext() {			if(c>32)return true;			while(true) {				c=nextChar();				if(c==NC)return false;				else if(c>32)return true;			}		}	}}
