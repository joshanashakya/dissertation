/*    Method 2: Small to Large Merging. *///created by Whiplash99import java.io.*;import java.util.*;public class A{    private static ArrayDeque<Integer>[] edge;    private static int[] val, edgeVal, ans, set;    private static PriorityQueue<Long>[] PQ;     private static void merge(int u, int v)    {        while (!PQ[v].isEmpty())            PQ[u].add(PQ[v].poll());    }    private static void DFS(int u, long dist)    {        set[u]=u;        for(int v:edge[u])        {            DFS(v,dist+edgeVal[v]);            if(PQ[set[v]].size()>PQ[set[u]].size())            {                merge(set[v], set[u]);                set[u]=set[v];            }            else merge(set[u], set[v]);        }         while (!PQ[set[u]].isEmpty()&&dist<PQ[set[u]].peek())            PQ[set[u]].poll();         ans[u]=PQ[set[u]].size();        PQ[set[u]].add(dist-val[u]);    }    public static void main(String[] args) throws IOException    {        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));         int i,N;         N=Integer.parseInt(br.readLine().trim());         PQ=new PriorityQueue[N]; set =new int[N];        edge=new ArrayDeque[N]; val=new int[N];        edgeVal=new int[N]; ans=new int[N];        for(i=0;i<N;i++) edge[i]=new ArrayDeque<>();        for(i=0;i<N;i++) PQ[i]=new PriorityQueue<>(Collections.reverseOrder());         String[] s=br.readLine().trim().split(" ");        for(i=0;i<N;i++) val[i]=Integer.parseInt(s[i]);         for(i=0;i<N-1;i++)        {            s=br.readLine().trim().split(" ");            int u=Integer.parseInt(s[0])-1;            int w=Integer.parseInt(s[1]);             edge[u].add(i+1);            edgeVal[i+1]=w;        }         DFS(0,0);         StringBuilder sb=new StringBuilder();        for(i=0;i<N;i++) sb.append(ans[i]).append(" ");         System.out.println(sb);    }}
