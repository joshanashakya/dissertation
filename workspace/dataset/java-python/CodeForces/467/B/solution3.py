from os import pathimport sys,time# mod = int(1e9 + 7)# import refrom math import ceil, floor,gcd,log,log2 ,factorial,sqrtfrom collections import defaultdict ,Counter , OrderedDict , dequefrom itertools import combinations ,accumulate# from string import ascii_lowercase ,ascii_uppercasefrom bisect import *from functools import reducefrom operator import mulstar = lambda x: print(' '.join(map(str, x)))grid = lambda  r :[lint() for i in range(r)]stpr = lambda x : sys.stdout.write(f'{x}' + '\n')INF = float('inf')if (path.exists('input.txt')):    sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');import sysfrom sys import stdin, stdoutfrom collections import *from math import gcd, floor, ceildef st(): return list(stdin.readline().strip())def inp():    return int(stdin.readline())def inlt():    return list(map(int, stdin.readline().split()))def insr():    s = input()    return(list(s[:len(s) - 1]))def invr():    return map(int, stdin.readline().split())def pr(n): return stdout.write(str(n)+"\n")def return_divisors(n):    ll = []    for i in range(1,n+1):        if n%i==0:            ll.append(i)    return lldef calc(n):    return sum([int(i)for i in list(str(n))]) def mismatch(a,b):    c = 0    for i in range(32):        if(((a>>i)&1)!=(b>>i)&1):            c+=1    return cdef solve():    n,m,k = invr()    a = []    for i in range(m):        a.append(inp())    xx = inp()    res = 0    for i in a:        if mismatch(i,xx)<=k:            res+=1    print(res) t = 1#t = inp()for _ in range(t):    solve() 
