def sumOfTheSeries ( n ) : NEWLINE INDENT return int ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ) NEWLINE DEDENT n = 5 NEWLINE print ( "Sum =" , sumOfTheSeries ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) z = a . count ( 0 ) o = a . count ( 1 ) ze = 0 on = 0 for i in range ( n ) : if ze == z : print ( i ) break ; elif on == o : print ( i ) break ; if a [ i ] == 0 : ze += 1 else : on += 1 NEWLINE NL ENDMARKER
def PositionRightmostSetbit ( n ) : NEWLINE INDENT position = 1 NEWLINE m = 1 NEWLINE while ( not ( n & m ) ) : NEWLINE INDENTINDENT m = m << 1 NEWLINE position += 1 NEWLINE DEDENT return position NEWLINE DEDENT n = 16 NEWLINE print ( PositionRightmostSetbit ( n ) ) NEWLINE NL ENDMARKER
for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE b = input ( ) NEWLINE a = '' NEWLINE d = '' NEWLINE for i in b : try : if 1 + int ( i ) == int ( d [ - 1 ] ) : NEWLINE INDENT a += '0' else : NEWLINE a += '1' except : a = '1' NEWLINE DEDENT d = str ( int ( a [ - 1 ] ) + int ( i ) ) NEWLINE print ( a ) NEWLINE NL ENDMARKER
from math import pow NEWLINE def findSum ( N , k ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 1 , N + 1 , 1 ) : NEWLINE INDENTINDENT sum += pow ( i , k ) NEWLINE DEDENT return sum NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 8 NEWLINE k = 4 NEWLINE print ( int ( findSum ( N , k ) ) ) NEWLINE NL DEDENT ENDMARKER
def cyl ( r , R , h ) : NEWLINE INDENT if ( h < 0 and r < 0 and R < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT r1 = r NEWLINE h1 = h NEWLINE V = 3.14 * pow ( r1 , 2 ) * h1 NEWLINE return round ( V , 2 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT r , R , h = 7 , 11 , 6 NEWLINE print ( cyl ( r , R , h ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) li = list ( map ( int , input ( ) . split ( ) ) ) for i in li : tmp = i % 14 dc = i // 14 if 6 >= tmp >= 1 and dc >= 1 : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) p = [ 0 ] * 2 + list ( map ( int , input ( ) . split ( ) ) )  c = npath = [ n ] while c != 1 : c = p [ c ] path . append ( c ) print ( * path [ : : - 1 ] ) NEWLINE NL ENDMARKER
def countOperations ( n ) : NEWLINE INDENT i = 2 NEWLINE while ( ( i * i ) < n and ( n % i ) ) : NEWLINE INDENTINDENT i += 1 NEWLINE DEDENT if ( ( i * i ) > n ) : NEWLINE INDENTINDENT i = n NEWLINE DEDENT return ( 1 + ( n - i ) // 2 ) NEWLINE DEDENT n = 5 NEWLINE print ( countOperations ( n ) ) NEWLINE NL ENDMARKER
n , m , a = map ( int , input ( ) . split ( ) ) ans = 0 ans1 = 0 if n % a == 0 : ans = n // aelse : ans = n // a + 1 if m % a == 0 : ans1 = m // a else : ans1 = m // a + 1 print ( ans * ans1 ) NEWLINE NL ENDMARKER
 a = int ( input ( ) ) b = int ( input ( ) )    n = a + b + 1 t = [ ]   for k in range ( 1 , n + 1 ) : t . append ( k )  print ( * ( t [ : a ] + t [ a : ] [ : : - 1 ] ) ) NEWLINE NL ENDMARKER
for t in range ( int ( input ( ) ) ) : s , i , e = map ( int , input ( ) . split ( ) ) low = 0 high = e low_pos = high_pos = e + 1 while low <= high : mid = low + ( high - low ) // 2 if mid + s > i + ( e - mid ) : low_pos = mid high = mid - 1 else : low = mid + 1 print ( high_pos - low_pos ) NEWLINE NL ENDMARKER
a , b , s = map ( int , input ( ) . split ( ) ) if a < 0 : a *= ( - 1 ) if b < 0 : b *= ( - 1 ) if a + b > s : print ( "No" ) else : if a + b == s : print ( "Yes" ) else : if ( a + b - s ) % 2 == 1 : print ( "No" ) else : print ( "Yes" ) NEWLINE NL ENDMARKER
def ncr ( n , r ) : NEWLINE INDENT ans = 1 NEWLINE for i in range ( 1 , r + 1 ) : NEWLINE INDENTINDENT ans *= ( n - r + i ) NEWLINE ans //= i NEWLINE DEDENT return ans NEWLINE DEDENT def totalWays ( X , Y , M , W ) : NEWLINE INDENT return ( ncr ( M , X ) * ncr ( W , Y ) ) NEWLINE DEDENT X = 4 NEWLINE Y = 3 NEWLINE M = 6 NEWLINE W = 5 NEWLINE print ( totalWays ( X , Y , M , W ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = [ ] for i in range ( n ) : l . append ( list ( map ( int , input ( ) . split ( ) ) ) ) ans = [ ] a = int ( ( ( l [ 0 ] [ 1 ] * l [ 1 ] [ 2 ] ) // l [ 0 ] [ 2 ] ) ** 0.5 )  for i in range ( n ) : if l [ 1 ] [ i ] != 0 : ans . append ( l [ 1 ] [ i ] // a ) else : ans . append ( a ) print ( * ans ) NEWLINE NL ENDMARKER
a , b , c , d = map ( int , input ( ) . split ( ) )  x = max ( 3 * a // 10 , a - ( a // 250 ) * c ) y = max ( 3 * b // 10 , b - ( b // 250 ) * d )  if x > y : print ( 'Misha' ) elif x < y : print ( 'Vasya' ) else : print ( 'Tie' ) NEWLINE NL ENDMARKER
def checkOrigin ( x1 , y1 , x2 , y2 ) : NEWLINE INDENT return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) NEWLINE DEDENT if ( checkOrigin ( 1 , 28 , 2 , 56 ) == True ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
def countNum ( N , arr ) : NEWLINE INDENT Sum , count = 0 , 0 NEWLINE for i in range ( N ) : NEWLINE INDENTINDENT Sum += arr [ i ] NEWLINE DEDENT for i in range ( N ) : NEWLINE INDENTINDENT if ( ( Sum - arr [ i ] ) % arr [ i ] == 0 ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT return count NEWLINE DEDENT arr = [ 3 , 10 , 4 , 6 , 7 ] NEWLINE n = len ( arr ) NEWLINE print ( countNum ( n , arr ) ) NEWLINE NL ENDMARKER
from math import pow NEWLINE def printf ( n , k ) : NEWLINE INDENT print ( int ( k ) , end = " " ) NEWLINE for i in range ( 2 , n + 1 , 1 ) : NEWLINE INDENTINDENT x = pow ( k , i ) - pow ( k , i - 1 ) NEWLINE print ( int ( x ) , end = " " ) NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 3 NEWLINE K = 4 NEWLINE printf ( N , K ) NEWLINE NL DEDENT ENDMARKER
def squarearea ( r ) : NEWLINE INDENT if ( r < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT a = 4 * ( pow ( r , 2 ) / 5 ) NEWLINE return a NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT r = 5 NEWLINE print ( int ( squarearea ( r ) ) ) NEWLINE NL DEDENT ENDMARKER
t = int ( input ( ) ) for i in range ( 0 , t ) : s , a , b , c = map ( int , input ( ) . split ( ) ) chocolates = 0 chocolates += s // c if s // c >= a : chocolates += ( chocolates // a ) * b print ( chocolates ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( 9 * n , end = " " ) print ( 8 * n ) NEWLINE NL ENDMARKER
import math NEWLINE def findBucketNo ( p ) : NEWLINE INDENT return math . ceil ( ( math . sqrt ( 8 * p + 1 ) - 1 ) / 2 ) NEWLINE DEDENT p = 10 NEWLINE print ( findBucketNo ( p ) ) NEWLINE NL ENDMARKER
k = int ( input ( ) )  for _ in range ( k ) :  n = int ( input ( ) ) planks_in = input ( ) planks = planks_in . split ( ) planks = list ( map ( int , planks ) ) planks . sort ( )  for i in range ( n ) : if planks [ i ] >= ( n - i ) : print ( n - i ) break NEWLINE NL ENDMARKER
def XorSum ( arr , n ) : NEWLINE INDENT result = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT k = 0 NEWLINE for j in range ( 1 , arr [ i ] + 1 ) : NEWLINE INDENTINDENTINDENT k = k ^ arr [ i ] NEWLINE DEDENT result = result + k NEWLINE DEDENT return result NEWLINE DEDENT arr = [ 1 , 2 , 6 , 3 , 4 , 5 ] NEWLINE n = len ( arr ) NEWLINE print ( XorSum ( arr , n ) ) NEWLINE NL ENDMARKER
s = input ( ) c = 0 ; t = s . rfind ( '#' ) ans = [ ] ; b = Truefor i in range ( t ) : if s [ i ] == '(' : c += 1 elif s [ i ] == ')' : c -= 1 else : c -= 1 ans . append ( 1 ) if c < 0 : b = False breakm = cfor i in range ( t + 1 , len ( s ) ) : if s [ i ] == '(' : c += 1 else : c -= 1 m = min ( m , c )  if b and m > 0 and m == c : ans . append ( m ) print ( * ans , sep = '\n' ) else : print ( - 1 ) NEWLINE NL ENDMARKER
def items ( n , a ) : NEWLINE INDENT a . sort ( ) NEWLINE z = a [ n - 1 ] NEWLINE x = 1 NEWLINE s = 0 NEWLINE for i in range ( 0 , n - 1 ) : NEWLINE INDENTINDENT s += a [ i ] NEWLINE if ( s <= z ) : NEWLINE INDENTINDENTINDENT x += 1 NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT break NEWLINE DEDENT DEDENT return x NEWLINE DEDENT n = 5 NEWLINE a = [ 5 , 3 , 1 , 5 , 6 ] NEWLINE print ( items ( n , a ) ) NEWLINE NL ENDMARKER
from math import ceiln , x = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) print ( ceil ( abs ( sum ( l ) ) / x ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if n % 2 == 0 : print ( n // 2 ) elif n % 3 == 0 : print ( n // 3 ) elif n % 4 == 0 : print ( n // 4 ) elif n % 5 == 0 : print ( n // 5 ) elif n % 6 == 0 : print ( n // 6 ) elif n % 7 == 0 : print ( n // 7 ) else : print ( ( n - 3 ) // 2 + 1 ) NEWLINE NL ENDMARKER
import eulerlib NEWLINE import itertools NEWLINE def compute ( ) : NEWLINE INDENT ans = next ( itertools . islice ( filter ( eulerlib . is_prime , itertools . count ( 2 ) ) , 10000 , None ) ) NEWLINE return str ( ans ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( compute ( ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) )  i = 2 while i * i <= n : while n % ( i * i ) == 0 : n /= i i += 1  print ( int ( n ) ) NEWLINE NL ENDMARKER
def arraySum ( arr , n ) : NEWLINE INDENT x = ( n + 1 ) / 2 NEWLINE return ( arr [ 0 ] - 1 ) * n + x * x NEWLINE DEDENT arr = [ 10 , 11 , 12 , 13 , 12 , 11 , 10 ] NEWLINE n = len ( arr ) NEWLINE print ( arraySum ( arr , n ) ) NEWLINE NL ENDMARKER
a , b , c = list ( map ( int , input ( ) . split ( " " ) ) ) total = int ( a * c * ( c + 1 ) * 1 / 2 ) if ( total - b ) < 0 : print ( 0 ) else : print ( total - b ) NEWLINE NL ENDMARKER
def Valid ( a , b , c , d ) : NEWLINE INDENT if ( a + b + c + d == 360 ) : NEWLINE INDENTINDENT return True ; NEWLINE DEDENT return False ; NEWLINE DEDENT a = 80 ; b = 70 ; c = 100 ; d = 110 ; NEWLINE if ( Valid ( a , b , c , d ) ) : NEWLINE INDENT print ( "Valid quadilateral" ) ; NEWLINE DEDENT else : NEWLINE INDENT print ( "Invalid quadilateral" ) ; NEWLINE NL DEDENT ENDMARKER
def findNumber ( n ) : NEWLINE INDENT i = 1 NEWLINE while i <= n : NEWLINE INDENTINDENT print ( ( 2 * i ) - 1 , end = " " ) NEWLINE i += 1 NEWLINE DEDENT DEDENT n = 3 NEWLINE findNumber ( n ) NEWLINE NL ENDMARKER
def modInverse ( a , m ) : NEWLINE INDENT a = a % m ; NEWLINE for x in range ( 1 , m ) : NEWLINE INDENTINDENT if ( ( a * x ) % m == 1 ) : NEWLINE INDENTINDENTINDENT return x NEWLINE DEDENT DEDENT return 1 NEWLINE DEDENT a = 3 NEWLINE m = 11 NEWLINE print ( modInverse ( a , m ) ) NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) if a % 2 == 0 : if b > a / 2 : print ( int ( ( b - a / 2 ) * 2 ) ) else : print ( int ( b * 2 - 1 ) ) else : if b > a // 2 + 1 : print ( int ( ( b - ( a // 2 + 1 ) ) * 2 ) ) else : print ( int ( b * 2 - 1 ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : l = list ( input ( ) . split ( ) ) a = l [ 0 ] b = l [ 1 ] x = len ( b ) if ( '9' * len ( b ) != b ) : x = x - 1 print ( int ( a ) * x ) NEWLINE NL ENDMARKER
maxi = 0 for i in range ( int ( input ( ) ) ) : x , y = map ( int , input ( ) . split ( ' ' ) ) maxi = max ( x + y , maxi ) print ( maxi ) NEWLINE NL ENDMARKER
m = int ( input ( ) ) j = 2 while m % j != 0 : j += 1 print ( j , m // j , sep = '' ) NEWLINE NL ENDMARKER
a = int ( input ( ) ) x = [ str ( x ) for x in str ( input ( ) [ : a ] ) ] z = x . count ( 'z' ) e = x . count ( 'e' ) r = x . count ( 'r' ) o = x . count ( 'o' ) n = x . count ( 'n' ) print ( * [ n * '1 ' + r * '0 ' ] ) NEWLINE NL ENDMARKER
def CountZeroBit ( n ) : NEWLINE INDENT count = 0 NEWLINE while ( n ) : NEWLINE INDENTINDENT if ( not ( n & 1 ) ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT n >>= 1 NEWLINE DEDENT return count NEWLINE DEDENT def CountORandSumEqual ( N ) : NEWLINE INDENT count = CountZeroBit ( N ) NEWLINE return ( 1 << count ) NEWLINE DEDENT N = 10 NEWLINE print ( CountORandSumEqual ( N ) ) NEWLINE NL ENDMARKER
def countMoves ( n ) : NEWLINE INDENT ct = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT ct += i * ( n - i ) NEWLINE DEDENT ct += n NEWLINE return ct NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 3 NEWLINE print ( countMoves ( n ) ) NEWLINE NL DEDENT ENDMARKER
import math NEWLINE if __name__ == '__main__' : NEWLINE INDENT n = 12 NEWLINE print ( math . sqrt ( n ) ) NEWLINE NL DEDENT ENDMARKER
class Solution ( object ) : NEWLINE INDENT def pivotIndex ( self , nums ) : NEWLINE INDENTINDENT totalsum = sum ( nums ) NEWLINE leftsum = 0 NEWLINE for i , v in enumerate ( nums ) : NEWLINE INDENTINDENTINDENT if leftsum == totalsum - leftsum - v : NEWLINE INDENTINDENTINDENTINDENT return i NEWLINE DEDENT leftsum += v NEWLINE DEDENT return - 1 NEWLINE NL DEDENT DEDENT ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) print ( max ( min ( n , k - 1 ) - k // 2 , 0 ) ) NEWLINE NL ENDMARKER
x , y = map ( int , input ( ) . split ( ) ) num = int ( input ( ) ) num %= 6 num = num if num != 0 else num + 6 t , l = x , yfor _ in range ( num - 2 ) : x , y = y , y - x x %= 10 ** 9 + 7 y %= 10 ** 9 + 7 if num == 1 : print ( t % ( 10 ** 9 + 7 ) ) elif num == 2 : print ( l % ( 10 ** 9 + 7 ) ) else :   print ( y ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) if ( n == 1 ) : print ( 1 ) else : ans = 2 * n - 1 while ( n >= 2 ) : ans += 4 * n - 6 n -= 1 print ( ans ) NEWLINE NL ENDMARKER
Max = 100 NEWLINE def countCommon ( mat , n ) : NEWLINE INDENT res = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] : NEWLINE INDENTINDENTINDENT res = res + 1 NEWLINE DEDENT DEDENT return res NEWLINE DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEWLINE print ( countCommon ( mat , 3 ) ) NEWLINE NL ENDMARKER
def centeredTetrahedralNumber ( n ) : NEWLINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 3 ) // 3 NEWLINE DEDENT n = 6 NEWLINE print ( centeredTetrahedralNumber ( n ) ) NEWLINE NL ENDMARKER
def centered_square_num ( n ) : NEWLINE INDENT return n * n + ( ( n - 1 ) * ( n - 1 ) ) NEWLINE DEDENT n = 7 NEWLINE print ( "%sth Centered square number: " % n , centered_square_num ( n ) ) NEWLINE NL ENDMARKER
def countOfMultiples ( n ) : NEWLINE INDENT return ( int ( n / 3 ) + int ( n / 5 ) - int ( n / 15 ) ) ; NEWLINE DEDENT print ( countOfMultiples ( 6 ) ) NEWLINE print ( countOfMultiples ( 16 ) ) NEWLINE NL ENDMARKER
def getHeight ( X ) : NEWLINE INDENT return ( 2 * X ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT X = 35 NEWLINE print ( getHeight ( X ) ) NEWLINE NL DEDENT ENDMARKER
def Cel_To_Fah ( n ) : NEWLINE INDENT return ( n * 1.8 ) + 32 NEWLINE DEDENT n = 20 NEWLINE print ( int ( Cel_To_Fah ( n ) ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) s = sum ( l ) if s == n and n % 2 : print ( "First" ) elif s == n and n % 2 == 0 : print ( "Second" ) else : w = 0 for i in l : if i == 1 : w = 1 - w else : break if w == 0 : print ( "First" ) else : print ( "Second" ) NEWLINE NL ENDMARKER
def findRotations ( str ) : NEWLINE INDENT tmp = str + str NEWLINE n = len ( str ) NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT substring = tmp [ i : i + n ] NEWLINE if ( str == substring ) : NEWLINE INDENTINDENTINDENT return i NEWLINE DEDENT DEDENT return n NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT str = "abc" NEWLINE print ( findRotations ( str ) ) NEWLINE NL DEDENT ENDMARKER
from collections import deque  n , m = map ( int , input ( ) . split ( ) ) a = [ 1000000 ] * 10100 a [ n ] = 0 q = deque ( ) q . append ( n ) NEWLINE NL ENDMARKER
def counLastDigitK ( low , high , k ) : NEWLINE INDENT count = ( high - low ) / 10 NEWLINE if ( high % 10 >= k ) : NEWLINE INDENTINDENT count += 1 NEWLINE DEDENT if ( low % 10 > k ) : NEWLINE INDENTINDENT count -= 1 NEWLINE DEDENT return int ( count ) NEWLINE DEDENT low = 3 NEWLINE high = 35 NEWLINE k = 3 NEWLINE print ( counLastDigitK ( low , high , k ) ) NEWLINE NL ENDMARKER
from collections import Counter  def solve ( ) : n = int ( input ( ) ) count = 1  for i in range ( 2 , n // 2 + 1 ) : if n % i == 0 : count += 1  return count  print ( solve ( ) ) NEWLINE NL ENDMARKER
def largestSubStr ( s ) : NEWLINE INDENT while ( len ( s ) and s [ len ( s ) - 1 ] == '1' ) : NEWLINE INDENTINDENT s = s [ : len ( s ) - 1 ] ; NEWLINE DEDENT if ( len ( s ) == 0 ) : NEWLINE INDENTINDENT return "-1" ; NEWLINE DEDENT else : NEWLINE INDENTINDENT return s ; NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT s = "11001" ; NEWLINE print ( largestSubStr ( s ) ) ; NEWLINE NL DEDENT ENDMARKER
import sys todo = [ ] base = 0 flag = Truefor line in sys . stdin : NEWLINE NL ENDMARKER
n , m , k = ( int ( i ) for i in input ( ) . split ( ) ) if ( m >= n and k >= n ) : print ( "Yes" ) else : print ( "No" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( )  best = nfor i in range ( 2 , n // 2 + 1 ) : if s [ : i ] == s [ i : 2 * i ] : cur = i + 1 + n - 2 * i best = min ( best , cur ) print ( best ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = int ( n ** 0.5 ) while n % a : a -= 1 print ( a , n // a ) NEWLINE NL ENDMARKER
import math NEWLINE def edgeCover ( n ) : NEWLINE INDENT result = 0 NEWLINE result = math . ceil ( n / 2.0 ) NEWLINE return result NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 5 NEWLINE print ( int ( edgeCover ( n ) ) ) NEWLINE NL DEDENT ENDMARKER
for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) ans = 0 while n >= 10 : ans += ( 10 * ( n // 10 ) ) n = n - ( 9 * ( n // 10 ) ) ans += n print ( ans ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) print ( ( n + 1 ) // 2 ) NEWLINE NL ENDMARKER
def printExpansion ( str ) : NEWLINE INDENT for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEWLINE INDENTINDENT for j in range ( i , len ( str ) ) : NEWLINE INDENTINDENTINDENT print ( str [ j ] , end = "" ) NEWLINE DEDENT DEDENT DEDENT str = "geeks" NEWLINE printExpansion ( str ) NEWLINE NL ENDMARKER
def angleextcycquad ( z ) : NEWLINE INDENT print ( "The exterior angle of the" , end = "" ) ; NEWLINE print ( "cyclic quadrilateral is " , end = "" ) ; NEWLINE print ( z , " degrees" ) ; NEWLINE DEDENT z = 48 ; NEWLINE angleextcycquad ( z ) ; NEWLINE NL ENDMARKER
n = int ( input ( ) ) NEWLINE if ( n % 2 == 0 ) : NEWLINE INDENT print ( int ( ( n / 2 + 1 ) ** 2 ) ) else : NEWLINE n = ( n + 1 ) / 2 NEWLINE DEDENT print ( int ( 4 + ( ( n - 1 ) * ( 2 * 8 + ( n - 2 ) * 4 ) ) / 2 ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) vet = list ( input ( ) ) res = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] for item in vet : if item == 'L' : pos = res . index ( 0 ) res [ pos ] = 1  elif item == 'R' : res . reverse ( ) pos = 9 - res . index ( 0 ) res . reverse ( ) res [ pos ] = 1  else : res [ int ( item ) ] = 0  str1 = '' . join ( [ str ( elem ) for elem in res ] ) print ( str1 ) NEWLINE NL ENDMARKER
import math NEWLINE def divide ( n , m ) : NEWLINE INDENT print ( "Remainder = " , ( ( n ) & ( m - 1 ) ) ) NEWLINE print ( "Quotient = " , ( n >> ( int ) ( math . log2 ( m ) ) ) ) NEWLINE DEDENT n = 43 NEWLINE m = 8 NEWLINE divide ( n , m ) NEWLINE NL ENDMARKER
M = ( 10 ** 9 ) + 7 h , w = map ( int , input ( ) . split ( ) ) r = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) ans = 1 mat = [ ] for i in range ( h + 1 ) : o = [ 0 ] * ( w + 1 ) mat . append ( o )  for row in range ( h ) : col = r [ row ] for x in range ( col ) : if mat [ row ] [ x ] == 0 : mat [ row ] [ x ] = 1  mat [ row ] [ col ] = 2  NEWLINE NL ENDMARKER
def CalculateRatio ( m , n ) : NEWLINE INDENT return ( 2 * m - 1 ) / ( 2 * n - 1 ) ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT m = 6 ; NEWLINE n = 2 ; NEWLINE print ( float ( CalculateRatio ( m , n ) ) ) ; NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) s = input ( ) if s . count ( '8' ) == 0 : print ( 0 ) elif len ( s ) < 11 : print ( 0 ) else : x = n // 11 y = s . count ( '8' ) if x <= y : print ( x ) else : print ( y ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] c = 0 flag = 0 for i in range ( n ) : if a [ i ] % 2 != 0 : flag = 1 breakif flag == 1 : print ( 'First' ) else : print ( 'Second' ) NEWLINE NL ENDMARKER
def makePolygon ( a ) : NEWLINE INDENT n = 360 / ( 180 - a ) NEWLINE if n == int ( n ) : NEWLINE INDENTINDENT print ( "YES" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "NO" ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT a = 90 NEWLINE makePolygon ( a ) NEWLINE NL DEDENT ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) if n == 1 : print ( 1 ) else : print ( m - 1 if m - 1 >= n - m else m + 1 ) NEWLINE NL ENDMARKER
def oppositeSigns ( x , y ) : NEWLINE INDENT return ( ( x ^ y ) < 0 ) ; NEWLINE DEDENT x = 100 NEWLINE y = 1 NEWLINE if ( oppositeSigns ( x , y ) == True ) : NEWLINE INDENT print "Signs are opposite" NEWLINE DEDENT else : NEWLINE INDENT print "Signs are not opposite" NEWLINE NL DEDENT ENDMARKER
import sys , os , ioimport math , bisect , operatorinf , mod = float ( 'inf' ) , 10 ** 9 + 7 NEWLINE NL ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return 2 * pow ( n , 3 ) + pow ( n , 2 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 3 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
N = int ( input ( ) ) print ( N , * range ( 1 , N ) ) NEWLINE NL ENDMARKER
def calculateSum ( n ) : NEWLINE INDENT return ( n * ( n + 1 ) // 2 + n * ( n + 1 ) * ( 2 * n + 1 ) // 6 ) NEWLINE DEDENT n = 3 NEWLINE print ( "Sum = " , calculateSum ( n ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) print ( n // 2 ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) if ( n <= 3 ) : print ( 4 - n ) else : print ( n % 2 ) NEWLINE NL ENDMARKER
import sys  input = sys . stdin . buffer . readlinet = int ( input ( ) )  for _ in range ( t ) : n = int ( input ( ) )  print ( " " . join ( list ( map ( str , list ( range ( 2 * n + 2 , 4 * n + 1 , 2 ) ) ) ) ) ) NEWLINE NL ENDMARKER
for _ in range ( 1 ) : n = int ( input ( ) ) currH = 0 total = 0 for i in range ( n ) : h = int ( input ( ) ) if currH <= h : total += h - currH + 2 currH = h  else : total += currH - h + 2 currH = h  print ( total - 1 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) if n == 1 : print ( "0" ) elif n % 2 == 0 : print ( n // 2 - 1 ) else : print ( ( n // 2 - 1 ) + ( ( n // 2 + 1 ) + ( n + 1 ) // 2 ) % n ) NEWLINE NL ENDMARKER
def averageOdd ( n ) : NEWLINE INDENT if ( n % 2 == 0 ) : NEWLINE INDENTINDENT print ( "Invalid Input" ) NEWLINE return - 1 NEWLINE DEDENT return ( n + 1 ) // 2 NEWLINE DEDENT n = 15 NEWLINE print ( averageOdd ( n ) ) NEWLINE NL ENDMARKER
def binaryToDecimal ( n ) : NEWLINE INDENT num = n ; NEWLINE dec_value = 0 ; NEWLINE base1 = 1 ; NEWLINE len1 = len ( num ) ; NEWLINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEWLINE INDENTINDENT if ( num [ i ] == '1' ) : NEWLINE INDENTINDENTINDENT dec_value += base1 ; NEWLINE DEDENT base1 = base1 * 2 ; NEWLINE DEDENT return dec_value ; NEWLINE DEDENT num = "10101001" ; NEWLINE print ( binaryToDecimal ( num ) ) ; NEWLINE NL ENDMARKER
def printSeriesSum ( N ) : NEWLINE INDENT sum = 0 ; NEWLINE for i in range ( 1 , N + 1 ) : NEWLINE INDENTINDENT if ( i & 1 ) : NEWLINE INDENTINDENTINDENT sum += i / ( i + 1 ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT sum -= i / ( i + 1 ) ; NEWLINE DEDENT DEDENT print ( sum ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 10 ; NEWLINE printSeriesSum ( N ) ; NEWLINE NL DEDENT ENDMARKER
def sumNatural ( n ) : NEWLINE INDENT sum = ( n * ( n + 1 ) ) NEWLINE return int ( sum ) NEWLINE DEDENT def sumEven ( l , r ) : NEWLINE INDENT return ( sumNatural ( int ( r / 2 ) ) - sumNatural ( int ( ( l - 1 ) / 2 ) ) ) NEWLINE DEDENT l , r = 2 , 5 NEWLINE print ( "Sum of Natural numbers" , "from L to R is" , sumEven ( l , r ) ) NEWLINE NL ENDMARKER
import math NEWLINE def calculate ( x , k , m ) : NEWLINE INDENT result = x ; NEWLINE k = k - 1 ; NEWLINE while ( k ) : NEWLINE INDENTINDENT result = math . pow ( result , x ) ; NEWLINE if ( result > m ) : NEWLINE INDENTINDENTINDENT result = result % m ; NEWLINE DEDENT k = k - 1 ; NEWLINE DEDENT return int ( result ) ; NEWLINE DEDENT x = 5 ; NEWLINE k = 2 ; NEWLINE m = 3 ; NEWLINE print ( calculate ( x , k , m ) ) ; NEWLINE NL ENDMARKER
n , k = [ int ( i ) for i in input ( ) . split ( ) ] m = [ int ( i ) for i in input ( ) . split ( ) ] m . sort ( ) a = m [ n - 1 ] - m [ 0 ] for i in range ( 1 , k - 1 ) : if i + n - 1 > k - 1 : break c = m [ i + n - 1 ] - m [ i ] if c < a : a = m [ i + n - 1 ] - m [ i ] print ( a ) NEWLINE NL ENDMARKER
def count ( n ) : NEWLINE INDENT x = ( n // 3 ) - 1 ; NEWLINE if ( n % 3 > 0 ) : NEWLINE INDENTINDENT x += 1 ; NEWLINE DEDENT return ( 4 * x + 4 * n ) ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 5 ; NEWLINE print ( count ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
def number_of_digits ( n ) : NEWLINE INDENT i = 4 ; NEWLINE res = 1 ; NEWLINE sum = 0 ; NEWLINE while ( True ) : NEWLINE INDENTINDENT i *= 4 ; NEWLINE res += 1 ; NEWLINE sum += i ; NEWLINE if ( sum >= n ) : NEWLINE INDENTINDENTINDENT break ; NEWLINE DEDENT DEDENT return res ; NEWLINE DEDENT n = 21 ; NEWLINE print ( number_of_digits ( n ) ) ; NEWLINE NL ENDMARKER
n , p = map ( int , input ( ) . split ( ) ) a = [ ] NEWLINE NL ENDMARKER
n = int ( input ( ) ) lst = [ int ( i ) for i in input ( ) . split ( ) ] mn = lst . index ( min ( lst ) ) mx = lst . index ( max ( lst ) )  print ( max ( mn , n - mn - 1 , mx , n - mx - 1 ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 cnt = 2 for i in range ( 2 , n ) : if a [ i ] == ( a [ i - 1 ] + a [ i - 2 ] ) : cnt += 1 else : cnt = 2 ans = max ( ans , cnt ) if n <= 2 : ans = nprint ( ans )        NEWLINE NL ENDMARKER
n = int ( input ( ) ) d = int ( input ( ) ) e = int ( input ( ) ) i = 0 ans = nwhile ( i * e * 5 <= n ) : ans = min ( ans , ( n - i * e * 5 ) % d ) i += 1 print ( ans ) NEWLINE NL ENDMARKER
from collections import Counterimport math  def solve ( ) : n , k = list ( map ( int , input ( ) . split ( ) ) ) array = list ( map ( int , input ( ) . split ( ) ) ) array . sort ( ) if ( n % 3 == 0 ) : end = n else : end = n - n % 3  i , count = 0 , 0  while i < end - 2 : if array [ i ] + k <= 5 and array [ i + 1 ] + k <= 5 and array [ i + 2 ] + k <= 5 : count += 1 else : break i += 3 return count   print ( solve ( ) ) NEWLINE NL ENDMARKER
import sysfrom array import array NEWLINE NL ENDMARKER
for i in range ( int ( input ( ) ) ) : a = input ( ) print ( len ( set ( input ( ) . split ( ) ) ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) x , y = map ( int , input ( ) . split ( " " ) ) if x + y > n + 1 : print ( "Black" ) else : print ( "White" ) NEWLINE NL ENDMARKER
def count ( S , m , n ) : NEWLINE INDENT if ( n == 0 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT if ( n < 0 ) : NEWLINE INDENTINDENT return 0 ; NEWLINE DEDENT if ( m <= 0 and n >= 1 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; NEWLINE DEDENT arr = [ 1 , 2 , 3 ] NEWLINE m = len ( arr ) NEWLINE print ( count ( arr , m , 4 ) ) NEWLINE NL ENDMARKER
def minimumNumbers ( n , s ) : NEWLINE INDENT if ( s % n ) : NEWLINE INDENTINDENT return s / n + 1 ; NEWLINE DEDENT else : NEWLINE INDENTINDENT return s / n ; NEWLINE DEDENT DEDENT n = 5 ; NEWLINE s = 11 ; NEWLINE print ( int ( minimumNumbers ( n , s ) ) ) ; NEWLINE NL ENDMARKER
k , p = map ( int , input ( ) . split ( ) ) res = 0 for i in range ( 1 , k + 1 ) : res += int ( str ( i ) + ( str ( i ) [ : : - 1 ] ) ) res %= pprint ( res ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) s = input ( ) total = 0 for i in range ( n ) : if s [ i ] == 'B' : total += p [ i ] ans = totalcur = totalfor i in range ( n ) : if s [ i ] == 'A' : cur += p [ i ] else : cur -= p [ i ] ans = max ( ans , cur )  cur = totalfor i in reversed ( range ( n ) ) : if s [ i ] == 'A' : cur += p [ i ] else : cur -= p [ i ] ans = max ( ans , cur )  print ( ans ) NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readline  ''''''  from math import ceil  a1 , a2 , a3 = map ( int , input ( ) . split ( ) ) b1 , b2 , b3 = map ( int , input ( ) . split ( ) ) n = int ( input ( ) ) shelves_cup = ceil ( ( a1 + a2 + a3 ) / 5 ) shelves_medal = ceil ( ( b1 + b2 + b3 ) / 10 )  print ( "YES" if shelves_cup + shelves_medal <= n else "NO" ) NEWLINE NL ENDMARKER
def mySort ( arr , n ) : NEWLINE INDENT arr1 = arr [ : n // 2 ] NEWLINE arr2 = arr [ n // 2 : ] NEWLINE arr1 . sort ( ) NEWLINE arr2 . sort ( reverse = True ) NEWLINE return arr1 + arr2 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , 7 ] NEWLINE n = len ( arr ) NEWLINE arr = mySort ( arr , n ) NEWLINE print ( "Modified Array : " ) NEWLINE print ( arr ) NEWLINE NL DEDENT ENDMARKER
def allCharactersSame ( s ) : NEWLINE INDENT n = len ( s ) NEWLINE for i in range ( 1 , n ) : NEWLINE INDENTINDENT if s [ i ] != s [ 0 ] : NEWLINE INDENTINDENTINDENT return False NEWLINE DEDENT DEDENT return True NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT s = "aaa" NEWLINE if allCharactersSame ( s ) : NEWLINE INDENTINDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) NEWLINE NL DEDENT DEDENT ENDMARKER
t = int ( input ( ) ) while ( t ) : a , b = map ( int , input ( ) . split ( ) ) if ( a % b == 0 ) : print ( '0' ) else : print ( b - ( a % b ) ) t -= 1 NEWLINE NL ENDMARKER
n = int ( input ( ) ) nums = list ( map ( int , input ( ) . split ( ' ' ) ) ) one = nums . count ( 1 ) two = nums . count ( 2 ) if one == 0 : print ( 0 ) elif two == 0 : print ( one // 3 ) else : discard = max ( one , two ) - min ( one , two ) form = len ( nums ) - discard if discard > 2 and one > two : discard = discard // 3 print ( ( form // 2 ) + discard ) else : print ( form // 2 ) NEWLINE NL ENDMARKER
import math NEWLINE def factorial ( n ) : NEWLINE INDENT res = 1 NEWLINE i = 2 NEWLINE for i in ( n + 1 ) : NEWLINE INDENTINDENT res = res * i NEWLINE DEDENT return res NEWLINE DEDENT def calculateSeries ( n ) : NEWLINE INDENT return ( 2 + ( n * n + n - 2 ) * math . factorial ( n + 1 ) ) NEWLINE DEDENT n = 3 NEWLINE print ( calculateSeries ( n ) ) NEWLINE NL ENDMARKER
MAX = 11 ; NEWLINE def isMultipleof5 ( n ) : NEWLINE INDENT s = str ( n ) ; NEWLINE l = len ( s ) ; NEWLINE if ( s [ l - 1 ] == '5' or s [ l - 1 ] == '0' ) : NEWLINE INDENTINDENT return True ; NEWLINE DEDENT return False ; NEWLINE DEDENT n = 19 ; NEWLINE if ( isMultipleof5 ( n ) == True ) : NEWLINE INDENT print ( n , "is multiple of 5" ) ; NEWLINE DEDENT else : NEWLINE INDENT print ( n , "is not a multiple of 5" ) ; NEWLINE NL DEDENT ENDMARKER
def increaseInVol ( l , b , h ) : NEWLINE INDENT percentInc = ( ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ) NEWLINE percentInc -= 1 NEWLINE percentInc *= 100 NEWLINE return percentInc NEWLINE DEDENT l = 50 NEWLINE b = 20 NEWLINE h = 10 NEWLINE print ( increaseInVol ( l , b , h ) , "%" ) NEWLINE NL ENDMARKER
def NicomachuTheorum_sum ( n ) : NEWLINE INDENT sum = 0 ; NEWLINE for k in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT sum += k * k * k ; NEWLINE DEDENT triNo = n * ( n + 1 ) / 2 ; NEWLINE if ( sum == triNo * triNo ) : NEWLINE INDENTINDENT print ( "Yes" ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) ; NEWLINE DEDENT DEDENT n = 5 ; NEWLINE NicomachuTheorum_sum ( n ) ; NEWLINE NL ENDMARKER
n = int ( input ( ) ) for t in range ( n ) : if t : input ( ) board = [ [ c for c in input ( ) ] for i in range ( 8 ) ] k1 , k2 = ( ( i , j ) for i in range ( 8 ) for j in range ( 8 ) if board [ i ] [ j ] == 'K' ) if ( k1 [ 0 ] - k2 [ 0 ] ) % 4 == 0 and ( k1 [ 1 ] - k2 [ 1 ] ) % 4 == 0 : print ( 'YES' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
def squareRoot ( n ) : NEWLINE INDENT x = n ; NEWLINE y = 1 ; NEWLINE while ( x > y ) : NEWLINE INDENTINDENT x = ( x + y ) / 2 ; NEWLINE y = n / x ; NEWLINE DEDENT return x ; NEWLINE DEDENT n = 49 ; NEWLINE print ( "root of" , n , "is" , squareRoot ( n ) ) ; NEWLINE NL ENDMARKER
def countNumbers ( l , r ) : NEWLINE INDENT return ( ( r // 6 ) - ( l - 1 ) // 6 ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT l = 1000 ; r = 6000 ; NEWLINE print ( countNumbers ( l , r ) ) ; NEWLINE NL DEDENT ENDMARKER
def stepRequired ( n ) : NEWLINE INDENT return bin ( 94 ) . count ( '1' ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 94 NEWLINE print ( stepRequired ( n ) ) NEWLINE NL DEDENT ENDMARKER
def findArea ( a , b ) : NEWLINE INDENT Area = 3.142 * a * b ; NEWLINE print ( "Area:" , round ( Area , 2 ) ) ; NEWLINE DEDENT a = 5 ; NEWLINE b = 4 ; NEWLINE findArea ( a , b ) ; NEWLINE NL ENDMARKER
t , s , x = map ( int , input ( ) . split ( ) ) if x >= t : x -= t sss = x // s x = x % s if x == 0 or ( sss != 0 and x == 1 ) : print ( 'YES' ) else : print ( 'NO' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
c1 , c2 , c3 , c4 = map ( int , input ( ) . split ( ) ) n , m = map ( int , input ( ) . split ( ) ) b = list ( map ( int , input ( ) . split ( ) ) ) t = list ( map ( int , input ( ) . split ( ) ) ) a = 0 for i in range ( n ) : a += min ( c1 * b [ i ] , c2 ) ans = min ( a , c3 ) b = 0 for i in range ( m ) : b += min ( c1 * t [ i ] , c2 ) ans += min ( b , c3 ) print ( min ( ans , c4 ) ) NEWLINE NL ENDMARKER
def evenDecimalValue ( str , n ) : NEWLINE INDENT result = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT if ( str [ i ] == '0' ) : NEWLINE INDENTINDENTINDENT result += ( n - i ) NEWLINE DEDENT DEDENT return result NEWLINE DEDENT str = "10010" NEWLINE n = 5 NEWLINE print ( evenDecimalValue ( str , n ) ) NEWLINE NL ENDMARKER
def gcd ( a , b ) : NEWLINE INDENT if a == 0 : NEWLINE INDENTINDENT return b NEWLINE DEDENT return gcd ( b % a , a ) NEWLINE DEDENT a = 2 NEWLINE b = 4 NEWLINE print ( gcd ( a , b ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) NEWLINE s = nl = [ n ] NEWLINE i = s - 1 NEWLINE while ( s > 0 ) : if NEWLINE i == 0 : NEWLINE break NEWLINE if s % i == 0 : l . append ( i ) NEWLINE s = i NEWLINE i = s - 1 NEWLINE if i == 0 : NEWLINE INDENT break else : NEWLINE i -= 1 NEWLINE DEDENT print ( * l ) NEWLINE NL ENDMARKER
for t in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) print ( a + b ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) x = 0 for i in range ( n ) : bit_operation = input ( ) if bit_operation == "X++" or bit_operation == "++X" : x = x + 1 elif bit_operation == "X--" or bit_operation == "--X" : x = x - 1 print ( x ) NEWLINE NL ENDMARKER
import mathh , l = map ( int , input ( ) . split ( ) ) angle = math . atan ( l / h ) - math . atan ( h / l ) print ( math . tan ( angle ) * l ) NEWLINE NL ENDMARKER
from sys import stdinimport math  NEWLINE NL ENDMARKER
t = int ( input ( ) ) NEWLINE for _ in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) NEWLINE print ( a ^ b ) NEWLINE NL ENDMARKER
def maxAND ( L , R ) : NEWLINE INDENT maximum = L & R NEWLINE for i in range ( L , R , 1 ) : NEWLINE INDENTINDENT for j in range ( i + 1 , R + 1 , 1 ) : NEWLINE INDENTINDENTINDENT maximum = max ( maximum , ( i & j ) ) NEWLINE DEDENT DEDENT return maximum NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT L = 1 NEWLINE R = 632 NEWLINE print ( maxAND ( L , R ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) if n == 3 : print ( 5 ) exit ( ) for i in range ( 1 , 200 ) : if i % 2 != 0 : v = ( i * i ) // 2 + 1 if n <= v : print ( i ) exit ( ) NEWLINE NL ENDMARKER
def log_a_to_base_b ( a , b ) : NEWLINE INDENT rslt = ( 1 + log_a_to_base_b ( a // b , b ) ) if ( a > ( b - 1 ) ) else 0 ; NEWLINE return rslt ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = 3 ; NEWLINE b = 2 ; NEWLINE print ( log_a_to_base_b ( a , b ) ) ; NEWLINE a = 256 ; NEWLINE b = 4 ; NEWLINE print ( log_a_to_base_b ( a , b ) ) ; NEWLINE NL DEDENT ENDMARKER
from math import sqrt NEWLINE def maxVol ( P , A ) : NEWLINE INDENT l = ( P - sqrt ( P * P - 24 * A ) ) / 12 NEWLINE V = l * ( A / 2.0 - l * ( P / 4.0 - l ) ) NEWLINE return V NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT P = 20 NEWLINE A = 16 NEWLINE print ( maxVol ( P , A ) ) NEWLINE NL DEDENT ENDMARKER
from sys import stdin NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) kmin = n // mkmax = n - m  pairMin = m * kmin * ( kmin - 1 ) // 2 + kmin * ( n % m ) pairMax = ( kmax + 1 ) * kmax // 2  print ( pairMin , pairMax ) NEWLINE NL ENDMARKER
import sys  sys . stdin = open ( r'input.txt' , 'r' ) sys . stdout = open ( r'output.txt' , 'w' )  n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )  i = k - 1 ; while ( True ) : if i == n : i = 0 continue  if a [ i ] == 1 : print ( i + 1 ) break  i += 1 NEWLINE NL ENDMARKER
def calculateSum ( n ) : NEWLINE INDENT return ( n * ( n + 1 ) // 2 + pow ( ( n * ( n + 1 ) // 2 ) , 2 ) ) NEWLINE DEDENT n = 3 NEWLINE print ( "Sum = " , calculateSum ( n ) ) NEWLINE NL ENDMARKER
import math  n , a , b = map ( int , input ( ) . split ( ' ' ) ) rounds = math . log ( n , 2 ) r = int ( rounds ) for i in range ( 1 , int ( rounds ) + 1 ) : a = math . ceil ( a / 2 ) b = math . ceil ( b / 2 ) if ( a == b ) : if ( i == r ) : print ( 'Final!' ) break else : print ( i ) break NEWLINE NL ENDMARKER
n = input ( ) S = list ( map ( str , input ( ) . split ( ) ) ) Max = 0 for i in range ( len ( S ) ) : C = 0 for j in range ( len ( S [ i ] ) ) : if S [ i ] [ j ] . isupper ( ) : C += 1 if C > Max : Max = Cprint ( Max ) NEWLINE NL ENDMARKER
a , b , c = map ( int , input ( ) . split ( ) ) ; s = 0 if c == 0 : if a == b : print ( "YES" ) else : print ( "NO" ) elif c < 0 : if a < b : print ( "NO" ) else : if abs ( a - b ) % c == 0 : print ( "YES" ) else : print ( "NO" ) else : if a > b : print ( "NO" ) else : if abs ( a - b ) % c == 0 : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
daf = list ( map ( int , input ( ) . split ( ) ) )  daf . sort ( )  x1 = daf [ 2 ] - daf [ 1 ] - daf [ 0 ] x2 = daf [ 3 ] - daf [ 2 ] - daf [ 1 ]  x = min ( x1 , x2 )  if x > 0 : print ( 'IMPOSSIBLE' ) elif x == 0 : print ( 'SEGMENT' ) else : print ( 'TRIANGLE' ) NEWLINE NL ENDMARKER
def smallestEven ( n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT return pow ( 10 , n - 1 ) NEWLINE DEDENT n = 4 NEWLINE print ( smallestEven ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) array = input ( ) . split ( ) c = ( n + 1 ) / 2 most_repeated = max ( set ( array ) , key = array . count ) counter = 0  for i in array : if ( i == most_repeated ) : counter += 1 else : continue  if ( c <= counter and n % 2 == 0 ) : print ( "NO" ) elif ( c < counter and n % 2 != 0 ) : print ( "NO" ) else : print ( "YES" ) NEWLINE NL ENDMARKER
from math import * NEWLINE def nextPerfectCube ( N ) : NEWLINE INDENT nextN = floor ( N ** ( 1 / 3 ) ) + 1 NEWLINE return nextN ** 3 NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 35 NEWLINE print ( nextPerfectCube ( n ) ) NEWLINE NL DEDENT ENDMARKER
for _ in range ( int ( input ( ) ) ) : print ( * [ 1 ] * int ( input ( ) ) , sep = " " ) NEWLINE NL ENDMARKER
def product ( ar , n ) : NEWLINE INDENT result = 1 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT result = result * ar [ i ] NEWLINE DEDENT return result NEWLINE DEDENT ar = [ 1 , 2 , 3 , 4 , 5 ] NEWLINE n = len ( ar ) NEWLINE print ( product ( ar , n ) ) NEWLINE NL ENDMARKER
t = int ( input ( ) )  while t > 0 : t -= 1 s = input ( ) if '0' not in s or '1' not in s : print ( s ) else : s1 = "01" * len ( s ) print ( s1 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) if ( n % 2 == 1 ) : print ( 0 ) elif ( n % 4 == 0 ) : print ( n // 4 - 1 ) else : print ( n // 4 ) NEWLINE NL ENDMARKER
def counLastDigitK ( low , high , k ) : NEWLINE INDENT count = 0 NEWLINE for i in range ( low , high + 1 ) : NEWLINE INDENTINDENT if ( i % 10 == k ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT return count NEWLINE DEDENT low = 3 NEWLINE high = 35 NEWLINE k = 3 NEWLINE print ( counLastDigitK ( low , high , k ) ) NEWLINE NL ENDMARKER
def find_array ( a , n ) : NEWLINE INDENT x = 0 ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT a [ i ] += x ; NEWLINE print ( a [ i ] , end = ' ' ) ; NEWLINE x = max ( x , a [ i ] ) ; NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT a = [ 40 , 12 , 62 ] ; NEWLINE n = len ( a ) ; NEWLINE find_array ( a , n ) ; NEWLINE NL DEDENT ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) ans = min ( k - 1 , n - k ) * 2 + max ( k - 1 , n - k ) + 2 * n + 1 print ( ans ) NEWLINE NL ENDMARKER
from __future__ import division , print_functionfrom collections import * from math import * from itertools import * import osimport sysfrom io import BytesIO , IOBaseimport math  if sys . version_info [ 0 ] < 3 : from __builtin__ import xrange as range from future_builtins import ascii , filter , hex , map , oct , zip    def main ( ) : n = int ( input ( ) ) NEWLINE NL ENDMARKER
s = input ( ) ans = set ( ) ans . add ( s ) c = s [ 1 : ] + s [ 0 ] while c != s : ans . add ( c ) c = c [ 1 : ] + c [ 0 ]   print ( len ( ans ) )  NEWLINE NL ENDMARKER
n = input ( ) n1 = int ( n ) c = list ( map ( int , input ( ) . split ( ) [ : n1 ] ) ) c . sort ( reverse = True ) l = len ( c ) i = - 1 while i < l - 2 : i = i + 1 if i == l - 1 : break if c [ i ] > c [ i + 1 ] : c [ i ] = c [ i ] - c [ i + 1 ] c . sort ( reverse = True ) i = - 1 print ( sum ( c ) ) NEWLINE NL ENDMARKER
def series ( n ) : NEWLINE INDENT print ( ( 8 * n ** 2 ) + 1 ) NEWLINE DEDENT series ( 5 ) NEWLINE NL ENDMARKER
a , b , c , d = map ( int , input ( ) . split ( ) ) print ( ( a * d ) / ( b * c + a * d - a * c ) ) NEWLINE NL ENDMARKER
def XorSum ( arr , n ) : NEWLINE INDENT result = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT if ( arr [ i ] % 2 != 0 ) : NEWLINE INDENTINDENTINDENT result += arr [ i ] NEWLINE DEDENT DEDENT return result NEWLINE DEDENT arr = [ 1 , 2 , 6 , 3 , 4 , 5 ] NEWLINE n = len ( arr ) NEWLINE print ( XorSum ( arr , n ) ) NEWLINE NL ENDMARKER
n , m = input ( ) . split ( ) n = int ( n ) m = int ( m ) q = n // mr = n % mlst = [ ] for i in range ( m ) : if ( i < m - r ) : lst . append ( q ) else : lst . append ( q + 1 ) print ( * lst ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) genomes = list ( input ( ) ) if n % 4 != 0 or any ( [ genomes . count ( x ) > n // 4 for x in 'ACGT' ] ) : print ( '===' ) else : cnt = { } for x in 'ACGT' : cnt [ x ] = n // 4 - genomes . count ( x ) for i in range ( n ) : if genomes [ i ] == '?' : for x in 'ACGT' : if cnt [ x ] > 0 : genomes [ i ] = x cnt [ x ] -= 1 break print ( '' . join ( genomes ) ) NEWLINE NL ENDMARKER
import sys , mathfrom collections import deque , defaultdictimport operator as opfrom functools import reducefrom itertools import permutations  NEWLINE NL ENDMARKER
N = int ( input ( ) ) one = input ( ) . count ( '1' ) two = N - oneif not one or not two : ans = [ 1 ] * one + [ 2 ] * twoelse : ans = [ 2 , 1 ] + [ 2 ] * ( two - 1 ) + [ 1 ] * ( one - 1 ) print ( * ans ) NEWLINE NL ENDMARKER
from sys import stdinn , m , a , b = map ( int , stdin . readline ( ) . split ( ) ) x = n % mprint ( min ( a * ( m - x ) , b * x ) ) NEWLINE NL ENDMARKER
def count ( n ) : NEWLINE INDENT return 15 * pow ( 16 , n - 1 ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 2 ; NEWLINE print ( count ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) )  if n >= - 128 and n <= 127 : NEWLINE INDENT print ( 'byte' ) elif n >= - 32768 and n <= 32767 : NEWLINE print ( 'short' ) elif n >= - 2147483648 and n <= 2147483647 : NEWLINE print ( 'int' ) elif n >= - 9223372036854775808 and n <= 9223372036854775807 : NEWLINE print ( 'long' ) else : NEWLINE print ( 'BigInteger' ) NEWLINE NL DEDENT ENDMARKER
def findTrailingZeros ( n ) : NEWLINE INDENT count = 0 NEWLINE i = 5 NEWLINE while ( n / i >= 1 ) : NEWLINE INDENTINDENT count += int ( n / i ) NEWLINE i *= 5 NEWLINE DEDENT return int ( count ) NEWLINE DEDENT n = 100 NEWLINE print ( "Count of trailing 0s " + "in 100! is" , findTrailingZeros ( n ) ) NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readlinefor NEWLINE _ in range ( int ( input ( ) ) ) : a , b , c = [ int ( x ) for x in input ( ) . split ( ) ] NEWLINE print ( c + ( b * c + c - 1 + a + - 2 ) // ( a - 1 ) ) NEWLINE NL ENDMARKER
def LucasSum ( N ) : NEWLINE INDENT Sum = 0 NEWLINE a = 2 NEWLINE b = 1 NEWLINE c = 0 NEWLINE Sum += a NEWLINE while ( b <= N ) : NEWLINE INDENTINDENT Sum += b NEWLINE c = a + b NEWLINE a = b NEWLINE b = c NEWLINE DEDENT return Sum NEWLINE DEDENT N = 20 NEWLINE print ( LucasSum ( N ) ) NEWLINE NL ENDMARKER
def binaryToDecimal ( n ) : NEWLINE INDENT num = n ; NEWLINE dec_value = 0 ; NEWLINE base = 1 ; NEWLINE temp = num ; NEWLINE while ( temp ) : NEWLINE INDENTINDENT last_digit = temp % 10 ; NEWLINE temp = int ( temp / 10 ) ; NEWLINE dec_value += last_digit * base ; NEWLINE base = base * 2 ; NEWLINE DEDENT return dec_value ; NEWLINE DEDENT num = 10101001 ; NEWLINE print ( binaryToDecimal ( num ) ) ; NEWLINE NL ENDMARKER
import math   if __name__ == '__main__' : n , m , z = map ( int , input ( ) . split ( ) ) print ( z // ( n * m // math . gcd ( n , m ) ) ) NEWLINE NL ENDMARKER
def centered_heptagonal_num ( n ) : NEWLINE INDENT return ( 7 * n * n - 7 * n + 2 ) // 2 NEWLINE DEDENT n = 5 NEWLINE print ( "%sth Centered heptagonal number : " % n , centered_heptagonal_num ( n ) ) NEWLINE NL ENDMARKER
def unitDigitXRaisedY ( x , y ) : NEWLINE INDENT res = 1 NEWLINE for i in range ( y ) : NEWLINE INDENTINDENT res = ( res * x ) % 10 NEWLINE DEDENT return res NEWLINE DEDENT print ( unitDigitXRaisedY ( 4 , 2 ) ) NEWLINE NL ENDMARKER
import ren = int ( input ( ) ) x = input ( ) a = len ( re . findall ( 'L' , x ) ) b = len ( re . findall ( 'R' , x ) ) d = - 1 * ac = b - aprint ( b - d + 1 ) NEWLINE NL ENDMARKER
def xor_pair_sum ( ar , n ) : NEWLINE INDENT total = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT for j in range ( n ) : NEWLINE INDENTINDENTINDENT total = total ^ ( ar [ i ] + ar [ j ] ) NEWLINE DEDENT DEDENT return total NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT data = [ 1 , 2 , 3 ] NEWLINE print ( xor_pair_sum ( data , len ( data ) ) ) NEWLINE NL DEDENT ENDMARKER
N = int ( input ( ) ) for _ in range ( N ) : _ = int ( input ( ) ) a = sorted ( [ int ( ii ) for ii in input ( ) . split ( ' ' ) ] , reverse = True ) print ( * a , sep = ' ' ) NEWLINE NL ENDMARKER
class Solution : NEWLINE INDENT def xorQueries ( self , arr : List [ int ] , queries : List [ List [ int ] ] ) -> List [ int ] : NEWLINE INDENTINDENT pref = [ 0 ] NEWLINE for e in arr : NEWLINE INDENTINDENTINDENT pref . append ( e ^ pref [ - 1 ] ) NEWLINE DEDENT ans = [ ] NEWLINE for [ l , r ] in queries : NEWLINE INDENTINDENTINDENT ans . append ( pref [ r + 1 ] ^ pref [ l ] ) NEWLINE DEDENT return ans NEWLINE NL DEDENT DEDENT ENDMARKER
import math NEWLINE def bitAtGivenPosSetOrUnset ( n , k ) : NEWLINE INDENT new_num = n >> ( k - 1 ) NEWLINE return ( new_num & 1 ) NEWLINE DEDENT n = 10 NEWLINE k = 2 NEWLINE if ( bitAtGivenPosSetOrUnset ( n , k ) ) : NEWLINE INDENT print ( "Set" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "Unset" ) NEWLINE NL DEDENT ENDMARKER
import sys  def main ( ) : _ , * l = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) s , c , m = set ( ) , 0 , 0 for i in l : if i in s : s . remove ( i ) if m < c : m = c c -= 1 else : s . add ( i ) ; c += 1 return m print ( main ( ) ) NEWLINE NL ENDMARKER
import sys  lines = list ( sys . stdin . read ( ) . strip ( ) . split ( ) )  print_lines = 0 columns = [ 0 for _ in range ( 8 ) ] for line in lines : if line == 'BBBBBBBB' : print_lines += 1 for j , s in enumerate ( line ) : columns [ j ] += bool ( s == 'B' )  print_col = sum ( j == 8 for j in columns )  if print_col == 8 : print_col = 0  NEWLINE NL ENDMARKER
n = int ( input ( ) ) k = 0 c = 0 for i in range ( 1 , 10001 ) : k += i c += k if c == n : print ( i ) break if c >= n : print ( i - 1 ) break  NEWLINE NL ENDMARKER
def getFinalElement ( n ) : NEWLINE INDENT finalNum = 2 NEWLINE while finalNum * 2 <= n : NEWLINE INDENTINDENT finalNum *= 2 NEWLINE DEDENT return finalNum NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 12 NEWLINE print ( getFinalElement ( N ) ) NEWLINE NL DEDENT ENDMARKER
def findNthNumber ( A , B , N ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 2 , N ) : NEWLINE INDENTINDENT sum = A + B NEWLINE A = B NEWLINE B = sum NEWLINE DEDENT return sum NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT A = 5 NEWLINE B = 7 NEWLINE N = 10 NEWLINE print ( findNthNumber ( A , B , N ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) s = str ( input ( ) ) y = s [ : : - 1 ] t = 0j = 1 for i in range ( n ) : if y [ n - j ] == '1' : t += 1 j += 1 else : print ( t + 1 ) exit ( ) print ( t ) NEWLINE NL ENDMARKER
def sumNatural ( n ) : NEWLINE INDENT sum = ( n * ( n + 1 ) ) // 2 NEWLINE return sum NEWLINE DEDENT def suminRange ( l , r ) : NEWLINE INDENT return sumNatural ( r ) - sumNatural ( l - 1 ) NEWLINE DEDENT l = 2 ; r = 5 NEWLINE print ( "Sum of Natural numbers from L to R is " , suminRange ( l , r ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) count = 0 g = int ( input ( ) ) count += g + 1 for i in range ( n - 1 ) : a = int ( input ( ) ) if ( a > g ) : count += a - g + 1 + 1 g = a else : count += g - a + 1 + 1 g = aprint ( count ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ris = 0 num2 = arr . count ( 2 ) num1 = arr . count ( 1 ) if num1 >= num2 : ris += num2 num1 -= num2 ris += num1 // 3 elif num1 <= num2 and 1 in arr : ris += num1print ( ris ) NEWLINE NL ENDMARKER
def getMaxNum ( a , b , c ) : NEWLINE INDENT if ( b % c == 0 ) : NEWLINE INDENTINDENT return b NEWLINE DEDENT x = ( ( b // c ) * c ) NEWLINE if ( x >= a and x <= b ) : NEWLINE INDENTINDENT return x NEWLINE DEDENT else : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT DEDENT a , b , c = 2 , 10 , 3 NEWLINE print ( getMaxNum ( a , b , c ) ) NEWLINE NL ENDMARKER
def sumOfSeries ( n ) : NEWLINE INDENT x = 0 NEWLINE if n % 2 == 0 : NEWLINE INDENTINDENT x = ( n / 2 ) * ( n + 1 ) NEWLINE DEDENT else : NEWLINE INDENTINDENT x = ( ( n + 1 ) / 2 ) * n NEWLINE DEDENT return ( int ) ( x * x ) NEWLINE DEDENT n = 5 NEWLINE print ( sumOfSeries ( n ) ) NEWLINE NL ENDMARKER
def sumOfAP ( a , d , n ) : NEWLINE INDENT sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) NEWLINE return sum NEWLINE DEDENT n = 20 NEWLINE a = 2.5 NEWLINE d = 1.5 NEWLINE print ( sumOfAP ( a , d , n ) ) NEWLINE NL ENDMARKER
def pell ( n ) : NEWLINE INDENT if ( n <= 2 ) : NEWLINE INDENTINDENT return n NEWLINE DEDENT return ( 2 * pell ( n - 1 ) + pell ( n - 2 ) ) NEWLINE DEDENT n = 4 ; NEWLINE print ( pell ( n ) ) NEWLINE NL ENDMARKER
def printMultiples ( n ) : NEWLINE INDENT unit_digit = n % 10 NEWLINE if ( unit_digit == 0 ) : NEWLINE INDENTINDENT unit_digit = 10 NEWLINE DEDENT for i in range ( unit_digit , n + 1 , unit_digit ) : NEWLINE INDENTINDENT print ( i , end = " " ) NEWLINE DEDENT DEDENT n = 39 NEWLINE printMultiples ( n ) NEWLINE NL ENDMARKER
def calculateSum ( n , k ) : NEWLINE INDENT res = 1 NEWLINE MOD = 1000000007 NEWLINE while k > 0 : NEWLINE INDENTINDENT if ( k & 1 ) == 1 : NEWLINE INDENTINDENTINDENT res = ( res * n ) % MOD NEWLINE DEDENT k = k // 2 NEWLINE n = ( n * n ) % MOD NEWLINE DEDENT return res NEWLINE DEDENT n = 4 NEWLINE k = 3 NEWLINE print ( calculateSum ( n , k ) ) NEWLINE NL ENDMARKER
from sys import stdin , stdoutinput = stdin . readline def main ( ) : n = int ( input ( ) ) preva = prevb = - 1 ans = 0 for i in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) if preva != prevb : ans += max ( 0 , min ( a , b ) - max ( preva , prevb ) + 1 ) else : ans += max ( 0 , min ( a , b ) - max ( preva , prevb ) ) preva , prevb = a , b print ( ans ) main ( )  NEWLINE NL ENDMARKER
def product ( x , y ) : NEWLINE INDENT if x < y : NEWLINE INDENTINDENT return product ( y , x ) NEWLINE DEDENT elif y != 0 : NEWLINE INDENTINDENT return ( x + product ( x , y - 1 ) ) NEWLINE DEDENT else : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT DEDENT x = 5 NEWLINE y = 2 NEWLINE print ( product ( x , y ) ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) l1 = list ( map ( int , input ( ) . split ( ) ) ) l2 = list ( map ( int , input ( ) . split ( ) ) ) d2 = { } for i in l2 : if ( i in d2 ) : d2 [ i ] += 1 else : d2 [ i ] = 1 for i in l1 : if ( i in d2 ) : print ( i , end = ' ' ) d2 [ i ] -= 1 if ( d2 [ i ] <= 0 ) : del ( d2 [ i ] ) NEWLINE NL ENDMARKER
def printTwoSetBitNums ( n ) : NEWLINE INDENT x = 1 NEWLINE while ( n > 0 ) : NEWLINE INDENTINDENT y = 0 NEWLINE while ( y < x ) : NEWLINE INDENTINDENTINDENT print ( ( 1 << x ) + ( 1 << y ) , end = " " ) NEWLINE n -= 1 NEWLINE if ( n == 0 ) : NEWLINE INDENTINDENTINDENTINDENT return NEWLINE DEDENT y += 1 NEWLINE DEDENT x += 1 NEWLINE DEDENT DEDENT printTwoSetBitNums ( 4 ) NEWLINE NL ENDMARKER
def setKthBit ( n , k ) : NEWLINE INDENT return ( ( 1 << k ) | n ) NEWLINE DEDENT n = 10 NEWLINE k = 2 NEWLINE print ( "Kth bit set number = " , setKthBit ( n , k ) ) NEWLINE NL ENDMARKER
def summation ( n ) : NEWLINE INDENT sum = 0 NEWLINE j = 1 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT sum = sum + j NEWLINE j = ( j * 10 ) + 1 NEWLINE DEDENT return sum NEWLINE DEDENT n = 5 NEWLINE print ( summation ( n ) ) NEWLINE NL ENDMARKER
for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE a = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE i = 0 NEWLINE j = n - 1 NEWLINE result = [ 0 ] * n NEWLINE while i < j : result [ i ] = - a [ j ] NEWLINE result [ j ] = a [ i ] NEWLINE i += 1 NEWLINE j -= 1 NEWLINE print ( " " . join ( str ( x ) for x in result ) ) NEWLINE NL ENDMARKER
s = list ( input ( ) )   if s == s [ : : - 1 ] : if len ( set ( s ) ) == 1 : print ( 0 ) else : print ( len ( s ) - 1 )  else : print ( len ( s ) )  NEWLINE NL ENDMARKER
def areAllBitsSet ( n ) : NEWLINE INDENT if ( n == 0 ) : NEWLINE INDENTINDENT return "No" NEWLINE DEDENT while ( n > 0 ) : NEWLINE INDENTINDENT if ( ( n & 1 ) == 0 ) : NEWLINE INDENTINDENTINDENT return "No" NEWLINE DEDENT n = n >> 1 NEWLINE DEDENT return "Yes" NEWLINE DEDENT n = 7 NEWLINE print ( areAllBitsSet ( n ) ) NEWLINE NL ENDMARKER
def countDigits ( a , b ) : NEWLINE INDENT count = 0 NEWLINE p = abs ( a * b ) NEWLINE if ( p == 0 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT while ( p > 0 ) : NEWLINE INDENTINDENT count = count + 1 NEWLINE p = p // 10 NEWLINE DEDENT return count NEWLINE DEDENT a = 33 NEWLINE b = - 24 NEWLINE print ( "Number of digits = " , countDigits ( a , b ) ) NEWLINE NL ENDMARKER
'''import syssys.stdin=open("input.txt","r")sys.stdout=open("output.txt","w")'''  n = int ( input ( ) ) p = [ int ( i ) for i in input ( ) . split ( ) ] flag = Truefor i in range ( n ) : s = input ( ) if ( s . count ( 'a' ) + s . count ( 'e' ) + s . count ( 'i' ) + s . count ( 'o' ) + s . count ( 'u' ) + s . count ( 'y' ) ) != p [ i ] and flag : flag = Falseif flag : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
n , m = ( map ( int , input ( ) . split ( ) ) ) bt = list ( map ( int , input ( ) . split ( ) ) ) ini = 1 ans = 0 for a in bt : if ( a >= ini ) : ans += ( a - ini ) ini = a else : ans += ( n - ini ) + 1 ini = 1 ans += ( a - ini ) ini = aprint ( ans ) NEWLINE NL ENDMARKER
def minNumber ( a , n , x ) : NEWLINE INDENT a . sort ( reverse = False ) NEWLINE k = 0 NEWLINE while ( a [ int ( ( n - 1 ) / 2 ) ] != x ) : NEWLINE INDENTINDENT a [ n - 1 ] = x NEWLINE n += 1 NEWLINE a . sort ( reverse = False ) NEWLINE k += 1 NEWLINE DEDENT return k NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT x = 10 NEWLINE a = [ 10 , 20 , 30 ] NEWLINE n = 3 NEWLINE print ( minNumber ( a , n , x ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) aux = input ( ) . split ( ) first = int ( aux [ 0 ] ) flag = 1 for i in range ( 1 , n ) : if int ( aux [ i ] ) < first : flag = 1 else : flag += 1 first = int ( aux [ i ] ) print ( n - flag ) NEWLINE NL ENDMARKER
cases = int ( input ( ) ) NEWLINE while cases : cases -= 1 NEWLINE a , b = map ( int , input ( ) . split ( ) ) NEWLINE s = input ( )  while b : b -= 1 NEWLINE l , r = ( map ( int , input ( ) . split ( ) ) ) NEWLINE l , r = l - 1 , r - 1  if s [ : l ] . count ( s [ l ] ) == s [ r + 1 : ] . count ( s [ r ] ) == 0 : NEWLINE INDENT print ( "NO" ) else : NEWLINE print ( "YES" ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) print ( n // 3 * 2 if n % 3 == 0 else n // 3 * 2 + 1 ) NEWLINE NL ENDMARKER
x , y = map ( int , input ( ) . split ( ) ) if y == 0 : print ( 'No' ) exit ( 0 ) if y == 1 : if x == 0 : print ( 'Yes' ) else : print ( 'No' ) exit ( 0 ) print ( 'Yes' if x - y + 1 >= 0 and ( x - y + 1 ) % 2 == 0 else 'No' ) NEWLINE NL ENDMARKER
def factorial ( start , end ) : NEWLINE INDENT res = 1 NEWLINE for i in range ( start , end + 1 ) : NEWLINE INDENTINDENT res *= i NEWLINE DEDENT return res NEWLINE DEDENT def sumofsquare ( n ) : NEWLINE INDENT return int ( factorial ( n + 1 , 2 * n ) / factorial ( 1 , n ) ) NEWLINE DEDENT n = 4 NEWLINE print ( sumofsquare ( n ) ) NEWLINE NL ENDMARKER
from collections import dequefrom collections import defaultdict  n , m = map ( int , input ( ) . split ( ) ) INF = 10 ** 9 visited = defaultdict ( int )  g = [ [ ] for _ in range ( n + m ) ] NEWLINE NL ENDMARKER
t = input ( ) print ( 25 ) NEWLINE NL ENDMARKER
def minXOR ( arr , n ) : NEWLINE INDENT arr . sort ( ) ; NEWLINE min_xor = 999999 NEWLINE val = 0 NEWLINE for i in range ( 0 , n - 1 ) : NEWLINE INDENTINDENT for j in range ( i + 1 , n - 1 ) : NEWLINE INDENTINDENTINDENT val = arr [ i ] ^ arr [ j ] NEWLINE min_xor = min ( min_xor , val ) NEWLINE DEDENT DEDENT return min_xor NEWLINE DEDENT arr = [ 9 , 5 , 3 ] NEWLINE n = len ( arr ) NEWLINE print ( minXOR ( arr , n ) ) NEWLINE NL ENDMARKER
a = int ( input ( ) ) b = list ( map ( int , input ( ) . split ( ) ) ) z = max ( b ) if z == 1 : b [ b . index ( z ) ] = 2 else : b [ b . index ( z ) ] = 1 print ( * sorted ( b ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) NEWLINE print ( n + ( n // 2 ) ) NEWLINE NL ENDMARKER
def loydTriangle ( n ) : NEWLINE INDENT val = 1 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT for j in range ( 1 , i + 1 ) : NEWLINE INDENTINDENTINDENT print ( val , end = " " ) NEWLINE val += 1 NEWLINE DEDENT print ( "" ) NEWLINE DEDENT DEDENT loydTriangle ( 6 ) NEWLINE NL ENDMARKER
def doublefactorial ( n ) : NEWLINE INDENT if ( n == 0 or n == 1 ) : NEWLINE INDENTINDENT return 1 ; NEWLINE DEDENT return n * doublefactorial ( n - 2 ) ; NEWLINE DEDENT print ( "Double factorial is" , doublefactorial ( 5 ) ) ; NEWLINE NL ENDMARKER
s = input ( ) c = 0 d = 0 if ( len ( s ) > 1 ) : for i in range ( len ( s ) - 1 ) : if ( s [ i ] != s [ i + 1 ] ) :  c = c + 1 d = 0  else : d = d + 1 if ( d == 5 ) : d = 0 c = c + 1 if ( s [ - 1 ] == s [ - 2 ] and d != 5 ) : c = c + 1 elif ( s [ - 1 ] != s [ - 2 ] ) : c = c + 1 print ( c ) else : print ( 1 ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) x = 180 / n  y = int ( m / x )  z = y * x  w = ( y + 1 ) * x  if m - z <= w - m : v = yelse : v = y + 1 if v == 0 : v = 1 if 2 + v > n : print ( 2 , 1 , n ) else : print ( 2 , 1 , 2 + v ) NEWLINE NL ENDMARKER
from collections import Counterdef f ( arr , k ) : x = Counter ( arr ) ans = 0 for i , j in sorted ( x . items ( ) , key = lambda s : s [ 1 ] , reverse = True ) : if j <= k : k -= j ans += j ** 2 else : ans += k ** 2 k = 0 break return ans   a , b = map ( int , input ( ) . strip ( ) . split ( ) ) lst = input ( ) print ( f ( lst , b ) ) NEWLINE NL ENDMARKER
def evenPowerSum ( n ) : NEWLINE INDENT return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; NEWLINE DEDENT n = 4 ; NEWLINE print ( int ( evenPowerSum ( n ) ) ) ; NEWLINE NL ENDMARKER
def sumOfSeries ( n ) : NEWLINE INDENT res = 0.0 NEWLINE sum = 0 NEWLINE prod = 1 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT sum = sum + i NEWLINE prod = prod * i NEWLINE res = res + ( sum / prod ) NEWLINE DEDENT return res NEWLINE DEDENT n = 4 NEWLINE print ( round ( sumOfSeries ( n ) , 5 ) ) NEWLINE NL ENDMARKER
def minDiff ( n , x , A ) : NEWLINE INDENT mn = A [ 0 ] NEWLINE mx = A [ 0 ] NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT mn = min ( mn , A [ i ] ) NEWLINE mx = max ( mx , A [ i ] ) NEWLINE DEDENT return max ( 0 , mx - mn - 2 * x ) NEWLINE DEDENT n = 3 NEWLINE x = 3 NEWLINE A = [ 1 , 3 , 6 ] NEWLINE print ( minDiff ( n , x , A ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) nums = [ int ( j ) for j in input ( ) . split ( ) ] p = 0 val = 0 while p < n : length , sp = 1 , p + 1 while sp < n : if nums [ sp ] - nums [ sp - 1 ] < 2 : sp += 1 length += 1 else : break if nums [ p ] != 1 : length -= 1 if nums [ sp - 1 ] != 1000 : length -= 1 val = max ( val , length ) p = spprint ( val ) NEWLINE NL ENDMARKER
print ( ( int ( input ( ) ) - 1 ) % 9 + 1 ) NEWLINE NL ENDMARKER
import eulerlib NEWLINE import itertools NEWLINE def compute ( ) : NEWLINE INDENT totients = eulerlib . list_totients ( 10 ** 6 ) NEWLINE ans = sum ( itertools . islice ( totients , 2 , None ) ) NEWLINE return str ( ans ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( compute ( ) ) NEWLINE NL DEDENT ENDMARKER
def oddSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE curr = 1 NEWLINE i = 0 NEWLINE while i < n : NEWLINE INDENTINDENT sum = sum + curr NEWLINE curr = curr + 2 NEWLINE i = i + 1 NEWLINE DEDENT return sum NEWLINE DEDENT n = 20 NEWLINE print ( " Sum of first" , n , "Odd Numbers is: " , oddSum ( n ) ) NEWLINE NL ENDMARKER
n , K = map ( int , input ( ) . split ( ) ) b = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) l = cur = 0 for i in range ( 1 , n ) : if b [ i ] == b [ i - 1 ] : continue if b [ i ] > b [ i - 1 ] + K : l = i else : cur += ( i - l ) ; l = iprint ( n - cur ) NEWLINE NL ENDMARKER
def xorEqualsOrCount ( N ) : NEWLINE INDENT count = 0 NEWLINE while ( N > 0 ) : NEWLINE INDENTINDENT bit = N % 2 NEWLINE if bit == 0 : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT N //= 2 NEWLINE DEDENT return int ( pow ( 2 , count ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 7 NEWLINE print ( xorEqualsOrCount ( N ) ) NEWLINE NL DEDENT ENDMARKER
def findKHCF ( x , y , k ) : NEWLINE INDENT small = min ( x , y ) NEWLINE count = 1 NEWLINE for i in range ( 2 , small + 1 ) : NEWLINE INDENTINDENT if ( x % i == 0 and y % i == 0 ) : NEWLINE INDENTINDENTINDENT count = count + 1 NEWLINE DEDENT if ( count == k ) : NEWLINE INDENTINDENTINDENT return i NEWLINE DEDENT DEDENT return - 1 NEWLINE DEDENT x = 4 NEWLINE y = 24 NEWLINE k = 3 NEWLINE print ( findKHCF ( x , y , k ) ) NEWLINE NL ENDMARKER
from math import * NEWLINE def nthTerm ( n ) : NEWLINE INDENT return pow ( n , 2 ) + 2 * n + 2 NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 4 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
def Centered_Trigunal_num ( n ) : NEWLINE INDENT return ( 3 * n * n + 3 * n + 2 ) // 2 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 3 NEWLINE print ( Centered_Trigunal_num ( n ) ) NEWLINE n = 12 NEWLINE print ( Centered_Trigunal_num ( n ) ) NEWLINE NL DEDENT ENDMARKER
s = input ( ) dot = 0 if "." in s : dot = s . index ( "." ) else : dot = len ( s ) a = s [ 0 : dot ] NEWLINE NL ENDMARKER
s = [ i for i in input ( ) ] i = 0 a = 0 x = 0 while i < len ( s ) : if s [ i ] == 'a' : a = a + 1 else : x = x + 1 i = i + 1 if a > x : print ( a + x ) else : print ( a + a - 1 ) NEWLINE NL ENDMARKER
def countOddPair ( A , N ) : NEWLINE INDENT count = 0 NEWLINE for i in range ( 0 , N ) : NEWLINE INDENTINDENT if ( A [ i ] % 2 != 1 ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT evenPairCount = count * ( count - 1 ) / 2 NEWLINE totPairs = N * ( N - 1 ) / 2 NEWLINE return ( int ) ( totPairs - evenPairCount ) NEWLINE DEDENT A = [ 5 , 6 , 2 , 8 ] NEWLINE N = len ( A ) NEWLINE print ( countOddPair ( A , N ) ) NEWLINE NL ENDMARKER
def count ( n ) : NEWLINE INDENT cnt = 0 NEWLINE p = 1 NEWLINE while ( p <= n ) : NEWLINE INDENTINDENT cnt = cnt + 1 NEWLINE p *= 2 NEWLINE DEDENT return cnt NEWLINE DEDENT n = 7 NEWLINE print ( count ( n ) ) ; NEWLINE NL ENDMARKER
s = input ( )  print ( s + s [ : : - 1 ] )    NEWLINE NL ENDMARKER
def summation ( n ) : NEWLINE INDENT return sum ( [ i ** 2 for i in range ( 1 , n + 1 ) ] ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 2 NEWLINE print ( summation ( n ) ) NEWLINE NL DEDENT ENDMARKER
class Solution ( object ) : NEWLINE INDENT def subarraySum ( self , nums , k ) : NEWLINE INDENTINDENT sum_map = { } NEWLINE sum_map [ 0 ] = 1 NEWLINE count = curr_sum = 0 NEWLINE for num in nums : NEWLINE INDENTINDENTINDENT curr_sum += num NEWLINE count += sum_map . get ( curr_sum - k , 0 ) NEWLINE sum_map [ curr_sum ] = sum_map . get ( curr_sum , 0 ) + 1 NEWLINE DEDENT return count NEWLINE NL DEDENT DEDENT ENDMARKER
kg = int ( input ( ) ) if kg <= 2 : print ( "NO" ) else : for n in range ( 2 , kg , 2 ) : if ( kg - n ) % 2 == 0 : print ( "YES" ) break elif n == kg - 1 or n == kg - 2 : print ( "NO" ) NEWLINE NL ENDMARKER
def countPaths ( m , n ) : NEWLINE INDENT if m == 1 or n == 1 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT return ( countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 5 NEWLINE m = 5 NEWLINE print ( countPaths ( n , m ) ) NEWLINE NL DEDENT ENDMARKER
t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) if ( n % 2 == 1 ) : print ( 7 , end = '' ) n -= 3 while ( n > 0 ) : print ( 1 , end = '' ) n -= 2 print ( ) NEWLINE NL ENDMARKER
import sys , os , ioimport math , bisect , operatorinf , mod = float ( 'inf' ) , 10 ** 9 + 7 NEWLINE NL ENDMARKER
def area ( r ) : NEWLINE INDENT return ( 0.5 ) * ( 3.14 ) * ( r * r ) NEWLINE DEDENT def perimeter ( r ) : NEWLINE INDENT return ( 3.14 ) * ( r ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT r = 10 NEWLINE print ( "The Area of Semicircle: " , area ( r ) ) NEWLINE print ( "The Perimeter of Semicircle: " , perimeter ( r ) ) NEWLINE NL DEDENT ENDMARKER
size = int ( input ( ) ) num1 = list ( map ( int , input ( ) . split ( ' ' ) ) ) nums2 = list ( map ( int , input ( ) . split ( ' ' ) ) ) sum1 = sum ( num1 ) sum2 = sum ( nums2 ) if sum2 <= sum1 : print ( 'Yes' ) else : print ( 'No' ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = [ 0 ] + [ int ( i ) for i in input ( ) . split ( ) ] x = [ ] for ind , a_i in enumerate ( a [ 1 : ] ) : x . append ( a_i - a [ ind ] ) NEWLINE NL ENDMARKER
from math import sqrtn , h = map ( int , input ( ) . split ( ) ) result = [ ] for i in range ( 1 , n ) : result . append ( h * sqrt ( i / n ) ) print ( * result ) NEWLINE NL ENDMARKER
from math import gcd , sqrtn = int ( input ( ) ) ; ans = 0 for i in range ( 5 , n + 1 ) : for j in range ( 1 , i ) : k = i ** 2 - j ** 2 if int ( sqrt ( k ) ) == sqrt ( k ) : ans += 1 print ( ans // 2 ) NEWLINE NL ENDMARKER
n , l = map ( int , input ( ) . split ( ) ) lights = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True )  max_dif = 0  for i in range ( len ( lights ) - 1 ) : max_dif = max ( max_dif , lights [ i ] - lights [ i + 1 ] )  print ( format ( max ( max_dif / 2 , lights [ - 1 ] , l - lights [ 0 ] ) , '.10f' ) ) NEWLINE NL ENDMARKER
def isDivisible ( n ) : NEWLINE INDENT while n // 100 : NEWLINE INDENTINDENT d = n % 10 NEWLINE n //= 10 NEWLINE n = abs ( n - ( d * 14 ) ) NEWLINE DEDENT return ( n % 47 == 0 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 59173 NEWLINE if ( isDivisible ( n ) ) : NEWLINE INDENTINDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) NEWLINE NL DEDENT DEDENT ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) ans = n + 1 for i in range ( m ) : a , b = map ( int , input ( ) . split ( ) ) ans = min ( ans , b - a + 1 ) print ( ans ) arr = [ 0 ] * nput = 0 for i in range ( n ) : arr [ i ] = put put += 1 if ( put == ans ) : put = 0 print ( * arr ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) NEWLINE for i in range ( t ) : z = int ( input ( ) ) NEWLINE c = 0 NEWLINE for j in range ( z // 2020 + 1 ) : if NEWLINE ( z - 2020 * j ) % 2021 == 0 : c = 1 NEWLINE if c == 1 : NEWLINE INDENT print ( 'YES' ) else : NEWLINE print ( 'NO' ) NEWLINE NL DEDENT ENDMARKER
for _ in range ( int ( input ( ) ) ) : n , a , b , c , d = map ( int , input ( ) . split ( ) ) u1 = a + b d1 = abs ( a - b ) u2 = c + d d2 = abs ( c - d ) z = 0 if ( n * u1 < d2 ) : z = 1 elif ( n * d1 > u2 ) : z = 1 if ( z == 1 ) : print ( "NO" ) else : print ( "YES" ) NEWLINE NL ENDMARKER
import math NEWLINE def solve ( M , N , s ) : NEWLINE INDENT ans = ( ( math . ceil ( M / s ) ) * ( math . ceil ( N / s ) ) ) ; NEWLINE return ans NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 12 NEWLINE M = 13 NEWLINE s = 4 NEWLINE print ( solve ( M , N , s ) ) NEWLINE NL DEDENT ENDMARKER
def Area ( b1 , b2 , h ) : NEWLINE INDENT return ( ( b1 + b2 ) / 2 ) * h NEWLINE DEDENT base1 = 8 ; base2 = 10 ; height = 6 NEWLINE area = Area ( base1 , base2 , height ) NEWLINE print ( "Area is:" , area ) NEWLINE NL ENDMARKER
def sum_even_and_even_index ( arr , n ) : NEWLINE INDENT i = 0 NEWLINE sum = 0 NEWLINE for i in range ( 0 , n , 2 ) : NEWLINE INDENTINDENT if ( arr [ i ] % 2 == 0 ) : NEWLINE INDENTINDENTINDENT sum += arr [ i ] NEWLINE DEDENT DEDENT return sum NEWLINE DEDENT arr = [ 5 , 6 , 12 , 1 , 18 , 8 ] NEWLINE n = len ( arr ) NEWLINE print ( "Sum of even numbers at " , "even indices is " , sum_even_and_even_index ( arr , n ) ) NEWLINE NL ENDMARKER
def calculateSum ( n ) : NEWLINE INDENT return ( ( 2 * ( n * ( n + 1 ) / 2 ) ** 2 ) + ( ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ) ) NEWLINE DEDENT n = 4 NEWLINE print ( "Sum =" , calculateSum ( n ) ) NEWLINE NL ENDMARKER
from math import pow NEWLINE def sumOfTermsInNthRow ( n ) : NEWLINE INDENT sum = n * ( 2 * pow ( n , 2 ) + 1 ) NEWLINE return sum NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 4 NEWLINE print ( "Sum of all the terms in nth row =" , int ( sumOfTermsInNthRow ( n ) ) ) NEWLINE NL DEDENT ENDMARKER
for i in range ( int ( input ( ) ) ) : a = int ( input ( ) ) print ( a - 1 , 1 ) NEWLINE NL ENDMARKER
import sysimport NEWLINE mathfrom NEWLINE collections NEWLINE import deque NEWLINE NL ENDMARKER
for i in range ( int ( input ( ) ) ) : NEWLINE INDENT m , n = map ( int , input ( ) . split ( ) ) NEWLINE if n % m == 0 : NEWLINE INDENTINDENT print ( m , n ) NEWLINE DEDENT elif m * 2 <= n : NEWLINE INDENTINDENT print ( m , m * 2 ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( - 1 , - 1 ) NEWLINE NL DEDENT DEDENT ENDMARKER
def calcDeterminant ( arr , n ) : NEWLINE INDENT determinant = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT determinant += pow ( arr [ i ] , 3 ) NEWLINE DEDENT determinant -= 3 * arr [ 0 ] * arr [ 1 ] * arr [ 2 ] NEWLINE return determinant NEWLINE DEDENT arr = [ 4 , 5 , 3 ] NEWLINE n = len ( arr ) NEWLINE print ( calcDeterminant ( arr , n ) ) NEWLINE NL ENDMARKER
K = int ( input ( ) ) T = list ( map ( int , input ( ) . split ( ) ) ) T . sort ( ) if T [ - 1 ] <= 25 : print ( '0' ) else : print ( T [ - 1 ] - 25 ) NEWLINE NL ENDMARKER
'''Jana Goodman5A chat server''' import sys  ADD = '+' REMOVE = '-' SEND = ':' if __name__ == '__main__' : chatters , answer = 0 , 0 for command in sys . stdin : if command [ 0 ] == ADD : chatters += 1 elif command [ 0 ] == REMOVE : chatters -= 1 else : name , message = command . split ( SEND ) answer += chatters * len ( message . strip ( ) ) print ( answer ) NEWLINE NL ENDMARKER
def isMultipleof5 ( n ) : NEWLINE INDENT while ( n > 0 ) : NEWLINE INDENTINDENT n = n - 5 NEWLINE DEDENT if ( n == 0 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT return 0 NEWLINE DEDENT i = 19 NEWLINE if ( isMultipleof5 ( i ) == 1 ) : NEWLINE INDENT print ( i , "is multiple of 5" ) NEWLINE DEDENT else : NEWLINE INDENT print ( i , "is not a multiple of 5" ) NEWLINE NL DEDENT ENDMARKER
def findSum ( n ) : NEWLINE INDENT summ = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT summ = ( summ + ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ) NEWLINE DEDENT return summ NEWLINE DEDENT n = 3 NEWLINE print ( int ( findSum ( n ) ) ) NEWLINE NL ENDMARKER
def make_permutation ( arr , n ) : NEWLINE INDENT arr . sort ( ) ; NEWLINE ans = 0 ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT ans += abs ( i + 1 - arr [ i ] ) ; NEWLINE DEDENT return ans ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 5 , 3 , 8 , 1 , 1 ] ; NEWLINE n = len ( arr ) ; NEWLINE print ( make_permutation ( arr , n ) ) ; NEWLINE NL DEDENT ENDMARKER
def last_digit ( X , Y ) : NEWLINE INDENT print ( X % Y ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT X = 55 ; Y = 3 ; NEWLINE last_digit ( X , Y ) ; NEWLINE NL DEDENT ENDMARKER
arr = [ int ( x ) for x in input ( ) . split ( ) ] n , k = arr [ 0 ] , arr [ 1 ] c = n - k - 1 ans = [ i + 1 for i in range ( c ) ] for i in range ( n , n - k - 1 , - 1 ) : ans . append ( i ) print ( * ans ) NEWLINE NL ENDMARKER
n , d = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) s = sum ( l ) + ( n - 1 ) * 10  if ( s > d ) : print ( - 1 ) else : x = ( n - 1 ) * 2 x += ( d - s ) // 5 print ( x ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) ax , ay = map ( int , input ( ) . split ( ) ) bx , by = map ( int , input ( ) . split ( ) ) cx , cy = map ( int , input ( ) . split ( ) ) if ax in range ( min ( bx , cx ) , max ( bx , cx ) ) or ay in range ( min ( by , cy ) , max ( by , cy ) ) : print ( 'NO' ) else : print ( 'YES' ) NEWLINE NL ENDMARKER
import eulerlib NEWLINE def compute ( ) : NEWLINE INDENT return str ( eulerlib . binomial ( 40 , 20 ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( compute ( ) ) NEWLINE NL DEDENT ENDMARKER
def sum ( x , y , n ) : NEWLINE INDENT sum1 = ( ( x ** 2 ) * ( x ** ( 2 * n ) - 1 ) ) // ( x ** 2 - 1 ) NEWLINE sum2 = ( x * y * ( x ** n * y ** n - 1 ) ) // ( x * y - 1 ) NEWLINE return ( sum1 + sum2 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT x = 2 NEWLINE y = 2 NEWLINE n = 2 NEWLINE print ( sum ( x , y , n ) ) NEWLINE NL DEDENT ENDMARKER
_ = input ( ) l = map ( int , input ( ) . split ( ) )  if any ( l ) : print ( "HARD" ) else : print ( "EASY" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) print ( n - 1 ) for i in range ( n - 1 ) : j = a . index ( min ( a [ i : ] ) , i ) print ( i , j ) a [ i ] , a [ j ] = a [ j ] , a [ i ] NEWLINE NL ENDMARKER
print ( bin ( 4 ) . count ( '1' ) ) ; NEWLINE print ( bin ( 15 ) . count ( '1' ) ) ; NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( 'YES' if sum ( [ int ( i ) for i in input ( ) . split ( ) ] ) >= sum ( [ int ( i ) for i in input ( ) . split ( ) ] ) else 'NO' ) NEWLINE NL ENDMARKER
c1 , c2 , c3 , c4 , c5 = map ( int , input ( ) . split ( ) ) if ( c1 + c2 + c3 + c4 + c5 ) % 5 == 0 and ( c1 + c2 + c3 + c4 + c5 ) != 0 : print ( ( c1 + c2 + c3 + c4 + c5 ) // 5 ) else : print ( - 1 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = ( ( n + 1 ) // 2 ) print ( s % 2 ) NEWLINE NL ENDMARKER
def findAnswer ( n , arr ) : NEWLINE INDENT arr . sort ( reverse = False ) NEWLINE sum = 0 NEWLINE for i in range ( int ( n / 2 ) ) : NEWLINE INDENTINDENT sum += ( ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ) NEWLINE DEDENT return sum NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 53 , 28 , 143 , 5 ] NEWLINE n = len ( arr ) NEWLINE print ( findAnswer ( n , arr ) ) NEWLINE NL DEDENT ENDMARKER
def floatError ( no ) : NEWLINE INDENT sum = 0.0 NEWLINE for i in range ( 10 ) : NEWLINE INDENTINDENT sum = sum + no NEWLINE DEDENT return sum NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT print ( floatError ( 0.1 ) ) NEWLINE NL DEDENT ENDMARKER
def sameLength ( A , B ) : NEWLINE INDENT while ( A > 0 and B > 0 ) : NEWLINE INDENTINDENT A = A / 10 ; NEWLINE B = B / 10 ; NEWLINE DEDENT if ( A == 0 and B == 0 ) : NEWLINE INDENTINDENT return True ; NEWLINE DEDENT return False ; NEWLINE DEDENT A = 21 ; B = 1 ; NEWLINE if ( sameLength ( A , B ) ) : NEWLINE INDENT print ( "Yes" ) ; NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) ; NEWLINE NL DEDENT ENDMARKER
def printExpansion ( str ) : NEWLINE INDENT suff = "" NEWLINE for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEWLINE INDENTINDENT suff = suff + str [ i ] NEWLINE print ( suff , end = "" ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT str = "geeks" NEWLINE printExpansion ( str ) NEWLINE NL DEDENT ENDMARKER
m , k = [ int ( i ) for i in input ( ) . split ( ) ]  days = [ int ( i ) for i in input ( ) . split ( ) ]   s1 = 0 for q in range ( 1 , m ) : if days [ q ] + days [ q - 1 ] < k : s1 += k - ( days [ q ] + days [ q - 1 ] ) days [ q ] += k - ( days [ q ] + days [ q - 1 ] )  print ( s1 ) print ( * days ) NEWLINE NL ENDMARKER
def xorOfArray ( arr , n ) : NEWLINE INDENT xor_arr = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT xor_arr = xor_arr ^ arr [ i ] NEWLINE DEDENT return xor_arr NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 3 , 9 , 12 , 13 , 15 ] NEWLINE n = len ( arr ) NEWLINE print ( xorOfArray ( arr , n ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) dp = [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) : if i > 0 : dp [ i ] = ( 2 * dp [ i - 1 ] + 2 - dp [ a [ i - 1 ] - 1 ] ) % 1000000007 print ( ( dp [ n ] + 1000000007 ) % 1000000007 ) NEWLINE NL ENDMARKER
for x in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) mi = min ( a , b ) ma = max ( a , b ) if 2 * mi < ma : print ( ma ** 2 ) else : print ( ( mi * 2 ) ** 2 ) NEWLINE NL ENDMARKER
import math NEWLINE def isPower ( x , y ) : NEWLINE INDENT res1 = math . log ( y ) // math . log ( x ) ; NEWLINE res2 = math . log ( y ) / math . log ( x ) ; NEWLINE return 1 if ( res1 == res2 ) else 0 ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT print ( isPower ( 27 , 729 ) ) ; NEWLINE NL DEDENT ENDMARKER
def isPalindrome ( n ) : NEWLINE INDENT if n % 11 == 0 : NEWLINE INDENTINDENT return True NEWLINE DEDENT return False NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 123321 NEWLINE if isPalindrome ( n ) : NEWLINE INDENTINDENT print ( "Palindrome" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "Not Palindrome" ) NEWLINE NL DEDENT DEDENT ENDMARKER
def countways ( n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT return 0 ; NEWLINE DEDENT elif ( n % 2 == 0 ) : NEWLINE INDENTINDENT return 1 + countways ( n / 2 ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENT return 1 + min ( countways ( n - 1 ) , countways ( n + 1 ) ) ; NEWLINE DEDENT DEDENT n = 15 ; NEWLINE print ( countways ( n ) ) ; NEWLINE NL ENDMARKER
def highestPowerof2 ( n ) : NEWLINE INDENT res = 0 ; NEWLINE for i in range ( n , 0 , - 1 ) : NEWLINE INDENTINDENT if ( ( i & ( i - 1 ) ) == 0 ) : NEWLINE INDENTINDENTINDENT res = i ; NEWLINE break ; NEWLINE DEDENT DEDENT return res ; NEWLINE DEDENT n = 10 ; NEWLINE print ( highestPowerof2 ( n ) ) ; NEWLINE NL ENDMARKER
'''* Author : Ayushman Chahar #* About  : IT Sophomore    #* Insti  : VIT, Vellore    #'''  import osimport sys NEWLINE NL ENDMARKER
 n , m = map ( int , input ( ) . split ( ) )   count = 0 for i in range ( 0 , int ( n ** ( 1 / 2 ) ) + 1 ) : for j in range ( 0 , int ( m ** ( 1 / 2 ) ) + 1 ) : if ( i ** 2 ) + j == n and i + ( j ** 2 ) == m : count += 1  print ( count ) NEWLINE NL ENDMARKER
a , b = input ( ) . split ( )  ans = "z" * 101   f = "" l = ""  for i in a : f += i l = "" for j in b : l += j ans = min ( ans , f + l )  print ( ans )  NEWLINE NL ENDMARKER
import itertoolsimport bisectimport mathfrom collections import * import osimport sysfrom io import BytesIO , IOBase  ii = lambda : int ( input ( ) ) lmii = lambda : list ( map ( int , input ( ) . split ( ) ) ) slmii = lambda : sorted ( map ( int , input ( ) . split ( ) ) ) li = lambda : list ( input ( ) ) mii = lambda : map ( int , input ( ) . split ( ) ) msi = lambda : map ( str , input ( ) . split ( ) )   def main ( ) : NEWLINE NL ENDMARKER
n , k , t = map ( int , input ( ) . split ( ) ) print ( min ( t , k , n + k - t ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) )  v = [ 'a' , [ 'aa' , 'bb' ] , 'aab' , 'aabb' ] if n == 1 : print ( 'a' ) elif n == 2 : print ( 'ab' ) elif n == 3 : print ( 'aab' ) elif n == 4 : print ( 'aabb' ) else : s = 'aabb' while len ( s ) < n : s += s  print ( s [ : n ] ) NEWLINE NL ENDMARKER
def findMaximumPieces ( n ) : NEWLINE INDENT x = n // 2 NEWLINE return ( ( x + 1 ) * ( n - x + 1 ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 3 NEWLINE print ( "Max number of pieces for n = " + str ( n ) + " is " + str ( findMaximumPieces ( 3 ) ) ) NEWLINE NL DEDENT ENDMARKER
s = input ( ) if ( s == 'a1' ) or ( s == 'a8' ) or ( s == 'h1' ) or ( s == 'h8' ) : print ( 3 ) elif ( s [ 1 ] == '1' ) or ( s [ 1 ] == '8' ) or ( s [ 0 ] == 'a' ) or ( s [ 0 ] == 'h' ) : print ( 5 ) else : print ( 8 ) NEWLINE NL ENDMARKER
def findValues ( a , b ) : NEWLINE INDENT if ( ( a - b ) % 2 == 1 ) : NEWLINE INDENTINDENT print ( "-1" ) ; NEWLINE return ; NEWLINE DEDENT print ( ( a - b ) // 2 , ( a + b ) // 2 ) ; NEWLINE DEDENT a = 12 ; b = 8 ; NEWLINE findValues ( a , b ) ; NEWLINE NL ENDMARKER
def frequencyDigits ( n , d ) : NEWLINE INDENT c = 0 ; NEWLINE while ( n > 0 ) : NEWLINE INDENTINDENT if ( n % 10 == d ) : NEWLINE INDENTINDENTINDENT c += 1 ; NEWLINE DEDENT n = int ( n / 10 ) ; NEWLINE DEDENT return c ; NEWLINE DEDENT N = 1122322 ; NEWLINE D = 2 ; NEWLINE print ( frequencyDigits ( N , D ) ) ; NEWLINE NL ENDMARKER
def rectanglearea ( r ) : NEWLINE INDENT if r < 0 : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT a = r * r NEWLINE return a NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT r = 5 NEWLINE print ( rectanglearea ( r ) ) NEWLINE NL DEDENT ENDMARKER
a = int ( input ( ) ) b = input ( ) . split ( ) sec = 0 mx = 0 mn = 0 x = [ ] for i in b : x . append ( int ( i ) ) if x [ 0 ] != max ( x ) : for i in range ( a ) : if x [ i ] == max ( x ) : sec += i mx = i breakelse : mx = 0 if x [ - 1 ] != min ( x ) : for i in range ( a - 1 , - 1 , - 1 ) : if x [ i ] == min ( x ) : sec += len ( x ) - 1 - i mn = i breakelse : mn = a - 1 if mx > mn : sec -= 1 print ( sec ) NEWLINE NL ENDMARKER
def kPresentProbability ( a , n , k ) : NEWLINE INDENT count = a . count ( k ) NEWLINE return round ( count / n , 2 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT A = [ 4 , 7 , 2 , 0 , 8 , 7 , 5 ] NEWLINE K = 2 NEWLINE N = len ( A ) NEWLINE print ( kPresentProbability ( A , N , K ) ) NEWLINE NL DEDENT ENDMARKER
def maxLen ( arr , n ) : NEWLINE INDENT min_val = min ( arr ) ; NEWLINE freq = 0 ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT if ( arr [ i ] == min_val ) : NEWLINE INDENTINDENTINDENT freq += 1 ; NEWLINE DEDENT DEDENT return freq ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 1 , 3 , 1 ] ; NEWLINE n = len ( arr ) ; NEWLINE print ( maxLen ( arr , n ) ) ; NEWLINE NL DEDENT ENDMARKER
def countSolutions ( a ) : NEWLINE INDENT count = 0 NEWLINE for i in range ( a + 1 ) : NEWLINE INDENTINDENT if ( a == ( i + ( a ^ i ) ) ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT return count NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = 3 NEWLINE print ( countSolutions ( a ) ) NEWLINE NL DEDENT ENDMARKER
class Solution : NEWLINE INDENT def sumZero ( self , n : int ) -> List [ int ] : NEWLINE INDENTINDENT prefix_sum = 0 NEWLINE res = [ ] NEWLINE for i in range ( 1 , n ) : NEWLINE INDENTINDENTINDENT res . append ( i ) NEWLINE prefix_sum = prefix_sum + i NEWLINE DEDENT res . append ( - prefix_sum ) NEWLINE return res NEWLINE NL DEDENT DEDENT ENDMARKER
n = input ( ) result = Truei = 0 t = len ( n ) while i < len ( n ) : if n [ i ] == "1" : i += 1 if i == t : break if n [ i ] == "4" : i += 1 if i == t : break if n [ i ] == "4" : i += 1 if i == t : break else : i += 1 result = Falseif result is True : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
s = input ( ) m = { '0' : 2 , '1' : 7 , '2' : 2 , '3' : 3 , '4' : 3 , '5' : 4 , '6' : 2 , '7' : 5 , '8' : 1 , '9' : 2 , } print ( m [ s [ 0 ] ] * m [ s [ 1 ] ] ) NEWLINE NL ENDMARKER
def countSquares ( n ) : NEWLINE INDENT return ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ) NEWLINE DEDENT n = 4 NEWLINE print ( "Count of squares is " , countSquares ( n ) ) NEWLINE NL ENDMARKER
def findTerm ( n ) : NEWLINE INDENT if n == 1 : NEWLINE INDENTINDENT return n NEWLINE DEDENT else : NEWLINE INDENTINDENT term = 7 NEWLINE for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENTINDENT term = term * 2 + ( i - 1 ) ; NEWLINE DEDENT DEDENT return term ; NEWLINE DEDENT print ( findTerm ( 5 ) ) NEWLINE NL ENDMARKER
def maxPrefix ( s , t ) : NEWLINE INDENT count = 0 NEWLINE for i in range ( 0 , len ( t ) ) : NEWLINE INDENTINDENT if ( count == len ( s ) ) : NEWLINE INDENTINDENTINDENT break NEWLINE DEDENT if ( t [ i ] == s [ count ] ) : NEWLINE INDENTINDENTINDENT count = count + 1 NEWLINE DEDENT DEDENT return count NEWLINE DEDENT S = "digger" NEWLINE T = "biggerdiagram" NEWLINE print ( maxPrefix ( S , T ) ) NEWLINE NL ENDMARKER
def isEven ( n ) : NEWLINE INDENT return ( not ( n & 1 ) ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 101 ; NEWLINE if isEven ( n ) : NEWLINE INDENTINDENT print ( "Even" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "Odd" ) ; NEWLINE NL DEDENT DEDENT ENDMARKER
n = input ( ) if n [ - 1 ] == '0' : print ( n ) elif n [ - 1 ] <= '5' : s = int ( n [ - 1 ] ) n = int ( n ) print ( n - s ) else : s = 10 - int ( n [ - 1 ] ) print ( int ( n ) + s )  NEWLINE NL ENDMARKER
PI = 3.14159265 NEWLINE def area_inscribed ( P , B , H ) : NEWLINE INDENT return ( ( P + B - H ) * ( P + B - H ) * ( PI / 4 ) ) NEWLINE DEDENT P = 3 NEWLINE B = 4 NEWLINE H = 5 NEWLINE print ( area_inscribed ( P , B , H ) ) NEWLINE NL ENDMARKER
def number_cake ( n ) : NEWLINE INDENT return ( n * n * n + 5 * n + 6 ) // 6 NEWLINE DEDENT n = 2 NEWLINE print ( number_cake ( n ) ) NEWLINE n = 8 NEWLINE print ( number_cake ( n ) ) NEWLINE n = 25 NEWLINE print ( number_cake ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) k = int ( input ( ) ) a = int ( input ( ) ) b = int ( input ( ) )  ans = 0  if k == 1 : ans += ( n ) * a - aelse : while n > 1 : if n % k > 0 : if n < k : ans += ( n % k ) * a - a ; n -= ( n % k ) else : ans += ( n % k ) * a ; n -= ( n % k ) else : ans += min ( ( n - ( n // k ) ) * a , b ) n = n // kprint ( ans )    NEWLINE NL ENDMARKER
def countStrings ( n ) : NEWLINE INDENT a = [ 0 ] * n NEWLINE b = [ 0 ] * n NEWLINE a [ 0 ] = b [ 0 ] = 1 NEWLINE for i in range ( 1 , n ) : NEWLINE INDENTINDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] NEWLINE b [ i ] = a [ i - 1 ] NEWLINE DEDENT return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] NEWLINE DEDENT print ( countStrings ( 5 ) ) NEWLINE NL ENDMARKER
def countSetBits ( n ) : NEWLINE INDENT if ( n == 0 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( n & 1 ) + countSetBits ( n >> 1 ) NEWLINE DEDENT DEDENT n = 9 NEWLINE print ( countSetBits ( n ) ) NEWLINE NL ENDMARKER
m = list ( map ( int , input ( ) . split ( ) ) ) w = list ( map ( int , input ( ) . split ( ) ) ) h = list ( map ( int , input ( ) . split ( ) ) ) points = [ 500 , 1000 , 1500 , 2000 , 2500 ] ans = 0 for i in range ( 5 ) : ans += max ( 0.3 * points [ i ] , ( ( 1 - m [ i ] / 250 ) * points [ i ] ) - 50 * w [ i ] ) ans += 100 * h [ 0 ] - 50 * h [ 1 ] print ( int ( ans ) ) NEWLINE NL ENDMARKER
import mathn = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) k = [ ] mn = 10000000000 for i in range ( n ) : sm = math . ceil ( ( a [ i ] - i ) / n ) if sm < mn : mn = sm ind = iprint ( ind + 1 ) NEWLINE NL ENDMARKER
for _ in range ( 1 ) : n = int ( input ( ) ) ans = n NEWLINE NL ENDMARKER
a , b , c = map ( int , input ( ) . split ( ) ) if ( a < b ) : max = b b = a a = maxif ( a < c ) : max = c c = a a = maxk = 0 if a >= b + c : k = a - ( b + c ) + 1 else : k = 0 print ( k ) NEWLINE NL ENDMARKER
def countUnsetBits ( n ) : NEWLINE INDENT cnt = 0 ; NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT temp = i ; NEWLINE while ( temp ) : NEWLINE INDENTINDENTINDENT if ( temp % 2 == 0 ) : NEWLINE INDENTINDENTINDENTINDENT cnt += 1 ; NEWLINE DEDENT temp = temp // 2 ; NEWLINE DEDENT DEDENT return cnt ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 5 ; NEWLINE print ( countUnsetBits ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) lst = [ 0 ] * ( 2 * n ) f = 0 lst [ 0 ] = 1 ind = 0 for i in range ( 2 , ( 2 * n ) + 1 ) : if f == 0 : ind = ( ind + n ) % ( 2 * n ) lst [ ind ] = i f = 1 else : ind -= 1 lst [ ind ] = i f = 0  if n % 2 : print ( "YES" ) print ( * lst ) else : print ( "NO" ) NEWLINE NL ENDMARKER
p , x , y = map ( int , input ( ) . split ( ) )   def check ( s ) : i = ( s // 50 ) % 475 for t in range ( 25 ) : i = ( i * 96 + 42 ) % 475 if 26 + i == p : return True return False   flag = Falsefor up in range ( 500 ) : for down in range ( 500 ) : if x + 100 * up - 50 * down >= y and check ( x + 100 * up - 50 * down ) : print ( up ) flag = True break if flag : break NEWLINE NL ENDMARKER
def count ( N ) : NEWLINE INDENT a = 0 ; NEWLINE a = ( N * ( N + 1 ) ) / 2 ; NEWLINE return int ( a ) ; NEWLINE DEDENT N = 4 ; NEWLINE print ( count ( N ) ) ; NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) d = { } for i in range ( n ) : d [ a [ i ] ] = i NEWLINE NL ENDMARKER
def Maxsum ( c1 , c2 , c3 , c4 ) : NEWLINE INDENT sum = 0 NEWLINE two34 = min ( c2 , min ( c3 , c4 ) ) NEWLINE sum = two34 * 234 NEWLINE c2 -= two34 NEWLINE sum += min ( c2 , c1 ) * 12 NEWLINE return sum NEWLINE DEDENT c1 = 5 ; c2 = 2 ; c3 = 3 ; c4 = 4 NEWLINE print ( Maxsum ( c1 , c2 , c3 , c4 ) ) NEWLINE NL ENDMARKER
x = [ "a" , "e" , "i" , "o" , "u" , "y" , "A" , "E" , "I" , "O" , "U" , "Y" ] a = input ( ) a = a . replace ( " " , "" ) if a [ - 2 ] in x : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
def count ( n ) : NEWLINE INDENT count = 0 NEWLINE while ( n ) : NEWLINE INDENTINDENT count += n & 1 NEWLINE n >>= 1 NEWLINE DEDENT return count NEWLINE DEDENT def findSetBits ( n ) : NEWLINE INDENT for i in range ( n + 1 ) : NEWLINE INDENTINDENT print ( count ( i ) , end = " " ) NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 5 NEWLINE findSetBits ( n ) NEWLINE NL DEDENT ENDMARKER
def push ( self , new_data ) : NEWLINE INDENT new_node = Node ( data = new_data ) NEWLINE new_node . next = self . head NEWLINE new_node . prev = None NEWLINE if self . head is not None : NEWLINE INDENTINDENT self . head . prev = new_node NEWLINE DEDENT self . head = new_node NEWLINE NL DEDENT ENDMARKER
class Node : NEWLINE INDENT def __init__ ( self , next = None , prev = None , data = None ) : NEWLINE INDENTINDENT self . next = next NEWLINE self . prev = prev NEWLINE self . data = data NEWLINE NL DEDENT DEDENT ENDMARKER
i = input ; n = int ( i ( ) ) ; x = sum ( int ( i ( ) . split ( ) [ 0 ] ) > 0 for _ in [ 0 ] * n ) ; print ( 'YNEOS' [ 1 < x < n - 1 : : 2 ] ) NEWLINE NL ENDMARKER
def countSubStr ( strr , lenn ) : NEWLINE INDENT ans = 0 NEWLINE for i in range ( lenn ) : NEWLINE INDENTINDENT if ( strr [ i ] == '0' ) : NEWLINE INDENTINDENTINDENT ans += ( i + 1 ) NEWLINE DEDENT DEDENT return ans NEWLINE DEDENT strr = "10010" NEWLINE lenn = len ( strr ) NEWLINE print ( countSubStr ( strr , lenn ) ) NEWLINE NL ENDMARKER
def squaresum ( n ) : NEWLINE INDENT return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) // 6 NEWLINE DEDENT n = 4 NEWLINE print ( squaresum ( n ) ) NEWLINE NL ENDMARKER
string = input ( ) while string [ - 1 ] == '0' : string = string [ : len ( string ) - 1 ] if string == string [ : : - 1 ] : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
def printNumber ( n ) : NEWLINE INDENT count = [ 0 ] * 10 NEWLINE while ( n ) : NEWLINE INDENTINDENT count [ n % 10 ] += 1 NEWLINE n //= 10 NEWLINE DEDENT for i in range ( 1 , 10 ) : NEWLINE INDENTINDENT for j in range ( count [ i ] * i ) : NEWLINE INDENTINDENTINDENT print ( i , end = "" ) NEWLINE DEDENT DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 3225 NEWLINE printNumber ( n ) NEWLINE NL DEDENT ENDMARKER
def isToOne ( n ) : NEWLINE INDENT return ( n > 0 ) NEWLINE DEDENT n = 5 NEWLINE if isToOne ( n ) == True : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
length , string = int ( input ( ) ) , input ( ) print ( sum ( [ 2 ** i if string [ i ] == "B" else 0 for i in range ( len ( string ) ) ] ) ) NEWLINE NL ENDMARKER
k , n , w = map ( int , input ( ) . split ( ) ) total = 0 for i in range ( 1 , w + 1 ) : total = total + k * iif total >= n : print ( total - n ) else : print ( 0 ) NEWLINE NL ENDMARKER
I = lambda : map ( int , input ( ) . split ( ) )  NEWLINE NL ENDMARKER
from math import sin NEWLINE def polyarea ( n , r ) : NEWLINE INDENT if ( r < 0 and n < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT A = ( ( ( r * r * n ) * sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ) ; NEWLINE return round ( A , 3 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT r , n = 9 , 6 NEWLINE print ( polyarea ( n , r ) ) NEWLINE NL DEDENT ENDMARKER
def findY ( x ) : NEWLINE INDENT if ( x > 2 ) : NEWLINE INDENTINDENT return x - 2 NEWLINE DEDENT return x + 2 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT x = 5 NEWLINE print ( findY ( x ) ) NEWLINE NL DEDENT ENDMARKER
import math as mt NEWLINE def countX ( n ) : NEWLINE INDENT count = 0 NEWLINE for i in range ( n + 1 ) : NEWLINE INDENTINDENT if n - i == ( n ^ i ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT return count NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 5 NEWLINE answer = countX ( n ) NEWLINE print ( answer ) NEWLINE NL DEDENT ENDMARKER
def calcNodes ( N , I ) : NEWLINE INDENT result = 0 NEWLINE result = I * ( N - 1 ) + 1 NEWLINE return result NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 5 NEWLINE I = 2 NEWLINE print ( "Leaf nodes = " , calcNodes ( N , I ) ) NEWLINE NL DEDENT ENDMARKER
s = input ( ) x , up , low , st = len ( s ) , 0 , 0 , "" for i in range ( 1 , x ) : if ( ord ( s [ i ] ) > 90 ) : low += 1 else : up += 1 if ( up == ( len ( s ) - 1 ) or len ( s ) == 1 ) : st += s . swapcase ( ) print ( st ) else : print ( s ) NEWLINE NL ENDMARKER
def Circumference ( l , w ) : NEWLINE INDENT return ( 2 * ( l + w ) ) NEWLINE DEDENT l = 8 NEWLINE w = 4 NEWLINE c = Circumference ( l , w ) NEWLINE print ( "Circumference of a" + " rectangle is % d" % ( c ) ) NEWLINE NL ENDMARKER
from math import ceil NEWLINE def cal_IST ( h , r ) : NEWLINE INDENT IST = round ( ( h * r * 1.0 ) / 360 , 3 ) ; NEWLINE int_IST = int ( IST ) ; NEWLINE float_IST = ceil ( ( IST - int_IST ) * 60 ) ; NEWLINE print ( int_IST , ":" , float_IST ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT h = 20 ; NEWLINE r = 150 ; NEWLINE cal_IST ( h , r ) ; NEWLINE NL DEDENT ENDMARKER
def cntWays ( n ) : NEWLINE INDENT if n % 2 == 1 : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( n - 2 ) // 4 NEWLINE DEDENT DEDENT n = 18 NEWLINE print ( cntWays ( n ) ) NEWLINE NL ENDMARKER
n = input ( ) a = [ int ( each ) for each in input ( ) . split ( ) ] a . sort ( reverse = True ) len0 = len ( a ) res = a [ 0 ] for i in range ( 1 , len0 ) : if a [ i ] > a [ i - 1 ] - 1 : a [ i ] = a [ i - 1 ] - 1 if a [ i ] == 0 : break res += a [ i ] print ( res )   NEWLINE NL ENDMARKER
def maxval ( a , n ) : NEWLINE INDENT if ( n < 2 ) : NEWLINE INDENTINDENT return - 99999 NEWLINE DEDENT max = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT for j in range ( i + 1 , n ) : NEWLINE INDENTINDENTINDENT x = ( a [ i ] + i ) * ( a [ j ] + j ) NEWLINE if max < x : NEWLINE INDENTINDENTINDENTINDENT max = x NEWLINE DEDENT DEDENT DEDENT return max NEWLINE DEDENT print ( maxval ( [ 4 , 5 , 3 , 1 , 10 ] , 5 ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = input ( ) c1 = 0 for i in a : if i == '+' : c1 += 1 else : if ( c1 > 0 ) : c1 -= 1 print ( c1 ) NEWLINE NL ENDMARKER
n , m = [ int ( j ) for j in input ( ) . split ( ) ] mat = [ ] for j in range ( m ) : mat . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) stream = n * [ 0 ] for j in range ( m ) : index = 0 for k in range ( 1 , n ) : if mat [ j ] [ k ] > mat [ j ] [ index ] : index = k stream [ index ] += 1 print ( stream . index ( max ( stream ) ) + 1 ) NEWLINE NL ENDMARKER
def calculateLeaps ( n ) : NEWLINE INDENT if ( n == 0 ) : NEWLINE INDENTINDENT return 1 ; NEWLINE DEDENT return ( 1 << ( n - 1 ) ) ; NEWLINE DEDENT print ( calculateLeaps ( 4 ) ) ; NEWLINE NL ENDMARKER
numbers = list ( map ( int , input ( ) . split ( ) ) ) max_ = max ( numbers ) output = [ ]  for num in numbers : if num != max_ : print ( max_ - num , end = " " ) NEWLINE NL ENDMARKER
n = int ( input ( ) )  while True : if sum ( map ( int , list ( str ( n ) ) ) ) % 4 == 0 : rep = n break else : n += 1 print ( rep ) NEWLINE NL ENDMARKER
n = int ( input ( ) )  p = [ int ( x ) for x in input ( ) . split ( ) ]  mx = n  a = [ 0 ] * ( n + 1 )  ans = [ 1 ]  for i in range ( 0 , n ) :  t = p [ i ]  a [ t ] = 1  while a [ mx ] == 1 and mx >= 1 : mx -= 1  ans . append ( i + 1 - ( n - mx ) + 1 )  print ( ' ' . join ( map ( str , ans ) ) )      NEWLINE NL ENDMARKER
from sys import stdinfrom bisect import bisect_right as br  input = stdin . readline  n = int ( input ( ) ) lst = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) arr = sorted ( lst ) ind = br ( arr , arr [ 0 ] ) - 1 if ind == 0 : print ( lst . index ( arr [ 0 ] ) + 1 ) else : print ( 'Still Rozdil' ) NEWLINE NL ENDMARKER
def perfectCube ( N ) : NEWLINE INDENT cube_root = round ( N ** ( 1 / 3 ) ) ; NEWLINE if cube_root * cube_root * cube_root == N : NEWLINE INDENTINDENT print ( "Yes" ) ; NEWLINE return ; NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "NO" ) ; NEWLINE return ; NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 125 ; NEWLINE perfectCube ( N ) ; NEWLINE NL DEDENT ENDMARKER
if __name__ == '__main__' : s = list ( ) for _ in range ( 4 ) : s . append ( len ( input ( ) ) - 2 ) l = sorted ( s ) mn , mx = l [ 0 ] , l [ 3 ] mn = l [ 0 ] if l [ 0 ] <= l [ 1 ] / 2 else 0 mx = l [ 3 ] if l [ 3 ] >= l [ 2 ] * 2 else 0 if not mn and mx : print ( chr ( s . index ( mx ) + ord ( "A" ) ) ) elif mn and not mx : print ( chr ( s . index ( mn ) + ord ( "A" ) ) ) else : print ( "C" ) NEWLINE NL ENDMARKER
def isPossible ( l , m , x , y ) : NEWLINE INDENT if ( l * m == x + y ) : NEWLINE INDENTINDENT return True ; NEWLINE DEDENT return False ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT l = 3 ; m = 2 ; x = 4 ; y = 2 ; NEWLINE if ( isPossible ( l , m , x , y ) ) : NEWLINE INDENTINDENT print ( "Yes" ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) ; NEWLINE NL DEDENT DEDENT ENDMARKER
def gcd ( a , b ) : NEWLINE INDENT if ( b == 0 ) : NEWLINE INDENTINDENT return a NEWLINE DEDENT return gcd ( b , a % b ) NEWLINE DEDENT a = 98 NEWLINE b = 56 NEWLINE if ( gcd ( a , b ) ) : NEWLINE INDENT print ( 'GCD of' , a , 'and' , b , 'is' , gcd ( a , b ) ) NEWLINE DEDENT else : NEWLINE INDENT print ( 'not found' ) NEWLINE NL DEDENT ENDMARKER
n , m , k = map ( int , input ( ) . split ( ) ) a = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) b = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) cou = ind = 0 l = min ( m , n ) aa = max ( b ) for i in range ( l ) : if a [ i ] > b [ i ] : cou += 1 ind = max ( ind , a [ i ] )  if m >= n and cou > 0 : print ( "YES" ) elif m < n : print ( "YES" ) else : print ( "NO" )                      NEWLINE NL ENDMARKER
PI = 3.14159265 NEWLINE def area_cicumscribed ( c ) : NEWLINE INDENT return ( c * c * ( PI / 4 ) ) NEWLINE DEDENT c = 8.0 NEWLINE print ( area_cicumscribed ( c ) ) NEWLINE NL ENDMARKER
def evenPowerSum ( n ) : NEWLINE INDENT sum = 0 ; NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT j = 2 * i ; NEWLINE sum = sum + ( j * j * j * j ) ; NEWLINE DEDENT return sum ; NEWLINE DEDENT n = 5 ; NEWLINE print ( evenPowerSum ( n ) ) ; NEWLINE NL ENDMARKER
def numberOfMen ( D , m , d ) : NEWLINE INDENT Men = ( m * ( D - d ) ) / d ; NEWLINE return int ( Men ) ; NEWLINE DEDENT D = 5 ; m = 4 ; d = 4 ; NEWLINE print ( numberOfMen ( D , m , d ) ) ; NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) c = 0 ; ans = str ( ) for i in range ( n ) : ans += str ( c ^ 1 ) c = c ^ 1 print ( ans ) NEWLINE NL ENDMARKER
def countDivisors ( N , a , b ) : NEWLINE INDENT count1 = N // a NEWLINE count2 = N // b NEWLINE count3 = ( N // ( a * b ) ) NEWLINE return count1 + count2 - count3 NEWLINE DEDENT N = 1000 NEWLINE a = 3 NEWLINE b = 4 NEWLINE print ( countDivisors ( N , a , b ) ) NEWLINE NL ENDMARKER
from math import * NEWLINE def calculateSum ( n ) : NEWLINE INDENT r1 , r2 = 2 , 3 NEWLINE a1 , a2 = 1 , 1 NEWLINE return ( a1 * ( pow ( r1 , n ) - 1 ) // ( r1 - 1 ) + a2 * ( pow ( r2 , n ) - 1 ) // ( r2 - 1 ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 4 NEWLINE print ( "SUM = " , calculateSum ( n ) ) NEWLINE NL DEDENT ENDMARKER
def findSum ( N ) : NEWLINE INDENT return ( ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 3 NEWLINE print ( findSum ( N ) ) NEWLINE NL DEDENT ENDMARKER
x = ( int ( input ( ) ) + 1 ) // 3 print ( x // 12 , x % 12 ) NEWLINE NL ENDMARKER
n , m , k = map ( int , input ( ) . split ( ) ) holes = set ( map ( int , input ( ) . split ( ) ) ) p = 1 f = Truefor _ in range ( k ) : u , v = map ( int , input ( ) . split ( ) ) if not f : continue else : if p in holes : f = False break elif u == p : p = v elif v == p : p = uprint ( p ) NEWLINE NL ENDMARKER
try : x = input ( ) z = input ( ) y = "" v = True for i in range ( len ( x ) ) : if ascii ( x [ i ] ) < ascii ( z [ i ] ) : print ( - 1 ) v = False break else : y = y + z [ i ] if v : print ( y ) except : pass NEWLINE NL ENDMARKER
n = int ( input ( ) ) u = [ int ( u ) for u in input ( ) . split ( ) ] print ( sum ( u ) / n ) NEWLINE NL ENDMARKER
def largestPower ( x , P ) : NEWLINE INDENT res = 0 NEWLINE while ( x ) : NEWLINE INDENTINDENT x = int ( x / P ) NEWLINE res += x NEWLINE DEDENT return res NEWLINE DEDENT def sumOfDivisblePowers ( L , R , P ) : NEWLINE INDENT return largestPower ( R , P ) - largestPower ( L - 1 , P ) NEWLINE DEDENT L = 1 NEWLINE R = 10 NEWLINE P = 2 NEWLINE print ( sumOfDivisblePowers ( L , R , P ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n , x , y = map ( int , input ( ) . split ( ) )  print ( max ( 1 , min ( n , x + y - n + 1 ) ) , min ( n , x + y - 1 ) ) NEWLINE NL ENDMARKER
n , h = map ( int , input ( ) . split ( ) ) a = input ( ) . split ( ) sum = 0 for i in a : if int ( i ) > h : sum += 2 else : sum += 1 print ( sum ) NEWLINE NL ENDMARKER
import os , iofrom sys import stdoutimport collections NEWLINE NL ENDMARKER
x = 10 NEWLINE y = 5 NEWLINE x = x * y NEWLINE y = x // y ; NEWLINE x = x // y ; NEWLINE print ( "After Swapping: x =" , x , " y =" , y ) ; NEWLINE NL ENDMARKER
s = input ( ) i = s . find ( '1' ) if i == - 1 : print ( 'no' ) else : if s [ i + 1 : ] . count ( '0' ) < 6 : print ( 'no' ) else : print ( 'yes' ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) f = n // mt = n % m  mini = ( f * ( f - 1 ) ) // ( 1 + 1 ) mini *= mmini += f * t ma = n - mma = ( ma * ( ma + 1 ) ) // ( 1 + 1 ) print ( mini , ma ) NEWLINE NL ENDMARKER
s = input ( ) print ( s + s [ : : - 1 ] ) NEWLINE NL ENDMARKER
import math NEWLINE def sumOfSeries ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) NEWLINE DEDENT return sum NEWLINE DEDENT n = 10 NEWLINE print ( sumOfSeries ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) ans = l [ - 1 ] x = n - 1 p = l [ - 1 ] while x >= 1 : if p == 0 : break else : if l [ x - 1 ] >= p : ans += p - 1 p = p - 1 else : ans += l [ x - 1 ] p = l [ x - 1 ] x -= 1 print ( ans ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for _ in range ( t ) : n , m = list ( map ( int , input ( ) . split ( ) ) ) if n % m == 0 : print ( 'YES' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
def countOdd ( L , R ) : NEWLINE INDENT N = ( R - L ) // 2 NEWLINE if ( R % 2 != 0 or L % 2 != 0 ) : NEWLINE INDENTINDENT N += 1 NEWLINE DEDENT return N NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT L = 3 NEWLINE R = 7 NEWLINE odds = countOdd ( L , R ) NEWLINE evens = ( R - L + 1 ) - odds NEWLINE print ( "Count of odd numbers is" , odds ) NEWLINE print ( "Count of even numbers is" , evens ) NEWLINE NL DEDENT ENDMARKER
from math import sqrt NEWLINE def isPerfectSquare ( x ) : NEWLINE INDENT sr = int ( sqrt ( x ) ) ; NEWLINE if ( sr * sr == x ) : NEWLINE INDENTINDENT print ( "Yes" ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) ; NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 7 ; k = 2 ; NEWLINE isPerfectSquare ( n + k ) ; NEWLINE NL DEDENT ENDMARKER
n , d = map ( int , input ( ) . split ( ) ) ar = list ( map ( int , input ( ) . split ( ) ) ) i , j , s = 0 , 0 , 0 while i < n : while ar [ i ] - ar [ j ] > d : j += 1 N = i - j s += N * ( N - 1 ) // 2 i += 1 print ( s ) NEWLINE NL ENDMARKER
n , k = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) )  if k <= n : a . sort ( reverse = True ) print ( f"{a[k - 1]} {a[k - 1]}" ) else : print ( - 1 ) NEWLINE NL ENDMARKER
cases = int ( input ( ) ) NEWLINE while cases : cases -= 1 NEWLINE num = int ( input ( ) )  matrix = [ [ 0 for i in range ( num ) ] for j in range ( num ) ] NEWLINE matrix [ 0 ] [ 0 ] = 1 NEWLINE for i in range ( 1 , num ) : matrix [ i ] [ i ] = 1 NEWLINE matrix [ i - 1 ] [ i ] = 1 NEWLINE matrix [ i ] [ i - 1 ] = 1  for i in matrix : print ( * i )  NEWLINE NL ENDMARKER
def findNth ( N ) : NEWLINE INDENT b = 14 NEWLINE for i in range ( 2 , N + 1 ) : NEWLINE INDENTINDENT if ( i % 2 == 0 ) : NEWLINE INDENTINDENTINDENT b = b * 2 NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT b = b - 8 NEWLINE DEDENT DEDENT return b NEWLINE DEDENT N = 6 NEWLINE print ( findNth ( N ) ) NEWLINE NL ENDMARKER
def rainDayProbability ( a , n ) : NEWLINE INDENT count = a . count ( 1 ) NEWLINE m = count / n NEWLINE return m NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 ] NEWLINE n = len ( a ) NEWLINE print ( rainDayProbability ( a , n ) ) NEWLINE NL DEDENT ENDMARKER
import matha , b , x , y = map ( int , input ( ) . split ( ) ) d = math . gcd ( x , y ) print ( min ( a * d // x , b * d // y ) ) NEWLINE NL ENDMARKER
res = [ ]  for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE if n < 0 : NEWLINE INDENT res . append ( - n ) else : NEWLINE s = 0 NEWLINE DEDENT i = 0 NEWLINE while s < n : i += 1 NEWLINE s += i NEWLINE if s == n or s - n > 1 : NEWLINE INDENT res . append ( i ) else : NEWLINE res . append ( i + 1 )  for i in res : print ( i ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) print ( 6 * n * n - 6 * n + 1 ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) if n == k or k == 0 : print ( 0 , 0 ) else : print ( 1 , min ( n - k , 2 * k ) ) NEWLINE NL ENDMARKER
def findIndex ( n ) : NEWLINE INDENT if ( n <= 1 ) : NEWLINE INDENTINDENT return n NEWLINE DEDENT a = 0 NEWLINE b = 1 NEWLINE c = 1 NEWLINE res = 1 NEWLINE while ( c < n ) : NEWLINE INDENTINDENT c = a + b NEWLINE res = res + 1 NEWLINE a = b NEWLINE b = c NEWLINE DEDENT return res NEWLINE DEDENT result = findIndex ( 21 ) NEWLINE print ( result ) NEWLINE NL ENDMARKER
s = input ( ) if ( s != s [ : : - 1 ] ) : print ( len ( s ) ) exit ( 0 ) p = s [ 0 ] * len ( s ) if p == s : print ( 0 ) ; exit ( 0 ) print ( len ( s ) - 1 ) NEWLINE NL ENDMARKER
def getOddOccurrence ( arr ) : NEWLINE INDENT res = 0 NEWLINE for element in arr : NEWLINE INDENTINDENT res = res ^ element NEWLINE DEDENT return res NEWLINE DEDENT arr = [ 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 ] NEWLINE print ( "%d" % getOddOccurrence ( arr ) ) NEWLINE NL ENDMARKER
import math NEWLINE def fibonacci ( n ) : NEWLINE INDENT for i in range ( n ) : NEWLINE INDENTINDENT fib = ( ( pow ( ( 1 + math . sqrt ( 5 ) ) , i ) - pow ( ( 1 - math . sqrt ( 5 ) ) , i ) ) / ( pow ( 2 , i ) * math . sqrt ( 5 ) ) ) ; NEWLINE print ( int ( fib ) , end = " " ) ; NEWLINE DEDENT DEDENT n = 8 ; NEWLINE fibonacci ( n ) ; NEWLINE NL ENDMARKER
def product ( mat , n ) : NEWLINE INDENT d1 = 0 NEWLINE d2 = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT d1 += mat [ i ] [ i ] NEWLINE d2 += mat [ i ] [ n - i - 1 ] NEWLINE DEDENT return d1 * d2 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT mat = [ [ 5 , 8 , 1 ] , [ 5 , 10 , 3 ] , [ - 6 , 17 , - 9 ] ] NEWLINE n = len ( mat ) NEWLINE print ( product ( mat , n ) ) NEWLINE NL DEDENT ENDMARKER
def printPartition ( n , m ) : NEWLINE INDENT k = int ( n / m ) NEWLINE ct = n % m NEWLINE for i in range ( 1 , ct + 1 , 1 ) : NEWLINE INDENTINDENT print ( k + 1 , end = " " ) NEWLINE DEDENT count = i NEWLINE for i in range ( count , m , 1 ) : NEWLINE INDENTINDENT print ( k , end = " " ) NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 5 NEWLINE m = 2 NEWLINE printPartition ( n , m ) NEWLINE NL DEDENT ENDMARKER
import matht = int ( input ( ) ) NEWLINE for i in range ( 0 , t ) : n = int ( input ( ) ) NEWLINE l = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) f = [ 1 ] + list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n + 1 ) : if f [ f [ f [ i ] ] ] == i : print ( 'Yes' ) breakelse : print ( 'No' ) NEWLINE NL ENDMARKER
def sumOfTheSeries ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT sum += 1.0 / ( i * ( i + 1 ) ) ; NEWLINE DEDENT return sum NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT ans = sumOfTheSeries ( 10 ) NEWLINE print ( round ( ans , 6 ) ) NEWLINE NL DEDENT ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return 2 * pow ( n , 2 ) + 4 * n - 2 NEWLINE DEDENT N = 4 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL ENDMARKER
h , l = list ( map ( int , input ( ) . split ( ) ) )  res = ( l ** 2 - h ** 2 ) / ( 2 * h ) print ( res )    NEWLINE NL ENDMARKER
def isDivisible ( n ) : NEWLINE INDENT while ( n // 100 ) : NEWLINE INDENTINDENT d = n % 10 NEWLINE n //= 10 NEWLINE n += d * 2 NEWLINE DEDENT return ( n % 19 == 0 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 101156 NEWLINE if ( isDivisible ( n ) ) : NEWLINE INDENTINDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) NEWLINE NL DEDENT DEDENT ENDMARKER
import math NEWLINE def findSum ( n ) : NEWLINE INDENT return math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 10 NEWLINE print ( findSum ( n ) ) NEWLINE NL DEDENT ENDMARKER
d = int ( input ( ) ) n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) count = 0 for i in range ( len ( a ) - 1 ) : count += d - a [ i ] print ( count ) NEWLINE NL ENDMARKER
import math NEWLINE def nextPowerOfFour ( n ) : NEWLINE INDENT x = math . floor ( ( n ** ( 1 / 2 ) ) ** ( 1 / 2 ) ) ; NEWLINE if ( ( x ** 4 ) == n ) : NEWLINE INDENTINDENT return n ; NEWLINE DEDENT else : NEWLINE INDENTINDENT x = x + 1 ; NEWLINE return ( x ** 4 ) ; NEWLINE DEDENT DEDENT n = 122 ; NEWLINE print ( nextPowerOfFour ( n ) ) ; NEWLINE NL ENDMARKER
def nthEven ( n ) : NEWLINE INDENT return ( 2 * n ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 10 NEWLINE print ( nthEven ( n ) ) NEWLINE NL DEDENT ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) if ( ( n // k ) % 2 == 0 ) : print ( "NO" ) else : print ( "YES" ) NEWLINE NL ENDMARKER
import math NEWLINE def GIF ( n ) : NEWLINE INDENT return int ( math . floor ( n ) ) ; NEWLINE DEDENT n = 2.3 ; NEWLINE print ( GIF ( n ) ) ; NEWLINE NL ENDMARKER
import math NEWLINE def term ( n ) : NEWLINE INDENT x = ( ( ( 1 ) + math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) NEWLINE return x NEWLINE DEDENT n = 5 NEWLINE print ( int ( term ( n ) ) ) NEWLINE NL ENDMARKER
def solve ( n , pillar , clues ) : index = 0 dup_clues = set ( clues ) while index < n : found = True x = pillar [ 0 ] [ 0 ] + clues [ index ] [ 0 ] y = pillar [ 0 ] [ 1 ] + clues [ index ] [ 1 ] for x1 , y1 in pillar : if ( x - x1 , y - y1 ) in dup_clues : continue else : found = False break if found : print ( x , y ) index += 1 NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readline  for test in range ( int ( input ( ) ) ) : a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) if a [ 0 ] == a [ 2 ] or a [ 0 ] + 1 == a [ 2 ] : print ( 0 ) continue a [ 0 ] += 1 a [ 1 ] = a [ 0 ] a [ 2 ] -= 1 ans = abs ( a [ 0 ] - a [ 1 ] ) + abs ( a [ 0 ] - a [ 2 ] ) + abs ( a [ 1 ] - a [ 2 ] ) print ( ans ) NEWLINE NL ENDMARKER
n , s = map ( int , input ( ) . split ( ) ) l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) cost = 0 boi0 = l [ : n // 2 ] boi1 = l [ n // 2 + 1 : ] for i in range ( n // 2 ) : if boi0 [ - 1 - i ] > s : cost += abs ( boi0 [ - 1 - i ] - s ) boi0 [ - 1 - i ] = s if boi1 [ i ] < s : cost += abs ( boi1 [ i ] - s ) boi1 [ i ] = scost += abs ( l [ n // 2 ] - s ) print ( cost ) NEWLINE NL ENDMARKER
def findNums ( arr , n ) : NEWLINE INDENT S = 0 ; X = 0 ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT S += arr [ i ] ; NEWLINE X ^= arr [ i ] ; NEWLINE DEDENT print ( X , X + S ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 1 , 7 ] ; NEWLINE n = len ( arr ) ; NEWLINE findNums ( arr , n ) ; NEWLINE NL DEDENT ENDMARKER
def maxZeros ( N ) : NEWLINE INDENT maxm = - 1 NEWLINE cnt = 0 NEWLINE while ( N ) : NEWLINE INDENTINDENT if ( not ( N & 1 ) ) : NEWLINE INDENTINDENTINDENT cnt += 1 NEWLINE N >>= 1 NEWLINE maxm = max ( maxm , cnt ) NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT maxm = max ( maxm , cnt ) NEWLINE cnt = 0 NEWLINE N >>= 1 NEWLINE DEDENT DEDENT return maxm NEWLINE DEDENT N = 14 NEWLINE print ( maxZeros ( N ) ) NEWLINE NL ENDMARKER
def getmax ( arr , n , x ) : NEWLINE INDENT s = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT s = s + arr [ i ] NEWLINE DEDENT print ( min ( s , x ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEWLINE x = 5 NEWLINE arr_size = len ( arr ) NEWLINE getmax ( arr , arr_size , x ) NEWLINE NL DEDENT ENDMARKER
import math as mpdef parallelepiped ( areas ) : a = areas [ 0 ] / areas [ 1 ] b2 = mp . sqrt ( areas [ 2 ] / a ) a1 = areas [ 1 ] / b2 b1 = areas [ 0 ] / a1 edge_sum = ( 4 * a1 ) + ( 4 * b1 ) + ( 4 * b2 ) return ( int ( edge_sum ) )  areas = list ( map ( int , input ( ) . split ( ) ) ) result = parallelepiped ( areas ) print ( result ) NEWLINE NL ENDMARKER
ans = 1 NEWLINE mod = 1000000007 * 120 NEWLINE for i in range ( 0 , 5 ) : NEWLINE INDENT ans = ( ans * ( 55555 - i ) ) % mod NEWLINE DEDENT ans = int ( ans / 120 ) NEWLINE print ( "Answer using shortcut: " , ans ) NEWLINE NL ENDMARKER
a , b = [ int ( x ) for x in input ( ) . split ( ) ]  x = b % 10 mul = 1 for i in range ( b , a , - 1 ) : mul *= x x -= 1 if x < 0 and i > a : print ( "0" ) mul = - 1 breakif mul != - 1 : mul = mul % 10 print ( mul ) NEWLINE NL ENDMARKER
def findArea ( r ) : NEWLINE INDENT PI = 3.142 NEWLINE return PI * ( r * r ) ; NEWLINE DEDENT print ( "Area is %.6f" % findArea ( 5 ) ) ; NEWLINE NL ENDMARKER
n , m , a , b = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( 0 , n * 2 ) : l . append ( i * b + ( ( n - m * i ) * a if n - m * i > 0 else 0 ) ) print ( min ( l ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) if ( n * ( n + 1 ) ) % 4 == 0 : print ( 0 ) elif n <= 2 : print ( 1 ) elif n == 3 : print ( 0 ) else : print ( 1 )  NEWLINE NL ENDMARKER
def findremainder ( arr , lens , n ) : NEWLINE INDENT mul = 1 NEWLINE for i in range ( lens ) : NEWLINE INDENTINDENT mul = ( mul * ( arr [ i ] % n ) ) % n NEWLINE DEDENT return mul % n NEWLINE DEDENT arr = [ 100 , 10 , 5 , 25 , 35 , 14 ] NEWLINE lens = len ( arr ) NEWLINE n = 11 NEWLINE print ( findremainder ( arr , lens , n ) ) NEWLINE NL ENDMARKER
import math NEWLINE def countRectangles ( l , w ) : NEWLINE INDENT squareSide = math . gcd ( l , w ) NEWLINE return ( l * w ) / ( squareSide * squareSide ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT l = 4 NEWLINE w = 6 NEWLINE ans = countRectangles ( l , w ) NEWLINE print ( int ( ans ) ) NEWLINE NL DEDENT ENDMARKER
def compute ( ) : NEWLINE INDENT ans = 0 NEWLINE x = 1 NEWLINE y = 2 NEWLINE while x <= 4000000 : NEWLINE INDENTINDENT if x % 2 == 0 : NEWLINE INDENTINDENTINDENT ans += x NEWLINE DEDENT x , y = y , x + y NEWLINE DEDENT return str ( ans ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( compute ( ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) s = input ( ) l = [ ] for i in s : k = i . lower ( ) if k not in l : l . append ( k ) if ( len ( l ) == 26 ) : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
def countReduce ( str ) : NEWLINE INDENT n = len ( str ) NEWLINE res = 0 NEWLINE for i in range ( 0 , int ( n / 2 ) ) : NEWLINE INDENTINDENT res += abs ( int ( ord ( str [ i ] ) ) - int ( ord ( str [ n - i - 1 ] ) ) ) NEWLINE DEDENT return res NEWLINE DEDENT str = "abcd" NEWLINE print ( countReduce ( str ) ) NEWLINE NL ENDMARKER
n = 4562 ; NEWLINE rev = 0 NEWLINE while ( n > 0 ) : NEWLINE INDENT a = n % 10 NEWLINE rev = rev * 10 + a NEWLINE n = n / 10 NEWLINE DEDENT print ( rev ) NEWLINE NL ENDMARKER
def search ( arr , n , x ) : NEWLINE INDENT for i in range ( n ) : NEWLINE INDENTINDENT if arr [ i ] == x : NEWLINE INDENTINDENTINDENT return i NEWLINE DEDENT DEDENT return - 1 NEWLINE DEDENT arr = [ 1 , 10 , 30 , 15 ] NEWLINE x = 30 NEWLINE n = len ( arr ) NEWLINE print ( x , "is present at index" , search ( arr , n , x ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) + 1 fingers = sum ( map ( int , input ( ) . split ( ) ) ) start = fingers % noptions = 0 for x in range ( 1 , 6 ) : if ( start + x ) % n != 1 : options += 1 print ( options ) NEWLINE NL ENDMARKER
n , m , l , r = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) if max ( a ) > r or min ( a ) < l : print ( "Incorrect" ) elif n - m >= 2 : print ( "Correct" ) else : if l not in a and r not in a and l != r : print ( "Incorrect" ) else : print ( "Correct" ) NEWLINE NL ENDMARKER
a = int ( input ( ) ) b = list ( ) for i in range ( a ) : b . append ( list ( map ( int , input ( ) . split ( ) ) ) ) h = 0 for i in range ( a ) : for j in range ( a ) : if ( sum ( b [ i ] [ j ] for i in range ( a ) ) > sum ( b [ i ] ) ) : h += 1 print ( h )                        NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = [ int ( x ) for x in input ( ) . split ( ) ] print ( max ( l ) - ( sum ( l ) - max ( l ) ) + 1 ) NEWLINE NL ENDMARKER
def printNonConsecutive ( n ) : NEWLINE INDENT p = ( 1 << n ) NEWLINE for i in range ( 1 , p ) : NEWLINE INDENTINDENT if ( ( i & ( i << 1 ) ) == 0 ) : NEWLINE INDENTINDENTINDENT print ( i , end = " " ) NEWLINE DEDENT DEDENT DEDENT n = 3 NEWLINE printNonConsecutive ( n ) NEWLINE NL ENDMARKER
def cost ( a , n ) : NEWLINE INDENT return ( ( n - 1 ) * min ( a ) ) NEWLINE DEDENT a = [ 4 , 3 , 2 ] NEWLINE n = len ( a ) NEWLINE print ( cost ( a , n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) )  space = n * 2 arr = [ ' ' * space + "0" ]  for i in range ( 1 , n + 1 ) : space -= 2 arr . append ( ( ' ' * space + ( arr [ - 1 ] + " " + str ( i ) ) . strip ( ) ) )  NEWLINE NL ENDMARKER
n = int ( input ( ) ) lst = [ int ( i ) for i in input ( ) . split ( ) ] exp = sorted ( lst , reverse = True )  for i in lst : print ( exp . index ( i ) + 1 , end = ' ' ) NEWLINE NL ENDMARKER
def addOne ( x ) : NEWLINE INDENT return ( - ( ~ x ) ) ; NEWLINE DEDENT print ( addOne ( 13 ) ) NEWLINE NL ENDMARKER
def printPair ( g , l ) : NEWLINE INDENT print ( g , l ) NEWLINE DEDENT g = 3 ; l = 12 ; NEWLINE printPair ( g , l ) ; NEWLINE NL ENDMARKER
p = list ( map ( int , input ( ) . split ( ) ) ) k = p [ 0 ] a = [ ] for i in range ( k ) : s = input ( ) a . append ( s ) ans = int ( 0 ) for i in range ( 1 , k - 1 ) : for j in range ( 1 , k - 1 ) : if a [ i - 1 ] [ j - 1 ] == 'X' and a [ i - 1 ] [ j + 1 ] == 'X' and a [ i + 1 ] [ j - 1 ] == 'X' and a [ i + 1 ] [ j + 1 ] == 'X' and a [ i ] [ j ] == 'X' : ans = ans + 1 print ( ans ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) if n <= 2 : print ( "-1" ) else : for i in range ( n , 0 , - 1 ) : print ( i , end = " " ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) NEWLINE ans = [ ] NEWLINE for i in range ( t ) : n = input ( ) NEWLINE p = input ( ) . split ( ) NEWLINE p . reverse ( ) NEWLINE ans . append ( p ) NEWLINE for j in ans : print ( " " . join ( j ) ) NEWLINE NL ENDMARKER
def sum ( n ) : NEWLINE INDENT if n == 0 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT return 1 / pow ( 3 , n ) + sum ( n - 1 ) NEWLINE DEDENT n = 5 ; NEWLINE print ( sum ( n ) ) ; NEWLINE NL ENDMARKER
str = str ( input ( ) ) def pal ( ) : global str lst = [ ] count1 = 0 count2 = 0 n = len ( str ) for i in str : lst . append ( i ) for i in range ( len ( lst ) ) : if lst [ i ] == lst [ n - 1 - i ] : count1 += 1 else : count2 += 1 if len ( str ) % 2 == 0 : if ( count2 == 2 ) : print ( "YES" ) else : print ( "NO" ) if len ( str ) % 2 == 1 : if ( count2 == 0 or count2 == 2 ) : print ( "YES" ) else : print ( 'NO' ) pal ( ) NEWLINE NL ENDMARKER
s = input ( )   f = Falsefor i in range ( len ( s ) - 2 ) : x = s [ i : i + 3 ]  if 'A' in x and 'B' in x and 'C' in x : f = True break  NEWLINE NL ENDMARKER
a = 3 * [ 0 ] + sorted ( map ( int , input ( ) . split ( ) ) ) print ( sum ( a ) - max ( 2 * z + ( x == z ) * z for x , y , z in zip ( a , a [ 1 : ] , a [ 2 : ] ) if z == y ) ) NEWLINE NL ENDMARKER
def answer ( X , K ) : NEWLINE INDENT MIN = pow ( 10 , K - 1 ) NEWLINE if ( MIN % X == 0 ) : NEWLINE INDENTINDENT return ( MIN ) NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( ( MIN + X ) - ( ( MIN + X ) % X ) ) NEWLINE DEDENT DEDENT X = 83 ; NEWLINE K = 5 ; NEWLINE print ( answer ( X , K ) ) ; NEWLINE NL ENDMARKER
n = int ( input ( ) ) if n % 2 == 0 : if ( n // 2 ) % 2 == 1 : print ( n // 2 - 2 , n // 2 + 2 ) else : print ( n // 2 - 1 , n // 2 + 1 ) else : print ( n // 2 , n // 2 + 1 ) NEWLINE NL ENDMARKER
def printCombination ( n ) : NEWLINE INDENT print ( "1 " , end = "" ) ; NEWLINE if ( ( n - 2 ) % 3 == 0 ) : NEWLINE INDENTINDENT print ( "2" , n - 3 , end = "" ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "1" , ( n - 2 ) , end = "" ) ; NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 233 ; NEWLINE printCombination ( n ) ; NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) d = dict ( zip ( range ( 1 , n + 1 ) , map ( int , input ( ) . split ( ) ) ) ) ans = [ 0 ] * nfor i in d : node = i s = set ( ) while node not in s : s . add ( node ) node = d [ node ] ans [ i - 1 ] = node  print ( * ans )  NEWLINE NL ENDMARKER
def per ( a , b ) : NEWLINE INDENT return ( a + b ) NEWLINE DEDENT def area ( s ) : NEWLINE INDENT return ( s / 2 ) NEWLINE DEDENT a = 7 NEWLINE b = 8 NEWLINE s = 10 NEWLINE print ( per ( a , b ) ) NEWLINE print ( area ( s ) ) NEWLINE NL ENDMARKER
n , m = list ( map ( int , input ( ) . split ( ) ) ) a = [ 1 ] + list ( map ( int , input ( ) . split ( ) ) ) print ( sum ( [ ( a [ i ] - a [ i - 1 ] ) % n for i in range ( 1 , m + 1 ) ] ) ) NEWLINE NL ENDMARKER
x = int ( input ( ) ) for i in range ( x ) : n = int ( input ( ) ) s = 0 k = 1 for j in range ( 1 , 11 ) : for h in range ( 1 , 10 ) : if ( h * k <= n ) : s = s + 1 k = ( k * 10 ) + 1 print ( s ) NEWLINE NL ENDMARKER
p , k = input ( ) . split ( )  p = int ( p ) k = int ( k )  y = 10 * k - 1 x = ( ( 10 ** ( p - 1 ) ) - k ) % y   b = True  for i in range ( k , 10 ) : if ( ( x * i % y ) == 0 ) : NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) s = [ ] for i in range ( n ) : a = input ( ) s . append ( a ) flag = Trueb = 0 w = 0 d = 0 l = 0 password = input ( ) for i in range ( n ) : if len ( s [ i ] ) < len ( password ) : d += 1 elif len ( s [ i ] ) == len ( password ) : l += 1 x = d + l - 1 w = x + ( x // k ) * 5 + 1 b = d + ( d // k ) * 5 + 1 print ( b , w ) NEWLINE NL ENDMARKER
def oddNumSum ( n ) : NEWLINE INDENT j = 0 NEWLINE sm = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT j = ( 2 * i - 1 ) NEWLINE sm = sm + ( j * j * j * j ) NEWLINE DEDENT return sm NEWLINE DEDENT n = 6 ; NEWLINE print ( oddNumSum ( n ) ) NEWLINE NL ENDMARKER
def countSolutions ( a ) : NEWLINE INDENT count = bin ( a ) . count ( '1' ) NEWLINE return 2 ** count NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = 3 NEWLINE print ( countSolutions ( a ) ) NEWLINE NL DEDENT ENDMARKER
a = int ( input ( ) ) for i in range ( a ) : m , n , o = map ( int , input ( ) . split ( ) ) print ( ( o - n ) // m * m + n ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) cur = mans = [ 0 ] * nfor i , a in enumerate ( A ) : if a < cur : cur -= a ans [ i ] = 0 else : q = ( a - cur + m - 1 ) // m r = q * m - ( a - cur ) NEWLINE NL ENDMARKER
from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( 'input.txt' ) ) : stdin = open ( "input.txt" , "r" ) import time NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) buttons = list ( map ( int , input ( ) . split ( ) ) ) lights = [ 0 ] * nfor i in buttons : for j in range ( i - 1 , len ( lights ) ) : if lights [ j ] == 0 : lights [ j ] = ifor i in range ( len ( lights ) ) : print ( lights [ i ] , end = " " ) NEWLINE NL ENDMARKER
def countSum ( N , L , R ) : NEWLINE INDENT if ( L > R ) : NEWLINE INDENTINDENT return 0 ; NEWLINE DEDENT if ( N == 1 ) : NEWLINE INDENTINDENT return R - L + 1 ; NEWLINE DEDENT if ( N > 1 ) : NEWLINE INDENTINDENT return ( N - 2 ) * ( R - L ) + 1 ; NEWLINE DEDENT return 0 ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N , L , R = 4 , 4 , 6 ; NEWLINE print ( countSum ( N , L , R ) ) ; NEWLINE NL DEDENT ENDMARKER
def getResult ( n ) : NEWLINE INDENT if n & 1 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT return - 1 NEWLINE DEDENT n = 3 NEWLINE print ( getResult ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = input ( ) a = [ int ( x ) for x in a . split ( ) ] sum = 0 ans = 0 for i in range ( n ) : if a [ i ] == 1 : sum += 1 else : ans += sumprint ( ans ) NEWLINE NL ENDMARKER
def minimumIncrease ( a , b , c ) : NEWLINE INDENT arr = [ a , b , c ] NEWLINE arr . sort ( ) NEWLINE if arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT else : NEWLINE INDENTINDENT return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT a , b , c = 3 , 5 , 10 NEWLINE print ( minimumIncrease ( a , b , c ) ) NEWLINE NL DEDENT ENDMARKER
Str = input ( ) NStr = Str . replace ( "WUB" , " " ) NStr1 = NStr . title ( ) NStr2 = NStr1 . replace ( " " , "" )  import reStr1 = re . sub ( '([A-Z])' , r' \1' , NStr2 ) Str2 = Str1 [ 1 : ] . upper ( ) print ( Str2 ) NEWLINE NL ENDMARKER
import mathn , m , z = map ( int , input ( ) . split ( ) ) print ( z // ( ( n * m ) // math . gcd ( n , m ) ) ) NEWLINE NL ENDMARKER
def newvol ( x ) : NEWLINE INDENT print ( "percentage increase in the" " volume of the sphere is " , pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 , "%" ) NEWLINE DEDENT x = 10.0 NEWLINE newvol ( x ) NEWLINE NL ENDMARKER
def seriesSum ( n ) : NEWLINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) NEWLINE DEDENT n = 4 NEWLINE print ( seriesSum ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) a = list ( s ) i = 0 c = 0 while i < n - 1 : if a [ i ] == 'U' and a [ i + 1 ] == 'R' : c = c + 1 a [ i ] = 'D' a [ i + 1 ] = 'D' elif a [ i ] == 'R' and a [ i + 1 ] == 'U' : a [ i ] = 'D' a [ i + 1 ] = 'D' c = c + 1 i = i + 1 print ( n - c ) NEWLINE NL ENDMARKER
a , b = [ * open ( 0 ) ] [ 1 : ] if '*' in a : x , y = a . split ( '*' ) r = b . startswith ( x ) and b [ len ( x ) : ] . endswith ( y ) else : r = a == bprint ( 'NYOE S' [ r : : 2 ] ) NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readlineimport math  def inpit ( ) : NEWLINE NL ENDMARKER
def exponential ( n , x ) : NEWLINE INDENT sum = 1.0 NEWLINE for i in range ( n , 0 , - 1 ) : NEWLINE INDENTINDENT sum = 1 + x * sum / i NEWLINE DEDENT print ( "e^x =" , sum ) NEWLINE DEDENT n = 10 NEWLINE x = 1.0 NEWLINE exponential ( n , x ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) while sum ( [ int ( x ) for x in str ( n ) ] ) % 4 != 0 : n += 1 print ( n ) NEWLINE NL ENDMARKER
n = int ( input ( ) )  if n > 2 : for i in range ( n , 0 , - 1 ) : print ( i , end = ' ' ) else : print ( - 1 ) NEWLINE NL ENDMARKER
for u in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE x = [ int ( w ) for w in input ( ) . split ( ) ] NEWLINE f = False NEWLINE for i in range ( n - 1 ) : if NEWLINE INDENT ( x [ i ] <= x [ i + 1 ] ) : f = True NEWLINE DEDENT break NEWLINE if ( f ) : NEWLINE INDENT print ( "YES" ) else : NEWLINE print ( "NO" ) NEWLINE NL DEDENT ENDMARKER
def area ( a , b ) : NEWLINE INDENT if ( a < 0 or b < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT A = a * b NEWLINE return A NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = 5 NEWLINE b = 2 NEWLINE print ( area ( a , b ) ) NEWLINE NL DEDENT ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) d = { } for _ in range ( n ) : s = list ( input ( ) . split ( ) ) d [ s [ 1 ] ] = s [ 0 ] for _ in range ( m ) : x = list ( input ( ) . split ( ) ) print ( x [ 0 ] + " " + x [ 1 ] + " #" + d [ x [ 1 ] [ : - 1 ] ] ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) c = 1 for i in range ( n ) : if i == 0 : new = input ( ) continue old = new new = input ( ) if old [ 1 ] == new [ 0 ] : c += 1 print ( c ) NEWLINE NL ENDMARKER
def circlearea ( R ) : NEWLINE INDENT if ( R < 0 ) : NEWLINE INDENTINDENT return - 1 ; NEWLINE DEDENT a = ( 3.14 * R * R ) / 4 ; NEWLINE return a ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT R = 2 ; NEWLINE print ( circlearea ( R ) ) ; NEWLINE NL DEDENT ENDMARKER
PHI = 1.6180339 NEWLINE f = [ 0 , 1 , 1 , 2 , 3 , 5 ] NEWLINE def fib ( n ) : NEWLINE INDENT if n < 6 : NEWLINE INDENTINDENT return f [ n ] NEWLINE DEDENT t = 5 NEWLINE fn = 5 NEWLINE while t < n : NEWLINE INDENTINDENT fn = round ( fn * PHI ) NEWLINE t += 1 NEWLINE DEDENT return fn NEWLINE DEDENT n = 9 NEWLINE print ( n , "th Fibonacci Number =" , fib ( n ) ) NEWLINE NL ENDMARKER
s = input ( ) x1 , y1 = s . count ( "7" ) , s . count ( "4" ) if x1 == 0 and y1 == 0 : print ( "-1" )  elif x1 > y1 : print ( "7" ) else : print ( "4" ) NEWLINE NL ENDMARKER
n , m , k , t = map ( int , input ( ) . split ( ) ) NEWLINE waste = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( k ) ] NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) if n < k : print ( k + n ) else : ans = [ ] ; i = 1 while i * i <= n : if n % i == 0 and n % ( n // i ) == 0 : ans . append ( [ i , n // i ] ) i += 1 ans1 = [ ] for j in ans : if k > j [ 0 ] : ans1 . append ( k * j [ 1 ] + j [ 0 ] ) if k > j [ 1 ] : ans1 . append ( k * j [ 0 ] + j [ 1 ] ) print ( min ( ans1 ) ) NEWLINE NL ENDMARKER
def sum ( n ) : NEWLINE INDENT if n < 2 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT else : NEWLINE INDENTINDENT return 1 / n + ( sum ( n - 1 ) ) NEWLINE DEDENT DEDENT print ( sum ( 8 ) ) NEWLINE print ( sum ( 10 ) ) NEWLINE NL ENDMARKER
def solve ( arr , n ) : NEWLINE INDENT arr . sort ( ) NEWLINE a = 0 ; b = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT if ( i % 2 != 0 ) : NEWLINE INDENTINDENTINDENT a = a * 10 + arr [ i ] NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT b = b * 10 + arr [ i ] NEWLINE DEDENT DEDENT return a + b NEWLINE DEDENT arr = [ 6 , 8 , 4 , 5 , 2 , 3 ] NEWLINE n = len ( arr ) NEWLINE print ( "Sum is " , solve ( arr , n ) ) NEWLINE NL ENDMARKER
m , n = map ( int , input ( ) . split ( ) ) print ( ( "abcdefghijklmnopqrstuvwxyz" [ : n ] * m ) [ : m ] )   NEWLINE NL ENDMARKER
def countP ( n , k ) : NEWLINE INDENT if ( n == 0 or k == 0 or k > n ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT if ( k == 1 or k == n ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( countP ( 3 , 2 ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) z = [ ] c = 0 for i in range ( n ) : a , b = i , x [ i ] for j in range ( i , n ) : if x [ j ] < b : a = j b = x [ j ] x [ i ] , x [ a ] = x [ a ] , x [ i ] if a != i : c += 1 z . append ( [ i , a ] ) print ( c ) for i in z : for j in i : print ( j , end = " " ) print ( "" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( n // 2 + 1 ) NEWLINE NL ENDMARKER
x = input ( ) n = len ( x ) if n == 1 : print ( x ) exit ( 0 ) ans = "" s = 0 ps = 0 pn = "" for i in range ( n ) : ts = ps + int ( x [ i ] ) - 1 + 9 * ( n - i - 1 ) if ts >= s : ans = pn + str ( int ( x [ i ] ) - 1 ) + "9" * ( n - i - 1 ) s = ts ps += int ( x [ i ] ) pn += x [ i ] if ps >= s : ans = pnprint ( int ( ans ) ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) if k == n or k == 0 : print ( 0 , 0 ) elif k <= ( n ) // 3 : print ( 1 , k * 2 ) else : print ( 1 , n - k ) NEWLINE NL ENDMARKER
import math NEWLINE def findNumberOfDigits ( n , base ) : NEWLINE INDENT dig = ( math . floor ( math . log ( n ) / math . log ( base ) ) + 1 ) NEWLINE print ( "The Number of digits of" " Number {} in base {} is {}" . format ( n , base , dig ) ) NEWLINE DEDENT n = 1446 NEWLINE base = 7 NEWLINE findNumberOfDigits ( n , base ) NEWLINE NL ENDMARKER
def countunsetbits ( n ) : NEWLINE INDENT count = 0 NEWLINE x = 1 NEWLINE while ( x < n + 1 ) : NEWLINE INDENTINDENT if ( ( x & n ) == 0 ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT x = x << 1 NEWLINE DEDENT return count NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 17 NEWLINE print ( countunsetbits ( n ) ) NEWLINE NL DEDENT ENDMARKER
def bin ( n ) : NEWLINE INDENT if ( n > 1 ) : NEWLINE INDENTINDENT bin ( n >> 1 ) NEWLINE DEDENT print ( n & 1 , end = "" ) NEWLINE DEDENT bin ( 131 ) NEWLINE print ( ) NEWLINE bin ( 3 ) NEWLINE NL ENDMARKER
import math   def func ( num_buckets , length , buckets ) : buckets . sort ( reverse = True ) for i in range ( num_buckets ) : if ( length % buckets [ i ] == 0 ) : return ( int ( length / buckets [ i ] ) ) return None  num_buckets , length = list ( map ( int , input ( ) . split ( ) ) ) buckets = list ( map ( int , input ( ) . split ( ) ) )  hours = func ( num_buckets , length , buckets )  print ( hours )  NEWLINE NL ENDMARKER
def countPairs ( n ) : NEWLINE INDENT if ( n == 2 ) : NEWLINE INDENTINDENT return 4 NEWLINE DEDENT num = ( ( n // 2 ) + 1 ) ; NEWLINE max = n % num ; NEWLINE count = n - max ; NEWLINE return count NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 5 ; NEWLINE DEDENT print ( countPairs ( n ) ) ; NEWLINE NL ENDMARKER
def findNthTerm ( x , y , n ) : NEWLINE INDENT f = [ 0 ] * 6 NEWLINE f [ 0 ] = x NEWLINE f [ 1 ] = y NEWLINE for i in range ( 2 , 6 ) : NEWLINE INDENTINDENT f [ i ] = f [ i - 1 ] - f [ i - 2 ] NEWLINE DEDENT return f [ n % 6 ] NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT x , y , n = 2 , 3 , 3 NEWLINE print ( findNthTerm ( x , y , n ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) A = [ int ( d ) for d in input ( ) ] f = [ int ( x ) for x in input ( ) . split ( ) ] flag = Falsefor i in range ( n ) : d = A [ i ] x = f [ A [ i ] - 1 ] if x > d : flag = True A [ i ] = x elif x == d : continue else : if flag : breakA = list ( map ( str , A ) ) print ( '' . join ( A ) ) NEWLINE NL ENDMARKER
def toDecimal ( binary , i = 0 ) : NEWLINE INDENT n = len ( binary ) NEWLINE if ( i == n - 1 ) : NEWLINE INDENTINDENT return int ( binary [ i ] ) - 0 NEWLINE DEDENT return ( ( ( int ( binary [ i ] ) - 0 ) << ( n - i - 1 ) ) + toDecimal ( binary , i + 1 ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT binary = "1010" NEWLINE print ( toDecimal ( binary ) ) NEWLINE NL DEDENT ENDMARKER
num = input ( ) given = input ( )  num = "" . join ( sorted ( num ) )  idx = - 1 for i in range ( len ( num ) ) : if int ( num [ i ] ) > 0 : idx = i break  if idx == - 1 : solution = "0" else : solution = num [ idx ] + num [ : idx ] + num [ idx + 1 : ]  print ( "WRONG_ANSWER" if solution != given else "OK" ) NEWLINE NL ENDMARKER
tests = [ ] maxh = 0 for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if n > maxh : maxh = n tests . append ( n ) cards = 2 h = [ 2 ] x = 0 while cards <= maxh : x += 1 cards += 3 * x + 2 h . append ( cards ) for t in tests : ans = 0 while t >= h [ 0 ] : for b in h [ : : - 1 ] : if b <= t : ans += 1 t -= b break print ( ans ) NEWLINE NL ENDMARKER
def angle ( n ) : NEWLINE INDENT return 2 * n NEWLINE DEDENT n = 30 NEWLINE print ( angle ( n ) ) NEWLINE NL ENDMARKER
def power ( x , y ) : NEWLINE INDENT if ( y == 0 ) : return 1 NEWLINE elif ( int ( y % 2 ) == 0 ) : NEWLINE INDENTINDENT return ( power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ) NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( x * power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ) NEWLINE DEDENT DEDENT x = 2 ; y = 3 NEWLINE print ( power ( x , y ) ) NEWLINE NL ENDMARKER
a , b = 1 , 1 k = int ( input ( ) ) n = 1 while n <= k : if n == b : print ( "O" , end = "" ) a , b = b , a + b else : print ( "o" , end = "" ) n = n + 1 NEWLINE NL ENDMARKER
import sysimport mathclass DictList ( dict ) : def __setitem__ ( self , key , value ) : try : NEWLINE NL ENDMARKER
def myCopy ( s1 , s2 , index ) : NEWLINE INDENT s2 [ index ] = s1 [ index ] ; NEWLINE if ( index == len ( s1 ) - 1 ) : NEWLINE INDENTINDENT return ; NEWLINE DEDENT myCopy ( s1 , s2 , index + 1 ) ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT s1 = "GEEKSFORGEEKS" ; NEWLINE s2 = [ 0 ] * ( len ( s1 ) ) ; NEWLINE index = 0 ; NEWLINE myCopy ( s1 , s2 , index ) ; NEWLINE print ( "" . join ( s2 ) ) ; NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) for i in range ( 1 , 35 ) : if 2 ** i - 1 >= n : print ( i ) ; break NEWLINE NL ENDMARKER
s = input ( ) . split ( "^" ) l = s [ 0 ] r = s [ 1 ]  l = l [ : : - 1 ] l_v = 0 r_v = 0  for index in range ( 0 , len ( l ) ) : if l [ index ] != "=" : l_v += int ( l [ index ] ) * ( index + 1 )  for index in range ( 0 , len ( r ) ) : if r [ index ] != "=" : r_v += int ( r [ index ] ) * ( index + 1 )   if l_v == r_v : print ( "balance" ) elif l_v > r_v : print ( "left" ) else : print ( "right" ) NEWLINE NL ENDMARKER
def Nth_Term ( n ) : NEWLINE INDENT return ( 3 * pow ( n , 2 ) - n + 2 ) // ( 2 ) NEWLINE DEDENT N = 5 NEWLINE print ( Nth_Term ( N ) ) NEWLINE NL ENDMARKER
def findCullen ( n ) : NEWLINE INDENT return ( 1 << n ) * n + 1 NEWLINE DEDENT n = 2 NEWLINE print ( findCullen ( n ) ) NEWLINE NL ENDMARKER
b = 0 w = int ( input ( ) ) maxyear = 0 n = list ( map ( int , input ( ) . split ( ) ) ) [ : w ] a , b = map ( int , input ( ) . split ( ) ) d = ( b - 1 ) for j in range ( ( a - 1 ) , d ) : maxyear += n [ j ] print ( maxyear ) NEWLINE NL ENDMARKER
def countDigit ( n ) : NEWLINE INDENT if n == 0 : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT return 1 + countDigit ( n // 10 ) NEWLINE DEDENT n = 345289467 NEWLINE print ( "Number of digits : % d" % ( countDigit ( n ) ) ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) points = 0 if n < m : points = nelse : points = mif ( points % 2 ) != 0 : print ( "Akshat" ) else : print ( "Malvika" ) NEWLINE NL ENDMARKER
def digital_root ( n ) : NEWLINE INDENT x = sum ( int ( digit ) for digit in str ( n ) ) NEWLINE if x < 10 : NEWLINE INDENTINDENT return x NEWLINE DEDENT else : NEWLINE INDENTINDENT return digital_root ( x ) NEWLINE DEDENT DEDENT def main ( ) : NEWLINE INDENT a = int ( input ( ) ) NEWLINE print ( digital_root ( a ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT main ( ) NEWLINE NL DEDENT ENDMARKER
from sys import stdin , stdoutfrom itertools import accumulatenmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEWLINE NL ENDMARKER
from math import * NEWLINE def countCubes ( a , b ) : NEWLINE INDENT return ( floor ( b ** ( 1. / 3. ) ) - ceil ( a ** ( 1. / 3. ) ) + 1 ) NEWLINE DEDENT a = 7 NEWLINE b = 28 NEWLINE print ( "Count of cubes is" , countCubes ( a , b ) ) NEWLINE NL ENDMARKER
import sys n , k = map ( int , input ( ) . split ( ) ) if k == 1 : print ( n ) sys . exit ( 0 ) NEWLINE NL ENDMARKER
import math NEWLINE def findCount ( d ) : NEWLINE INDENT return 9 * ( ( int ) ( math . pow ( 10 , d - 1 ) ) - ( int ) ( math . pow ( 9 , d - 1 ) ) ) ; NEWLINE DEDENT d = 1 NEWLINE print ( findCount ( d ) ) NEWLINE d = 2 NEWLINE print ( findCount ( d ) ) NEWLINE d = 4 NEWLINE print ( findCount ( d ) ) NEWLINE NL ENDMARKER
n , m = [ int ( x ) for x in input ( ) . split ( ) ] F = [ 1 , 1 ] for i in range ( 2 , n ) : F . append ( F [ - 1 ] + F [ - 2 ] ) perm = [ i + 1 for i in range ( n ) ] for i in range ( n ) : if m > F [ n - 1 - i ] : m -= F [ n - 1 - i ] perm [ i ] , perm [ i + 1 ] = perm [ i + 1 ] , perm [ i ] for k in perm : print ( k , end = ' ' ) NEWLINE NL ENDMARKER
def swapThree ( a , b , c ) : NEWLINE INDENT a = a + b + c NEWLINE b = a - ( b + c ) NEWLINE c = a - ( b + c ) NEWLINE a = a - ( b + c ) NEWLINE print ( "After swapping a =" , a , ", b =" , b , ", c =" , c ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = 10 NEWLINE b = 20 NEWLINE c = 30 NEWLINE print ( "Before swapping a =" , a , ", b =" , b , ", c =" , c ) NEWLINE swapThree ( a , b , c ) NEWLINE NL DEDENT ENDMARKER
def sum ( a , b , c , d , x ) : NEWLINE INDENT ans = ( ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ) ; NEWLINE return ans ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a , b , c , d , x = 1 , 2 , 9 , 13 , 5 ; NEWLINE print ( sum ( a , b , c , d , x ) ) ; NEWLINE NL DEDENT ENDMARKER
''' 1393a Rainbow Dash, Fluttershy and Chess coloring ''' NEWLINE for _ in range ( int ( input ( ) ) ) : NEWLINE INDENT print ( int ( input ( ) ) // 2 + 1 ) NEWLINE NL DEDENT ENDMARKER
R = lambda : map ( int , input ( ) . split ( ) ) n , m = R ( ) a = set ( range ( 1 , n + 1 ) ) for i in range ( m ) : a = a - set ( R ( ) ) a = list ( a ) [ 0 ] print ( n - 1 ) for i in range ( 1 , n + 1 ) : if i != a : print ( a , i ) NEWLINE NL ENDMARKER
a = input ( ) n = len ( a ) ans = 1 c = 0 for i in range ( n - 1 ) : if int ( a [ i + 1 ] ) + int ( a [ i ] ) == 9 : c += 1 else : if c % 2 == 0 and c != 0 : NEWLINE NL ENDMARKER
x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) )  if x1 == x2 : x3 = x1 + abs ( y2 - y1 ) x4 = x3 y3 = y1 y4 = y2 NEWLINE NL ENDMARKER
from sys import stdin , stdout  def main ( ) : for _ in range ( int ( stdin . readline ( ) ) ) : s = int ( stdin . readline ( ) ) x = 0 while s >= 10 : q = s // 10 r = s % 10 s = q + r x += q * 10 x += s stdout . write ( str ( x ) + '\n' )  if __name__ == "__main__" : main ( ) NEWLINE NL ENDMARKER
"""Code of Ayush TiwariCodeforces: servermonkCodechef: ayush572000""" NEWLINE NL ENDMARKER
def numLen ( K ) : NEWLINE INDENT if ( K % 2 == 0 or K % 5 == 0 ) : NEWLINE INDENTINDENT return - 1 ; NEWLINE DEDENT number = 0 ; NEWLINE len = 1 ; NEWLINE for len in range ( 1 , K + 1 ) : NEWLINE INDENTINDENT number = number * 10 + 1 ; NEWLINE if ( ( number % K == 0 ) ) : NEWLINE INDENTINDENTINDENT return len ; NEWLINE DEDENT DEDENT return - 1 ; NEWLINE DEDENT K = 7 ; NEWLINE print ( numLen ( K ) ) ; NEWLINE NL ENDMARKER
import math NEWLINE def minOperations ( A , B ) : NEWLINE INDENT if ( A > B ) : NEWLINE INDENTINDENT swap ( A , B ) NEWLINE DEDENT B = B // math . gcd ( A , B ) ; NEWLINE return B - 1 NEWLINE DEDENT A = 7 NEWLINE B = 15 NEWLINE print ( minOperations ( A , B ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) res = 0 for a in range ( 1 , n ) : for b in range ( a + 1 , n + 1 ) : c = a ^ b if c >= b and c <= n and ( a + b > c ) and ( a + c > b ) and ( b + c > a ) and ( a ^ b ^ c == 0 ) : res += 1 print ( res ) NEWLINE NL ENDMARKER
a , b , c = map ( int , input ( ) . split ( ) ) print ( 2 * min ( a , b ) + 2 * c + ( 0 if a == b else 1 ) ) NEWLINE NL ENDMARKER
import math NEWLINE def countNumbers ( N ) : NEWLINE INDENT return int ( math . sqrt ( N ) ) - 1 NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 36 NEWLINE print ( countNumbers ( N ) ) NEWLINE NL DEDENT ENDMARKER
from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( 'input.txt' ) ) : stdin = open ( "input.txt" , "r" ) import time NEWLINE NL ENDMARKER
t = int ( input ( ) ) i = 1 k = 0 x = 0 while x < t : x = x + i i = i * 2 k = k + 1 print ( k ) NEWLINE NL ENDMARKER
def countDivisibles ( A , B , M ) : NEWLINE INDENT counter = 0 ; NEWLINE for i in range ( A , B ) : NEWLINE INDENTINDENT if ( i % M == 0 ) : NEWLINE INDENTINDENTINDENT counter = counter + 1 NEWLINE DEDENT DEDENT return counter NEWLINE DEDENT A = 30 NEWLINE B = 100 NEWLINE M = 30 NEWLINE print ( countDivisibles ( A , B , M ) ) NEWLINE NL ENDMARKER
def getRemainder ( num , divisor ) : NEWLINE INDENT return ( num - divisor * ( num // divisor ) ) NEWLINE DEDENT num = 100 NEWLINE divisor = 7 NEWLINE print ( getRemainder ( num , divisor ) ) NEWLINE NL ENDMARKER
n , x = map ( int , input ( ) . split ( ) ) count = 0 for i in range ( 1 , n + 1 ) : if x % i == 0 and x // i <= n and i <= n : count = count + 1 print ( count ) NEWLINE NL ENDMARKER
def sum_of_series ( n ) : NEWLINE INDENT result = 0 NEWLINE if ( n % 2 == 0 ) : NEWLINE INDENTINDENT result = - ( n * ( n + 1 ) ) // 2 NEWLINE DEDENT else : NEWLINE INDENTINDENT result = ( n * ( n + 1 ) ) // 2 NEWLINE DEDENT return result NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 3 NEWLINE print ( sum_of_series ( n ) ) NEWLINE n = 10 NEWLINE print ( sum_of_series ( n ) ) NEWLINE NL DEDENT ENDMARKER
def sum ( k , n ) : NEWLINE INDENT sum = ( pow ( k , n + 1 ) - pow ( k - 1 , n + 1 ) ) ; NEWLINE return sum ; NEWLINE DEDENT n = 3 ; NEWLINE K = 3 ; NEWLINE print ( sum ( K , n ) ) ; NEWLINE NL ENDMARKER
def nthTerm ( N ) : NEWLINE INDENT nth = 0 NEWLINE nth = ( N * N * ( N + 1 ) ) // 2 NEWLINE return nth NEWLINE DEDENT N = 5 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL ENDMARKER
from bisect import bisect_leftn , k = map ( int , input ( ) . split ( ) ) NEWLINE q = "abcdefghijklmnopqrstuvwxyz" NEWLINE a = { i : [ ] for i in q }  for key , value in enumerate ( input ( ) ) : a [ value ] . append ( key ) NEWLINE NL ENDMARKER
def min_elimination ( n , arr ) : NEWLINE INDENT countOdd = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT if ( arr [ i ] % 2 ) : NEWLINE INDENTINDENTINDENT countOdd += 1 NEWLINE DEDENT DEDENT return min ( countOdd , n - countOdd ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 1 , 2 , 3 , 7 , 9 ] NEWLINE n = len ( arr ) NEWLINE print ( min_elimination ( n , arr ) ) NEWLINE NL DEDENT ENDMARKER
for i in range ( int ( input ( ) ) ) : a , b , n = map ( int , input ( ) . split ( ' ' ) ) g = [ a , b , a ^ b ] print ( g [ n % 3 ] ) NEWLINE NL ENDMARKER
def sumOfSeries ( num ) : NEWLINE INDENT res = 0 NEWLINE fact = 1 NEWLINE for i in range ( 1 , num + 1 ) : NEWLINE INDENTINDENT fact *= i NEWLINE res = res + ( i / fact ) NEWLINE DEDENT return res NEWLINE DEDENT n = 5 NEWLINE print ( "Sum: " , sumOfSeries ( n ) ) NEWLINE NL ENDMARKER
s = input ( ) t = [ 0 ] * 4 d = { } for i , c in enumerate ( s ) : if c == "!" : t [ i % 4 ] += 1 else : d [ c ] = i % 4 for c in "RBYG" : print ( t [ d [ c ] ] , end = " " ) NEWLINE NL ENDMARKER
def findPoint ( x1 , y1 , x2 , y2 ) : NEWLINE INDENT print ( "(" , 2 * x2 - x1 , "," , 2 * y2 - y1 , ")" ) ; NEWLINE DEDENT x1 = 0 ; NEWLINE y1 = 0 ; NEWLINE x2 = 1 ; NEWLINE y2 = 1 ; NEWLINE findPoint ( x1 , y1 , x2 , y2 ) ; NEWLINE NL ENDMARKER
pos = input ( ) NEWLINE if pos . find ( "0000000" ) != - 1 or pos . find ( "1111111" ) != - 1 : NEWLINE INDENT print ( "YES" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "NO" ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) l = [ ] q = [ 0 ] * 100 p = list ( map ( int , input ( ) . split ( ) ) ) l . append ( p ) for i in range ( n - 1 ) : p = list ( map ( int , input ( ) . split ( ) ) ) l . append ( p ) for k in range ( p [ 0 ] , p [ 1 ] ) : q [ k ] = 1 r = 0 for i in range ( l [ 0 ] [ 0 ] , l [ 0 ] [ 1 ] ) : if ( q [ i ] == 0 ) : r = r + 1 print ( r ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) home = input ( ) L = [ ] for i in range ( n ) : L . append ( input ( ) ) NEWLINE NL ENDMARKER
class Solution : NEWLINE INDENT def isOneBitCharacter ( self , bits : List [ int ] ) -> bool : NEWLINE INDENTINDENT pos = 0 NEWLINE while pos < len ( bits ) - 1 : NEWLINE INDENTINDENTINDENT pos += bits [ pos ] + 1 NEWLINE DEDENT return pos == len ( bits ) - 1 NEWLINE NL DEDENT DEDENT ENDMARKER
num = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )  mx = max ( arr )  print ( max ( 0 , mx - 25 ) )          NEWLINE NL ENDMARKER
k , r = map ( int , input ( ) . split ( " " ) ) i , m = 1 , kwhile m % 10 != r and m % 10 != 0 : i += 1 m = k * iprint ( i ) NEWLINE NL ENDMARKER
def printElements ( arr , n ) : NEWLINE INDENT for i in range ( 1 , n - 1 , 1 ) : NEWLINE INDENTINDENT if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) : NEWLINE INDENTINDENTINDENT print ( arr [ i ] , end = " " ) NEWLINE DEDENT DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 ] NEWLINE n = len ( arr ) NEWLINE printElements ( arr , n ) NEWLINE NL DEDENT ENDMARKER
def isDivisible ( n ) : NEWLINE INDENT while n // 100 : NEWLINE INDENTINDENT d = n % 10 NEWLINE n //= 10 NEWLINE n -= d * 4 NEWLINE DEDENT return n % 41 == 0 NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 104413920565933 NEWLINE if isDivisible ( n ) : NEWLINE INDENTINDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) NEWLINE NL DEDENT DEDENT ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return 3 * pow ( n , 2 ) + n - 2 NEWLINE DEDENT N = 4 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) NEWLINE if ( m < 2 * n ) : NEWLINE INDENT print ( "YES" ) else : NEWLINE print ( "NO" )  NEWLINE NL DEDENT ENDMARKER
from collections import defaultdictfrom collections import dequeclass graph : def __init__ ( self , V ) : self . nodes = defaultdict ( list ) self . V = V self . edges = [ ] def addEdge ( self , u , v ) : self . nodes [ u ] . append ( v ) self . nodes [ v ] . append ( u ) NEWLINE NL ENDMARKER
def pentagon_pyramidal ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT p = ( 3 * i * i - i ) / 2 NEWLINE sum = sum + p NEWLINE DEDENT return sum NEWLINE DEDENT n = 4 NEWLINE print ( int ( pentagon_pyramidal ( n ) ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) ; l = list ( map ( int , input ( ) . split ( ) ) ) ; l . sort ( ) l2 = l [ : len ( l ) // 2 ] ; l1 = l [ len ( l ) // 2 : ] print ( l1 [ - 1 ] , * l2 [ 1 : ] , * l1 [ : - 1 ] , l2 [ 0 ] ) NEWLINE NL ENDMARKER
def ladder_pattern ( N ) : NEWLINE INDENT for i in range ( N + 1 ) : NEWLINE INDENTINDENT print ( "*   *" ) ; NEWLINE print ( "*   *" ) ; NEWLINE if ( i < N ) : NEWLINE INDENTINDENTINDENT print ( "*****" ) ; NEWLINE DEDENT DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 3 ; NEWLINE ladder_pattern ( N ) ; NEWLINE NL DEDENT ENDMARKER
from sys import stdinn = int ( stdin . readline ( ) ) a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) a = [ i - 1 for i in a ] ans = 0 pos = 0 while pos < n : ans += 1 mx_val = pos while pos < n and pos <= mx_val : mx_val = max ( mx_val , a [ pos ] ) pos += 1  print ( ans ) NEWLINE NL ENDMARKER
n , a , b = map ( int , input ( ) . split ( ) )  s = 0 drctn = 1 if b >= 0 else - 1 while s < abs ( b ) : a += 1 * drctn s += 1  if a > n : a = 1 elif a <= 0 : a = n  print ( a ) NEWLINE NL ENDMARKER
p , vd , t , f , c = [ int ( input ( ) ) for i in range ( 5 ) ] if p >= vd : exit ( print ( 0 ) ) cur = ( p * t * vd ) / ( vd - p ) ans = 0 while c > cur : ans += 1 cur += p * ( 2 * cur + f * vd ) / ( vd - p ) print ( ans ) NEWLINE NL ENDMARKER
a = 0 for i in range ( int ( input ( ) ) ) : s , d = list ( map ( int , input ( ) . split ( ) ) ) a += 1 while a < s or ( a - s ) % d != 0 : a += 1 print ( a ) NEWLINE NL ENDMARKER
'''Description: https://blog.csdn.net/qq_45859188Author: NEFU AB_INversion: 1.0Date: 2021-03-14 09:56:33LastEditors: NEFU AB_INLastEditTime: 2021-03-20 18:45:06''' import math  def solve ( ) : n , x = map ( int , input ( ) . split ( ) ) print ( 2 * x ) for _ in range ( int ( input ( ) ) ) : solve ( ) NEWLINE NL ENDMARKER
def squareSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 0 , n + 1 ) : NEWLINE INDENTINDENT sum += ( 2 * i ) * ( 2 * i ) NEWLINE DEDENT return sum NEWLINE DEDENT ans = squareSum ( 8 ) NEWLINE print ( ans ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) arr = list ( input ( ) . split ( ) ) ans = 0 for i in arr : if i . count ( '4' ) + i . count ( '7' ) <= k : ans += 1 print ( ans ) NEWLINE NL ENDMARKER
def nthTerm ( N ) : NEWLINE INDENT return ( N * ( ( N % 2 ) + ( N % 3 ) ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 5 NEWLINE print ( "Nth term for N = " , N , " : " , nthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
n , l , m , a = int ( input ( ) ) , [ 0 ] * 1000000 , 0 , [ ] for _ in range ( n ) : a . append ( input ( ) ) for i in range ( n ) : v = int ( a [ i ] [ 2 : ] ) if a [ i ] [ 0 ] == '+' : l [ v - 1 ] = 1 elif not l [ v - 1 ] : m += 1 ans = mfor i in range ( n ) : if a [ i ] [ 0 ] == '+' : m += 1 ; ans = max ( m , ans ) else : m -= 1 print ( ans ) NEWLINE NL ENDMARKER
a , b , c = map ( int , input ( ) . split ( ) )  divs = [ 1 ] * 1000001 mod = 1073741824  for i in range ( 2 , 1000001 ) : for j in range ( i , 1000001 , i ) : divs [ j ] += 1  ans = 0 for i in range ( 1 , a + 1 ) : for j in range ( 1 , b + 1 ) : for k in range ( 1 , c + 1 ) : ans += ( divs [ i * j * k ] ) % mod  print ( ans % ( mod * 2 ** 30 ) ) NEWLINE NL ENDMARKER
def minimumProduct ( arr , n ) : NEWLINE INDENT arr = sorted ( arr ) NEWLINE product = 1 NEWLINE for i in range ( 0 , n , 2 ) : NEWLINE INDENTINDENT product *= ( arr [ i ] + arr [ i + 1 ] ) NEWLINE DEDENT return product NEWLINE DEDENT arr = [ 1 , 6 , 3 , 1 , 7 , 8 ] NEWLINE n = len ( arr ) NEWLINE print ( minimumProduct ( arr , n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) NEWLINE for i in range ( n ) : m = int ( input ( ) ) NEWLINE print ( m ) NEWLINE print ( * [ k for k in range ( 1 , m + 1 ) ] ) NEWLINE NL ENDMARKER
def alternate ( a , b , x ) : NEWLINE INDENT x = a ^ b ^ x NEWLINE print ( "After exchange" ) NEWLINE print ( "x is" , x ) NEWLINE DEDENT a = - 10 NEWLINE b = 15 NEWLINE x = a NEWLINE print ( "x is" , x ) NEWLINE alternate ( a , b , x ) NEWLINE NL ENDMARKER
s = list ( input ( ) ) s [ 0 ] = s [ 0 ] . upper ( ) print ( '' . join ( map ( str , s ) ) ) NEWLINE NL ENDMARKER
for i in range ( int ( input ( ) ) ) : n = 360 / ( 180 - int ( input ( ) ) ) print ( "YES" if int ( n ) == n else "NO" ) NEWLINE NL ENDMARKER
def prints ( a , n , ind ) : NEWLINE INDENT i = ind NEWLINE while i < n + ind : NEWLINE INDENTINDENT print ( a [ ( i % n ) ] , end = " " ) NEWLINE i = i + 1 NEWLINE DEDENT DEDENT a = [ 'A' , 'B' , 'C' , 'D' , 'E' , 'F' ] NEWLINE n = len ( a ) ; NEWLINE prints ( a , n , 3 ) ; NEWLINE NL ENDMARKER
def getsum ( x ) : NEWLINE INDENT return int ( ( x * ( x + 1 ) ) / 2 ) NEWLINE DEDENT def countJumps ( n ) : NEWLINE INDENT n = abs ( n ) NEWLINE ans = 0 NEWLINE while ( getsum ( ans ) < n or ( getsum ( ans ) - n ) & 1 ) : NEWLINE INDENTINDENT ans += 1 NEWLINE DEDENT return ans NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 9 NEWLINE print ( countJumps ( n ) ) NEWLINE NL DEDENT ENDMARKER
def toggleLastMBits ( n , m ) : NEWLINE INDENT num = ( 1 << m ) - 1 NEWLINE return ( n ^ num ) NEWLINE DEDENT n = 107 NEWLINE m = 4 NEWLINE print ( toggleLastMBits ( n , m ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) NEWLINE m = n // 2 l = n - mans = ( m + 1 ) * ( l + 1 ) NEWLINE if n % 2 == 1 : ans *= 2 NEWLINE print ( ans ) NEWLINE NL ENDMARKER
def LexicographicalMaxString ( str ) : NEWLINE INDENT mx = "" NEWLINE for i in range ( len ( str ) ) : NEWLINE INDENTINDENT mx = max ( mx , str [ i : ] ) NEWLINE DEDENT return mx NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT str = "ababaa" NEWLINE print ( LexicographicalMaxString ( str ) ) NEWLINE NL DEDENT ENDMARKER
s = input ( )  i = 0 NEWLINE t = [ ] NEWLINE while i < len ( s ) : j = i NEWLINE while j + 1 < len ( s ) and s [ j + 1 ] == s [ i ] : j += 1 NEWLINE if ( j - i + 1 ) % 2 == 1 : if NEWLINE t and t [ - 1 ] == s [ i ] : t . pop ( ) else : t . append ( s [ i ] ) NEWLINE i = j + 1  print ( '' . join ( t ) ) NEWLINE NL ENDMARKER
I = lambda : map ( int , input ( ) . split ( ) ) n , m = I ( ) x = sum ( a % 2 for a in I ( ) ) y = sum ( b % 2 for b in I ( ) ) print ( min ( x , m - y ) + min ( y , n - x ) ) NEWLINE NL ENDMARKER
def countNumber ( n ) : NEWLINE INDENT return ( pow ( 10 , n ) - 1 ) - ( pow ( 10 , n ) - pow ( 8 , n ) ) // 2 NEWLINE DEDENT n = 2 NEWLINE print ( countNumber ( n ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n , x = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( )  start = int ( x / a [ - 1 ] ) * a [ - 1 ] ans = int ( x / a [ - 1 ] ) diff = x - start temp = ans for i in a : if i > diff and start != 0 : ans += 1 break elif i == diff : ans += 1 break if temp == ans : ans += 2 if x % a [ - 1 ] == 0 : ans = int ( x / a [ - 1 ] ) print ( ans ) NEWLINE NL ENDMARKER
num = input ( )  arr = input ( ) . split ( )  mx = 0 ct = 0 for word in arr : for char in word : if char . isupper ( ) : ct += 1 mx = max ( mx , ct ) ct = 0  print ( mx )  NEWLINE NL ENDMARKER
a , b = input ( ) , input ( ) NEWLINE c = [ 0 ] * len ( a ) NEWLINE for i in range ( len ( a ) ) : if NEWLINE a [ i ] != b [ i ] : c [ i ] = 1 NEWLINE print ( * c , sep = '' ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) if m == 0 : print ( "YES" ) exit ( ) a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) if a [ 0 ] == 1 or a [ - 1 ] == n : print ( "NO" ) exit ( ) x = 0 for i in range ( m - 1 ) : if a [ i ] + 1 == a [ i + 1 ] : x += 1 if x == 2 : print ( "NO" ) exit ( ) else : x = 0 print ( "YES" ) NEWLINE NL ENDMARKER
def numberOfPaths ( m , n ) : NEWLINE INDENT if ( m == 1 or n == 1 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) NEWLINE DEDENT m = 3 NEWLINE n = 3 NEWLINE print ( numberOfPaths ( m , n ) ) NEWLINE NL ENDMARKER
def findSum ( arr , n , k ) : NEWLINE INDENT ans = arr [ n - k - 1 ] - arr [ 0 ] ; NEWLINE for i in range ( 1 , k + 1 ) : NEWLINE INDENTINDENT ans = min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; NEWLINE DEDENT return ans ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 1 , 2 , 100 , 120 , 140 ] ; NEWLINE k = 2 ; NEWLINE n = len ( arr ) ; NEWLINE print ( findSum ( arr , n , k ) ) ; NEWLINE NL DEDENT ENDMARKER
n = input ( ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( reverse = True ) count = 0 ans = sum ( l ) for i in range ( len ( l ) ) : count += l [ i ] if ( count > ans / 2 ) : print ( i + 1 ) break NEWLINE NL ENDMARKER
def sumOfDigit ( n , b ) : NEWLINE INDENT unitDigit = 0 NEWLINE sum = 0 NEWLINE while ( n > 0 ) : NEWLINE INDENTINDENT unitDigit = n % b NEWLINE sum += unitDigit NEWLINE n = n // b NEWLINE DEDENT return sum NEWLINE DEDENT n = 50 NEWLINE b = 2 NEWLINE print ( sumOfDigit ( n , b ) ) NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readline NEWLINE NL ENDMARKER
import mathm , n = map ( int , input ( ) . split ( ) ) while True : NEWLINE NL ENDMARKER
def series ( A , X , n ) : NEWLINE INDENT term = pow ( A , n ) NEWLINE print ( term , end = " " ) NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT term = int ( term * X * ( n - i + 1 ) / ( i * A ) ) NEWLINE print ( term , end = " " ) NEWLINE DEDENT DEDENT A = 3 ; X = 4 ; n = 5 NEWLINE series ( A , X , n ) NEWLINE NL ENDMARKER
input ( ) nums = map ( int , str ( input ( ) ) . split ( ' ' ) ) print ( ' ' . join ( map ( str , map ( lambda x : x if x % 2 == 1 else x - 1 , nums ) ) ) ) NEWLINE NL ENDMARKER
def findTrailingZeros ( n ) : NEWLINE INDENT if ( n & 1 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT else : NEWLINE INDENTINDENT ans = 0 NEWLINE n //= 2 NEWLINE while ( n ) : NEWLINE INDENTINDENTINDENT ans += n // 5 NEWLINE n //= 5 NEWLINE DEDENT return ans NEWLINE DEDENT DEDENT n = 12 NEWLINE print ( findTrailingZeros ( n ) ) NEWLINE NL ENDMARKER
x , y , z = map ( int , input ( ) . split ( ) ) if y >= x and z >= x : print ( "Yes" ) else : print ( "No" ) NEWLINE NL ENDMARKER
import math as mt NEWLINE def sph ( r , R , h ) : NEWLINE INDENT if ( r < 0 and R < 0 and h < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT x = r NEWLINE V = ( 4 * 3.14 * pow ( r , 3 ) ) / 3 NEWLINE return V NEWLINE DEDENT r , R , h = 5 , 8 , 11 NEWLINE print ( sph ( r , R , h ) ) NEWLINE NL ENDMARKER
str = "geeksforgeeks" ; NEWLINE str = "" . join ( reversed ( str ) ) NEWLINE print ( str ) ; NEWLINE NL ENDMARKER
import osimport NEWLINE sysfrom NEWLINE io NEWLINE import BytesIO , IOBase NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) ev = 0 od = 0  for i in range ( len ( l ) ) : if ( l [ i ] % 2 == 0 ) : ev += 1 else : od += 1  print ( min ( ev , od ) ) NEWLINE NL ENDMARKER
def numberOfDays ( a , b , n ) : NEWLINE INDENT Days = b * ( n + a ) // ( a + b ) NEWLINE return Days NEWLINE DEDENT a = 10 NEWLINE b = 20 NEWLINE n = 5 NEWLINE print ( numberOfDays ( a , b , n ) ) NEWLINE NL ENDMARKER
n , m , k = map ( int , input ( ) . split ( ) ) if k == - 1 and n % 2 != m % 2 : print ( 0 ) else : print ( pow ( 2 , ( n - 1 ) * ( m - 1 ) , 10 ** 9 + 7 ) ) NEWLINE NL ENDMARKER
def PowerOFPINnfactorial ( n , p ) : NEWLINE INDENT ans = 0 NEWLINE temp = p NEWLINE while ( temp <= n ) : NEWLINE INDENTINDENT ans += n / temp NEWLINE temp = temp * p NEWLINE DEDENT return int ( ans ) NEWLINE DEDENT print ( PowerOFPINnfactorial ( 4 , 2 ) ) NEWLINE NL ENDMARKER
def nthTerm ( N ) : NEWLINE INDENT return N * N + ( N + 1 ) * ( N + 1 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 3 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
lectura = input ( ) sufix = set ( ) comb = { ( len ( lectura ) , 2 ) } setPrueba = set ( ) while comb : x , y = comb . pop ( ) pos3 = x + y for i in [ y , 5 - y ] : posIni = x - i stringActual = ( posIni , i ) if ( stringActual in setPrueba or ( posIni < 5 ) or ( lectura [ posIni : x ] == lectura [ x : pos3 ] ) ) : NEWLINE NL ENDMARKER
def difference ( n ) : NEWLINE INDENT S = ( n * ( n + 1 ) ) // 2 ; NEWLINE res = S * ( S - 1 ) ; NEWLINE return res ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 5 ; NEWLINE print ( difference ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
def remainder ( st ) : NEWLINE INDENT ln = len ( st ) NEWLINE rem = 0 NEWLINE for i in range ( 0 , ln ) : NEWLINE INDENTINDENT num = rem * 10 + ( int ) ( st [ i ] ) NEWLINE rem = num % 11 NEWLINE DEDENT return rem NEWLINE DEDENT st = "3435346456547566345436457867978" NEWLINE print ( remainder ( st ) ) NEWLINE NL ENDMARKER
import math as mt NEWLINE def ReuleauxArea ( a ) : NEWLINE INDENT if a < 0 : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT return 0.70477 * pow ( a , 2 ) NEWLINE DEDENT a = 6 NEWLINE print ( ReuleauxArea ( a ) ) NEWLINE NL ENDMARKER
from math import * NEWLINE def cal ( n ) : NEWLINE INDENT res = pow ( ceil ( ( pow ( pow ( 10 , ( n - 1 ) ) , 1 / 4 ) ) ) , 4 ) NEWLINE return int ( res ) NEWLINE DEDENT n = 1 NEWLINE print ( cal ( n ) ) NEWLINE NL ENDMARKER
a , = map ( int , input ( ) . split ( ) ) if a == 2 : print ( 2 ) else : print ( 1 ) NEWLINE NL ENDMARKER
def NumberOfRectangles ( n , m ) : NEWLINE INDENT if ( n % 2 == 0 ) : NEWLINE INDENTINDENT return ( n / 2 ) * m NEWLINE DEDENT elif ( m % 2 == 0 ) : NEWLINE INDENTINDENT return ( m // 2 ) * n NEWLINE DEDENT return ( n * m - 1 ) // 2 NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 3 NEWLINE m = 3 NEWLINE print ( NumberOfRectangles ( n , m ) ) NEWLINE NL DEDENT ENDMARKER
def maxRegions ( n ) : NEWLINE INDENT num = n * ( n + 1 ) // 2 + 1 NEWLINE print ( num ) NEWLINE DEDENT n = 10 NEWLINE maxRegions ( n ) NEWLINE NL ENDMARKER
nennum = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr . sort ( ) print ( arr [ ( len ( arr ) - 1 ) // 2 ] ) NEWLINE NL ENDMARKER
def getCount ( a , b ) : NEWLINE INDENT if ( len ( b ) % len ( a ) != 0 ) : NEWLINE INDENTINDENT return - 1 ; NEWLINE DEDENT count = int ( len ( b ) / len ( a ) ) NEWLINE a = a * count NEWLINE if ( a == b ) : NEWLINE INDENTINDENT return count NEWLINE DEDENT return - 1 ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = 'geeks' NEWLINE b = 'geeksgeeks' NEWLINE print ( getCount ( a , b ) ) NEWLINE NL DEDENT ENDMARKER
def NumberOfSolutions ( a , b , c , d ) : NEWLINE INDENT ans = 0 NEWLINE for i in range ( a , b + 1 ) : NEWLINE INDENTINDENT if d >= max ( c , i + 1 ) : NEWLINE INDENTINDENTINDENT ans += d - max ( c , i + 1 ) + 1 NEWLINE DEDENT DEDENT return ans NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a , b , c , d = 2 , 3 , 3 , 4 NEWLINE print ( NumberOfSolutions ( a , b , c , d ) ) NEWLINE NL DEDENT ENDMARKER
import math as mt NEWLINE def gcd ( a , b ) : NEWLINE INDENT while ( b != 0 ) : NEWLINE INDENTINDENT t = b NEWLINE b = a % b NEWLINE a = t NEWLINE DEDENT return a NEWLINE DEDENT def findMinDiff ( a , b , x , y ) : NEWLINE INDENT g = gcd ( a , b ) NEWLINE diff = abs ( x - y ) % g NEWLINE return min ( diff , g - diff ) NEWLINE DEDENT a , b , x , y = 20 , 52 , 5 , 7 NEWLINE print ( findMinDiff ( a , b , x , y ) ) NEWLINE NL ENDMARKER
import math NEWLINE def squareRoot ( n ) : NEWLINE INDENT return pow ( 2 , 0.5 * math . log2 ( n ) ) NEWLINE DEDENT n = 12 NEWLINE print ( squareRoot ( n ) ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) for r in range ( 1 , 10 ** 5 ) : if ( r * ( r + 1 ) ) // 2 + r == k + n : print ( n - r ) exit ( ) NEWLINE NL ENDMARKER
def countDivisors ( n , k ) : NEWLINE INDENT count = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT if ( n % i == 0 and i % k == 0 ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT return count NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n , k = 12 , 3 NEWLINE print ( countDivisors ( n , k ) ) NEWLINE NL DEDENT ENDMARKER
t = int ( input ( ) ) for _ in range ( t ) : n , k = list ( map ( int , input ( ) . split ( ) ) ) if n <= k : print ( k - n ) else : if ( n + k ) % 2 == 0 : print ( 0 ) else : print ( 1 ) NEWLINE NL ENDMARKER
from re import findallfrom typing import Iterator   def get_num_input ( ) -> Iterator [ int ] : return map ( int , input ( ) . split ( ) )   def main ( ) -> None : print ( sum ( map ( len , findall ( r"(?<=1)0+(?=1)" , input ( ) ) ) ) )   if __name__ == "__main__" : ONLY_ONCE : bool = False for _ in range ( 1 if ONLY_ONCE else int ( input ( ) ) ) : main ( ) NEWLINE NL ENDMARKER
for i in range ( int ( input ( ) ) ) : k , x = map ( int , input ( ) . split ( ) ) print ( 9 * ( k - 1 ) + x ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) NEWLINE for _ in range ( t ) : n = int ( input ( ) ) NEWLINE sum1 = 0 NEWLINE base = 1 NEWLINE ans = 0 NEWLINE while sum1 <= n : sum1 += ( base * ( base + 1 ) ) // 2 NEWLINE base = ( base * 2 ) + 1 NEWLINE ans += 1 NEWLINE print ( ans - 1 ) NEWLINE NL ENDMARKER
def getParity ( n ) : NEWLINE INDENT parity = 0 NEWLINE while n : NEWLINE INDENTINDENT parity = ~ parity NEWLINE n = n & ( n - 1 ) NEWLINE DEDENT return parity NEWLINE DEDENT n = 7 NEWLINE print ( "Parity of no " , n , " = " , ( "odd" if getParity ( n ) else "even" ) ) NEWLINE NL ENDMARKER
a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) ; if a * c * e < b * d * f or a == 0 and b * d > 0 or c == 0 and d > 0 : print ( "Ron" ) ; else : print ( "Hermione" ) ; NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) if k == 0 or n == 1 : print ( 0 ) elif k >= n // 2 : print ( ( ( n - 1 ) * n ) // 2 ) else : ans = 0 for i in range ( 1 , n + 1 ) : if i <= k : ans += n - i elif i <= n - k : ans += k for j in range ( k - 1 , - 1 , - 1 ) : ans += j print ( ans ) NEWLINE NL ENDMARKER
def printAP ( a , d , n ) : NEWLINE INDENT curr_term NEWLINE DEDENT curr_term = a NEWLINE INDENT for i in range ( 1 , n + 1 ) : NEWLINE DEDENT print ( curr_term , end = ' ' ) NEWLINE INDENT curr_term = curr_term + d NEWLINE DEDENT a = 2 NEWLINE d = 1 NEWLINE n = 5 NEWLINE printAP ( a , d , n ) NEWLINE NL ENDMARKER
def Minsteps ( n , m ) : NEWLINE INDENT ans = 0 NEWLINE while ( m > n ) : NEWLINE INDENTINDENT if ( m & 1 ) : NEWLINE INDENTINDENTINDENT m += 1 NEWLINE ans += 1 NEWLINE DEDENT m //= 2 NEWLINE ans += 1 NEWLINE DEDENT return ans + n - m NEWLINE DEDENT n = 4 NEWLINE m = 6 NEWLINE print ( Minsteps ( n , m ) ) NEWLINE NL ENDMARKER
def pairAndSum ( arr , n ) : NEWLINE INDENT ans = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT for j in range ( ( i + 1 ) , n ) : NEWLINE INDENTINDENTINDENT ans = ans + arr [ i ] & arr [ j ] NEWLINE DEDENT DEDENT return ans NEWLINE DEDENT arr = [ 5 , 10 , 15 ] NEWLINE n = len ( arr ) NEWLINE print ( pairAndSum ( arr , n ) ) NEWLINE NL ENDMARKER
s = list ( str ( input ( ) ) ) k = int ( input ( ) ) r = 0 possible = Trueif len ( s ) < k : possible = Falseelse : r = k - len ( set ( s ) ) r = 0 if r < 0 else rprint ( r if possible else "impossible" ) NEWLINE NL ENDMARKER
def sumProductDifference ( a , b , c , d , e ) : NEWLINE INDENT rootSum = ( - 1 * b ) / a NEWLINE rootProduct = e / a NEWLINE return abs ( rootSum - rootProduct ) NEWLINE DEDENT print ( sumProductDifference ( 8 , 4 , 6 , 4 , 1 ) ) NEWLINE NL ENDMARKER
for case in range ( int ( input ( ) ) ) : c , s = [ int ( x ) for x in input ( ) . split ( ) ] mn = s // c c2 = 0 if mn != 0 : c2 = s % c else : c2 = s  c -= c2 NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) if m < n or n == 2 : print ( - 1 ) else : print ( 2 * sum ( a ) ) for i in range ( n ) : print ( i + 1 , max ( 1 , ( i + 2 ) % ( n + 1 ) ) ) NEWLINE NL ENDMARKER
import math NEWLINE def distance ( x1 , y1 , x2 , y2 ) : NEWLINE INDENT return math . sqrt ( math . pow ( x2 - x1 , 2 ) + math . pow ( y2 - y1 , 2 ) * 1.0 ) NEWLINE DEDENT print ( "%.6f" % distance ( 3 , 4 , 4 , 3 ) ) NEWLINE NL ENDMARKER
NumUnsignBits = 64 ; NEWLINE def findNum ( x ) : NEWLINE INDENT for i in range ( NumUnsignBits - 1 ) : NEWLINE INDENTINDENT if ( ( ( x >> i ) & 1 ) != ( ( x >> ( i + 1 ) ) & 1 ) ) : NEWLINE INDENTINDENTINDENT x ^= ( 1 << i ) | ( 1 << ( i + 1 ) ) ; NEWLINE return x ; NEWLINE DEDENT DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 92 ; NEWLINE print ( findNum ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) x = 0 y = 0 for i in range ( 0 , n ) : z = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) x = x - z [ 0 ] x = x + z [ 1 ] if y < x : y = xprint ( y ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) m = n // 2 + 1 print ( m ) for i in range ( n ) : print ( i // 2 + 1 , i // 2 + 1 + i % 2 ) NEWLINE NL ENDMARKER
def countStrings ( s ) : NEWLINE INDENT sum = 1 NEWLINE for i in range ( len ( s ) ) : NEWLINE INDENTINDENT if ( i % 2 == 0 and s [ i ] == '$' ) : NEWLINE INDENTINDENTINDENT sum *= 21 NEWLINE DEDENT elif ( s [ i ] == '$' ) : NEWLINE INDENTINDENTINDENT sum *= 5 NEWLINE DEDENT DEDENT return sum NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT str = "s$$e$" NEWLINE print ( countStrings ( str ) ) NEWLINE NL DEDENT ENDMARKER
n , t = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) i = 1 while i < t : i += a [ i - 1 ] print ( 'YES' if i == t else 'NO' ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) ax , ay = map ( int , input ( ) . split ( ) ) NEWLINE NL ENDMARKER
def newvol ( x ) : NEWLINE INDENT print ( "percentage increase in the volume of the cylinder is " , x , "%" ) NEWLINE DEDENT x = 10.0 NEWLINE newvol ( x ) NEWLINE NL ENDMARKER
from collections import Countera = list ( input ( ) ) b = list ( input ( ) ) d1 = Counter ( a ) c = 0 d2 = Counter ( b ) for i in d2 : if i in d1 : if d1 [ i ] < d2 [ i ] : c += d1 [ i ] else : c += d2 [ i ] else : c = 0 breakif c == 0 : print ( - 1 ) else : print ( c ) NEWLINE NL ENDMARKER
print ( bin ( int ( input ( ) ) ) . count ( '1' ) ) NEWLINE NL ENDMARKER
def findpos ( n ) : NEWLINE INDENT i = 0 NEWLINE j = len ( n ) NEWLINE pos = 0 NEWLINE while ( i < j ) : NEWLINE INDENTINDENT if ( n [ i ] == '4' ) : NEWLINE INDENTINDENTINDENT pos = pos * 2 + 1 NEWLINE DEDENT if ( n [ i ] == '7' ) : NEWLINE INDENTINDENTINDENT pos = pos * 2 + 2 NEWLINE DEDENT i = i + 1 NEWLINE DEDENT return pos NEWLINE DEDENT n = "774" NEWLINE print ( findpos ( n ) ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) )  answer = n + n // ( m - 1 )  if n % ( m - 1 ) == 0 : answer -= 1  print ( answer ) NEWLINE NL ENDMARKER
n , d , h = map ( int , input ( ) . split ( ) ) if n == 2 : if d == h and d == 1 : print ( '1 2' ) else : print ( - 1 ) elif d == 1 or d > 2 * h : print ( - 1 ) else : for i in range ( h ) : print ( i + 1 , i + 2 ) for i in range ( d - h ) : print ( 1 if i == 0 else i + h + 1 , i + h + 2 ) for i in range ( d + 1 , n ) : print ( 2 if d == h else 1 , i + 1 )   NEWLINE NL ENDMARKER
p = [ ] for i in range ( 3 ) : p . append ( list ( map ( int , input ( ) . split ( ) ) ) ) print ( 3 ) print ( p [ 0 ] [ 0 ] + p [ 1 ] [ 0 ] - p [ 2 ] [ 0 ] , p [ 0 ] [ 1 ] + p [ 1 ] [ 1 ] - p [ 2 ] [ 1 ] ) print ( p [ 0 ] [ 0 ] + p [ 2 ] [ 0 ] - p [ 1 ] [ 0 ] , p [ 0 ] [ 1 ] + p [ 2 ] [ 1 ] - p [ 1 ] [ 1 ] ) print ( p [ 1 ] [ 0 ] + p [ 2 ] [ 0 ] - p [ 0 ] [ 0 ] , p [ 1 ] [ 1 ] + p [ 2 ] [ 1 ] - p [ 0 ] [ 1 ] ) NEWLINE NL ENDMARKER
def sn ( n , an ) : NEWLINE INDENT return ( n * ( 1 + an ) ) / 2 ; NEWLINE DEDENT def trace ( n , m ) : NEWLINE INDENT an = 1 + ( n - 1 ) * ( m + 1 ) ; NEWLINE rowmajorSum = sn ( n , an ) ; NEWLINE an = 1 + ( n - 1 ) * ( n + 1 ) ; NEWLINE colmajorSum = sn ( n , an ) ; NEWLINE return int ( rowmajorSum + colmajorSum ) ; NEWLINE DEDENT N = 3 ; NEWLINE M = 3 ; NEWLINE print ( trace ( N , M ) ) ; NEWLINE NL ENDMARKER
def countNumbers ( X , Y , N ) : NEWLINE INDENT count = 0 ; NEWLINE for i in range ( 1 , N + 1 ) : NEWLINE INDENTINDENT if ( ( i % X == 0 ) and ( i % Y != 0 ) ) : NEWLINE INDENTINDENTINDENT count += 1 ; NEWLINE DEDENT DEDENT return count ; NEWLINE DEDENT X = 2 ; NEWLINE Y = 3 ; NEWLINE N = 10 ; NEWLINE print ( countNumbers ( X , Y , N ) ) ; NEWLINE NL ENDMARKER
import mathque = int ( input ( ) )  name = [ "Sheldon" , "Leonard" , "Penny" , "Rajesh" , "Howard" ]  n = 0 NEWLINE while que - 5 * math . pow ( 2 , n ) > 0 : que -= 5 * math . pow ( 2 , n ) NEWLINE n += 1  print ( name [ math . ceil ( que / math . pow ( 2 , n ) ) - 1 ] ) NEWLINE NL ENDMARKER
from math import gcd NEWLINE def minValidNumber ( p , q ) : NEWLINE INDENT if ( q % p == 0 ) : NEWLINE INDENTINDENT return gcd ( p , q ) NEWLINE DEDENT else : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT p , q = 2 , 6 ; NEWLINE print ( minValidNumber ( p , q ) ) NEWLINE NL DEDENT ENDMARKER
import mathn = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) c = 0 d = 0 for i in l : if i / 1 > 0 : c += 1 for i in l : if i / ( - 1 ) > 0 : d += 1 if c >= math . ceil ( n / 2 ) : print ( 1 ) elif d >= math . ceil ( n / 2 ) : print ( - 1 ) else : print ( 0 ) NEWLINE NL ENDMARKER
def sumOfSeries ( n ) : NEWLINE INDENT x = ( n * ( n + 1 ) / 2 ) NEWLINE return ( int ) ( x * x ) NEWLINE DEDENT n = 5 NEWLINE print ( sumOfSeries ( n ) ) NEWLINE NL ENDMARKER
def printSeries ( n ) : NEWLINE INDENT for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT num = i * ( i + 1 ) * ( i + 2 ) // 6 NEWLINE print ( num , end = ' ' ) NEWLINE DEDENT DEDENT n = 10 NEWLINE printSeries ( n ) NEWLINE NL ENDMARKER
def aliquotSum ( n ) : NEWLINE INDENT sm = 0 NEWLINE for i in range ( 1 , n ) : NEWLINE INDENTINDENT if ( n % i == 0 ) : NEWLINE INDENTINDENTINDENT sm = sm + i NEWLINE DEDENT DEDENT return sm NEWLINE DEDENT n = 12 NEWLINE print ( aliquotSum ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) p = [ int ( i ) for i in input ( ) . split ( ) ] b = [ int ( i ) for i in input ( ) . split ( ) ] ans = 0 visited = [ False for i in range ( n ) ] for i in range ( n ) : if visited [ i ] : continue ans += 1 while not visited [ i ] : visited [ i ] = True i = p [ i ] - 1 if ans == 1 : ans = 0 ans += ( sum ( b ) + 1 ) % 2 print ( ans ) NEWLINE NL ENDMARKER
import sys  def main ( ) : _ , s = sys . stdin . read ( ) . strip ( ) . split ( '\n' ) t = s . replace ( ' ' , '' ) . rstrip ( s [ - 1 ] ) return len ( t ) print ( main ( ) ) NEWLINE NL ENDMARKER
def countNonEmptySubstr ( str ) : NEWLINE INDENT n = len ( str ) ; NEWLINE return int ( n * ( n + 1 ) / 2 ) ; NEWLINE DEDENT s = "abcde" ; NEWLINE print ( countNonEmptySubstr ( s ) ) ; NEWLINE NL ENDMARKER
def adjacentSet ( n ) : NEWLINE INDENT return ( n & ( n >> 1 ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 3 NEWLINE if ( adjacentSet ( n ) ) : NEWLINE INDENTINDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) NEWLINE NL DEDENT DEDENT ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) arr = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] seg = 0 for i in range ( a , b + 1 ) : while ( i > 0 ) : x = int ( i % 10 ) seg += arr [ x ] i = i // 10 print ( seg ) NEWLINE NL ENDMARKER
exec ( int ( input ( ) ) * "print(int(input())//2);" ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ans = 10 ** 9 bestI = 0 for i in range ( k ) : score = 0 r = n // k while r > 0 : score += a [ i ] i += k if i >= n : i -= n r -= 1 if score < ans : ans = score bestI = i + 1 print ( bestI ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) NEWLINE print ( n * 3 // 2 ) NEWLINE NL ENDMARKER
def isMember ( a , d , x ) : NEWLINE INDENT if d == 0 : NEWLINE INDENTINDENT return x == a NEWLINE DEDENT return ( ( x - a ) % d == 0 & int ( ( x - a ) / d ) >= 0 ) NEWLINE DEDENT a = 1 NEWLINE x = 7 NEWLINE d = 3 NEWLINE if isMember ( a , d , x ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
def prod ( arr ) : p = 1 NEWLINE INDENT pass NEWLINE DEDENT for i in arr : p *= i NEWLINE return p   for test in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE lst = sorted ( list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) , reverse = True ) NEWLINE NL ENDMARKER
def factorial ( n ) : NEWLINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEWLINE DEDENT num = 5 NEWLINE print ( "Factorial of" , num , "is" , factorial ( num ) ) NEWLINE NL ENDMARKER
import sysfrom os import pathif ( path . exists ( 'input.txt' ) and path . exists ( 'output.txt' ) ) : sys . stdout = open ( 'output.txt' , 'w' ) sys . stdin = open ( 'input.txt' , 'r' )   def main ( ) : N = int ( input ( ) ) min_price = 200 ans = 0 for i in range ( N ) : a , p = map ( int , input ( ) . split ( ) ) min_price = min ( min_price , p ) ans += min_price * a print ( ans )  main ( ) NEWLINE NL ENDMARKER
from math import sqrt NEWLINE def countSteps ( n ) : NEWLINE INDENT steps = 0 ; NEWLINE while ( n ) : NEWLINE INDENTINDENT largest = int ( sqrt ( n ) ) ; NEWLINE n -= ( largest * largest ) ; NEWLINE steps += 1 ; NEWLINE DEDENT return steps ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 85 ; NEWLINE print ( countSteps ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return 5 * pow ( n , 2 ) - 5 * n NEWLINE DEDENT N = 4 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL ENDMARKER
na , nb = map ( int , input ( ) . split ( ) )  if na - nb == 8 : print ( 9 , 10 ) elif nb - na == 1 : print ( na * 10 + 9 , nb * 10 )  elif na == nb : print ( na * 10 , nb * 10 + 1 )  else : print ( - 1 )      NEWLINE NL ENDMARKER
import sysfrom math import sqrt , log , log2 , ceil , log10 , gcd , floor , pow , sin , cos , tan , pi , inf , factorialfrom copy import copy , deepcopyfrom sys import exit , stdin , stdoutfrom collections import Counter , defaultdict , dequefrom itertools import permutationsimport heapqfrom bisect import bisect_left from bisect import bisect_right NEWLINE NL ENDMARKER
def isDivisible ( n ) : NEWLINE INDENT while ( int ( n / 100 ) ) : NEWLINE INDENTINDENT last_digit = int ( n % 10 ) NEWLINE n = int ( n / 10 ) NEWLINE n += last_digit * 3 NEWLINE DEDENT return ( n % 29 == 0 ) NEWLINE DEDENT n = 348 NEWLINE if ( isDivisible ( n ) != 0 ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
def printFactorialNums ( n ) : NEWLINE INDENT fact = 1 NEWLINE x = 2 NEWLINE while fact <= n : NEWLINE INDENTINDENT print ( fact , end = " " ) NEWLINE fact = fact * x NEWLINE x += 1 NEWLINE DEDENT DEDENT n = 100 NEWLINE printFactorialNums ( n ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l1 = list ( map ( int , input ( ) . split ( ) ) ) d = dict . fromkeys ( l1 ) for i in l : if ( i in d ) : print ( i , end = ' ' ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) a = input ( ) mx , cur = 0 , 0 for ch in a : if ch == '.' : mx = max ( mx , cur ) cur = 0 else : cur += 1 print ( "YES" ) if mx < k else print ( "NO" )  '''* So I drown it out * Like I always do* Dancing through our house* With the ghost of you''' NEWLINE NL ENDMARKER
NL NL ENDMARKER
n = int ( input ( ) ) num = input ( ) s = [ ] for ch in num : s . append ( int ( ch ) ) s . sort ( ) total = sum ( s ) if total >= n : print ( 0 ) exit ( ) total = n - totali , count = 0 , 1  while i < len ( s ) : if ( 9 - s [ i ] ) < total : total -= 9 - s [ i ] count += 1 i += 1 else : print ( count ) exit ( ) NEWLINE NL ENDMARKER
def productAscii ( str ) : NEWLINE INDENT prod = 1 NEWLINE for i in range ( 0 , len ( str ) ) : NEWLINE INDENTINDENT prod = prod * ord ( str [ i ] ) NEWLINE DEDENT return prod NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT str = "GfG" NEWLINE print ( productAscii ( str ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) sq = n * nfor i in range ( 0 , int ( sq / 2 ) ) : print ( i + 1 , sq - i ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) if n == 1 : print ( 1 ) elif m - 1 < n - m : print ( m + 1 ) else : print ( m - 1 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) b = list ( map ( int , input ( ) . split ( ) ) ) l = [ 0 ] * ( m + n ) w = 0 for i in range ( m ) : for j in range ( n ) : z = b [ i ] / a [ j ] if ( z . is_integer ( ) ) : l [ j ] = z w += 1 for k in range ( l . count ( 0 ) ) : l . remove ( 0 ) t = max ( l ) print ( l . count ( t ) ) NEWLINE NL ENDMARKER
import mathimport collectionsimport bisect  def solve ( n , a ) : ans = 0 for i in range ( n ) : ans = max ( ans , min ( a [ i ] - 1 , 10 ** 6 - a [ i ] ) ) return ans  n = int ( input ( ) ) a = [ int ( s ) for s in input ( ) . split ( ) ] result = solve ( n , a ) print ( result ) NEWLINE NL ENDMARKER
def vowelOrConsonant ( x ) : NEWLINE INDENT if ( x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u' or x == 'A' or x == 'E' or x == 'I' or x == 'O' or x == 'U' ) : NEWLINE INDENTINDENT print ( "Vowel" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "Consonant" ) NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT vowelOrConsonant ( 'c' ) NEWLINE vowelOrConsonant ( 'E' ) NEWLINE NL DEDENT ENDMARKER
import syst1 , t2 , t = map ( int , input ( ) . split ( ) ) u = 1 n = int ( input ( ) ) if n == 0 : print ( t1 ) sys . exit ( ) a = [ int ( i ) for i in input ( ) . split ( ) ] mini = 10 ** 20 ans = 0 time = t1for x in a : if x <= t2 - t : if time - x + 1 < mini and x > 0 : mini = time - x + 1 if x - 1 > time : ans = time else : ans = x - 1 time = t + max ( time , x ) if time > t2 - t : print ( ans ) else : print ( time ) NEWLINE NL ENDMARKER
for _ in range ( 1 ) : n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) g = 1 for i in range ( n ) : if arr [ i ] < 0 : g = 0 break  if arr [ i ] % 2 == 0 : pass else : if i < n - 1 : arr [ i + 1 ] -= 1 else : g = 0  if g == 0 : print ( "NO" ) else : print ( "YES" ) NEWLINE NL ENDMARKER
from sys import stdinfrom collections import deque  n , S = [ int ( x ) for x in stdin . readline ( ) . split ( ) ]  ppl = [ ]  base = 0  tSlices = 0  for dude in range ( n ) : s , a , b = [ int ( x ) for x in stdin . readline ( ) . split ( ) ] base += s * a tSlices += s ppl . append ( [ b - a , s ] ) NEWLINE NL ENDMARKER
def findF_N ( n ) : NEWLINE INDENT ans = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT ans = ans + ( i + 1 ) * ( n - i - 1 ) NEWLINE DEDENT return ans NEWLINE DEDENT n = 3 NEWLINE print ( findF_N ( n ) ) NEWLINE NL ENDMARKER
T_ON = 0 DEBUG_ON = 0 MOD = 998244353   def solve ( ) : n = read_int ( ) q , r = divmod ( n , 7 ) MIN = q * 2 + max ( r - 5 , 0 ) MAX = q * 2 + min ( r , 2 ) print ( MIN , MAX )   def main ( ) : T = read_int ( ) if T_ON else 1 for i in range ( T ) : solve ( )   def debug ( * xargs ) : if DEBUG_ON : print ( * xargs )   from collections import * import math   NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 for i in range ( 1 , n ) : if l [ i ] + l [ i - 1 ] < k : ans = ans + k - l [ i ] - l [ i - 1 ] l [ i ] = l [ i ] + k - ( l [ i ] + l [ i - 1 ] ) print ( ans ) print ( * l ) NEWLINE NL ENDMARKER
import mathimport collections def solve ( n , l ) : return max ( l ) - ( sum ( l ) - max ( l ) ) + 1  n = int ( input ( ) ) l = [ int ( s ) for s in input ( ) . split ( ) ] result = solve ( n , l ) print ( result ) NEWLINE NL ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return 3 * pow ( n , 2 ) - 4 * n + 2 NEWLINE DEDENT N = 4 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL ENDMARKER
from math import sqrt NEWLINE def heightCalculate ( H , n , m ) : NEWLINE INDENT N = n * 1.0 NEWLINE M = m * 1.0 NEWLINE h = H * sqrt ( N / ( N + M ) ) NEWLINE return h NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT H = 10 NEWLINE n = 3 NEWLINE m = 4 NEWLINE print ( "{0:.6}" . format ( heightCalculate ( H , n , m ) ) ) ; NEWLINE NL DEDENT ENDMARKER
import sys  NEWLINE NL ENDMARKER
a , b , c = map ( int , input ( ) . split ( ) ) flag = 0 if b >= c : x = b - c a -= x if a >= 0 and a % 2 == 0 : z = a // 2 if c - z >= 0 : print ( x + z , c - z , z ) else : flag = 1 else : flag = 1 else : x = c - b a -= x if a >= 0 and a % 2 == 0 : z = a // 2 if b - z >= 0 : print ( z , b - z , x + z ) else : flag = 1 else : flag = 1 if flag : print ( "Impossible" ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = 0 ans = - 1 for i in range ( n - 1 ) : while c < n - 1 and a [ c + 1 ] - a [ i ] <= m : c += 1 if i < c - 1 : ans = max ( ans , ( a [ c ] - a [ i + 1 ] ) / ( a [ c ] - a [ i ] ) ) print ( ans ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) ans = "YES" num = 0 for i in range ( n ) : w , h = map ( int , input ( ) . split ( ) ) if i == 0 : num = max ( w , h ) else : if max ( w , h ) <= num : num = max ( w , h ) elif min ( w , h ) <= num : num = min ( w , h ) else : ans = "NO" print ( ans ) NEWLINE NL ENDMARKER
def anglechordtang ( z ) : NEWLINE INDENT print ( "The angle between tangent" , "and the chord is" , z , "degrees" ) ; NEWLINE DEDENT z = 48 ; NEWLINE anglechordtang ( z ) ; NEWLINE NL ENDMARKER
def compute ( ) : NEWLINE INDENT s = "" . join ( str ( i ) for i in range ( 1 , 1000000 ) ) NEWLINE ans = 1 NEWLINE for i in range ( 7 ) : NEWLINE INDENTINDENT ans *= int ( s [ 10 ** i - 1 ] ) NEWLINE DEDENT return str ( ans ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( compute ( ) ) NEWLINE NL DEDENT ENDMARKER
def isEven ( n ) : NEWLINE INDENT if ( n ^ 1 == n + 1 ) : NEWLINE INDENTINDENT return True ; NEWLINE DEDENT else : NEWLINE INDENTINDENT return False ; NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 100 ; NEWLINE print ( "Even" ) if isEven ( n ) else print ( "Odd" ) ; NEWLINE NL DEDENT ENDMARKER
def maxSum ( a , n ) : NEWLINE INDENT maxAnd = max ( a ) NEWLINE maxOR = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT maxOR |= a [ i ] NEWLINE DEDENT print ( maxAnd + maxOR ) NEWLINE DEDENT n = 4 NEWLINE a = [ 3 , 5 , 6 , 1 ] NEWLINE maxSum ( a , n ) NEWLINE NL ENDMARKER
import math NEWLINE def countSC ( N ) : NEWLINE INDENT res = ( int ( math . sqrt ( N ) ) + int ( N ** ( 1 / 3 ) ) - int ( math . sqrt ( N ** ( 1 / 3 ) ) ) ) NEWLINE return res NEWLINE DEDENT N = 20 NEWLINE print ( "Number of squares and cubes is" , countSC ( N ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) f = [ int ( x ) for x in input ( ) . split ( ) ]  main = [ ] for i in range ( n ) : main . append ( ( f [ i ] , i ) ) main . sort ( )  ans = 0 for i in range ( n - 1 ) : ans += abs ( main [ i ] [ 1 ] - main [ i + 1 ] [ 1 ] )  print ( ans ) NEWLINE NL ENDMARKER
s = input ( ) if len ( set ( s ) ) == 1 and s [ 0 ] == 'a' : print ( s [ : - 1 ] + 'z' ) exit ( ) j = 0 for i in range ( len ( s ) ) : if s [ i ] == 'a' and j != 0 : print ( s [ i : ] ) break else : if s [ i ] == 'a' : print ( s [ i ] , end = '' ) else : j += 1 print ( chr ( ord ( s [ i ] ) - 1 ) , end = '' ) print ( ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) l = [ ] for i in range ( t ) : h = list ( map ( int , input ( ) . split ( ) ) ) l . append ( [ ] ) NEWLINE NL ENDMARKER
def Remainder ( str , R ) : NEWLINE INDENT l = len ( str ) NEWLINE Rem = 0 NEWLINE for i in range ( l ) : NEWLINE INDENTINDENT Num = Rem * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) NEWLINE Rem = Num % R NEWLINE DEDENT return Rem NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT str = "13589234356546756" NEWLINE R = 13 NEWLINE print ( Remainder ( str , R ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr2 = sorted ( arr ) count = 0 a = 0 for i in range ( n ) : if arr [ i ] != arr2 [ i ] : count += 1 k = arr [ i ] arr [ i ] = arr2 [ i ] z = arr . index ( arr2 [ i ] ) arr [ z ] = k  if count > 2 : a = 1 breakif a == 0 : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
import math   def func ( num_buckets , length , buckets ) : lista = [ ] for i in range ( num_buckets ) : if ( length % buckets [ i ] == 0 ) : lista . append ( buckets [ i ] ) return int ( length / max ( lista ) )  num_buckets , length = list ( map ( int , input ( ) . split ( ) ) ) buckets = list ( map ( int , input ( ) . split ( ) ) )  hours = func ( num_buckets , length , buckets )  print ( hours )  NEWLINE NL ENDMARKER
p1 , p2 , p3 , p4 , a , b = map ( int , input ( ) . split ( ) )  m = min ( p1 , p2 , p3 , p4 )  if m - a <= 0 : NEWLINE INDENT print ( 0 ) elif m > b : NEWLINE print ( b - a + 1 ) else : NEWLINE print ( m - a ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) count = 1 divisor = nfor i in range ( 2 , n + 1 ) : if i * i > n : break if n % i == 0 : while n % i == 0 : n //= i if n == 1 : print ( i ) else : print ( 1 ) exit ( 0 ) print ( n ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for _ in range ( t ) : n , s , t = map ( int , input ( ) . split ( ) ) if s + t > n : print ( max ( s , t ) - ( ( s + t ) - n ) + 1 ) else : print ( max ( s , t ) + 1 ) NEWLINE NL ENDMARKER
def findsolution ( n , x , y ) : NEWLINE INDENT if ( ( y - n + 1 ) * ( y - n + 1 ) + n - 1 < x or y < n ) : NEWLINE INDENTINDENT print ( "No solution" ) ; NEWLINE return ; NEWLINE DEDENT print ( y - n + 1 ) ; NEWLINE while ( n > 1 ) : NEWLINE INDENTINDENT print ( 1 ) ; NEWLINE n -= 1 ; NEWLINE DEDENT DEDENT n = 5 ; NEWLINE x = 15 ; NEWLINE y = 15 ; NEWLINE findsolution ( n , x , y ) ; NEWLINE NL ENDMARKER
def toggle ( n ) : NEWLINE INDENT temp = 1 NEWLINE while ( temp <= n ) : NEWLINE INDENTINDENT n = n ^ temp NEWLINE temp = temp << 1 NEWLINE DEDENT return n NEWLINE DEDENT n = 10 NEWLINE n = toggle ( n ) NEWLINE print ( n ) NEWLINE NL ENDMARKER
a , b , c = map ( int , input ( ) . split ( ) )  if a == b : print ( 'YES' ) elif c == 0 or b > a and c < 0 or b < a and c > 0 : print ( 'NO' ) else : c = abs ( c )  if ( b - a ) % c == 0 : print ( 'YES' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
def setAllBitsAfterMSB ( n ) : NEWLINE INDENT n |= n >> 1 NEWLINE n |= n >> 2 NEWLINE n |= n >> 4 NEWLINE n |= n >> 8 NEWLINE n |= n >> 16 NEWLINE return n NEWLINE DEDENT def toggle ( n ) : NEWLINE INDENT n = n ^ setAllBitsAfterMSB ( n ) NEWLINE return n NEWLINE DEDENT n = 10 NEWLINE n = toggle ( n ) NEWLINE print ( n ) NEWLINE NL ENDMARKER
import sys , os NEWLINE NL ENDMARKER
def countPairs ( n ) : NEWLINE INDENT num = ( ( n // 2 ) + 1 ) NEWLINE Max = n % num NEWLINE count = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT for j in range ( 1 , n + 1 ) : NEWLINE INDENTINDENTINDENT val = ( ( n % i ) % j ) % n NEWLINE if ( val == Max ) : NEWLINE INDENTINDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT DEDENT return count NEWLINE DEDENT n = 5 NEWLINE print ( countPairs ( n ) ) NEWLINE NL ENDMARKER
def fib ( n ) : NEWLINE INDENT if ( n <= 1 ) : NEWLINE INDENTINDENT return n NEWLINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 6 NEWLINE print ( fib ( n ) ) NEWLINE NL DEDENT ENDMARKER
def printPermutation ( n , k ) : NEWLINE INDENT for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT x = 2 * i - 1 ; NEWLINE y = 2 * i ; NEWLINE if ( i <= k ) : NEWLINE INDENTINDENTINDENT print ( y , x , end = " " ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT print ( x , y , end = " " ) ; NEWLINE DEDENT DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 2 ; k = 1 ; NEWLINE printPermutation ( n , k ) ; NEWLINE NL DEDENT ENDMARKER
import sysinput = sys . stdin . readline  n = int ( input ( ) ) s = input ( ) for i in range ( 1 , n + 1 ) : if n % i : continue s = s [ : i ] [ : : - 1 ] + s [ i : ] print ( s ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] a . sort ( ) print ( min ( a [ - 2 ] - a [ 0 ] , a [ - 1 ] - a [ 1 ] ) ) NEWLINE NL ENDMARKER
def gcd ( a , b ) : NEWLINE INDENT if ( a == 0 ) : NEWLINE INDENTINDENT return b NEWLINE DEDENT return gcd ( b % a , a ) NEWLINE DEDENT def findgcd ( n , x , y ) : NEWLINE INDENT g = gcd ( x , y ) NEWLINE for i in range ( g ) : NEWLINE INDENTINDENT print ( n ) NEWLINE DEDENT DEDENT n = 123 NEWLINE x = 5 NEWLINE y = 2 NEWLINE findgcd ( n , x , y ) NEWLINE NL ENDMARKER
import mathdef solve ( n ) : if n <= 2 : return [ - 1 ] return [ i for i in range ( n , 0 , - 1 ) ] def main ( ) : n = int ( input ( ) ) NEWLINE NL ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return 2 * pow ( n , 2 ) + 3 * n - 5 NEWLINE DEDENT N = 4 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) min_idx = - 1 min_dist = float ( "inf" )  for idx , d in enumerate ( map ( int , input ( ) . split ( ) ) ) : if d == min_dist : min_idx = - 1 elif d < min_dist : min_idx = idx + 1 min_dist = min ( min_dist , d )  if min_idx >= 0 : print ( min_idx ) else : print ( "Still Rozdil" ) NEWLINE NL ENDMARKER
def check ( s ) : NEWLINE INDENT for i in range ( 0 , len ( s ) ) : NEWLINE INDENTINDENT if ( s [ i ] == s [ i + 1 ] ) : NEWLINE INDENTINDENTINDENT return True NEWLINE DEDENT DEDENT return False NEWLINE DEDENT s = "xzyyz" NEWLINE if ( check ( s ) ) : NEWLINE INDENT print ( "YES" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "NO" ) NEWLINE NL DEDENT ENDMARKER
import sys , os , ioimport math , bisect , operatorinf , mod = float ( 'inf' ) , 10 ** 9 + 7 NEWLINE NL ENDMARKER
for x in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if n % 2 == 0 : print ( n // 2 ) else : print ( n // 2 + 1 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) l1 = [ ] for i in range ( n ) : l1 . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) l2 = [ ] for i in range ( n ) : l2 . append ( [ int ( j ) for j in input ( ) . split ( ) ] ) l1 . sort ( ) l2 . sort ( ) x = l1 [ 0 ] [ 0 ] + l2 [ - 1 ] [ 0 ] y = l1 [ 0 ] [ 1 ] + l2 [ - 1 ] [ 1 ] print ( x , y ) NEWLINE NL ENDMARKER
import sysn , m , * inp = map ( int , sys . stdin . read ( ) . split ( ) )  inp . reverse ( ) f = [ [ 0 for x in range ( 201 ) ] for y in range ( 201 ) ] NEWLINE NL ENDMARKER
n = int ( input ( ) ) if n % 2 == 1 : print ( 0 ) else : target = n // 2 ans = ( target - 1 ) // 2 print ( ans ) NEWLINE NL ENDMARKER
def assignValue ( a , b , x ) : NEWLINE INDENT arr = [ a , b ] NEWLINE return ( arr [ x ] ) NEWLINE DEDENT y = assignValue ( 3 , 7 , 0 ) NEWLINE print ( y ) NEWLINE NL ENDMARKER
def bomb_required ( n ) : NEWLINE INDENT print ( n + n // 2 ) NEWLINE for i in range ( 2 , n + 1 , 2 ) : NEWLINE INDENTINDENT print ( i , end = " " ) NEWLINE DEDENT for i in range ( 1 , n + 1 , 2 ) : NEWLINE INDENTINDENT print ( i , end = " " ) NEWLINE DEDENT for i in range ( 2 , n , 2 ) : NEWLINE INDENTINDENT print ( i , end = " " ) NEWLINE DEDENT DEDENT bomb_required ( 3 ) NEWLINE NL ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return n ** 2 + 4 * n ; NEWLINE DEDENT N = 4 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) a = k - n + 1 for i in range ( n ) : for j in range ( n ) : if i == j : print ( a , end = " " ) else : print ( 1 , end = " " ) print ( "" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) leaves = [ ] for i in range ( n ) : leaves . append ( input ( ) ) ; print ( len ( set ( leaves ) ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) nn = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) mm = list ( map ( int , input ( ) . split ( ) ) ) nn . sort ( ) mm . sort ( ) i = 0j = 0 count = 0  while i < n and j < m : if abs ( nn [ i ] - mm [ j ] ) <= 1 : count += 1 i += 1 j += 1 elif nn [ i ] < mm [ j ] : i += 1 else : j += 1 print ( count ) NEWLINE NL ENDMARKER
def minimumMoves ( a , n ) : NEWLINE INDENT operations = 0 NEWLINE a . sort ( reverse = False ) NEWLINE for i in range ( 0 , n , 1 ) : NEWLINE INDENTINDENT operations = operations + abs ( a [ i ] - ( i + 1 ) ) NEWLINE DEDENT return operations NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 5 , 3 , 2 ] NEWLINE n = len ( arr ) NEWLINE print ( minimumMoves ( arr , n ) ) NEWLINE NL DEDENT ENDMARKER
for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE s = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE a = [ 0 ] * 102 NEWLINE b = [ 0 ] * 102 NEWLINE s . sort ( ) NEWLINE for i in s : if NEWLINE a [ i ] == 0 : a [ i ] += 1 else : b [ i ] += 1 NEWLINE print ( a . index ( 0 ) + b . index ( 0 ) ) NEWLINE NL ENDMARKER
t = int ( input ( ) )  while t > 0 : t -= 1 a , b = map ( int , input ( ) . split ( " " ) ) print ( a + b ) NEWLINE NL ENDMARKER
def minJumps ( a , b , d ) : NEWLINE INDENT temp = a NEWLINE a = min ( a , b ) NEWLINE b = max ( temp , b ) NEWLINE if ( d >= b ) : NEWLINE INDENTINDENT return ( d + b - 1 ) / b NEWLINE DEDENT if ( d == 0 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT if ( d == a ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT return 2 NEWLINE DEDENT a , b , d = 3 , 4 , 11 NEWLINE print ( int ( minJumps ( a , b , d ) ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) c = 0 s = 0 for i in range ( 1 , n ) : x [ i ] += c if x [ i ] < x [ i - 1 ] : c += x [ i - 1 ] - x [ i ] x [ i ] = x [ i - 1 ] print ( c ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) p = [ ] ; c = 0 for i in range ( len ( a ) ) : a . append ( a [ i ] ) i = 0 while i < len ( a ) : if a [ i ] == 1 : c += 1 else : p . append ( c ) c = 0 i += 1 print ( max ( p ) ) NEWLINE NL ENDMARKER
s , l , r = [ int ( i ) for i in input ( ) . split ( " " ) ] input ( )  temp = [ 1 for i in input ( ) . split ( " " ) if l < int ( i ) < r ] print ( sum ( temp ) )  NEWLINE NL ENDMARKER
def Max_Sum ( n ) : NEWLINE INDENT return ( n * ( n - 1 ) ) // 2 ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 8 ; NEWLINE print ( Max_Sum ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
import mathfor _ in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) if math . gcd ( a , b ) != 1 : print ( "INFINITE" ) else : print ( "FINITE" ) NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def transpose ( self , A ) : NEWLINE INDENTINDENT R , C = len ( A ) , len ( A [ 0 ] ) NEWLINE ans = [ [ None ] * R for _ in xrange ( C ) ] NEWLINE for r , row in enumerate ( A ) : NEWLINE INDENTINDENTINDENT for c , val in enumerate ( row ) : NEWLINE INDENTINDENTINDENTINDENT ans [ c ] [ r ] = val NEWLINE DEDENT DEDENT return ans NEWLINE NL DEDENT DEDENT ENDMARKER
import osimport NEWLINE sysfrom NEWLINE io NEWLINE import BytesIO , IOBase   NEWLINE NL ENDMARKER
n = int ( input ( ) ) c = list ( map ( int , input ( ) . split ( ) ) ) import mathfor i in c : print ( int ( i * 4 / math . gcd ( i * 4 , i + 1 ) ) + 1 )        NEWLINE NL ENDMARKER
import math NEWLINE def setBitNumber ( n ) : NEWLINE INDENT k = int ( math . log ( n , 2 ) ) NEWLINE return 2 ** k NEWLINE DEDENT n = 273 NEWLINE print ( setBitNumber ( n ) ) NEWLINE NL ENDMARKER
def findEquation ( a , b ) : NEWLINE INDENT summ = ( a + b ) NEWLINE product = ( a * b ) NEWLINE print ( "x^2 - (" , summ , "x) + (" , product , ") = 0" ) NEWLINE DEDENT a = 2 NEWLINE b = 3 NEWLINE findEquation ( a , b ) NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) while a != 0 and b != 0 : if a >= 2 * b : a = a % ( 2 * b ) elif b >= 2 * a : b = b % ( 2 * a ) else : print ( a , b ) exit ( 0 ) print ( a , b ) NEWLINE NL ENDMARKER
def powerSet ( string , index , curr ) : NEWLINE INDENT if index == len ( string ) : NEWLINE INDENTINDENT print ( curr ) NEWLINE return NEWLINE DEDENT powerSet ( string , index + 1 , curr + string [ index ] ) NEWLINE powerSet ( string , index + 1 , curr ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT s1 = "abc" NEWLINE index = 0 NEWLINE curr = "" NEWLINE powerSet ( s1 , index , curr ) NEWLINE NL DEDENT ENDMARKER
from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect  NEWLINE NL ENDMARKER
a , b , c = input ( ) . split ( ) a = int ( a ) b = int ( b ) c = int ( c ) sum = a + b + cif sum % 2 == 0 : sum /= 2 x = int ( sum - c ) y = int ( sum - a ) z = int ( sum - b ) if x >= 0 and y >= 0 and z >= 0 : print ( x , y , z ) else : print ( 'Impossible\n' ) else : print ( 'Impossible\n' ) NEWLINE NL ENDMARKER
def countIntersections ( n ) : NEWLINE INDENT return n * ( n - 1 ) // 2 NEWLINE DEDENT n = 3 NEWLINE print ( countIntersections ( n ) ) NEWLINE NL ENDMARKER
l2 = [ ] n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 2 * n ) : l2 . append ( [ l [ i ] , i ] ) l2 . sort ( ) sd , dd = l2 [ 0 ] [ 1 ] , l2 [ 1 ] [ 1 ] for i in range ( 2 , 2 * n ) : if i % 2 : dd += abs ( l2 [ i ] [ 1 ] - l2 [ i - 2 ] [ 1 ] ) else : sd += abs ( l2 [ i ] [ 1 ] - l2 [ i - 2 ] [ 1 ] ) print ( sd + dd ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) m = int ( input ( ) ) a = [ ] for i in range ( n ) : a . append ( int ( input ( ) ) ) k1 = max ( a ) kmax = k1 + m   aa = m / nk2 = sum ( a ) + m + n - 1 kmin = k2 // n   print ( max ( kmin , k1 ) , kmax ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) k = 2 * ( m - 1 ) p = [ 0 ] * nfor i in range ( n ) : s , f , t = map ( int , input ( ) . split ( ) ) d = t % k if s < f : p [ i ] = ( k if s <= d else 0 ) + f - 1 + t - d elif f < s : p [ i ] = ( k if d + s > k + 1 else 0 ) + k + 1 - f + t - d else : p [ i ] = tprint ( '\n' . join ( map ( str , p ) ) ) NEWLINE NL ENDMARKER
str1 = input ( '' ) k = int ( input ( '' ) ) w = list ( map ( int , input ( ) . split ( ) ) ) p = max ( w ) pidx = w . index ( p ) + 97 q = chr ( pidx ) str2 = k * qstr3 = str1 + str2f = 0 for i in range ( 0 , len ( str3 ) ) : a = ord ( str3 [ i ] ) - 97 f = f + ( i + 1 ) * w [ a ] print ( f ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )  a . sort ( reverse = True ) ai = [ 1 ] * n  j = 0 for i in range ( 1 , n ) : if a [ i ] == a [ i - 1 ] : ai [ j ] += 1 else : j += 1  ai = ai [ : j + 1 ]  conan = Falsefor i in ai : if i % 2 : conan = True break  print ( "Conan" if conan else "Agasa" ) NEWLINE NL ENDMARKER
time = input ( ) NEWLINE if int ( time [ 0 ] + time [ 1 ] ) >= 12 : newtime = str ( int ( time [ 0 ] + time [ 1 ] ) - 12 ) . zfill ( 2 ) + time [ 2 : ]  else : newtime = time  hour = int ( newtime [ 0 ] + newtime [ 1 ] ) NEWLINE min = int ( newtime [ 3 ] + newtime [ 4 ] )  hourhand = 360 * ( hour / 12 ) + ( min / 60 ) * 30 NEWLINE minhand = 360 * ( min / 60 )  print ( hourhand , minhand )  NEWLINE NL ENDMARKER
n , d , h = list ( map ( int , input ( ) . split ( ) ) ) if 2 * h < d or ( h == d == 1 and n > 2 ) : print ( - 1 ) else : ans = [ ] z = 1 for i in range ( h ) : ans . append ( ( i + 1 , i + 2 ) ) z = i + 2 k = d - h if k > 0 : ans . append ( ( 1 , z + 1 ) ) z += 1 k -= 1 NEWLINE NL ENDMARKER
def getTotalXorOfSubarrayXors ( arr , N ) : NEWLINE INDENT res = 0 NEWLINE for i in range ( 0 , N ) : NEWLINE INDENTINDENT freq = ( i + 1 ) * ( N - i ) NEWLINE if ( freq % 2 == 1 ) : NEWLINE INDENTINDENTINDENT res = res ^ arr [ i ] NEWLINE DEDENT DEDENT return res NEWLINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEWLINE N = len ( arr ) NEWLINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEWLINE NL ENDMARKER
def rectCount ( n , m ) : NEWLINE INDENT return ( m * n * ( n + 1 ) * ( m + 1 ) ) // 4 NEWLINE DEDENT n , m = 5 , 4 NEWLINE print ( rectCount ( n , m ) ) NEWLINE NL ENDMARKER
import mathdef solve ( t , s , x ) : if x < t : return 'NO' if x == t : return 'YES' if x < t + s : return 'NO' if ( x - t ) % s == 0 or ( x - t - 1 ) % s == 0 : return 'YES' return 'NO'                    def main ( ) : NEWLINE NL ENDMARKER
def check ( n ) : NEWLINE INDENT if n % 2 == 1 and n > 5 : NEWLINE INDENTINDENT print ( 'YES' ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( 'NO' ) NEWLINE DEDENT DEDENT def main ( ) : NEWLINE INDENT a = 3 NEWLINE b = 7 NEWLINE check ( a ) NEWLINE check ( b ) NEWLINE DEDENT main ( ) NEWLINE NL ENDMARKER
def maxSelectionCount ( a , n ) : NEWLINE INDENT res = 0 ; NEWLINE a . sort ( ) ; NEWLINE select = 1 ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT if ( a [ i ] >= select ) : NEWLINE INDENTINDENTINDENT res += 1 ; NEWLINE select += 1 ; NEWLINE DEDENT DEDENT return res ; NEWLINE DEDENT arr = [ 4 , 2 , 1 , 3 , 5 , 1 , 4 ] ; NEWLINE N = len ( arr ) ; NEWLINE print ( maxSelectionCount ( arr , N ) ) ; NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = 0 tmp = nwhile n > 0 : r = n % 10 n = n // 10 l += 1 if tmp < 10 : print ( 1 ) else : print ( ( r + 1 ) * ( 10 ** ( l - 1 ) ) - tmp ) NEWLINE NL ENDMARKER
m = int ( input ( ) ) count = 0 i = n = 5 arr = [ ] while count <= m : while n % 5 == 0 : count += 1 n //= 5 if count == m : arr . append ( i ) i += 1 n = iif arr == [ ] : print ( 0 ) else : print ( 5 ) print ( * arr ) NEWLINE NL ENDMARKER
if __name__ == "__main__" : dic = { } n , m = map ( int , input ( ) . split ( ) ) li = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : dic . setdefault ( i + 1 , 0 ) for i in li : if 0 not in dic . values ( ) : c = c + 1 for j in range ( 1 , n + 1 ) : dic [ j ] = dic [ j ] - 1  dic [ i ] = dic [ i ] + 1 if 0 not in dic . values ( ) : c = c + 1 print ( c ) NEWLINE NL ENDMARKER
def MaximumHeight ( a , n ) : NEWLINE INDENT result = 1 NEWLINE for i in range ( 1 , n ) : NEWLINE INDENTINDENT y = ( i * ( i + 1 ) ) / 2 NEWLINE if ( y < n ) : NEWLINE INDENTINDENTINDENT result = i NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT break NEWLINE DEDENT DEDENT return result NEWLINE DEDENT arr = [ 40 , 100 , 20 , 30 ] NEWLINE n = len ( arr ) NEWLINE print ( MaximumHeight ( arr , n ) ) NEWLINE NL ENDMARKER
f = lambda : map ( int , input ( ) . split ( ) ) g = lambda x , y : d . setdefault ( x , set ( ) ) . add ( y ) d = { } m , k = f ( ) for i in range ( m ) : a , b = f ( ) g ( a , b ) g ( b , a ) t = sorted ( d ) for a in t : s = [ str ( b ) for b in t if a != b and b not in d [ a ] and len ( d [ a ] & d [ b ] ) * 100 >= k * len ( d [ a ] ) ] print ( str ( a ) + ':' , len ( s ) , ' ' . join ( s ) ) NEWLINE NL ENDMARKER
import math as mt NEWLINE def Area ( a ) : NEWLINE INDENT if ( a < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT x = 0.464 * a NEWLINE A = 0.70477 * pow ( x , 2 ) NEWLINE return A NEWLINE DEDENT a = 5 NEWLINE print ( Area ( a ) ) NEWLINE NL ENDMARKER
def sumOfTheSeries ( n ) : NEWLINE INDENT sum_n = int ( ( n * ( n + 1 ) / 2 ) ) ; NEWLINE sum_sq_n = int ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ) NEWLINE return ( sum_n + sum_sq_n ) ; NEWLINE DEDENT n = 5 NEWLINE ans = sumOfTheSeries ( n ) NEWLINE print ( ans ) NEWLINE NL ENDMARKER
import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEWLINE NL ENDMARKER
import sys NEWLINE def minXOR ( arr , n ) : NEWLINE INDENT arr . sort ( ) NEWLINE minXor = int ( sys . float_info . max ) NEWLINE val = 0 NEWLINE for i in range ( 0 , n - 1 ) : NEWLINE INDENTINDENT val = arr [ i ] ^ arr [ i + 1 ] ; NEWLINE minXor = min ( minXor , val ) ; NEWLINE DEDENT return minXor NEWLINE DEDENT arr = [ 9 , 5 , 3 ] NEWLINE n = len ( arr ) NEWLINE print ( minXOR ( arr , n ) ) NEWLINE NL ENDMARKER
s = int ( input ( ) ) f = 0 i = 0 while s >= 36 : s -= 36 f += 1 while s >= 3 : s -= 3 i += 1 if s == 2 : i += 1  while i >= 12 : f += 1 i -= 12   print ( f , end = ' ' ) print ( i ) NEWLINE NL ENDMARKER
def numberOfTriangles ( n ) : NEWLINE INDENT ans = 2 * ( pow ( 3 , n ) ) - 1 ; NEWLINE return ans ; NEWLINE DEDENT n = 2 NEWLINE print ( numberOfTriangles ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) m = abs ( l [ 0 ] - l [ - 1 ] ) a , b = 1 , nfor i in range ( n - 1 ) : if m > abs ( l [ i ] - l [ i + 1 ] ) : m = abs ( l [ i ] - l [ i + 1 ] ) a , b = i + 1 , i + 2 print ( a , b ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) oddeven = [ ] s = sum ( a ) odd = 0 even = 0  for i in a : if ( i % 2 == 0 ) : even += 1 oddeven . append ( 0 ) else : odd += 1 oddeven . append ( 1 ) if ( s % 2 != 0 ) : print ( "First" ) else : if ( odd == 0 ) : print ( "Second" ) else : print ( "First" ) NEWLINE NL ENDMARKER
n , d = map ( int , input ( ) . split ( ) ) m = [ ] f = [ ] for _ in range ( n ) : mm , ff = map ( int , input ( ) . split ( ) ) m . append ( mm ) f . append ( ff ) z = sorted ( zip ( m , f ) ) i , j , maxi , cnt = 0 , 0 , 0 , 0 while j < n : if z [ j ] [ 0 ] - z [ i ] [ 0 ] < d : cnt += z [ j ] [ 1 ] maxi = max ( maxi , cnt ) j += 1 else : cnt -= z [ i ] [ 1 ] i += 1 print ( maxi ) NEWLINE NL ENDMARKER
for s in [ * open ( 0 ) ] [ 1 : ] : p , a , b , c = [ * map ( int , s . split ( ) ) ] ; print ( min ( - p % a , - p % b , - p % c ) ) NEWLINE NL ENDMARKER
def countDyckPaths ( n ) : NEWLINE INDENT res = 1 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT res *= ( 2 * n - i ) NEWLINE res /= ( i + 1 ) NEWLINE DEDENT return res / ( n + 1 ) NEWLINE DEDENT n = 4 NEWLINE print ( "Number of Dyck Paths is " , str ( int ( countDyckPaths ( n ) ) ) ) NEWLINE NL ENDMARKER
import mathdef NEWLINE getint ( ) : NEWLINE return [ int ( i ) for i in input ( ) . split ( ) ] NEWLINE def getstr ( ) : return [ str ( i ) for i in input ( ) . split ( ) ] NEWLINE NL ENDMARKER
def summation ( n ) : NEWLINE INDENT return n << ( n - 1 ) ; NEWLINE DEDENT n = 2 ; NEWLINE print ( summation ( n ) ) ; NEWLINE NL ENDMARKER
n = int ( input ( ) ) c = 1 for i in range ( n + 1 , n + 100 ) : x = list ( str ( i ) ) if '8' in x : break c += 1 print ( c ) NEWLINE NL ENDMARKER
n , d = list ( map ( int , input ( ) . split ( ) ) ) array = list ( map ( int , input ( ) . split ( ) ) ) start = 0 end = 0 ans = 0  while end < n : while array [ end ] - array [ start ] > d : start += 1 k = end - start ans += k * ( k - 1 ) // 2 end += 1 print ( ans ) NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readline  for test in range ( int ( input ( ) ) ) : x , y = [ int ( i ) for i in input ( ) . split ( ) ] if x == 1 : print ( "YES" if y == 1 else "NO" ) elif x <= 3 : print ( "YES" if 1 <= y <= 3 else "NO" ) else : print ( "YES" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) b = 0 for i in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) if ( a [ 1 ] - a [ 0 ] >= 2 ) : b += 1 print ( b ) NEWLINE NL ENDMARKER
start , end = map ( int , input ( ) . split ( ) ) t , d = map ( int , input ( ) . split ( ) ) ans = 0 for i in range ( t ) : if start > end : start , end = end , start ans += start start += dprint ( ans ) NEWLINE NL ENDMARKER
def removeChar ( s , c ) : NEWLINE INDENT counts = s . count ( c ) NEWLINE s = list ( s ) NEWLINE while counts : NEWLINE INDENTINDENT s . remove ( c ) NEWLINE counts -= 1 NEWLINE DEDENT s = '' . join ( s ) NEWLINE print ( s ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT s = "geeksforgeeks" NEWLINE removeChar ( s , 'g' ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) subs = list ( map ( int , input ( ) . split ( ) ) ) memo = [ 0 , 1 ] + [ 0 ] * ( n - 1 ) max_subs = 1  for i in range ( 2 , n + 1 ) : current = subs [ i - 1 ] if current >= subs [ i - 2 ] : memo [ i ] = memo [ i - 1 ] + 1 max_subs = memo [ i ] if memo [ i ] > max_subs else max_subs else : if memo [ i - 1 ] > max_subs : max_subs = memo [ i - 1 ] memo [ i ] = 1 print ( max_subs ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) NEWLINE if ( n == 0 ) : NEWLINE INDENT print ( "1" ) else : NEWLINE ans = int ( 3 ** ( n - 1 ) ) NEWLINE DEDENT ans = ans % ( 1000003 ) NEWLINE print ( ans ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) wires = [ * map ( int , input ( ) . split ( " " ) ) ] m = int ( input ( ) ) for i in range ( m ) : x , y = map ( int , input ( ) . split ( " " ) ) if x > 1 : wires [ x - 2 ] += y - 1 if x < n : wires [ x ] += wires [ x - 1 ] - y wires [ x - 1 ] = 0 for n in wires : print ( n ) NEWLINE NL ENDMARKER
try : n = int ( input ( ) ) if n <= 2 : print ( "No" ) else : e = [ ] o = [ ] for i in range ( 1 , n + 1 ) : if i % 2 == 0 : e . append ( i ) else : o . append ( i ) print ( "Yes" ) print ( len ( e ) , * e ) print ( len ( o ) , * o ) except : pass NEWLINE NL ENDMARKER
import math NEWLINE def findNumber ( n ) : NEWLINE INDENT x = int ( math . floor ( ( - 1 + math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ) NEWLINE base = ( x * ( x + 1 ) ) / 2 + 1 NEWLINE return n - base + 1 NEWLINE DEDENT n = 55 NEWLINE print ( findNumber ( n ) ) NEWLINE NL ENDMARKER
def factorial ( n ) : NEWLINE INDENT if n == 0 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT return n * factorial ( n - 1 ) NEWLINE DEDENT num = 5 ; NEWLINE print ( "Factorial of" , num , "is" , factorial ( num ) ) NEWLINE NL ENDMARKER
import sys , os , ioimport NEWLINE math , bisect , operatorinf , mod = float ( 'inf' ) , 10 ** 9 + 7 NEWLINE NL ENDMARKER
n , p = map ( int , input ( ) . split ( ) ) s = str ( input ( ) ) t = [ 0 ] * nfor i in range ( n ) : if s [ i ] != '.' : t [ i ] = s [ i ] else : if i - p >= 0 : t [ i ] = str ( 1 - int ( t [ i - p ] ) ) else : if i + p <= n - 1 : if s [ i + p ] != '.' : t [ i ] = str ( 1 - int ( s [ i + p ] ) ) else : t [ i ] = '0' else : t [ i ] = '0' NEWLINE NL ENDMARKER
import math NEWLINE phi = ( 1 + 5 ** .5 ) / 2 NEWLINE def numberOfDig ( n ) : NEWLINE INDENT if n == 1 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT return math . ceil ( ( n * math . log10 ( phi ) - .5 * math . log10 ( 5 ) ) ) NEWLINE DEDENT // Driver Code NEWLINE for i in range ( 1 , 11 ) : NEWLINE INDENT print ( "Number of Digits in F(" + str ( i ) + ") - " + str ( numberOfDig ( i ) ) ) NEWLINE NL DEDENT ENDMARKER
from sys import stdoutn = int ( input ( ) ) stdout . write ( "2\n" ) for lv in range ( 2 , n + 1 ) : stdout . write ( str ( lv * ( lv + 1 ) * ( lv + 1 ) - ( lv - 1 ) ) + '\n' ) NEWLINE NL ENDMARKER
PI = 3.14159265 NEWLINE def area_leaf ( a ) : NEWLINE INDENT return ( a * a * ( PI / 2 - 1 ) ) NEWLINE DEDENT a = 7 NEWLINE print ( area_leaf ( a ) ) NEWLINE NL ENDMARKER
from math import gcddef lcm ( a , b ) : return a * b // gcd ( a , b ) input ( ) a = list ( map ( int , input ( ) . split ( ) ) ) t = gcd ( a [ 0 ] , a [ 1 ] ) q = lcm ( a [ 0 ] , a [ 1 ] ) for i in range ( 2 , len ( a ) ) : q = gcd ( q , lcm ( a [ i ] , t ) ) t = gcd ( t , a [ i ] ) print ( q ) NEWLINE NL ENDMARKER
f = open ( 'input.txt' , 'r' ) n1 = f . readline ( ) n2 = f . readline ( ) n2 = int ( n2 ) n1 = n1 [ : n1 . index ( '\n' ) ] g = open ( 'output.txt' , 'w' ) if n1 == 'front' and n2 == 1 : g . write ( 'L' ) elif n1 == 'back' and n2 == 1 : g . write ( 'R' ) elif n1 == 'back' and n2 == 2 : g . write ( 'L' ) elif n1 == 'front' and n2 == 2 : g . write ( 'R' ) NEWLINE NL ENDMARKER
def canBeSumofConsec ( n ) : NEWLINE INDENT return ( ( n & ( n - 1 ) ) and n ) NEWLINE DEDENT n = 15 NEWLINE if ( canBeSumofConsec ( n ) ) : NEWLINE INDENT print ( "true" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "false" ) NEWLINE NL DEDENT ENDMARKER
from math import floor NEWLINE def countSteps ( n ) : NEWLINE INDENT steps = 0 NEWLINE while ( n ) : NEWLINE INDENTINDENT largest = floor ( n ** ( 1 / 3 ) ) NEWLINE n -= ( largest * largest * largest ) NEWLINE steps += 1 NEWLINE DEDENT return steps NEWLINE DEDENT n = 150 NEWLINE print ( countSteps ( n ) ) NEWLINE NL ENDMARKER
INF = int ( 1e9 )  n = int ( input ( ) ) s = list ( map ( int , input ( ) . split ( ) ) )  NEWLINE NL ENDMARKER
def maxProd ( N ) : NEWLINE INDENT if ( N == 0 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT if ( N < 10 ) : NEWLINE INDENTINDENT return N NEWLINE DEDENT return max ( maxProd ( N // 10 ) * ( N % 10 ) , maxProd ( N // 10 - 1 ) * 9 ) NEWLINE DEDENT N = 390 NEWLINE print ( maxProd ( N ) ) NEWLINE NL ENDMARKER
n , m , a , b = map ( int , input ( ) . split ( ) ) print ( min ( ( m - n % m ) * a , n % m * b ) ) NEWLINE NL ENDMARKER
n , m = [ int ( num ) for num in input ( ) . split ( ' ' ) ] a = [ int ( num ) for num in input ( ) . split ( ' ' ) ] c = [ 1 ] * ncheck_c = [ 0 ] * ( 10 ** 5 ) check_c [ a [ - 1 ] - 1 ] = 1 i = k = n - 2 while i >= 0 : flag = 0 if check_c [ a [ i ] - 1 ] : NEWLINE NL ENDMARKER
def maxSum ( a , n ) : NEWLINE INDENT a . sort ( ) ; NEWLINE sum = 0 ; NEWLINE for i in range ( 0 , n - 1 , 2 ) : NEWLINE INDENTINDENT sum += a [ i ] ; NEWLINE DEDENT return sum ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 1 , 3 , 2 , 1 , 4 , 5 ] ; NEWLINE n = len ( arr ) ; NEWLINE print ( maxSum ( arr , n ) ) ; NEWLINE NL DEDENT ENDMARKER
def alternateFib ( n ) : NEWLINE INDENT if ( n < 0 ) : NEWLINE INDENTINDENT return - 1 ; NEWLINE DEDENT f1 = 0 ; NEWLINE f2 = 1 ; NEWLINE print ( f1 , end = " " ) ; NEWLINE for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT f3 = f2 + f1 ; NEWLINE if ( i % 2 == 0 ) : NEWLINE INDENTINDENTINDENT print ( f3 , end = " " ) ; NEWLINE DEDENT f1 = f2 ; NEWLINE f2 = f3 ; NEWLINE DEDENT DEDENT N = 15 ; NEWLINE alternateFib ( N ) ; NEWLINE NL ENDMARKER
from collections import Counterc = Counter ( str ( int ( input ( ) ) ) ) if c [ '1' ] >= 1 and c [ '0' ] >= 6 : print ( "yes" ) else : print ( "no" ) NEWLINE NL ENDMARKER
l , p , q = [ int ( input ( ) ) for _ in [ 1 , 2 , 3 ] ] print ( l * p / ( p + q ) ) NEWLINE NL ENDMARKER
n , w = map ( int , input ( ) . split ( ) ) ans = 0 for x in range ( 1 , n ) : for y in range ( w - 1 ) : ans += ( ( w - y ) // 2 ) * min ( x , n - x ) print ( ans ) NEWLINE NL ENDMARKER
import math as m  t = int ( input ( ) )  for i in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) mx , mn = max ( a , b ) , min ( a , b ) c = 2 * ( mx - mn ) d = 1 ** 2 + 4 * c ds = m . sqrt ( d ) n = ( ds - 1 ) / 2 n = int ( n ) if int ( n ) == n else int ( n ) + 1 n += ( n * ( n + 1 ) // 2 ) % 2 != ( mx - mn ) % 2 n += ( n * ( n + 1 ) // 2 ) % 2 != ( mx - mn ) % 2 print ( n )  NEWLINE NL ENDMARKER
def findevenPair ( A , N ) : NEWLINE INDENT count = 0 NEWLINE for i in range ( 0 , N ) : NEWLINE INDENTINDENT if ( A [ i ] % 2 != 0 ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT oddCount = count * ( count - 1 ) / 2 NEWLINE return ( int ) ( ( N * ( N - 1 ) / 2 ) - oddCount ) NEWLINE DEDENT a = [ 5 , 1 , 3 , 2 ] NEWLINE n = len ( a ) NEWLINE print ( findevenPair ( a , n ) ) NEWLINE NL ENDMARKER
int ( input ( ) ) print ( 25 ) NEWLINE NL ENDMARKER
def findDelta ( a , b , c , d ) : NEWLINE INDENT return int ( ( b * c - a * d ) / ( d - c ) ) ; NEWLINE DEDENT a = 3 ; b = 9 ; NEWLINE c = 3 ; d = 5 ; NEWLINE print ( "X = {}" . format ( findDelta ( a , b , c , d ) ) ) ; NEWLINE NL ENDMARKER
m = int ( input ( ) ) while sum ( [ int ( m ) for m in str ( m ) ] ) % 4 != 0 : m = m + 1 print ( m ) NEWLINE NL ENDMARKER
a = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) print ( sum ( l ) / a ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ans = [ ] for i in range ( n ) : l = 0 r = len ( ans ) while l < r : mid = l + ( r - l ) // 2 if ans [ mid ] [ - 1 ] < a [ i ] : r = mid else : l = mid + 1 if l == len ( ans ) : ans . append ( [ a [ i ] ] ) else : ans [ l ] . append ( a [ i ] ) for x in ans : print ( * x )   NEWLINE NL ENDMARKER
if __name__ == "__main__" : n , k = list ( map ( int , input ( ) . split ( ) ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr . sort ( ) arr = arr [ : : - 1 ] for i in range ( n ) : if i + 1 == k : print ( arr [ i ] ) break NEWLINE NL ENDMARKER
n = int ( input ( ) ) c = "*" * nx = 1 mid = Falsefor i in range ( n ) : if i == ( n - 1 ) / 2 : mid = True a = c [ : int ( ( n - x ) / 2 ) ] b = "D" * x print ( a + b + a ) if mid == True : x -= 2 else : x += 2 NEWLINE NL ENDMARKER
n = int ( input ( ) ) list = [ 0 , 1 , 3 , 6 , 10 , 15 , 21 , 28 , 36 , 45 , 55 , 66 , 78 , 91 , 105 , 120 , 136 , 153 , 171 , 190 , 210 , 231 , 253 , 276 , 300 , 325 , 351 , 378 , 406 , 435 , 465 , 496 ] if n in list : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) lst = list ( map ( int , input ( ) . split ( ) ) ) ans = [ 1 ] summ2 = lst [ 0 ] for i in range ( 1 , n ) : if lst [ 0 ] >= ( 2 * lst [ i ] ) : ans . append ( i + 1 ) summ2 += lst [ i ] summ = sum ( lst ) NEWLINE NL ENDMARKER
num = int ( input ( ) ) s = input ( ) s1 = s . count ( '1' ) s0 = s . count ( '0' ) output = abs ( s1 - s0 ) print ( output ) NEWLINE NL ENDMARKER
from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEWLINE NL ENDMARKER
def grayCode ( n ) : NEWLINE INDENT return n ^ ( n >> 1 ) NEWLINE DEDENT n = 10 NEWLINE print ( grayCode ( n ) ) NEWLINE NL ENDMARKER
def Divisible ( arr , n ) : NEWLINE INDENT count_even = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT if ( arr [ i ] % 2 == 0 ) : NEWLINE INDENTINDENTINDENT count_even += 1 NEWLINE DEDENT DEDENT return count_even + ( n - count_even ) // 2 NEWLINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEWLINE n = len ( arr ) NEWLINE print ( Divisible ( arr , n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )   for i in reversed ( range ( len ( arr ) ) ) : for j in range ( 1 , i + 1 ) : if arr [ j - 1 ] > arr [ j ] : print ( j , j + 1 ) arr [ j - 1 ] , arr [ j ] = arr [ j ] , arr [ j - 1 ]    NEWLINE NL ENDMARKER
dat = "" . join ( [ i for i in input ( ) if i in "hello" ] ) + " " NEWLINE def check ( inp ) : now = "hello" NEWLINE INDENT pass NEWLINE DEDENT for step in now : if NEWLINE step in inp : inp = inp [ inp . index ( step ) + 1 : ] else : return "NO" NEWLINE return "YES" NEWLINE print ( check ( dat ) ) NEWLINE NL ENDMARKER
import sys  def main ( ) : n , * l = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) x , y = ( i for i , j in enumerate ( l , 1 ) if j in { 1 , n } ) return max ( y - 1 , n - x )  print ( main ( ) ) NEWLINE NL ENDMARKER
def findCountOfPairs ( a , b , n ) : NEWLINE INDENT ans = 0 NEWLINE ans += n * int ( a / n ) * int ( b / n ) NEWLINE ans += int ( a / n ) * ( b % n ) NEWLINE ans += ( a % n ) * int ( b / n ) NEWLINE ans += int ( ( ( a % n ) + ( b % n ) ) / n ) ; NEWLINE return ans NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = 5 NEWLINE b = 13 NEWLINE n = 3 NEWLINE print ( findCountOfPairs ( a , b , n ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) c = 0 q = [ ] while l : m = min ( l ) for i in list ( l ) : if i % m == 0 : c += 1 l . remove ( i ) q . append ( c ) c = 0 print ( len ( q ) )   NEWLINE NL ENDMARKER
from math import * NEWLINE def trianglearea ( a , b ) : NEWLINE INDENT if a < 0 or b < 0 : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT area = ( 3 * sqrt ( 3 ) * pow ( a , 2 ) ) / ( 4 * b ) NEWLINE return area NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a , b = 4 , 2 NEWLINE print ( round ( trianglearea ( a , b ) , 4 ) ) NEWLINE NL DEDENT ENDMARKER
def numberOfSolutions ( n ) : NEWLINE INDENT c = 0 NEWLINE for x in range ( n + 1 ) : NEWLINE INDENTINDENT if ( n == ( x + ( n ^ x ) ) ) : NEWLINE INDENTINDENTINDENT c += 1 NEWLINE DEDENT DEDENT return c NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 3 NEWLINE print ( numberOfSolutions ( n ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) t = 0 for a in range ( 1 , n + 1 ) : for b in range ( a , n + 1 ) : c = a ^ b if ( a + b <= c or c > n or a > c or b > c ) : continue else : t += 1 print ( t ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) l = [ 2 ** i for i in range ( 1 , n + 1 ) ] NEWLINE NL ENDMARKER
pie = 3.1415926535897 NEWLINE def findsolution ( d , h , m , n ) : NEWLINE INDENT k = ( 4 * m ) / ( pie * d * d ) NEWLINE if ( n > k ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT ans = ( h / ( k - n ) ) NEWLINE return round ( ans , 5 ) NEWLINE DEDENT d = 1 NEWLINE h = 1 NEWLINE m = 1 NEWLINE n = 1 NEWLINE print ( findsolution ( d , h , m , n ) ) NEWLINE NL ENDMARKER
a , b , c = map ( int , input ( ) . split ( ) ) print ( ( a * c + b - 1 ) // b - c ) NEWLINE NL ENDMARKER
import math NEWLINE def surface_area_octahedron ( side ) : NEWLINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEWLINE DEDENT side = 7 NEWLINE print ( "Surface area of octahedron =" , surface_area_octahedron ( side ) ) NEWLINE NL ENDMARKER
def compute ( ) : NEWLINE INDENT TILES = 10 ** 6 NEWLINE ans = 0 NEWLINE for n in range ( 3 , TILES // 4 + 2 ) : NEWLINE INDENTINDENT for k in range ( n - 2 , 0 , - 2 ) : NEWLINE INDENTINDENTINDENT if n * n - k * k > TILES : NEWLINE INDENTINDENTINDENTINDENT break NEWLINE DEDENT ans += 1 NEWLINE DEDENT DEDENT return str ( ans ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( compute ( ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) arr = [ int ( x ) for x in input ( ) . split ( ) ] s = 0 for i in range ( 1 , n + 1 ) : if i not in arr : s += 1 print ( s ) NEWLINE NL ENDMARKER
import math NEWLINE def geometricMean ( arr , n ) : NEWLINE INDENT product = 1 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT product = product * arr [ i ] NEWLINE DEDENT gm = ( float ) ( math . pow ( product , ( 1 / n ) ) ) NEWLINE return ( float ) ( gm ) NEWLINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEWLINE n = len ( arr ) NEWLINE print ( '{0:.6f}' . format ( geometricMean ( arr , n ) ) ) NEWLINE NL ENDMARKER
def calculateSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE sum = 1 << n ; NEWLINE return ( sum - 1 ) NEWLINE DEDENT n = 10 NEWLINE print ( "Sum of all elements:" , calculateSum ( n ) ) NEWLINE NL ENDMARKER
import sysfrom os import pathif ( path . exists ( 'input.txt' ) and path . exists ( 'output.txt' ) ) : sys . stdout = open ( 'output.txt' , 'w' ) sys . stdin = open ( 'input.txt' , 'r' )  NEWLINE NL ENDMARKER
def nthTerm ( N ) : NEWLINE INDENT nth = 0 ; first_term = 4 ; NEWLINE pi = 1 ; po = 1 ; NEWLINE n = N ; NEWLINE while ( n > 1 ) : NEWLINE INDENTINDENT pi *= n - 1 ; NEWLINE n -= 1 ; NEWLINE po *= 2 ; NEWLINE DEDENT nth = ( first_term * pi ) // po ; NEWLINE return nth ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 5 ; NEWLINE print ( nthTerm ( N ) ) ; NEWLINE NL DEDENT ENDMARKER
def ways ( n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT return 1 ; NEWLINE DEDENT if ( n == 2 ) : NEWLINE INDENTINDENT return 2 ; NEWLINE DEDENT else : NEWLINE INDENTINDENT return ways ( n - 1 ) + ways ( n - 2 ) ; NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 5 ; NEWLINE print ( "Number of ways = " , ways ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
def cost ( st ) : NEWLINE INDENT l = len ( st ) NEWLINE res = 0 NEWLINE j = l - 1 NEWLINE i = 0 NEWLINE while ( i < j ) : NEWLINE INDENTINDENT if ( st [ i ] != st [ j ] ) : NEWLINE INDENTINDENTINDENT res += ( min ( ord ( st [ i ] ) , ord ( st [ j ] ) ) - ord ( 'a' ) + 1 ) NEWLINE DEDENT i = i + 1 NEWLINE j = j - 1 NEWLINE DEDENT return res NEWLINE DEDENT st = "abcdef" ; NEWLINE print ( cost ( st ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) s = list ( s ) s1 = list ( dict . fromkeys ( s ) ) if len ( s1 ) < n : print ( 'NO' ) else : print ( 'YES' ) i = 0 j = 0 while ( j < n ) : ind = s . index ( s1 [ i ] ) j += 1 if j < n : ind2 = s . index ( s1 [ i + 1 ] ) for o in range ( ind , ind2 ) : print ( str ( s [ o ] ) , end = "" ) print ( ) else : for o in range ( ind , len ( s ) ) : print ( s [ o ] , end = "" ) print ( ) i += 1 NEWLINE NL ENDMARKER
from typing import Iterator   def get_num_input ( ) -> Iterator [ int ] : return map ( int , input ( ) . split ( ) )   def main ( ) -> None : first : int second : int _ , first , second , _ = get_num_input ( )  print ( first , second , second )   if __name__ == "__main__" : ONLY_ONCE : bool = False for _ in range ( 1 if ONLY_ONCE else int ( input ( ) ) ) : main ( ) NEWLINE NL ENDMARKER
def computeXOR ( n ) : NEWLINE INDENT switch = { 0 : n , 1 : 1 , 2 : n + 1 , 3 : 0 , } NEWLINE return switch . get ( n & 3 , "" ) NEWLINE DEDENT l = 1 NEWLINE r = 4 NEWLINE print ( computeXOR ( r ) ^ computeXOR ( l - 1 ) ) NEWLINE NL ENDMARKER
def count ( str1 , str2 ) : NEWLINE INDENT c = 0 ; j = 0 ; NEWLINE for i in range ( len ( str1 ) ) : NEWLINE INDENTINDENT if str1 [ i ] in str2 : NEWLINE INDENTINDENTINDENT c += 1 ; NEWLINE DEDENT j += 1 ; NEWLINE DEDENT print ( "No. of matching characters are: " , c ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT str1 = "aabcddekll12@" ; NEWLINE str2 = "bb2211@55k" ; NEWLINE count ( str1 , str2 ) ; NEWLINE NL DEDENT ENDMARKER
t = int ( input ( ) ) for _ in range ( t ) : x , y = map ( int , input ( ) . split ( ) ) if x >= y : print ( 'YES' ) else : if x == 2 and y == 3 or x >= 4 : print ( 'YES' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) if n == m : print ( 0 ) elif m == 0 : print ( 1 ) elif n / m < 2 : print ( n - m ) else : print ( m ) NEWLINE NL ENDMARKER
import mathk , b , n , t = list ( map ( int , input ( ) . split ( ) ) ) if k > 1 : ans = math . ceil ( n - math . log ( ( t + b / ( k - 1 ) ) / ( 1 + b / ( k - 1 ) ) ) / math . log ( k ) ) print ( max ( 0 , ans ) ) else : z = 1 + n * b f = 1 ans = 0 while f : if t + ans * b >= z : f = 0 break else : ans = ans + 1 print ( ans ) NEWLINE NL ENDMARKER
import sys NEWLINE def toggleLastMBits ( n , m ) : NEWLINE INDENT num = ( 1 << m ) - 1 NEWLINE return ( n ^ num ) NEWLINE DEDENT def unsetLastMBits ( n , m ) : NEWLINE INDENT num = ( 1 << ( sys . getsizeof ( int ) * 8 - 1 ) ) - 1 NEWLINE num = toggleLastMBits ( num , m ) NEWLINE return ( n & num ) NEWLINE DEDENT n = 150 NEWLINE m = 4 NEWLINE print ( unsetLastMBits ( n , m ) ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) a = nb = mwhile a * b > 0 : if a >= 2 * b : a = a % ( 2 * b ) elif b >= 2 * a : b = b % ( 2 * a ) else : breakprint ( a , b ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) for j in range ( n ) : print ( '1' , end = " " ) print ( ) NEWLINE NL ENDMARKER
def sumAP ( n , d ) : NEWLINE INDENT n = int ( n / d ) ; NEWLINE return ( n ) * ( 1 + n ) * ( d / 2 ) ; NEWLINE DEDENT def sumMultiples ( n ) : NEWLINE INDENT n -= 1 ; NEWLINE return ( int ( sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ) ) ; NEWLINE DEDENT n = 20 ; NEWLINE print ( sumMultiples ( n ) ) ; NEWLINE NL ENDMARKER
n = int ( input ( ) ) if ( n % 2 == 0 ) : print ( "Mahmoud" ) else : print ( "Ehab" ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : N = int ( input ( ) ) NEWLINE A = [ 4 ] * N NEWLINE print ( * A ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) x , y = map ( int , input ( ) . split ( ) ) min = x if x < y else ymax = x if x > y else yif min - 1 <= n - max : print ( "White" ) else : print ( "Black" ) NEWLINE NL ENDMARKER
x = input ( ) k , m = map ( int , input ( ) . split ( ) ) daf1 = list ( map ( int , input ( ) . split ( ) ) ) daf2 = list ( map ( int , input ( ) . split ( ) ) ) if daf1 [ k - 1 ] < daf2 [ - m ] : print ( 'YES' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
import mathdef solve ( a , b ) : if a == 0 and b == 0 : return 'NO' if abs ( a - b ) <= 1 : return 'YES' return 'NO'  def main ( ) : arr = list ( map ( int , input ( ) . split ( ' ' ) ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) c = 0 for i in range ( n ) : c += l [ i ] % 2 if ( c != 0 and c != n ) : l . sort ( ) print ( * l ) NEWLINE NL ENDMARKER
def countMultiples ( n ) : NEWLINE INDENT res = 0 ; NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT if ( i % 3 == 0 or i % 7 == 0 ) : NEWLINE INDENTINDENTINDENT res += 1 ; NEWLINE DEDENT DEDENT return res ; NEWLINE DEDENT print ( "Count =" , countMultiples ( 25 ) ) ; NEWLINE NL ENDMARKER
t = int ( input ( ) )  for tc in range ( t ) :  a , b = map ( int , input ( ) . split ( ) )  twow = a * 2 twol = b * 2  twowsq = max ( twow , b ) twolsq = max ( twol , a )  print ( min ( twolsq , twowsq ) ** 2 )   NEWLINE NL ENDMARKER
def sum ( n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT return 2 ; NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( n * ( n + 1 ) + sum ( n - 1 ) ) ; NEWLINE DEDENT DEDENT n = 2 ; NEWLINE print ( sum ( n ) ) ; NEWLINE NL ENDMARKER
t = int ( input ( ) ) sum = 0 nume = t // 2 sume = nume * ( nume + 1 ) sum = sume - ( ( t * ( t + 1 ) ) // 2 - sume ) print ( sum ) NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def minMoves ( self , nums ) : NEWLINE INDENTINDENT if nums is None or len ( nums ) == 0 : NEWLINE INDENTINDENTINDENT return 0 NEWLINE DEDENT min_num = min ( nums ) NEWLINE return sum ( [ i - min_num for i in nums ] ) NEWLINE NL DEDENT DEDENT ENDMARKER
import math NEWLINE def countDigits ( n ) : NEWLINE INDENT ans = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT ans += math . log10 ( i ) NEWLINE DEDENT ans = ans * n NEWLINE return 1 + math . floor ( ans ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 4 NEWLINE print ( countDigits ( n ) ) NEWLINE NL DEDENT ENDMARKER
from decimal import *  a = input ( ) b = Decimal ( a )  if ( int ( b ) == b ) : print ( "%d" % b ) else : print ( b ) NEWLINE NL ENDMARKER
def li ( ) : return list ( map ( int , input ( ) . split ( " " ) ) ) NEWLINE INDENT pass NEWLINE DEDENT for _ in range ( int ( input ( ) ) ) : a , b = li ( ) NEWLINE if b != 0 and a != 0 : s = ( max ( 0 , a - 4 * b ) + a ) / 2 NEWLINE s *= min ( ( a / 4 ) , b ) NEWLINE ans = 1 / 2 + s / ( 2 * a * b ) NEWLINE print ( "{:.8f}" . format ( ans ) ) elif b == 0 : print ( 1 ) else : print ( 0.5 ) NEWLINE NL ENDMARKER
import sys , mathfrom collections import deque , defaultdictimport operator as opfrom functools import reducefrom itertools import permutations  NEWLINE NL ENDMARKER
def nextPowerOf2 ( n ) : NEWLINE INDENT count = 0 ; NEWLINE if ( n and not ( n & ( n - 1 ) ) ) : NEWLINE INDENTINDENT return n NEWLINE DEDENT while ( n != 0 ) : NEWLINE INDENTINDENT n >>= 1 NEWLINE count += 1 NEWLINE DEDENT return 1 << count ; NEWLINE DEDENT n = 0 NEWLINE print ( nextPowerOf2 ( n ) ) NEWLINE NL ENDMARKER
w1 , h1 , w2 , h2 = map ( int , input ( ) . split ( ) ) print ( ( h1 + h2 ) * 2 + w1 * 2 + 4 ) NEWLINE NL ENDMARKER
import math NEWLINE def unitnumber ( x , y ) : NEWLINE INDENT x = x % 10 NEWLINE if y != 0 : NEWLINE INDENTINDENT y = y % 4 + 4 NEWLINE DEDENT return ( ( ( int ) ( math . pow ( x , y ) ) ) % 10 ) NEWLINE DEDENT x = 133 ; y = 5 NEWLINE print ( unitnumber ( x , y ) ) NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def fizzBuzz ( self , n ) : NEWLINE INDENTINDENT return [ str ( i ) * ( i % 3 != 0 and i % 5 != 0 ) + "Fizz" * ( i % 3 == 0 ) + "Buzz" * ( i % 5 == 0 ) for i in range ( 1 , n + 1 ) ] NEWLINE NL DEDENT DEDENT ENDMARKER
n = int ( input ( ) ) A = list ( map ( int , input ( ) . split ( ) ) )  p = [ ] m = [ ] for a in A : if a > 0 : p . append ( a ) elif a < 0 and a % 2 : m . append ( a )  if p : p . sort ( ) sm = sum ( p ) else : sm = 0 if sm % 2 : print ( sm ) exit ( )  pcand = float ( 'inf' ) if m : mcand = max ( m ) else : mcand = - float ( 'inf' ) for pp in p : if pp % 2 : pcand = pp break  print ( max ( sm - pcand , sm + mcand ) ) NEWLINE NL ENDMARKER
def AvgofSquareN ( n ) : NEWLINE INDENT return ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; NEWLINE DEDENT n = 2 ; NEWLINE print ( AvgofSquareN ( n ) ) ; NEWLINE NL ENDMARKER
import mathx , y = map ( int , input ( ) . split ( ) ) if y * math . log ( x ) > x * math . log ( y ) : print ( ">" ) elif y * math . log ( x ) < x * math . log ( y ) : print ( '<' ) else : print ( '=' ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) base = ( n // 4 + 1 ) * '9' ans = basei = j = 1 f = Truefor i in range ( 0 , n + 1 ) : j = 0 while i * 4 + j * 7 < n : j += 1 if i * 4 + j * 7 == n : x = ( '4' * i + '7' * j ) print ( x ) f = False break   if f : print ( - 1 )   NEWLINE NL ENDMARKER
f = lambda : map ( int , input ( ) . split ( ) ) n , p = f ( ) s = [ 0 ] * nx , y = - p , 0 for i in range ( n ) : a , b = f ( ) x += a y += b s [ i ] = ( a , b ) s . sort ( key = lambda q : q [ 0 ] / q [ 1 ] ) for a , b in s : if b * x > a * y : x -= a y -= b  print ( y / x if x > 0 else - 1 ) NEWLINE NL ENDMARKER
from math import sqrt NEWLINE def geometricMean ( n ) : NEWLINE INDENT return int ( sqrt ( n ) ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 16 ; NEWLINE print ( geometricMean ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
from math import ceil , log2  for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) x = n for k in range ( 2 , ceil ( log2 ( n ) ) + 1 ) : if n % ( 2 ** k - 1 ) == 0 : x = n // ( 2 ** k - 1 ) break print ( x ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) for i in range ( 1 , n ) : if i % 2 == 1 : print ( 'I hate that' , end = ' ' ) else : print ( 'I love that' , end = ' ' ) if n % 2 == 1 : print ( 'I hate it' , end = ' ' ) else : print ( 'I love it' , end = ' ' ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = 0 m = 0 i = n - 1 s = str ( input ( ) ) while ( i >= 0 ) : if s [ i ] == '+' : m += 1 else : m -= 1 a = max ( a , m ) i -= 1 print ( a )      NEWLINE NL ENDMARKER
n , k = [ int ( x ) for x in input ( ) . split ( ) ] last = 0 cnt = 1 ai = [ int ( x ) for x in input ( ) . split ( ) ] for i in range ( n ) : NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) x = [ ] d = { } for i in range ( n ) : a = list ( input ( ) ) x . append ( a ) for i in x : for j , k in enumerate ( i ) : d [ j ] = 0 for i in x : for j , k in enumerate ( i ) : d [ j ] = max ( d [ j ] , int ( k ) ) c = 0 for i in x : for j , k in enumerate ( i ) : if int ( k ) == d [ j ] : c += 1 breakprint ( c ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( 1 + ( n - 1 ) * n * 2 ) NEWLINE NL ENDMARKER
def angleequichord ( z ) : NEWLINE INDENT print ( "The angle subtended at" , "the center is" , z , "degrees" ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT z = 48 ; NEWLINE angleequichord ( z ) ; NEWLINE NL DEDENT ENDMARKER
if __name__ == "__main__" : NEWLINE INDENT ax , ay = 5 , 0 NEWLINE bx , by = 1 , 1 NEWLINE cx , cy = 2 , 5 NEWLINE print ( ax + cx - bx , "," , ay + cy - by ) NEWLINE NL DEDENT ENDMARKER
k , n = map ( int , input ( ) . split ( ) ) r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( ) x = float ( 'inf' )  for pos , i in enumerate ( arr ) : if ( k % i ) < x : x = k % i ans = pos    print ( ans + 1 , k // arr [ ans ] ) NEWLINE NL ENDMARKER
import sys  def main ( ) : _ , k , * l = sys . stdin . read ( ) . strip ( ) . split ( ) return sum ( sum ( i in '47' for i in s ) <= int ( k ) for s in l ) print ( main ( ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) + 1  if n == 1 : print ( 0 ) else : if n % 2 : print ( n ) else : print ( n // 2 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) lst = [ int ( i ) for i in input ( ) . split ( ) ]  for i in range ( n - 1 ) : print ( lst [ i ] + lst [ i + 1 ] , end = ' ' ) print ( lst [ n - 1 ] ) NEWLINE NL ENDMARKER
def sumOfSeries ( x , k ) : NEWLINE INDENT return ( float ( x ) / 81 ) * ( 9 * k - 1 + 10 ** ( ( - 1 ) * k ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT x = 9 NEWLINE k = 20 NEWLINE print ( sumOfSeries ( x , k ) ) NEWLINE NL DEDENT ENDMARKER
def solve ( n , base ) : NEWLINE INDENT result = 0 NEWLINE while ( n > 0 ) : NEWLINE INDENTINDENT remainder = n % base NEWLINE result = result + remainder NEWLINE n = int ( n / base ) NEWLINE DEDENT return result NEWLINE DEDENT def printSumsOfDigits ( n ) : NEWLINE INDENT for base in range ( 2 , n ) : NEWLINE INDENTINDENT print ( solve ( n , base ) , end = " " ) NEWLINE DEDENT DEDENT n = 8 NEWLINE printSumsOfDigits ( n ) NEWLINE NL ENDMARKER
import sys  input = sys . stdin . buffer . readline  t = int ( input ( ) ) NEWLINE for _ in range ( t ) : n , m = map ( int , input ( ) . split ( ) ) NEWLINE S = sum ( list ( map ( int , input ( ) . split ( ) ) ) ) NEWLINE print ( "YES" if S == m else "NO" ) NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readline  n = int ( input ( ) ) s = input ( ) for i in range ( 1 , n + 1 ) : if n % i == 0 : s = s [ : i ] [ : : - 1 ] + s [ i : ] print ( s ) NEWLINE NL ENDMARKER
def get ( x , y , z ) : NEWLINE INDENT if ( x > z ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT val = z - x NEWLINE div = ( z - x ) // y NEWLINE ans = div * y + x NEWLINE return ans NEWLINE DEDENT x = 1 NEWLINE y = 5 NEWLINE z = 8 NEWLINE print ( get ( x , y , z ) ) NEWLINE NL ENDMARKER
def sum ( x , n ) : NEWLINE INDENT total = 1.0 NEWLINE multi = x NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT total = total + multi / i NEWLINE multi = multi * x NEWLINE DEDENT return total NEWLINE DEDENT x = 2 NEWLINE n = 5 NEWLINE print ( round ( sum ( x , n ) , 2 ) ) NEWLINE NL ENDMARKER
def evenFib ( n ) : NEWLINE INDENT if ( n < 1 ) : NEWLINE INDENTINDENT return n NEWLINE DEDENT if ( n == 1 ) : NEWLINE INDENTINDENT return 2 NEWLINE DEDENT return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) NEWLINE DEDENT n = 7 NEWLINE print ( evenFib ( n ) ) NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readlinefor NEWLINE _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE res = [ ] NEWLINE for i in range ( min ( n , 2 ) ) : res . append ( str ( 9 - ( i % 10 ) ) ) NEWLINE for i in range ( 2 , n ) : res . append ( str ( ( 9 + i - 2 ) % 10 ) )  print ( "" . join ( res ) ) NEWLINE NL ENDMARKER
p = 1.0 NEWLINE f = 1.0 NEWLINE def e ( x , n ) : NEWLINE INDENT global p , f NEWLINE if ( n == 0 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT r = e ( x , n - 1 ) NEWLINE p = p * x NEWLINE f = f * n NEWLINE return ( r + p / f ) NEWLINE DEDENT x = 4 NEWLINE n = 15 NEWLINE print ( e ( x , n ) ) NEWLINE NL ENDMARKER
import mathn = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) )  least = math . ceil ( n / 2 )  newlist = [ i for i in l if i != 0 ] p = 0 n = 0  if len ( newlist ) >= least : for i in newlist : if i / 1 > 0 : p += 1 else : n += 1 if p >= n : if p >= least : print ( 1 ) else : print ( 0 ) else : if n >= least : print ( - 1 ) else : print ( 0 ) else : print ( 0 ) NEWLINE NL ENDMARKER
def pattern ( n ) : NEWLINE INDENT k = 1 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT p = k NEWLINE for j in range ( 1 , i + 1 ) : NEWLINE INDENTINDENTINDENT print ( p , end = " " ) NEWLINE p = p - ( n + j - i ) NEWLINE DEDENT print ( "" ) NEWLINE k = k + 1 + n - i NEWLINE DEDENT DEDENT n = 5 NEWLINE pattern ( n ) NEWLINE NL ENDMARKER
import math NEWLINE def printGreater ( x , y ) : NEWLINE INDENT X = y * math . log ( x ) ; NEWLINE Y = x * math . log ( y ) ; NEWLINE if ( abs ( X - Y ) < 1e-9 ) : NEWLINE INDENTINDENT print ( "Equal" ) ; NEWLINE DEDENT elif ( X > Y ) : NEWLINE INDENTINDENT print ( x , "^" , y ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( y , "^" , x ) ; NEWLINE DEDENT DEDENT x = 5 ; NEWLINE y = 8 ; NEWLINE printGreater ( x , y ) ; NEWLINE NL ENDMARKER
n , k = [ int ( i ) for i in input ( ) . split ( ) ] a = [ int ( i ) for i in input ( ) . split ( ) ] b = 0 c = 0 for i in range ( n ) : b += a [ i ] if b >= 8 : b -= 8 c += 8 else : c += b b = 0 if c >= k : print ( i + 1 ) breakelse : print ( - 1 ) NEWLINE NL ENDMARKER
a = input ( ) b = input ( ) coun = 0 leta = [ ] letb = [ ] n = len ( a ) if len ( a ) == len ( b ) : for i in range ( len ( a ) ) : if a [ i ] == b [ i ] : coun += 1 else : leta . append ( a [ i ] ) letb . append ( b [ i ] ) if coun >= n - 2 : leta . sort ( ) ; letb . sort ( ) if leta == letb : print ( "YES" ) else : print ( "NO" ) else : print ( "NO" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( 'input.txt' ) ) : stdin = open ( "input.txt" , "r" ) import time , math NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) c , d = map ( int , input ( ) . split ( ) ) ans = "-1" while b < 100000 : if b == d : ans = b break elif b > d : d += c else : b += aprint ( ans ) NEWLINE NL ENDMARKER
def squareArea ( l , b , h ) : NEWLINE INDENT if l < 0 or b < 0 or h < 0 : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT a = ( l * b ) / ( l + b ) NEWLINE return a * a NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT l , b , h = 5 , 12 , 13 NEWLINE print ( round ( squareArea ( l , b , h ) , 4 ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) m = input ( ) rb = { 'r' : 0 , 'b' : 0 } br = { 'r' : 0 , 'b' : 0 } for i in range ( n ) : if i % 2 == 0 : if m [ i ] == 'b' : br [ 'b' ] += 1 else : rb [ 'r' ] += 1 else : if m [ i ] == 'r' : br [ 'r' ] += 1 else : rb [ 'b' ] += 1 rbs = min ( rb [ 'b' ] , rb [ 'r' ] ) + abs ( rb [ 'b' ] - rb [ 'r' ] ) brs = min ( br [ 'b' ] , br [ 'r' ] ) + abs ( br [ 'b' ] - br [ 'r' ] ) print ( min ( rbs , brs ) ) NEWLINE NL ENDMARKER
def allBitsSetInTheGivenRange ( n , l , r ) : NEWLINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEWLINE new_num = n & num NEWLINE if ( new_num == 0 ) : NEWLINE INDENTINDENT return "Yes" NEWLINE DEDENT return "No" NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 17 NEWLINE l = 2 NEWLINE r = 4 NEWLINE print ( allBitsSetInTheGivenRange ( n , l , r ) ) NEWLINE NL DEDENT ENDMARKER
if __name__ == "__main__" : T = int ( input ( ) ) solution = 0 for t in range ( T ) : a , b , c = map ( int , input ( ) . split ( ) ) if b * a < c : print ( '1' , ' ' , '-1' ) elif b * a == c : print ( b - 1 , ' ' , '-1' ) else : NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) x = s . count ( "L" ) y = s . count ( "R" ) print ( y + x + 1 ) NEWLINE NL ENDMARKER
import sys , functools , collections , bisect , math , NEWLINE INDENT heapqinput = sys . stdin . readline NEWLINE NL DEDENT ENDMARKER
def mod ( num , a ) : NEWLINE INDENT res = 0 NEWLINE for i in range ( 0 , len ( num ) ) : NEWLINE INDENTINDENT res = ( res * 10 + int ( num [ i ] ) ) % a ; NEWLINE DEDENT return res NEWLINE DEDENT num = "12316767678678" ; NEWLINE print ( mod ( num , 10 ) ) NEWLINE NL ENDMARKER
def ifPossible ( X , Y ) : NEWLINE INDENT if ( X > Y ) : NEWLINE INDENTINDENT X , Y = Y , X NEWLINE DEDENT if ( ( X + Y ) % 5 == 0 and 3 * X >= 2 * Y ) : NEWLINE INDENTINDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) NEWLINE DEDENT DEDENT X = 33 NEWLINE Y = 27 NEWLINE ifPossible ( X , Y ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) fodac = input ( ) val = 100000 for i in range ( n ) : val = min ( val , sum ( int ( x ) * 5 + 15 for x in input ( ) . split ( ) ) ) print ( val ) NEWLINE NL ENDMARKER
def FirstAndLast ( string ) : NEWLINE INDENT arrOfStr = string . split ( ) ; NEWLINE res = "" ; NEWLINE for a in arrOfStr : NEWLINE INDENTINDENT res += a [ 1 : len ( a ) - 1 ] + " " ; NEWLINE DEDENT return res ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT string = "Geeks for Geeks" ; NEWLINE print ( string ) ; NEWLINE print ( FirstAndLast ( string ) ) ; NEWLINE NL DEDENT ENDMARKER
s = input ( ) NEWLINE NL ENDMARKER
s = input ( ) s1 = s [ : len ( s ) // 2 ] if len ( s ) % 2 == 0 : s2 = s [ len ( s ) // 2 : ] else : s2 = s [ len ( s ) // 2 + 1 : ]  s2 = s2 [ - 1 : : - 1 ] NEWLINE NL ENDMARKER
n = int ( input ( ) ) notes = list ( map ( int , input ( ) . split ( ) ) ) print ( ( 1 , - 1 ) [ min ( notes ) == 1 ] ) NEWLINE NL ENDMARKER
n , k , t = map ( int , input ( ) . split ( " " ) ) v = min ( t , k , n + k - t ) print ( v ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : NEWLINE INDENT n = int ( input ( ) ) NEWLINE print ( * list ( range ( 1 , n + 1 ) ) , sep = " " ) NEWLINE NL DEDENT ENDMARKER
'''* Author : Ayushman Chahar #* About  : IT Sophomore    #* Insti  : VIT, Vellore    #'''  import osimport sys NEWLINE NL ENDMARKER
def russianPeasant ( a , b ) : NEWLINE INDENT res = 0 NEWLINE while ( b > 0 ) : NEWLINE INDENTINDENT if ( b & 1 ) : NEWLINE INDENTINDENTINDENT res = res + a NEWLINE DEDENT a = a << 1 NEWLINE b = b >> 1 NEWLINE DEDENT return res NEWLINE DEDENT print ( russianPeasant ( 18 , 1 ) ) NEWLINE print ( russianPeasant ( 20 , 12 ) ) NEWLINE NL ENDMARKER
def OR ( a , n ) : NEWLINE INDENT ans = a [ 0 ] NEWLINE for i in range ( 1 , n ) : NEWLINE INDENTINDENT ans |= a [ i ] NEWLINE DEDENT return ans NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = [ 1 , 4 , 6 ] NEWLINE n = len ( a ) NEWLINE print ( OR ( a , n ) ) NEWLINE NL DEDENT ENDMARKER
def printPairs ( arr , n ) : NEWLINE INDENT for i in range ( n ) : NEWLINE INDENTINDENT for j in range ( n ) : NEWLINE INDENTINDENTINDENT print ( "(" , arr [ i ] , "," , arr [ j ] , ")" , end = ", " ) NEWLINE DEDENT DEDENT DEDENT arr = [ 1 , 2 ] NEWLINE n = len ( arr ) NEWLINE printPairs ( arr , n ) NEWLINE NL ENDMARKER
import osimport NEWLINE sysfrom NEWLINE io NEWLINE import BytesIO , IOBase NEWLINE NL ENDMARKER
def sumOfDivisblePowers ( L , R , P ) : NEWLINE INDENT res = 0 NEWLINE for i in range ( L , R + 1 ) : NEWLINE INDENTINDENT x = i NEWLINE while ( x % P == 0 ) : NEWLINE INDENTINDENTINDENT res += 1 NEWLINE x /= P NEWLINE DEDENT DEDENT return res NEWLINE DEDENT L = 1 NEWLINE R = 10 NEWLINE P = 2 NEWLINE print ( sumOfDivisblePowers ( L , R , P ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : print ( int ( input ( ) ) // 2 ) NEWLINE NL ENDMARKER
from math import sqrt NEWLINE def circleradius ( l , b ) : NEWLINE INDENT if ( l < 0 or b < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT r = ( l * b ) / ( 2 * sqrt ( ( pow ( l , 2 ) + pow ( b , 2 ) ) ) ) ; NEWLINE return r NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT l = 5 NEWLINE b = 3 NEWLINE print ( "{0:.5}" . format ( circleradius ( l , b ) ) ) NEWLINE NL DEDENT ENDMARKER
a , b , r = map ( int , input ( ) . split ( ) ) if ( 2 * r > min ( a , b ) ) : print ( "Second" ) else : print ( "First" ) NEWLINE NL ENDMARKER
def nextPowerOf2 ( n ) : NEWLINE INDENT n -= 1 NEWLINE n |= n >> 1 NEWLINE n |= n >> 2 NEWLINE n |= n >> 4 NEWLINE n |= n >> 8 NEWLINE n |= n >> 16 NEWLINE n += 1 NEWLINE return n NEWLINE DEDENT n = 5 NEWLINE print ( nextPowerOf2 ( n ) ) NEWLINE NL ENDMARKER
tests = int ( input ( ) )  for test in range ( tests ) : n , d = map ( int , input ( ) . split ( ) ) NEWLINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEWLINE a . sort ( )  if max ( a ) <= d : NEWLINE INDENT print ( "YES" ) else : NEWLINE b = [ a [ 0 ] + a [ 1 ] if x >= d else x for x in a ] NEWLINE DEDENT if max ( b ) <= d : NEWLINE INDENT print ( "YES" ) else : NEWLINE print ( "NO" ) NEWLINE NL DEDENT ENDMARKER
a , b , c , d = map ( int , input ( ) . split ( ) ) x , y = map ( int , input ( ) . split ( ) ) m = abs ( c - a ) n = abs ( d - b ) if m % x != 0 or n % y != 0 : print ( 'NO' ) elif ( m // x ) % 2 != ( n // y ) % 2 : print ( 'NO' ) else : print ( 'YES' ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) c = k + 1 if n % ( 2 * k + 1 ) >= k + 1 or n % ( 2 * k + 1 ) == 0 else 1 ans = [ ] while c <= n : ans . append ( c ) c += 2 * k + 1 if ans [ - 1 ] + k < n : ans . append ( min ( n , ans [ - 1 ] + k * 2 + 1 ) ) print ( len ( ans ) ) print ( * ans ) NEWLINE NL ENDMARKER
def digSum ( n ) : NEWLINE INDENT if n == 0 : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT return ( n % 9 == 0 ) and 9 or ( n % 9 ) NEWLINE DEDENT def repeatedNumberSum ( n , x ) : NEWLINE INDENT sum = x * digSum ( n ) NEWLINE return digSum ( sum ) NEWLINE DEDENT n = 24 ; x = 3 NEWLINE print ( repeatedNumberSum ( n , x ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : c , r = map ( int , input ( ) . split ( ) ) grid = [ [ ] for _ in range ( c ) ] grid [ 0 ] . append ( 'W' ) for i in grid : for _ in range ( r ) : i . append ( 'B' ) grid [ 0 ] . remove ( grid [ 0 ] [ - 1 ] ) for i in grid : print ( '' . join ( i ) ) NEWLINE NL ENDMARKER
l = [ ] for i in range ( int ( input ( ) ) ) : l . append ( sum ( list ( map ( int , input ( ) . split ( ) ) ) ) ) print ( sum ( 1 for i in l if i > l [ 0 ] ) + 1 ) NEWLINE NL ENDMARKER
def breakSum ( n ) : NEWLINE INDENT if ( n == 0 or n == 1 ) : NEWLINE INDENTINDENT return n NEWLINE DEDENT return max ( ( breakSum ( n // 2 ) + breakSum ( n // 3 ) + breakSum ( n // 4 ) ) , n ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 12 NEWLINE print ( breakSum ( n ) ) NEWLINE NL DEDENT ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) s = list ( input ( ) ) for i in range ( m ) : a , b , c , d = map ( str , input ( ) . split ( ) ) a = int ( a ) b = int ( b ) if a == b : if s [ a - 1 ] == c : s [ a - 1 ] = d else : for j in range ( a - 1 , b ) : if s [ j ] == c : s [ j ] = dfor i in s : print ( i , end = '' ) NEWLINE NL ENDMARKER
import sysdef add ( x , y , id_t , shelves , track ) : element = ( ( x - 1 ) % n ) * m + y - 1 ; if shelves [ element ] : element += 1 NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )  min = min ( arr ) sum = 0 for a in arr : if ( a - min ) % k != 0 : sum = 1 k = 2 break sum += a - min  print ( - 1 ) if sum % k != 0 and n > 1 else print ( int ( ( sum / k ) ) ) NEWLINE NL ENDMARKER
rooms = int ( input ( '' ) ) count = 0 for room in range ( rooms ) : x = input ( '' ) . split ( ) if int ( x [ 1 ] ) - int ( x [ 0 ] ) >= 2 : count += 1 print ( count ) NEWLINE NL ENDMARKER
def nCr ( n , r ) : NEWLINE INDENT return ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) NEWLINE DEDENT def fact ( n ) : NEWLINE INDENT res = 1 NEWLINE for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT res = res * i NEWLINE DEDENT return res NEWLINE DEDENT n = 5 NEWLINE r = 3 NEWLINE print ( int ( nCr ( n , r ) ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) if n == 1 or n == 2 : print ( - 1 ) else : arr = [ int ( i ) for i in range ( n , 0 , - 1 ) ] print ( * arr ) NEWLINE NL ENDMARKER
days = int ( input ( ) ) dailyReq = [ ] dailyPrice = [ ] totalCost = 0 for day in range ( days ) : a , p = input ( ) . split ( ) dailyReq . append ( int ( a ) ) dailyPrice . append ( int ( p ) )  minPrice = dailyPrice [ 0 ] for day in range ( days ) : if ( dailyPrice [ day ] < minPrice ) : minPrice = dailyPrice [ day ] totalCost += dailyReq [ day ] * minPrice  print ( totalCost )  NEWLINE NL ENDMARKER
def cen_octagonalnum ( n ) : NEWLINE INDENT return ( 4 * n * n - 4 * n + 1 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 6 NEWLINE print ( n , "th Centered" , "octagonal number: " , cen_octagonalnum ( n ) ) NEWLINE n = 11 NEWLINE print ( n , "th Centered" , "octagonal number: " , cen_octagonalnum ( n ) ) NEWLINE NL DEDENT ENDMARKER
s = input ( ) if 'H' in s or 'Q' in s or '9' in s : print ( 'YES' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
def solve ( n ) : NEWLINE INDENT n_2 = n // 2 ; NEWLINE den = "1" ; NEWLINE while ( n_2 ) : NEWLINE INDENTINDENT den += '0' ; NEWLINE n_2 -= 1 NEWLINE DEDENT print ( str ( 1 ) + "/" + str ( den ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 5 ; NEWLINE solve ( N ) ; NEWLINE NL DEDENT ENDMARKER
w , h = map ( int , input ( ) . split ( ) ) l = [ ] for i in range ( h ) : s = input ( ) l . append ( s ) for i in range ( w ) : s = '' for j in range ( h - 1 , - 1 , - 1 ) : s += l [ j ] [ i ] * 2 s = s [ : : - 1 ] print ( s ) print ( s ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) string = input ( )  ones = string . count ( 'n' ) length = nlength -= ones * 3  print ( ( '1 ' * ones ) + '0 ' * ( int ( length / 4 ) ) ) NEWLINE NL ENDMARKER
def product ( a , n ) : NEWLINE INDENT ans = 1 NEWLINE val = pow ( 2 , n - 1 ) NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT ans *= pow ( a [ i ] , val ) NEWLINE DEDENT return ans NEWLINE DEDENT n = 2 NEWLINE a = [ 3 , 7 ] NEWLINE print ( product ( a , n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) b = list ( map ( int , input ( ) . split ( ) ) ) s = [ 0 ] x = 0 g = [ ] for i in b : x += 1 if i >= 1 and i - max ( s ) == 1 : g . append ( 2000 + x ) s . append ( i ) else : continues . remove ( 0 ) k = list ( zip ( g , s ) ) h = [ ] for p in range ( len ( k ) ) : h . append ( k [ p ] [ 0 ] ) if len ( s ) == 0 : print ( 0 ) else : print ( len ( h ) ) print ( * h ) NEWLINE NL ENDMARKER
def rotate ( item : str ) -> str : NEWLINE NL ENDMARKER
def centered_pentagonal_Num ( n ) : NEWLINE INDENT return ( 5 * n * n - 5 * n + 2 ) // 2 NEWLINE DEDENT n = 7 NEWLINE print ( "%sth Centered pentagonal number : " % n , centered_pentagonal_Num ( n ) ) NEWLINE NL ENDMARKER
def gcd ( a , b ) : NEWLINE INDENT if a == 0 : NEWLINE INDENTINDENT return b NEWLINE DEDENT return gcd ( b % a , a ) NEWLINE DEDENT def lcm ( a , b ) : NEWLINE INDENT return ( a * b ) / gcd ( a , b ) NEWLINE DEDENT a = 15 NEWLINE b = 20 NEWLINE print ( 'LCM of' , a , 'and' , b , 'is' , lcm ( a , b ) ) NEWLINE NL ENDMARKER
def sumofseries ( n ) : NEWLINE INDENT res = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT res += ( i ) * ( i + 1 ) * ( i + 2 ) NEWLINE DEDENT return res NEWLINE DEDENT print ( sumofseries ( 3 ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) if n % 2 == 0 and n != 2 : print ( "YES" ) else : print ( "NO" )  NEWLINE NL ENDMARKER
def seriessum ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT sum += i * ( i + 1 ) / 2 NEWLINE DEDENT return sum NEWLINE DEDENT n = 4 NEWLINE print ( seriessum ( n ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : a , b , c = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) NEWLINE print ( a + b + c - 1 ) NEWLINE NL ENDMARKER
def nextPowerOf2 ( n ) : NEWLINE INDENT p = 1 NEWLINE if ( n and not ( n & ( n - 1 ) ) ) : NEWLINE INDENTINDENT return n NEWLINE DEDENT while ( p < n ) : NEWLINE INDENTINDENT p <<= 1 NEWLINE DEDENT return p ; NEWLINE DEDENT n = 5 NEWLINE print ( nextPowerOf2 ( n ) ) ; NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) k = 0 pas = 0 a = a [ : : - 1 ] for i in set ( a ) : s = a . count ( i ) if s > k : pas = i k = s elif s == k : if a . index ( i ) > a . index ( pas ) : pas = i k = a . count ( i ) print ( pas ) NEWLINE NL ENDMARKER
import math  a , b , x , y = map ( int , input ( ) . split ( ) ) c = math . gcd ( x , y ) x //= cy //= cans = min ( a // x , b // y ) print ( ans ) NEWLINE NL ENDMARKER
import sys  n , m , c = map ( int , input ( ) . split ( ) ) a = [ ] for i in range ( n + 1 ) : a . append ( 0 ) cnt = 0 while cnt < n : i = 0 x = int ( input ( ) ) if x * 2 <= c : i = 1 while a [ i ] and a [ i ] <= x : i += 1 else : i = n while a [ i ] and a [ i ] >= x : i -= 1 if a [ i ] == 0 : cnt += 1 a [ i ] = x print ( i ) sys . stdout . flush ( ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) tmp = 0 for i in range ( 1 , 10 ) : k = i while k <= n : tmp += 1 k = k * 10 + i print ( tmp ) NEWLINE NL ENDMARKER
import sysn = int ( input ( ) ) ls = [ ] for _ in range ( n ) : s = sys . stdin . readline ( ) ls . append ( int ( s ) ) ls . sort ( )  cnt = 0 mid = n // 2 - 1 right = n - 1 mated = 0 for _ in range ( n // 2 ) : if ls [ right ] >= 2 * ls [ mid ] and mid >= 0 : cnt += 1 mid -= 1 right -= 1 mated += 2 else : mid -= 1 print ( cnt + n - mated ) NEWLINE NL ENDMARKER
def smallestMultiple ( n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT return 5 NEWLINE DEDENT return pow ( 10 , n - 1 ) NEWLINE DEDENT n = 4 NEWLINE print ( smallestMultiple ( n ) ) NEWLINE NL ENDMARKER
def is_just ( num ) : newnum = num NEWLINE INDENT pass NEWLINE DEDENT while newnum > 0 : if NEWLINE newnum % 10 != 0 : NEWLINE if num % ( newnum % 10 ) != 0 : return False NEWLINE newnum //= 10 NEWLINE return True                  t = int ( input ( ) ) NEWLINE for ti in range ( t ) : n = int ( input ( ) ) NEWLINE x = n NEWLINE while not is_just ( x ) : x += 1 NEWLINE print ( x ) NEWLINE NL ENDMARKER
l = int ( input ( ) ) p = int ( input ( ) ) q = int ( input ( ) )  time = l / ( p + q ) print ( p * time ) NEWLINE NL ENDMARKER
def printXYZ ( n ) : NEWLINE INDENT if n == 1 : NEWLINE INDENTINDENT print ( - 1 ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "x is " , n ) NEWLINE print ( "y is " , n + 1 ) NEWLINE print ( "z is " , n * ( n + 1 ) ) NEWLINE DEDENT DEDENT n = 7 NEWLINE printXYZ ( n ) NEWLINE NL ENDMARKER
pp = printli = listtp = tuplebg = 1e9 sg = - 1e9 rd = roundss = sortedsj = "" . joinnl = "\n"   def solve ( ) : a , b , c , d = map ( int , input ( ) . split ( ) ) if b >= a : print ( b ) elif d >= c : print ( - 1 ) else : print ( b + ( 0 - - ( a - b ) // ( c - d ) ) * c )                def main ( ) : for i in range ( int ( input ( ) ) ) : solve ( )  main ( )                            NEWLINE NL ENDMARKER
n = int ( input ( ) )  for _ in range ( n ) : side_length = list ( map ( int , input ( ) . split ( ) ) ) print ( max ( min ( side_length ) * 2 , max ( side_length ) ) ** 2 ) NEWLINE NL ENDMARKER
def index ( i ) : NEWLINE INDENT return 1 + ( i >> 31 ) - ( - i >> 31 ) NEWLINE DEDENT def check ( n ) : NEWLINE INDENT s = "negative" , "zero" , "positive" NEWLINE val = index ( n ) NEWLINE print ( n , "is" , s [ val ] ) NEWLINE DEDENT check ( 30 ) NEWLINE check ( - 20 ) NEWLINE check ( 0 ) NEWLINE NL ENDMARKER
def fnMod ( n ) : NEWLINE INDENT rem = n % 4 NEWLINE if ( rem == 0 or rem == 3 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT elif ( rem == 1 or rem == 2 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 6 NEWLINE print ( fnMod ( n ) ) NEWLINE NL DEDENT ENDMARKER
def nthDigit ( a , n , b ) : NEWLINE INDENT for i in range ( 1 , n ) : NEWLINE INDENTINDENT a = a // b NEWLINE DEDENT return a % b NEWLINE DEDENT a = 100 NEWLINE n = 3 NEWLINE b = 4 NEWLINE print ( nthDigit ( a , n , b ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) print ( n + 1 ) NEWLINE NL ENDMARKER
def getSum ( n , d ) : NEWLINE INDENT sum = 0 NEWLINE while ( d <= n ) : NEWLINE INDENTINDENT sum += d NEWLINE d += 10 NEWLINE DEDENT return sum NEWLINE DEDENT n = 30 NEWLINE d = 3 NEWLINE print ( getSum ( n , d ) ) NEWLINE NL ENDMARKER
r = lambda : list ( map ( int , input ( ) . split ( ) ) ) t = int ( input ( ) ) for _ in range ( t ) : s = list ( input ( ) ) if ( len ( set ( s ) ) == 1 ) : print ( - 1 ) else : print ( '' . join ( sorted ( s ) ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) st = input ( ) for i in range ( n - 1 ) : if st [ i ] > st [ i + 1 ] : st = st [ : i ] + st [ i + 1 : ] breakif len ( st ) != n : print ( st ) else : print ( st [ : - 1 ] ) NEWLINE NL ENDMARKER
import sys  def main ( ) : n = int ( sys . stdin . read ( ) . strip ( ) ) d = { 1 : '0 A' , 3 : '2 A' , 2 : '1 B' , 0 : '1 A' } return d [ n % 4 ]  print ( main ( ) ) NEWLINE NL ENDMARKER
from sys import stdin , stdoutfor _ in range ( 1 ) : NEWLINE NL ENDMARKER
import math NEWLINE def cubeSide ( h , r ) : NEWLINE INDENT if ( h < 0 and r < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT a = ( ( h * r * math . sqrt ( 2 ) ) / ( h + math . sqrt ( 2 ) * r ) ) NEWLINE return a NEWLINE DEDENT h = 5 ; r = 6 ; NEWLINE print ( cubeSide ( h , r ) , "\n" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) if n % 2 == 1 : print ( 0 ) else : print ( 2 ** ( n // 2 ) ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for i in range ( t ) : NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) p = l . copy ( ) p . sort ( ) print ( n )  for i in range ( n ) : j = l [ i : ] . index ( p [ i ] ) + i print ( i , j ) l [ i ] , l [ j ] = l [ j ] , l [ i ] NEWLINE NL ENDMARKER
n = int ( input ( ) ) sum = 0 i = 0 for i in range ( 1 , n + 1 , 1 ) : for j in range ( 1 , i + 1 , 1 ) : sum += j if ( sum > n ) : breakif ( n < 4 ) : print ( 1 ) NEWLINE NL ENDMARKER
def findNumber ( n ) : NEWLINE INDENT n -= 1 NEWLINE i = 1 NEWLINE while n >= 0 : NEWLINE INDENTINDENT n -= i NEWLINE i += 1 NEWLINE DEDENT return ( n + i ) NEWLINE DEDENT n = 3 NEWLINE print ( findNumber ( n ) ) NEWLINE NL ENDMARKER
def fnMod ( n ) : NEWLINE INDENT if ( n % 5 == 1 ) : NEWLINE INDENTINDENT return 4 NEWLINE DEDENT else : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT DEDENT n = 10 NEWLINE print ( fnMod ( n ) ) NEWLINE n = 11 NEWLINE print ( fnMod ( n ) ) NEWLINE NL ENDMARKER
def countOddSquares ( n , m ) : NEWLINE INDENT return int ( m ** 0.5 ) - int ( ( n - 1 ) ** 0.5 ) NEWLINE DEDENT n = 5 NEWLINE m = 100 NEWLINE print ( "Count is" , countOddSquares ( n , m ) ) NEWLINE NL ENDMARKER
from math import sqrtdef distance ( x1 , y1 , x2 , y2 ) : return ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2  a , b , x , y , c , d = [ int ( element ) for element in input ( ) . split ( " " ) ]  if distance ( x , y , a , b ) == distance ( x , y , c , d ) and ( ( b - y ) * ( x - c ) - ( y - d ) * ( a - x ) ) != 0 : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
def getMissingNo ( a , n ) : NEWLINE INDENT x1 = a [ 0 ] NEWLINE x2 = 1 NEWLINE for i in range ( 1 , n ) : NEWLINE INDENTINDENT x1 = x1 ^ a [ i ] NEWLINE DEDENT for i in range ( 2 , n + 2 ) : NEWLINE INDENTINDENT x2 = x2 ^ i NEWLINE DEDENT return x1 ^ x2 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = [ 1 , 2 , 4 , 5 , 6 ] NEWLINE n = len ( a ) NEWLINE miss = getMissingNo ( a , n ) NEWLINE print ( miss ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) a = n // 36 rema = n % 36 if ( rema == 35 ) : a += 1 if ( a >= n ) : b = 0 else : b = ( n - a * 36 ) // 3 rem = ( n - a * 36 ) % 3 if ( rem == 2 ) : b += 1 print ( a , b ) NEWLINE NL ENDMARKER
from math import tan NEWLINE def polyapothem ( n , a ) : NEWLINE INDENT if ( a < 0 and n < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT return a / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = 9 NEWLINE n = 6 NEWLINE print ( '{0:.6}' . format ( polyapothem ( n , a ) ) ) NEWLINE NL DEDENT ENDMARKER
from math import ceiln = int ( input ( ) ) x = input ( ) p = [ 'ogo' ] + [ 'ogo' + 'go' * i for i in range ( 1 , 50 ) ] j = ceil ( ( n - 3 ) / 2 ) if n < 3 : print ( x ) else : while j >= 0 : if p [ j ] in x : x = x . replace ( p [ j ] , '***' ) else : j = j - 1 print ( x ) NEWLINE NL ENDMARKER
import math NEWLINE def Area ( a ) : NEWLINE INDENT if ( a < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT h = 1.268 * a NEWLINE A = 0.70477 * math . pow ( h , 2 ) NEWLINE return A NEWLINE DEDENT a = 5 NEWLINE print ( Area ( a ) , end = "\n" ) NEWLINE NL ENDMARKER
def sumOfTheSeries ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT k = 1 NEWLINE for j in range ( 1 , i + 1 ) : NEWLINE INDENTINDENTINDENT sum += k NEWLINE k += 2 NEWLINE DEDENT DEDENT return sum NEWLINE DEDENT n = 5 NEWLINE print ( "Sum =" , sumOfTheSeries ( n ) ) NEWLINE NL ENDMARKER
def printGroups ( n ) : NEWLINE INDENT x = 1 NEWLINE y = n * n NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT for j in range ( 1 , n // 2 + 1 ) : NEWLINE INDENTINDENTINDENT print ( "{" , x , "," , y , "}" , end = " " ) NEWLINE x += 1 NEWLINE y -= 1 NEWLINE DEDENT print ( ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 4 NEWLINE printGroups ( n ) NEWLINE NL DEDENT ENDMARKER
def heptagonalNumber ( n ) : NEWLINE INDENT return ( ( 5 * n * n ) - ( 3 * n ) ) // 2 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 2 NEWLINE print ( heptagonalNumber ( n ) ) NEWLINE n = 15 NEWLINE print ( heptagonalNumber ( n ) ) NEWLINE NL DEDENT ENDMARKER
def sumOfTheSeries ( n ) : NEWLINE INDENT return ( float ( n ) / ( n + 1 ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 10 NEWLINE ans = sumOfTheSeries ( n ) NEWLINE print ( round ( ans , 6 ) ) NEWLINE NL DEDENT ENDMARKER
def findGreater ( x , y ) : NEWLINE INDENT if ( x > y ) : NEWLINE INDENTINDENT return False ; NEWLINE DEDENT else : NEWLINE INDENTINDENT return True ; NEWLINE DEDENT DEDENT x = 4 ; NEWLINE y = 9 ; NEWLINE if ( findGreater ( x , y ) ) : NEWLINE INDENT print ( "1" ) ; NEWLINE DEDENT else : NEWLINE INDENT print ( "2" ) ; NEWLINE NL DEDENT ENDMARKER
def countPieces ( N ) : NEWLINE INDENT return 2 * N NEWLINE DEDENT N = 100 NEWLINE print ( countPieces ( N ) ) NEWLINE NL ENDMARKER
import math NEWLINE def fib ( n ) : NEWLINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) / 2 ; NEWLINE return int ( round ( pow ( phi , n ) / math . sqrt ( 5 ) ) ) ; NEWLINE DEDENT def calculateSum ( l , r ) : NEWLINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) ; NEWLINE return sum ; NEWLINE DEDENT l = 4 ; NEWLINE r = 8 ; NEWLINE print ( calculateSum ( l , r ) ) ; NEWLINE NL ENDMARKER
n = int ( input ( ) ) p = [ int ( i ) for i in input ( ) . split ( ) ] zeros = [ int ( i ) for i in input ( ) . split ( ) ]  ans = 0  if not sum ( zeros ) % 2 : ans += 1  visited = [ False for i in range ( n ) ]  ciclos = 0 for i in range ( n ) : if not visited [ i ] : ciclos += 1 j = i while not visited [ j ] : visited [ j ] = True j = p [ j ] - 1  if ciclos == 1 : ans += 0 else : ans += ciclos  print ( ans ) NEWLINE NL ENDMARKER
import math NEWLINE def getValue ( n ) : NEWLINE INDENT result = int ( math . floor ( math . log ( n + 1 ) / math . log ( 2 ) ) ) NEWLINE return int ( math . pow ( 2 , result ) ) NEWLINE DEDENT n = 9 NEWLINE print ( getValue ( n ) ) NEWLINE n = 1025 NEWLINE print ( getValue ( n ) ) NEWLINE NL ENDMARKER
   n = int ( input ( ) )   t = list ( map ( int , input ( ) . split ( ) ) )   if n <= 2 : print ( 0 ) else : p = 0 for k in range ( 1 , n - 1 ) :  if t [ k - 1 ] > t [ k ] < t [ k + 1 ] or t [ k - 1 ] < t [ k ] > t [ k + 1 ] : p += 1  print ( p ) NEWLINE NL ENDMARKER
size = int ( input ( ) ) stack = list ( input ( ) )  print ( sum ( [ 2 ** i for i in range ( size ) if stack [ i ] == 'B' ] ) ) NEWLINE NL ENDMARKER
l , d , v , g , r = list ( map ( int , input ( ) . split ( ) ) ) t1 = ( d / v ) % ( g + r ) - gif t1 < 0 : print ( l / v ) else : print ( l / v + r - t1 ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) lst = [ ] for i in range ( m ) : lst . append ( list ( map ( int , input ( ) . split ( ) ) ) ) lst . sort ( key = lambda x : x [ 1 ] ) lst . reverse ( ) count = 0 for i in lst : if n <= i [ 0 ] : count += ( n * i [ 1 ] ) break else : count += ( i [ 0 ] * i [ 1 ] ) n -= i [ 0 ] if n == 0 : break print ( count ) NEWLINE NL ENDMARKER
n = list ( map ( int , input ( ) . split ( ) ) ) a = { 'S' : 0 , 'M' : 1 , 'L' : 2 , 'XL' : 3 , 'XXL' : 4 } b = [ 'S' , 'M' , 'L' , 'XL' , 'XXL' ] for i in range ( int ( input ( ) ) ) : c = a [ input ( ) ] for i in range ( 5 ) : if c + i < 5 and n [ c + i ] > 0 : print ( b [ c + i ] ) n [ c + i ] -= 1 break elif c - i >= 0 and n [ c - i ] > 0 : print ( b [ c - i ] ) n [ c - i ] -= 1 break NEWLINE NL ENDMARKER
def isDivisible ( n ) : NEWLINE INDENT while n // 100 : NEWLINE INDENTINDENT d = n % 10 NEWLINE n //= 10 NEWLINE n = abs ( n - ( d * 7 ) ) NEWLINE DEDENT return ( n % 71 == 0 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 5041 NEWLINE if ( isDivisible ( N ) ) : NEWLINE INDENTINDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) NEWLINE NL DEDENT DEDENT ENDMARKER
import math NEWLINE def countLattice ( r ) : NEWLINE INDENT if ( r <= 0 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT result = 4 NEWLINE for x in range ( 1 , r ) : NEWLINE INDENTINDENT ySquare = r * r - x * x NEWLINE y = int ( math . sqrt ( ySquare ) ) NEWLINE if ( y * y == ySquare ) : NEWLINE INDENTINDENTINDENT result += 4 NEWLINE DEDENT DEDENT return result NEWLINE DEDENT r = 5 NEWLINE print ( countLattice ( r ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) + 1 print ( n // 36 , int ( n / 3 % 12 ) ) NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readline  n , k = [ int ( i ) for i in input ( ) . split ( ) ] a = [ int ( i ) for i in input ( ) . split ( ) ] count = 1 while k - count > 0 : k -= count count += 1 print ( a [ k - 1 ] ) NEWLINE NL ENDMARKER
def findSum ( N , K ) : NEWLINE INDENT ans = 0 ; NEWLINE for i in range ( 1 , N + 1 ) : NEWLINE INDENTINDENT ans += ( i % K ) ; NEWLINE DEDENT return ans ; NEWLINE DEDENT N = 10 ; NEWLINE K = 2 ; NEWLINE print ( findSum ( N , K ) ) ; NEWLINE NL ENDMARKER
from math import ceil NEWLINE def isPerfectCubeString ( str1 ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( len ( str1 ) ) : NEWLINE INDENTINDENT sum += ord ( str1 [ i ] ) NEWLINE DEDENT cr = ceil ( ( sum ) ** ( 1 / 3 ) ) NEWLINE return ( cr * cr * cr == sum ) NEWLINE DEDENT str1 = "ll" NEWLINE if ( isPerfectCubeString ( str1 ) ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
def getNthTerm ( N ) : NEWLINE INDENT return ( pow ( N , 2 ) + N + 1 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 11 NEWLINE print ( getNthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) if n % 2 == 0 : print ( n ** 2 // 2 ) for i in range ( n ) : if i % 2 == 0 : print ( 'C.' * ( n // 2 ) ) else : print ( '.C' * ( n // 2 ) ) else : print ( n ** 2 // 2 + 1 ) for i in range ( n ) : if i % 2 == 0 : print ( 'C.' * ( n // 2 ) + 'C' ) else : print ( '.C' * ( n // 2 ) + '.' ) NEWLINE NL ENDMARKER
def maximum ( x , y ) : NEWLINE INDENT return ( ( x + y + abs ( x - y ) ) // 2 ) NEWLINE DEDENT def minimum ( x , y ) : NEWLINE INDENT return ( ( x + y - abs ( x - y ) ) // 2 ) NEWLINE DEDENT x = 99 NEWLINE y = 18 NEWLINE print ( "Maximum:" , maximum ( x , y ) ) NEWLINE print ( "Minimum:" , minimum ( x , y ) ) NEWLINE NL ENDMARKER
n , m , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) ) d = { } for i in range ( n ) : if d . get ( b [ i ] ) : if d [ b [ i ] ] < a [ i ] : d [ b [ i ] ] = a [ i ] else : d [ b [ i ] ] = a [ i ] ans = 0 for i in c : if a [ i - 1 ] < d [ b [ i - 1 ] ] : ans += 1 print ( ans ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for i in range ( t ) : n , k = [ int ( x ) for x in input ( ) . split ( ) ] count = 0 while n != 0 : if n % k == 0 : n = n // k count = count + 1 else : count = count + n % k n = n - n % k print ( count ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) odd , evenGood , evenBad = 0 , 0 , 0 for i in range ( n ) : a = input ( ) if len ( a ) % 2 == 1 : odd += 1 if a . count ( '0' ) % 2 == 0 : evenGood += 1 else : evenBad += 1 print ( n - 1 if ( odd == 0 and evenBad % 2 == 1 ) else n ) NEWLINE NL ENDMARKER
def pairwiseSum ( lst , n ) : NEWLINE INDENT sum = 0 ; NEWLINE for i in range ( len ( lst ) - 1 ) : NEWLINE INDENTINDENT sum = lst [ i ] + lst [ i + 1 ] NEWLINE print ( sum , end = " " ) NEWLINE DEDENT DEDENT arr = [ 4 , 10 , 15 , 5 , 6 ] NEWLINE size = len ( arr ) NEWLINE pairwiseSum ( arr , size ) NEWLINE NL ENDMARKER
def distinctCount ( arr , n ) : NEWLINE INDENT s = set ( ) NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT s . add ( abs ( arr [ i ] ) ) NEWLINE DEDENT return len ( s ) NEWLINE DEDENT arr = [ - 2 , - 1 , 0 , 1 , 1 ] NEWLINE n = len ( arr ) NEWLINE print ( "Count of absolute distinct values:" , distinctCount ( arr , n ) ) NEWLINE NL ENDMARKER
def countWays ( n , k ) : NEWLINE INDENT total = k NEWLINE mod = 1000000007 NEWLINE same , diff = 0 , k NEWLINE for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT same = diff NEWLINE diff = total * ( k - 1 ) NEWLINE diff = diff % mod NEWLINE total = ( same + diff ) % mod NEWLINE DEDENT return total NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n , k = 3 , 2 NEWLINE print ( countWays ( n , k ) ) NEWLINE NL DEDENT ENDMARKER
for i in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) if k % 2 == n % 2 and n >= k * k : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for z in range ( t ) : n , x = input ( ) . split ( ) n = int ( n ) x = int ( x ) print ( n , 2 * n ) NEWLINE NL ENDMARKER
def checksum ( n ) : NEWLINE INDENT n = int ( n ) NEWLINE if n % 5 == 0 : NEWLINE INDENTINDENT print ( int ( n / 5 - 2 ) , " " , int ( n / 5 - 1 ) , " " , int ( n / 5 ) , " " , int ( n / 5 + 1 ) , " " , int ( n / 5 + 2 ) ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "-1" ) NEWLINE DEDENT DEDENT n = 15 NEWLINE checksum ( n ) NEWLINE NL ENDMARKER
def printGP ( a , r , n ) : NEWLINE INDENT for i in range ( 0 , n ) : NEWLINE INDENTINDENT curr_term = a * pow ( r , i ) NEWLINE print ( curr_term , end = " " ) NEWLINE DEDENT DEDENT a = 2 NEWLINE r = 3 NEWLINE n = 5 NEWLINE printGP ( a , r , n ) NEWLINE NL ENDMARKER
def reverseFibonacci ( n ) : NEWLINE INDENT a = [ 0 ] * n NEWLINE a [ 0 ] = 0 NEWLINE a [ 1 ] = 1 NEWLINE for i in range ( 2 , n ) : NEWLINE INDENTINDENT a [ i ] = a [ i - 2 ] + a [ i - 1 ] NEWLINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEWLINE INDENTINDENT print ( a [ i ] , end = " " ) NEWLINE DEDENT DEDENT n = 5 NEWLINE reverseFibonacci ( n ) NEWLINE NL ENDMARKER
import math , sys NEWLINE NL ENDMARKER
MAX = 1000000 NEWLINE def breakSum ( n ) : NEWLINE INDENT dp = [ 0 ] * ( n + 1 ) NEWLINE dp [ 0 ] = 0 NEWLINE dp [ 1 ] = 1 NEWLINE for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] + dp [ int ( i / 4 ) ] , i ) ; NEWLINE DEDENT return dp [ n ] NEWLINE DEDENT n = 24 NEWLINE print ( breakSum ( n ) ) NEWLINE NL ENDMARKER
import math NEWLINE def minRevolutions ( r , x1 , y1 , x2 , y2 ) : NEWLINE INDENT d = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) NEWLINE return math . ceil ( d // ( 2 * r ) ) NEWLINE DEDENT r = 2 NEWLINE x1 = 0 NEWLINE y1 = 0 NEWLINE x2 = 0 NEWLINE y2 = 4 NEWLINE print ( minRevolutions ( r , x1 , y1 , x2 , y2 ) ) NEWLINE NL ENDMARKER
import math   def main ( ) : t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) print ( n // 2 )   if __name__ == '__main__' : main ( ) NEWLINE NL ENDMARKER
def getPairs ( a ) : NEWLINE INDENT count = 0 NEWLINE for i in range ( len ( a ) ) : NEWLINE INDENTINDENT for j in range ( len ( a ) ) : NEWLINE INDENTINDENTINDENT if ( a [ i ] < a [ j ] ) : NEWLINE INDENTINDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT DEDENT return count NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = [ 2 , 4 , 3 , 1 ] NEWLINE print ( getPairs ( a ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) d = [ ] while ( n > 0 ) : l , r = map ( int , input ( ) . split ( ) ) n -= 1 z = [ l , r ] d . append ( z ) m = int ( input ( ) ) a = 0 for i in range ( len ( d ) ) : d1 = d [ i ] [ 0 ] d2 = d [ i ] [ 1 ] if ( m >= d1 or m <= d2 ) and m <= d2 : a += 1  print ( a ) NEWLINE NL ENDMARKER
MAX = 1000001  e = int ( input ( ) ) q = input ( ) . split ( ) m = int ( input ( ) ) arr1 = [ MAX ] * e  for i in range ( m ) : [ a , b , c ] = list ( map ( int , input ( ) . split ( ) ) ) arr1 [ b - 1 ] = min ( arr1 [ b - 1 ] , c )  count = 0 for x in arr1 : if x == MAX : count += 1 if count > 1 : print ( - 1 ) else : res = 0 for k in arr1 : if k != MAX : res += k print ( res ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = list ( map ( int , input ( ) . split ( ) ) ) b = max ( s ) for i in range ( 1 , b + 1 ) : if ( b % i == 0 ) : s . pop ( s . index ( i ) ) a = max ( s ) print ( a , b ) NEWLINE NL ENDMARKER
def cntWays ( string , n ) : NEWLINE INDENT x = n + 1 ; NEWLINE ways = x * x * ( x * x - 1 ) // 12 ; NEWLINE return ways ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT string = "ab" ; NEWLINE n = len ( string ) ; NEWLINE print ( cntWays ( string , n ) ) ; NEWLINE NL DEDENT ENDMARKER
s = str ( input ( ) ) a = s . find ( 'a' ) b = s . find ( 'b' ) c = s . find ( 'c' ) if ( 'a' in s ) and ( 'b' in s ) and ( 'b' in s ) and ( a < b < c ) and ( 'ba' not in s ) and ( 'ca' not in s ) and ( 'cb' not in s ) : if s . count ( 'a' ) == s . count ( 'c' ) or s . count ( 'b' ) == s . count ( 'c' ) : print ( "YES" ) else : print ( "NO" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
n = int ( input ( ) )  if n % 2 == 0 : NEWLINE INDENT print ( int ( ( ( n / 2 ) + 1 ) * ( ( n / 2 ) + 1 ) ) ) else : NEWLINE print ( int ( ( 2 + ( n - 1 ) / 2 ) * ( 2 * ( ( n - 1 ) / 2 + 1 ) ) ) ) NEWLINE NL DEDENT ENDMARKER
def halfsquare ( n , x , y ) : NEWLINE INDENT half = n // 2 NEWLINE if ( ( half == x or half == x - 1 ) and ( half == y or half == y - 1 ) ) : NEWLINE INDENTINDENT print ( "NO" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "YES" ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 100 NEWLINE x , y = 51 , 100 NEWLINE halfsquare ( n , x , y ) NEWLINE NL DEDENT ENDMARKER
def func1 ( n , ) : NEWLINE NL ENDMARKER
def countNumberOfTriangles ( n ) : NEWLINE INDENT return ( n * ( n - 1 ) * ( n - 2 ) // 6 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 4 NEWLINE print ( countNumberOfTriangles ( n ) ) NEWLINE NL DEDENT ENDMARKER
class Solution ( object ) : NEWLINE INDENT def peakIndexInMountainArray ( self , A ) : NEWLINE INDENTINDENT lo , hi = 0 , len ( A ) - 1 NEWLINE while lo < hi : NEWLINE INDENTINDENTINDENT mid = ( lo + hi ) / 2 NEWLINE if A [ mid ] < A [ mid + 1 ] : NEWLINE INDENTINDENTINDENTINDENT lo = mid + 1 NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENTINDENT hi = mid NEWLINE DEDENT DEDENT return lo NEWLINE NL DEDENT DEDENT ENDMARKER
class Solution ( object ) : NEWLINE INDENT def hammingDistance ( self , x , y ) : NEWLINE INDENTINDENT return bin ( x ^ y ) . count ( '1' ) NEWLINE NL DEDENT DEDENT ENDMARKER
n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) map = { } for i in arr : if i not in map : map [ i ] = 1 else : map [ i ] += 1 max = 0 for i in map : if map [ i ] > max : max = map [ i ] print ( n - max ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = [ ] for a in range ( 1 , n + 1 ) : for b in range ( 1 , n + 1 ) : if a % b == 0 and a * b > n and a / b < n : l . append ( a ) l . append ( b ) if len ( l ) > 0 : print ( l [ 0 ] , l [ 1 ] ) else : print ( - 1 )                        NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) bs , s = { } , { } for _ in " " * a : x , y , z = input ( ) . split ( ) y , z = int ( y ) , int ( z ) if x == 'B' : if y in bs : bs [ y ] += z else : bs [ y ] = z else : if y in s : s [ y ] += z else : s [ y ] = z NEWLINE NL ENDMARKER
n = int ( input ( ) ) if 0 <= n <= 10 : print ( 0 ) elif n == 11 : print ( 4 ) elif 12 <= n <= 19 : print ( 4 ) elif n == 20 : print ( 15 ) elif n == 21 : print ( 4 ) elif 22 <= n <= 25 : print ( 0 ) NEWLINE NL ENDMARKER
def findAngle ( n ) : NEWLINE INDENT interiorAngle = int ( ( n - 2 ) * 180 / n ) NEWLINE exteriorAngle = int ( 360 / n ) NEWLINE print ( "Interior angle: " , interiorAngle ) NEWLINE print ( "Exterior angle: " , exteriorAngle ) NEWLINE DEDENT n = 10 NEWLINE findAngle ( n ) NEWLINE NL ENDMARKER
def Sum ( n ) : NEWLINE INDENT return n * ( n + 1 ) * ( n + 2 ) // 3 NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 2 ; NEWLINE print ( Sum ( n ) ) NEWLINE NL DEDENT ENDMARKER
w , h , v , g = map ( int , input ( ) . split ( ) ) print ( 2 * ( w + h + g + 2 ) ) NEWLINE NL ENDMARKER
f = lambda : map ( int , input ( ) . split ( ) ) n , k = f ( ) p = sorted ( f ( ) )  m , d = n // k , n % ku , v = d + 1 , k - d + 1 g = [ 0 ] * u * v  i = 0 for a in range ( u ) : j = a * m + a - 1 for b in range ( v ) : x = g [ i - 1 ] + p [ j ] - p [ j - m + 1 ] if b else 9e9 y = g [ i - v ] + p [ j ] - p [ j - m ] if a else 9e9 if i : g [ i ] = min ( x , y ) i += 1 j += mprint ( g [ - 1 ] ) NEWLINE NL ENDMARKER
def sum ( x , n ) : NEWLINE INDENT total = 1.0 ; NEWLINE previous = 1.0 ; NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT previous = ( previous * x ) / ( i + 1 ) ; NEWLINE total = total + previous ; NEWLINE DEDENT return total ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT x = 5 ; NEWLINE n = 4 ; NEWLINE print ( "Sum is: " , sum ( x , n ) ) ; NEWLINE NL DEDENT ENDMARKER
string = list ( input ( ) ) differnt_words = int ( input ( ) ) difset = set ( string )  if ( differnt_words > len ( string ) ) : print ( "impossible" ) else : val = differnt_words - len ( difset ) if ( val < 0 ) : print ( 0 ) else : print ( val ) NEWLINE NL ENDMARKER
from math import gcdfrom functools import reduce NEWLINE NL ENDMARKER
import sys  def main ( ) : inp = sys . stdin . read ( ) . strip ( ) . split ( '\n' ) c = 0 for s in inp [ 1 : ] : t = s . split ( ) for i in range ( 0 , len ( t ) , 2 ) : c += '1' in t [ i : i + 2 ] return c  print ( main ( ) ) NEWLINE NL ENDMARKER
def perfectSquares ( l , r ) : NEWLINE INDENT for i in range ( l , r + 1 ) : NEWLINE INDENTINDENT if ( i ** ( .5 ) == int ( i ** ( .5 ) ) ) : NEWLINE INDENTINDENTINDENT print ( i , end = " " ) NEWLINE DEDENT DEDENT DEDENT l = 2 NEWLINE r = 24 NEWLINE perfectSquares ( l , r ) NEWLINE NL ENDMARKER
n , k = input ( ) . split ( ' ' ) a = input ( ) . split ( ' ' ) k = int ( k ) count = 0 storage = 0 total = 0 for ai in a : total += int ( ai )  df = min ( 8 , total ) k -= df total -= df count += 1 if k <= 0 : break  if k > 0 : print ( - 1 ) else : print ( count ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for i in range ( t ) : n , k = [ int ( x ) for x in input ( ) . split ( ) ] ind = 0 while n != 0 : if n % k == 0 : n = n // k ind += 1 else : ind = ind + ( n % k ) n = n - ( n % k ) print ( ind ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) maxi = max ( a ) s = sum ( a ) if maxi * 2 > s or s % 2 == 1 : print ( "NO" ) else : print ( "YES" ) NEWLINE NL ENDMARKER
x1 , x2 , x3 = input ( ) . split ( ) x11 = int ( x1 ) x22 = int ( x2 ) x33 = int ( x3 ) l = [ x11 , x22 , x33 ] l . sort ( ) x44 = min ( x11 , x22 , x33 ) x55 = max ( x11 , x22 , x33 )  x66 = x55 - l [ 1 ] x77 = l [ 1 ] - x44print ( x66 + x77 ) NEWLINE NL ENDMARKER
num = int ( input ( ) ) if num == 2 : print ( "2" ) else : print ( "1" ) NEWLINE NL ENDMARKER
import sysn , a = map ( int , input ( ) . split ( ) ) up = [ i for i in range ( 1 , n , 2 ) ] down = [ i for i in range ( n , 1 , - 2 ) ] if a in up : print ( up . index ( a ) + 1 ) else : print ( down . index ( a ) + 1 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) if ( ( n - 2 ) % 3 == 0 ) : a = 1 b = 2 c = n - 3 else : a = 1 b = 1 c = n - 2 print ( a , b , c ) NEWLINE NL ENDMARKER
def longestPrefixSuffix ( s ) : NEWLINE INDENT n = len ( s ) NEWLINE for res in range ( n // 2 , 0 , - 1 ) : NEWLINE INDENTINDENT prefix = s [ 0 : res ] NEWLINE suffix = s [ n - res : n ] NEWLINE if ( prefix == suffix ) : NEWLINE INDENTINDENTINDENT return res NEWLINE DEDENT DEDENT return 0 NEWLINE DEDENT s = "blablabla" NEWLINE print ( longestPrefixSuffix ( s ) ) NEWLINE NL ENDMARKER
def numberOfWays ( x ) : NEWLINE INDENT if x == 0 or x == 1 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) NEWLINE DEDENT DEDENT x = 3 NEWLINE print ( numberOfWays ( x ) ) NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def middleNode ( self , head ) : NEWLINE INDENTINDENT fast = slow = head NEWLINE while fast and fast . next : NEWLINE INDENTINDENTINDENT slow = slow . next NEWLINE fast = fast . next . next NEWLINE DEDENT return slow NEWLINE NL DEDENT DEDENT ENDMARKER
n = int ( input ( ) ) s = 1 result = [ ] t = 1 for i in range ( 1 , n ) : t += s if t > n : t -= n result . append ( t ) s += 1 print ( * result ) NEWLINE NL ENDMARKER
def isDivisible ( n ) : NEWLINE INDENT while n // 100 : NEWLINE INDENTINDENT d = n % 10 NEWLINE n //= 10 NEWLINE n = abs ( n + ( d * 13 ) ) NEWLINE DEDENT return ( n % 43 == 0 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 2795 NEWLINE if ( isDivisible ( N ) ) : NEWLINE INDENTINDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) NEWLINE NL DEDENT DEDENT ENDMARKER
n = int ( input ( ) ) NEWLINE x = 0 NEWLINE y = 0 NEWLINE z = 0 NEWLINE for i in range ( n ) : inp = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE x += inp [ 0 ] NEWLINE y += inp [ 1 ] NEWLINE z += inp [ 2 ] NEWLINE if ( x == 0 and y == 0 and z == 0 ) : NEWLINE INDENT print ( "YES" ) else : NEWLINE print ( "NO" ) NEWLINE NL DEDENT ENDMARKER
input ( ) instring = input ( ) balance = [ 0 ]  num0 = 0 num1 = 0  for c in instring : if c == "0" : num0 += 1 else : num1 += 1  balance . append ( num0 - num1 )  d = { }  for i in range ( len ( balance ) ) : if balance [ i ] not in d : d [ balance [ i ] ] = i  ans = 0 NEWLINE NL ENDMARKER
lst = [ ]  x = y = 0  for i in range ( 5 ) :  matrix = input ( ) . split ( )  lst . append ( matrix )  for j in range ( 0 , 5 ) :  if ( lst [ i ] [ j ] == "1" ) :  x = i - 2  y = j - 2  print ( abs ( x ) + abs ( y ) ) NEWLINE NL ENDMARKER
import osimport sysfrom io import BytesIO , IOBase NEWLINE NL ENDMARKER
def printReverseFloyd ( n ) : NEWLINE INDENT curr_val = int ( n * ( n + 1 ) / 2 ) NEWLINE for i in range ( n + 1 , 1 , - 1 ) : NEWLINE INDENTINDENT for j in range ( i , 1 , - 1 ) : NEWLINE INDENTINDENTINDENT print ( curr_val , end = "  " ) NEWLINE curr_val -= 1 NEWLINE DEDENT print ( "" ) NEWLINE DEDENT DEDENT n = 7 NEWLINE printReverseFloyd ( n ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) names = { } for i in range ( n ) : name = input ( ) if name in names : print ( 'YES' ) else : print ( 'NO' ) names [ name ] = 1 NEWLINE NL ENDMARKER
def shuffle ( N , key ) : NEWLINE INDENT NO_OF_BITS = N NEWLINE reverse_num = 0 NEWLINE for i in range ( NO_OF_BITS ) : NEWLINE INDENTINDENT temp = ( key & ( 1 << i ) ) NEWLINE if ( temp ) : NEWLINE INDENTINDENTINDENT reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) NEWLINE DEDENT DEDENT print ( reverse_num ) NEWLINE DEDENT N = 3 NEWLINE key = 3 NEWLINE shuffle ( N , key ) NEWLINE NL ENDMARKER
from math import logfrom collections import defaultdictn = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) dic = defaultdict ( lambda : 0 ) ans = 0 for el in a : i = int ( log ( el * 2 , 2 ) ) temp = 2 ** i while temp > 0 : if dic [ temp - el ] != 0 : ans += dic [ temp - el ] temp //= 2 dic [ el ] += 1 print ( ans ) NEWLINE NL ENDMARKER
if __name__ == '__main__' : n = int ( input ( ) ) for i in range ( n ) : for j in range ( n ) : if min ( i , n - i - 1 ) + min ( j , n - j - 1 ) < n // 2 : print ( '*' , end = '' ) else : print ( 'D' , end = '' ) print ( ) NEWLINE NL ENDMARKER
def multiply ( a , n ) : NEWLINE INDENT if n == 0 : NEWLINE INDENTINDENT return ( a [ n ] ) NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( a [ n ] * multiply ( a , n - 1 ) ) NEWLINE DEDENT DEDENT array = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEWLINE n = len ( array ) NEWLINE print ( multiply ( array , n - 1 ) ) NEWLINE NL ENDMARKER
def isTidy ( num ) : NEWLINE INDENT prev = 10 NEWLINE while ( num ) : NEWLINE INDENTINDENT rem = num % 10 NEWLINE num /= 10 NEWLINE if rem > prev : NEWLINE INDENTINDENTINDENT return False NEWLINE DEDENT prev = rem NEWLINE DEDENT return True NEWLINE DEDENT num = 1556 NEWLINE if isTidy ( num ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) NEWLINE print ( n // 2 * 3 ) NEWLINE NL ENDMARKER
def isWordPresent ( sentence , word ) : NEWLINE INDENT s = sentence . split ( " " ) NEWLINE for i in s : NEWLINE INDENTINDENT if ( i == word ) : NEWLINE INDENTINDENTINDENT return True NEWLINE DEDENT DEDENT return False NEWLINE DEDENT s = "Geeks for Geeks" NEWLINE word = "Geeks" NEWLINE if ( isWordPresent ( s , word ) ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
n , p , t = map ( int , input ( ) . split ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) ) arr = [ 0 ] + arr [ : : - 1 ] for i in range ( 1 , n + 1 ) : arr [ i ] += arr [ i - 1 ] maxi = 0 count = 0 for i in range ( n , 0 , - 1 ) : if ( t == - 1 ) : break maxi = max ( maxi , ( arr [ i ] + max ( 0 , min ( i * p , t ) ) ) / i ) t -= 1 print ( maxi ) NEWLINE NL ENDMARKER
def countNumbers ( x , n ) : NEWLINE INDENT if x > n : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT return ( 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 120 ; NEWLINE print ( countNumbers ( 1 , n ) ) ; NEWLINE NL DEDENT ENDMARKER
def minimumMoves ( k , l , r ) : NEWLINE INDENT count = r - l + 1 NEWLINE if ( count % k == 0 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT return ( k - ( count % k ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT k = 3 NEWLINE l = 10 NEWLINE r = 10 NEWLINE print ( minimumMoves ( k , l , r ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) ans = 0 i = 1 while n > 0 : if i == 1 : if n < 10 : ans += 9 n = 0 else : temp = n % 10 ans += 10 - temp n = n // 10 i += 1 else : if n < 10 : ans += 9 n = 0 else : temp = ( n % 10 ) + 1 ans += 10 - temp n = n // 10 print ( ans ) NEWLINE NL ENDMARKER
rfile = open ( 'input.txt' , 'r' ) maintxt = rfile . read ( ) . split ( '\n' ) rfile . close ( ) pos = int ( maintxt [ 0 ] ) for i in range ( 1 , 4 ) : temp = maintxt [ i ] . split ( ' ' ) cup1 , cup2 = int ( temp [ 0 ] ) , int ( temp [ 1 ] ) if pos == cup1 : pos = cup2 elif pos == cup2 : pos = cup1wfile = open ( 'output.txt' , 'w' ) wfile . write ( str ( pos ) ) NEWLINE NL ENDMARKER
n , s = map ( int , input ( ) . split ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) A . sort ( ) if sum ( A [ : n - 1 ] ) <= s : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
n , a , b , c = map ( int , input ( ) . split ( ) ) if ( n % 4 == 0 ) : print ( 0 ) else : hf = ( ( n // 4 ) * 4 ) + 4 diff = hf - n if ( diff == 1 ) : print ( min ( a , b + c , 3 * c ) ) elif ( diff == 2 ) : print ( min ( 2 * a , 2 * c , b ) ) else : print ( min ( c , 3 * a , a + b ) ) NEWLINE NL ENDMARKER
nums = input ( ) . split ( ) puzzles = input ( ) . split ( ) for i in range ( len ( puzzles ) ) : puzzles [ i ] = int ( puzzles [ i ] ) puzzles . sort ( ) min = 1000 for i in range ( int ( nums [ 1 ] ) - int ( nums [ 0 ] ) + 1 ) : if puzzles [ i + int ( nums [ 0 ] ) - 1 ] - puzzles [ i ] < min : min = puzzles [ i + int ( nums [ 0 ] ) - 1 ] - puzzles [ i ] print ( min ) NEWLINE NL ENDMARKER
import sys  def main ( ) : return sum ( abs ( int ( i ) ) for i in sys . stdin . read ( ) . strip ( ) . split ( ) [ 1 : ] )  print ( main ( ) ) NEWLINE NL ENDMARKER
def solve ( A , B ) : NEWLINE INDENT count = 0 NEWLINE for i in range ( 0 , 32 ) : NEWLINE INDENTINDENT if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) : NEWLINE INDENTINDENTINDENT count = count + 1 NEWLINE DEDENT DEDENT print ( "Number of different bits :" , count ) NEWLINE DEDENT A = 12 NEWLINE B = 15 NEWLINE solve ( A , B ) NEWLINE NL ENDMARKER
from math import * NEWLINE def longestRodInCuboid ( length , breadth , height ) : NEWLINE INDENT temp = length * length + breadth * breadth + height * height NEWLINE result = sqrt ( temp ) NEWLINE return result NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT length , breadth , height = 12 , 9 , 8 NEWLINE print ( longestRodInCuboid ( length , breadth , height ) ) NEWLINE NL DEDENT ENDMARKER
import sysfrom os import pathif ( path . exists ( 'input.txt' ) and path . exists ( 'output.txt' ) ) : sys . stdout = open ( 'output.txt' , 'w' ) sys . stdin = open ( 'input.txt' , 'r' )  NEWLINE NL ENDMARKER
def func ( a , k , n ) : NEWLINE INDENT for i in range ( 0 , n ) : NEWLINE INDENTINDENT if ( a [ i ] % k == 0 ) : NEWLINE INDENTINDENTINDENT return True NEWLINE DEDENT DEDENT DEDENT a = [ 14 , 27 , 38 , 76 , 84 ] NEWLINE k = 19 NEWLINE res = func ( a , k , 5 ) NEWLINE if ( res ) : NEWLINE INDENT print ( "true" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "false" ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) print ( ( n - 1 ) // 2 ) NEWLINE NL ENDMARKER
import sysdef input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( int , input ( ) . split ( ) ) ) n , l , r = minput ( ) mi = 2 ** l - 1 + n - lma = 2 ** r - 1 + 2 ** ( r - 1 ) * ( n - r ) print ( mi , ma ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) c , r = [ 0 ] * n , [ 0 ] * mvals = [ ] for i in range ( n ) : s = input ( ) vals . append ( s ) for j in range ( m ) : if ( s [ j ] == '*' ) : c [ i ] += 1 r [ j ] += 1 ans = 0 for i in range ( n ) : for j in range ( m ) : if ( vals [ i ] [ j ] == '*' ) : ans += ( c [ i ] - 1 ) * ( r [ j ] - 1 ) print ( ans ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) s = sum ( a [ : - 1 ] ) print ( a [ - 1 ] - s + 1 ) NEWLINE NL ENDMARKER
def setBitNumber ( n ) : NEWLINE INDENT if ( n == 0 ) : NEWLINE INDENTINDENT return 0 ; NEWLINE DEDENT msb = 0 ; NEWLINE while ( n > 0 ) : NEWLINE INDENTINDENT n = int ( n / 2 ) ; NEWLINE msb += 1 ; NEWLINE DEDENT return ( 1 << msb ) ; NEWLINE DEDENT n = 0 ; NEWLINE print ( setBitNumber ( n ) ) ; NEWLINE NL ENDMARKER
from math import floor , log2 NEWLINE def minAbsDiff ( n ) : NEWLINE INDENT left = pow ( 2 , floor ( log2 ( n ) ) ) NEWLINE right = left * 2 NEWLINE return min ( ( n - left ) , ( right - n ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 15 NEWLINE print ( minAbsDiff ( n ) ) NEWLINE NL DEDENT ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) res = 1 pep = 0 for i in range ( 0 , n ) : if ( pep + a [ i ] <= m ) : pep += a [ i ] else : res += 1 pep = a [ i ] print ( res ) NEWLINE NL ENDMARKER
def SquareCube ( N ) : NEWLINE INDENT cnt , i = 0 , 1 NEWLINE while ( i ** 6 <= N ) : NEWLINE INDENTINDENT cnt += 1 NEWLINE i += 1 NEWLINE DEDENT return cnt NEWLINE DEDENT N = 100000 NEWLINE print ( SquareCube ( N ) ) NEWLINE NL ENDMARKER
import math , sys , bisect , heapqfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulate NEWLINE NL ENDMARKER
n = int ( input ( ) ) maxln = 0 minrn = 10 ** 9 + 1 for i in range ( n ) : l , r = map ( int , input ( ) . split ( ) ) maxln = max ( l , maxln ) minrn = min ( r , minrn ) m = int ( input ( ) ) ans = - 1 for i in range ( m ) : l , r = map ( int , input ( ) . split ( ) ) if l > minrn : ans = max ( ans , l - minrn ) if r < maxln : ans = max ( ans , maxln - r ) ans = max ( 0 , ans ) print ( ans ) NEWLINE NL ENDMARKER
n , x = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) dp = [ 0 ] * ( 10 ** 6 + 1 ) for i in arr : dp [ i ] += 1 NEWLINE NL ENDMARKER
chot = { 0 : "O-|-OOOO" , 1 : "O-|O-OOO" , 2 : "O-|OO-OO" , 3 : "O-|OOO-O" , 4 : "O-|OOOO-" , 5 : "-O|-OOOO" , 6 : "-O|O-OOO" , 7 : "-O|OO-OO" , 8 : "-O|OOO-O" , 9 : "-O|OOOO-" }  num = int ( input ( ) )  divs = [ ]  if num == 0 : print ( chot [ 0 ] ) exit ( )  while num > 0 : divs . append ( ( num % 10 ) ) num //= 10  for i in divs : print ( chot [ i ] ) NEWLINE NL ENDMARKER
from math import * NEWLINE def previousFibonacci ( n ) : NEWLINE INDENT a = n / ( ( 1 + sqrt ( 5 ) ) / 2.0 ) NEWLINE return round ( a ) NEWLINE DEDENT n = 8 NEWLINE print ( previousFibonacci ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) count = 0 for i in range ( n ) : s1 = s [ i : i + 3 ] if ( s1 == 'xxx' ) : count += 1 print ( count ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = int ( input ( ) ) b = int ( input ( ) ) import mathdef extgcd ( a , b ) : NEWLINE NL ENDMARKER
import math NEWLINE def minAbsDiff ( n ) : NEWLINE INDENT left = 1 << ( int ) ( math . floor ( math . log2 ( n ) ) ) NEWLINE right = left * 2 NEWLINE return min ( ( n - left ) , ( right - n ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 15 NEWLINE print ( minAbsDiff ( n ) ) NEWLINE NL DEDENT ENDMARKER
s = input ( ) print ( s + s [ : : - 1 ] ) NEWLINE NL ENDMARKER
import sys , os , ioimport NEWLINE math , bisect , operatorinf , mod = float ( 'inf' ) , 10 ** 9 + 7 NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def searchBST ( self , root , val ) : NEWLINE INDENTINDENT while root : NEWLINE INDENTINDENTINDENT if root . val == val : NEWLINE INDENTINDENTINDENTINDENT return root NEWLINE DEDENT elif root . val > val : NEWLINE INDENTINDENTINDENTINDENT root = root . left NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENTINDENT root = root . right NEWLINE DEDENT DEDENT return root NEWLINE NL DEDENT DEDENT ENDMARKER
for ti in range ( int ( input ( ) ) ) : print ( int ( input ( ) ) // 2 ) NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) Limak_age = aBob_age = bn_years = 0 while Limak_age <= Bob_age : Limak_age *= 3 Bob_age *= 2 n_years += 1 print ( n_years ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) )  print ( arr [ n // 2 ] ) NEWLINE NL ENDMARKER
n1 , n2 , k1 , k2 = map ( int , input ( ) . split ( ) ) flag1 = 0 flag2 = 0 i = 1 while True : if i % 2 != 0 : if n1 < 1 : flag1 = 1 break else : n1 -= 1 if n1 < 1 : flag1 = 1 break else : if n2 < 1 : flag2 = 1 break else : n2 -= 1 if n2 < 1 : flag2 = 1 break i += 1 if flag1 == 1 : print ( "Second" ) else : print ( "First" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) chess = list ( map ( int , input ( ) . split ( ) ) )  move1 = 0 move2 = 0  chess . sort ( )  for i in range ( len ( chess ) ) : move1 += abs ( chess [ i ] - ( i * 2 + 1 ) ) move2 += abs ( chess [ i ] - ( i * 2 + 2 ) )  print ( min ( move1 , move2 ) ) NEWLINE NL ENDMARKER
import mathn = int ( input ( ) ) res = 0 while n >= 2 : n -= math . pow ( 2 , math . floor ( math . log2 ( n ) ) ) res += 1 print ( int ( res + n ) ) NEWLINE NL ENDMARKER
import math NEWLINE def areaOctagon ( side ) : NEWLINE INDENT return ( 2 * ( 1 + ( math . sqrt ( 2 ) ) ) * side * side ) NEWLINE DEDENT side = 4 NEWLINE print ( "Area of Regular Octagon =" , round ( areaOctagon ( side ) , 4 ) ) NEWLINE NL ENDMARKER
def sumAP ( n , d ) : NEWLINE INDENT n = n // d NEWLINE return ( n ) * ( 1 + n ) * d // 2 NEWLINE DEDENT def sumMultiples ( n , a , b ) : NEWLINE INDENT n = n - 1 NEWLINE return sumAP ( n , a ) + sumAP ( n , b ) - \ NEWLINE INDENTINDENT sumAP ( n , a * b ) NEWLINE DEDENT DEDENT n = 10 NEWLINE a = 3 NEWLINE b = 5 NEWLINE print ( sumMultiples ( n , a , b ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = input ( ) NEWLINE fx = n [ : : - 1 ] NEWLINE ffx = fx [ : : - 1 ] NEWLINE if int ( ffx ) == int ( n ) : NEWLINE INDENT print ( len ( n ) ) else : NEWLINE print ( len ( fx ) ) NEWLINE NL DEDENT ENDMARKER
def printPascal ( n ) : NEWLINE INDENT for line in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT C = 1 ; NEWLINE for i in range ( 1 , line + 1 ) : NEWLINE INDENTINDENTINDENT print ( C , end = " " ) ; NEWLINE C = int ( C * ( line - i ) / i ) ; NEWLINE DEDENT print ( "" ) ; NEWLINE DEDENT DEDENT n = 5 ; NEWLINE printPascal ( n ) ; NEWLINE NL ENDMARKER
import sys   def read_input ( input_path = None ) : if input_path is None : f = sys . stdin else : f = open ( input_path , 'r' )  n , k = map ( int , f . readline ( ) . split ( ) ) field = list ( ) for _ in range ( n ) : field . append ( f . readline ( ) . rstrip ( ) )  return n , k , field   NEWLINE NL ENDMARKER
def evensum ( n ) : NEWLINE INDENT curr = 2 NEWLINE sum = 0 NEWLINE i = 1 NEWLINE while i <= n : NEWLINE INDENTINDENT sum += curr NEWLINE curr += 2 NEWLINE i = i + 1 NEWLINE DEDENT return sum NEWLINE DEDENT n = 20 NEWLINE print ( "sum of first " , n , "even number is: " , evensum ( n ) ) NEWLINE NL ENDMARKER
def findSeries ( num , first , sec ) : NEWLINE INDENT print ( "{} {} " . format ( first , sec ) , end = "" ) NEWLINE counter = 0 NEWLINE while ( counter < num - 2 ) : NEWLINE INDENTINDENT sum = first + sec NEWLINE print ( "{} " . format ( sum ) , end = "" ) NEWLINE first = sec NEWLINE sec = sum NEWLINE counter = counter + 1 NEWLINE DEDENT DEDENT n = 5 NEWLINE first = 2 NEWLINE sec = 4 NEWLINE findSeries ( n , first , sec ) NEWLINE NL ENDMARKER
for t in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) if n % 2 == 0 : print ( n + k * 2 ) else : for i in range ( 2 , n + 1 ) : if n % i == 0 : print ( n + i + ( k - 1 ) * 2 ) ; break NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 for i in range ( k ) : s1 , s2 = 0 , 0 for j in range ( i , n , k ) : if A [ j ] == 1 : s1 += 1 else : s2 += 1 ans = ans + min ( s1 , s2 ) print ( ans ) NEWLINE NL ENDMARKER
red , blue = map ( int , input ( ) . split ( ) ) total_point = red + blue - 1 vasya = min ( red , blue ) petya = total_point - vasyaprint ( petya , vasya ) NEWLINE NL ENDMARKER
def findNthTerm ( N ) : NEWLINE INDENT ans = 0 ; NEWLINE if ( N % 2 == 0 ) : NEWLINE INDENTINDENT ans = ( N // 2 ) * 6 + ( N // 2 ) * 2 ; NEWLINE DEDENT else : NEWLINE INDENTINDENT ans = ( N // 2 + 1 ) * 6 + ( N // 2 ) * 2 ; NEWLINE DEDENT print ( ans ) ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 3 ; NEWLINE findNthTerm ( N ) ; NEWLINE NL DEDENT ENDMARKER
import mathtry : t = int ( input ( ) ) for i in range ( t ) : a , b , c = map ( int , input ( ) . split ( ) ) if ( c / b ) > a : print ( 1 , - 1 ) elif ( c / b ) < a : if b * a > c : if a < c : print ( 1 , b ) else : print ( - 1 , b ) else : print ( - 1 , b ) else : if b * a > c : print ( 1 , b ) else : print ( 1 , - 1 ) except : pass NEWLINE NL ENDMARKER
def pairORSum ( arr , n ) : NEWLINE INDENT ans = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT for j in range ( ( i + 1 ) , n ) : NEWLINE INDENTINDENTINDENT ans = ans + arr [ i ] | arr [ j ] NEWLINE DEDENT DEDENT return ans NEWLINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEWLINE n = len ( arr ) NEWLINE print ( pairORSum ( arr , n ) ) NEWLINE NL ENDMARKER
def XorAscii ( str1 , len1 ) : NEWLINE INDENT ans = ord ( str1 [ 0 ] ) NEWLINE for i in range ( 1 , len1 ) : NEWLINE INDENTINDENT ans = ( ans ^ ( ord ( str1 [ i ] ) ) ) NEWLINE DEDENT return ans NEWLINE DEDENT str1 = "geeksforgeeks" NEWLINE len1 = len ( str1 ) NEWLINE print ( XorAscii ( str1 , len1 ) ) NEWLINE str1 = "GfG" NEWLINE len1 = len ( str1 ) NEWLINE print ( XorAscii ( str1 , len1 ) ) NEWLINE NL ENDMARKER
import functoolsimport timefrom collections import Counter  def timer ( func ) : @ functools . wraps ( func ) def wrapper ( * args , ** kwargs ) : stime = time . perf_counter ( ) res = func ( * args , ** kwargs ) elapsed = time . perf_counter ( ) - stime print ( f"{func.__name__} in {elapsed:.4f} secs" ) return res return wrapper  class solver : NEWLINE NL ENDMARKER
def noOfYears ( t1 , n1 , t2 ) : NEWLINE INDENT years = ( t2 - 1 ) * n1 / ( t1 - 1 ) NEWLINE return years NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT T1 , N1 , T2 = 3 , 5 , 6 NEWLINE print ( noOfYears ( T1 , N1 , T2 ) ) NEWLINE NL DEDENT ENDMARKER
t = int ( input ( ) ) for test in range ( t ) : n , k = [ int ( i ) for i in input ( ) . split ( ) ] grid = [ [ True for i in range ( 3 ) ] for i in range ( n ) ] ok = [ [ False for i in range ( 3 ) ] for i in range ( n ) ] NEWLINE NL ENDMARKER
def totalSumDivisibleByNum ( n , number ) : NEWLINE INDENT firstnum = pow ( 10 , n - 1 ) NEWLINE lastnum = pow ( 10 , n ) NEWLINE sum = 0 NEWLINE for i in range ( firstnum , lastnum ) : NEWLINE INDENTINDENT if ( i % number == 0 ) : NEWLINE INDENTINDENTINDENT sum += i NEWLINE DEDENT DEDENT return sum NEWLINE DEDENT n = 3 ; num = 7 NEWLINE print ( totalSumDivisibleByNum ( n , num ) ) NEWLINE NL ENDMARKER
def sumOdd ( n ) : NEWLINE INDENT terms = ( n + 1 ) // 2 NEWLINE sum1 = terms * terms NEWLINE return sum1 NEWLINE DEDENT def suminRange ( l , r ) : NEWLINE INDENT return sumOdd ( r ) - sumOdd ( l - 1 ) NEWLINE DEDENT l = 2 ; r = 5 NEWLINE print ( "Sum of odd natural number" , "from L to R is" , suminRange ( l , r ) ) NEWLINE NL ENDMARKER
n , L , a = map ( int , input ( ) . split ( ) ) prev , ans = 0 , 0 for _ in range ( n ) : t , l = map ( int , input ( ) . split ( ) ) ans += ( t - prev ) // a prev = t + lans += ( L - prev ) // aprint ( ans ) NEWLINE NL ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return 3 * pow ( n , 2 ) + 2 * n - 5 NEWLINE DEDENT N = 4 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) print ( l [ ( - 1 ) * m ] ) NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readlinen = int ( input ( ) ) k = int ( input ( ) ) a = int ( input ( ) ) b = int ( input ( ) ) ans = 0 if k == 1 : print ( ( n - 1 ) * a ) exit ( ) while n > 1 : if n < k : ans += ( n - 1 ) * a break if n % k != 0 : ans += ( n % k ) * a n -= ( n % k ) else : while n % k == 0 and n > 1 : temp = n // k if ( n - temp ) * a >= b : ans += b else : ans += ( ( n - temp ) * a ) n //= kprint ( ans ) NEWLINE NL ENDMARKER
def compute ( ) : NEWLINE INDENT ans = sum ( i * ( i - ( 2 if i % 2 == 0 else 1 ) ) for i in range ( 3 , 1001 ) ) NEWLINE return str ( ans ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( compute ( ) ) NEWLINE NL DEDENT ENDMARKER
import sysimport os . pathif os . path . exists ( 'input.txt' ) : sys . stdin = open ( 'input.txt' , 'r' ) sys . stdout = open ( 'output.txt' , 'w' ) s = input ( ) n = len ( s ) ans = 0 for i in range ( n - 2 , - 1 , - 1 ) : if int ( s [ i ] + s [ i + 1 ] ) % 4 == 0 : ans += i + 1 for i in range ( n ) : if int ( s [ i ] ) % 4 == 0 : ans = ans + 1 print ( ans ) NEWLINE NL ENDMARKER
import mathk , n , s , p = map ( int , input ( ) . split ( ) ) sheets = math . ceil ( n / s ) * kprint ( math . ceil ( sheets / p ) ) NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def toHex ( self , num ) : NEWLINE INDENTINDENT if num == 0 : NEWLINE INDENTINDENTINDENT return '0' NEWLINE DEDENT mp = '0123456789abcdef' NEWLINE ans = '' NEWLINE for _ in range ( 8 ) : NEWLINE INDENTINDENTINDENT n = num & 15 NEWLINE c = mp [ n ] NEWLINE ans = c + ans NEWLINE num = num >> 4 NEWLINE DEDENT return ans . lstrip ( '0' ) NEWLINE NL DEDENT DEDENT ENDMARKER
def subString ( s , n ) : NEWLINE INDENT for i in range ( n ) : NEWLINE INDENTINDENT for len in range ( i + 1 , n + 1 ) : NEWLINE INDENTINDENTINDENT print ( s [ i : len ] ) ; NEWLINE DEDENT DEDENT DEDENT s = "abcd" ; NEWLINE subString ( s , len ( s ) ) ; NEWLINE NL ENDMARKER
from bisect import bisect_rightfrom math import inf  n = int ( input ( ) ) dp = [ inf ] * ndp [ 0 ] = 20   a = [ int ( input ( ) ) ] for i in range ( n - 1 ) : a . append ( int ( input ( ) ) ) print ( dp [ 0 ] ) for i in range ( 1 , n ) : NEWLINE NL ENDMARKER
def find_numbers ( N ) : NEWLINE INDENT if ( N == 1 ) : NEWLINE INDENTINDENT print ( - 1 , end = "" ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( N , N + 1 , N * ( N + 1 ) ) ; NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 5 ; NEWLINE find_numbers ( N ) ; NEWLINE NL DEDENT ENDMARKER
import sys  def sum1toN ( n ) : if n % 2 == 0 : return ( n + 1 ) * ( n // 2 ) else : return ( n // 2 ) * ( n + 1 ) + ( n // 2 + 1 )   def answer ( n , r ) : if n == 1 : return 1 if r == 1 : return 1 NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : NEWLINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEWLINE if 2 * l <= r : NEWLINE INDENTINDENT print ( l , 2 * l ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( - 1 , - 1 ) NEWLINE NL DEDENT DEDENT ENDMARKER
from math import gcd NEWLINE def getMinNum ( N ) : NEWLINE INDENT lcm = 1 ; NEWLINE for i in range ( 2 , N + 1 ) : NEWLINE INDENTINDENT lcm = ( ( i * lcm ) // ( gcd ( i , lcm ) ) ) ; NEWLINE DEDENT return ( lcm + 1 ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 5 ; NEWLINE print ( getMinNum ( N ) ) ; NEWLINE NL DEDENT ENDMARKER
def gcd ( a , b ) : NEWLINE INDENT if ( b == 0 ) : NEWLINE INDENTINDENT return a NEWLINE DEDENT return gcd ( b , a % b ) NEWLINE DEDENT def flip ( a , b ) : NEWLINE INDENT lcm = ( a * b ) // gcd ( a , b ) NEWLINE a = lcm // a NEWLINE b = lcm // b NEWLINE print ( a - 1 , b - 1 ) NEWLINE DEDENT a = 10 NEWLINE b = 5 NEWLINE flip ( a , b ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = len ( str ( n ) ) b = 0 for i in range ( 1 , a ) : b += i * ( 10 ** i - 10 ** ( i - 1 ) ) b += a * ( n + 1 - 10 ** ( a - 1 ) ) print ( b ) NEWLINE NL ENDMARKER
def surfaceArea ( a , b , h ) : NEWLINE INDENT return 5 * a * b + 5 * b * h NEWLINE DEDENT def volume ( b , h ) : NEWLINE INDENT return ( 5 * b * h ) / 2 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = 5 NEWLINE b = 3 NEWLINE h = 7 NEWLINE print ( "surface area =" , surfaceArea ( a , b , h ) , "," , "volume =" , volume ( b , h ) ) NEWLINE NL DEDENT ENDMARKER
num = int ( input ( ) ) print ( ( num // 2 ) + 1 ) NEWLINE NL ENDMARKER
s = input ( ) print ( min ( 2 * s . count ( 'a' ) - 1 , len ( s ) ) ) NEWLINE NL ENDMARKER
def Time ( arr , n , Emptypipe ) : NEWLINE INDENT fill = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT fill += ( 1 / arr [ i ] ) NEWLINE DEDENT fill = fill - ( 1 / float ( Emptypipe ) ) NEWLINE return int ( 1 / fill ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 12 , 14 ] NEWLINE Emptypipe = 30 NEWLINE n = len ( arr ) NEWLINE print ( ( Time ( arr , n , Emptypipe ) ) , "Hours" ) NEWLINE NL DEDENT ENDMARKER
import mathn , k = map ( int , input ( ) . split ( ) ) ans = 1 while ( k % 2 == 0 ) : k = k // 2 ans += 1 print ( ans ) NEWLINE NL ENDMARKER
in_tests = int ( input ( ) )  for i in range ( in_tests ) : [ x , y ] = input ( ) . split ( ) if int ( x ) - int ( y ) == 1 : print ( 'NO' ) else : print ( 'YES' )  NEWLINE NL ENDMARKER
def decToBin ( n ) : NEWLINE INDENT if ( n == 0 ) : NEWLINE INDENTINDENT return "0" ; NEWLINE DEDENT bin = "" ; NEWLINE while ( n > 0 ) : NEWLINE INDENTINDENT if ( n & 1 == 0 ) : NEWLINE INDENTINDENTINDENT bin = '0' + bin ; NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT bin = '1' + bin ; NEWLINE DEDENT n = n >> 1 ; NEWLINE DEDENT return bin ; NEWLINE DEDENT n = 38 ; NEWLINE print ( decToBin ( n ) ) ; NEWLINE NL ENDMARKER
n , k , a , b , s = int ( input ( ) ) , int ( input ( ) ) , int ( input ( ) ) , int ( input ( ) ) , 0 if ( k > 1 ) : while ( ( ( n // k ) * ( k - 1 ) * a ) > b ) : s += ( n % k ) * a + b n //= kprint ( int ( s + ( n - 1 ) * a ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = str ( n ) sum = 1 while ( sum % 4 != 0 ) : s = str ( n ) sum = 0 for i in s : sum += int ( i ) n += 1 print ( n - 1 ) NEWLINE NL ENDMARKER
t = input ( ) NEWLINE t = int ( t ) NEWLINE while t > 0 : n = input ( ) NEWLINE n = int ( n ) NEWLINE if ( n & ( n - 1 ) == 0 ) : NEWLINE INDENT print ( "NO" ) else : NEWLINE print ( "YES" ) NEWLINE DEDENT t -= 1  NEWLINE NL ENDMARKER
from math import gcd NEWLINE def FindRatio ( a , b , c ) : NEWLINE INDENT up = abs ( b - c ) NEWLINE down = abs ( c - a ) NEWLINE g = gcd ( up , down ) NEWLINE up //= g NEWLINE down //= g NEWLINE print ( up , ":" , down ) NEWLINE DEDENT a = 4 NEWLINE b = 10 NEWLINE c = 6 NEWLINE FindRatio ( a , b , c ) NEWLINE NL ENDMARKER
import math as mt NEWLINE def Area ( r ) : NEWLINE INDENT if ( r < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT x = ( 2 * r ) / mt . sqrt ( 5 ) NEWLINE A = 0.70477 * pow ( x , 2 ) NEWLINE return A NEWLINE DEDENT r = 5 NEWLINE print ( Area ( r ) ) NEWLINE NL ENDMARKER
w , h , k = map ( int , input ( ) . split ( ) ) print ( 2 * ( w + h ) * k - 8 * k * k + 4 * k ) NEWLINE NL ENDMARKER
import sysfrom string import ascii_lowercase as az  def main ( ) : n , k = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) return n // k * az [ : k ] + az [ : n % k ]  print ( main ( ) ) NEWLINE NL ENDMARKER
from math import sin NEWLINE def calculateSide ( n , r ) : NEWLINE INDENT theta = 360 / n NEWLINE theta_in_radians = theta * 3.14 / 180 NEWLINE return 2 * r * sin ( theta_in_radians / 2 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 3 NEWLINE r = 5 NEWLINE print ( '{0:.5}' . format ( calculateSide ( n , r ) ) ) NEWLINE NL DEDENT ENDMARKER
def newvol ( x ) : NEWLINE INDENT print ( "percentage increase" "in the volume of the cube is " , ( ( x ** ( 3 ) ) / 10000 + 3 * x + ( 3 * ( x ** ( 2 ) ) ) / 100 ) , "%" ) ; NEWLINE DEDENT x = 10 ; NEWLINE newvol ( x ) ; NEWLINE NL ENDMARKER
a = input ( ) ; b = len ( a ) ; print ( 9 * b - sum ( map ( int , a [ 1 : ] ) ) + ( b > 1 ) ) NEWLINE NL ENDMARKER
'''http://codeforces.com/contest/869/problem/B''' a , b = map ( int , input ( ) . split ( ) )  if a > b or b - a > 10 : print ( 0 ) elif a == b : print ( 1 ) else : fact = 1 for i in range ( a + 1 , b + 1 ) : fact = ( fact * ( i % 10 ) ) % 10 print ( fact )  NEWLINE NL ENDMARKER
n , q = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = [ a [ 0 ] ] for i in range ( 1 , n ) : b . append ( b [ i - 1 ] + a [ i ] )  ans = 0 for i in range ( q ) : x , y = map ( int , input ( ) . split ( ) ) temp = b [ y - 1 ] if x != 1 : temp -= b [ x - 2 ] ans = max ( ans , ans + temp ) print ( ans ) NEWLINE NL ENDMARKER
PI = 3.14 NEWLINE def areaOfInscribedCircle ( a ) : NEWLINE INDENT return ( PI / 4 ) * a * a NEWLINE DEDENT a = 8 NEWLINE print ( "Area of an inscribed circle:" , round ( areaOfInscribedCircle ( a ) , 2 ) ) NEWLINE NL ENDMARKER
n , m , k , l = map ( int , input ( ) . split ( ) ) x = 0 x = ( l + k + m - 1 ) // mif x * m > n : print ( - 1 ) else : print ( x ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) f = [ 0 ] * ( max ( a ) + 1 ) for i in a : f [ i ] += 1 c = 0 for i in f : if ( i % 2 != 0 ) : c = 1 breakif ( c == 0 ) : print ( 'Agasa' ) else : print ( 'Conan' ) NEWLINE NL ENDMARKER
b = int ( input ( ) ) c = int ( b ** .5 ) print ( 2 * sum ( b % i == 0 for i in range ( 1 , c + 1 ) ) - ( c * c == b ) ) NEWLINE NL ENDMARKER
max_width , max_height , x , y = map ( int , input ( ) . split ( ) )   def hcf ( num1 , num2 ) : if ( num2 == 0 ) : return num1 return hcf ( num2 , num1 % num2 )  ratio = 0 ratio = hcf ( x , y ) if ( ratio != 0 ) : x = x // ratio y = y // ratio posible_width = max_width // x possible_height = max_height // y      print ( min ( possible_height , posible_width ) )  NEWLINE NL ENDMARKER
def findMinRec ( A , n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT return A [ 0 ] NEWLINE DEDENT return min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT A = [ 1 , 4 , 45 , 6 , - 50 , 10 , 2 ] NEWLINE n = len ( A ) NEWLINE print ( findMinRec ( A , n ) ) NEWLINE NL DEDENT ENDMARKER
count = 0 columns = [ "" , "" , "" , "" , "" , "" , "" , "" ] for _ in range ( 8 ) : line = input ( ) if "W" not in line : count += 1 for index , character in enumerate ( line ) : columns [ index ] += characterfor column in columns : if "W" not in column : count += 1 print ( 8 if count == 16 else count ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = [ - 1 ] + list ( map ( int , input ( ) . split ( ) ) ) s = set ( ) s . add ( - 1 ) a . sort ( ) count , add = 0 , 0 flag = 0 for i in range ( 1 , n + 1 ) : if a [ i ] in s and a [ i ] - 1 in s : flag = 1 break if a [ i ] in s : add += 1 if ( add == 2 ) : flag = 1 break s . add ( a [ i ] ) count += a [ i ] - ( i - 1 ) if ( flag == 0 and count % 2 == 1 ) : print ( "sjfnb" ) else : print ( "cslnb" ) NEWLINE NL ENDMARKER
def swapNibbles ( x ) : NEWLINE INDENT return ( ( x & 0x0F ) << 4 | ( x & 0xF0 ) >> 4 ) NEWLINE DEDENT x = 100 NEWLINE print ( swapNibbles ( x ) ) NEWLINE NL ENDMARKER
import math NEWLINE NL ENDMARKER
def decToBinary ( n ) : NEWLINE INDENT binaryNum = [ 0 ] * n ; NEWLINE i = 0 ; NEWLINE while ( n > 0 ) : NEWLINE INDENTINDENT binaryNum [ i ] = n % 2 ; NEWLINE n = int ( n / 2 ) ; NEWLINE i += 1 ; NEWLINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEWLINE INDENTINDENT print ( binaryNum [ j ] , end = "" ) ; NEWLINE DEDENT DEDENT n = 17 ; NEWLINE decToBinary ( n ) ; NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) s = 0 for i in range ( 1 , n + 1 ) : s += ( a [ i - 1 ] - 1 ) * i + 1 print ( s ) NEWLINE NL ENDMARKER
def triangular_series ( n ) : NEWLINE INDENT j = 1 NEWLINE k = 1 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT print ( k , end = ' ' ) NEWLINE j = j + 1 NEWLINE k = k + j NEWLINE DEDENT DEDENT n = 5 NEWLINE triangular_series ( n ) NEWLINE NL ENDMARKER
n , k = [ int ( i ) for i in input ( ) . split ( ) ] a = [ int ( i ) for i in input ( ) . split ( ) ] i = 0 while i < n : if i == k - 1 : print ( "YES" ) break else : if i == n - 1 : i = i + 1 else : i = i + a [ i ] else : print ( "NO" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = str ( input ( ) ) ans = 0 for i in range ( n ) : if int ( s [ i ] ) % 2 == 0 : ans += ( i + 1 ) print ( ans ) NEWLINE NL ENDMARKER
def find_set ( n ) : NEWLINE INDENT if ( n <= 2 ) : NEWLINE INDENTINDENT print ( "-1" ) ; NEWLINE return ; NEWLINE DEDENT sum1 = ( n * ( n - 1 ) ) / 2 ; NEWLINE sum2 = n ; NEWLINE print ( sum1 , " " , sum2 ) ; NEWLINE DEDENT n = 8 ; NEWLINE find_set ( n ) ; NEWLINE NL ENDMARKER
n , t = map ( int , input ( ) . split ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) D = 86400 for i in range ( n ) : if D - A [ i ] >= t : print ( i + 1 ) break else : t -= ( D - A [ i ] ) NEWLINE NL ENDMARKER
def removeDulipcates ( arr ) : NEWLINE INDENT s = dict ( ) NEWLINE d = [ ] NEWLINE for i in arr : NEWLINE INDENTINDENT if i not in s . keys ( ) : NEWLINE INDENTINDENTINDENT d . append ( i ) NEWLINE s [ i ] = 1 NEWLINE DEDENT DEDENT print ( d ) NEWLINE DEDENT arr = [ 1 , 2 , 5 , 1 , 7 , 2 , 4 , 2 ] NEWLINE removeDulipcates ( arr ) NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) if a < b : c = b - a print ( a , end = " " ) else : c = a - b print ( b , end = " " ) if c == 1 : print ( 0 ) else : print ( c // 2 ) NEWLINE NL ENDMARKER
def leonardo ( n ) : NEWLINE INDENT if ( n == 0 or n == 1 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT return ( leonardo ( n - 1 ) + leonardo ( n - 2 ) + 1 ) ; NEWLINE DEDENT print ( leonardo ( 3 ) ) NEWLINE NL ENDMARKER
a = set ( list ( input ( ) [ 1 : - 1 ] . split ( ', ' ) ) ) if '' not in a : print ( len ( a ) ) else : print ( 0 ) NEWLINE NL ENDMARKER
a = [ '' ] * 8 for i in range ( 8 ) : a [ i ] = input ( ) a = list ( map ( lambda a : a . count ( 'B' ) , a ) ) b = set ( a ) c = 0 for i in b : if i == 8 : c += a . count ( 8 ) else : c += iprint ( c ) NEWLINE NL ENDMARKER
n , k = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) temp = max ( a ) ans = 0 while sum ( a ) / len ( a ) < ( k - 0.5 ) : NEWLINE NL ENDMARKER
s = input ( )  if '4' not in s and '7' not in s : print ( - 1 ) else : if s . count ( '4' ) >= s . count ( '7' ) : print ( 4 ) else : print ( 7 ) NEWLINE NL ENDMARKER
from math import * n = int ( input ( ) ) r = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ans = 10 ** 20 for i in range ( n ) : x0 , y0 = r [ ( i + n - 1 ) % n ] x1 , y1 = r [ ( i + 1 ) % n ] x , y = r [ i ] ans = min ( ans , abs ( ( y1 - y0 ) * x - ( x1 - x0 ) * y - ( x0 * y1 - x1 * y0 ) ) / sqrt ( ( x1 - x0 ) ** 2 + ( y1 - y0 ) ** 2 ) ) print ( ans / 2 ) NEWLINE NL ENDMARKER
n = int ( input ( "" ) ) A = [ ] for i in range ( n ) : x = int ( input ( "" ) ) A . append ( x ) for i in A : if ( i % 3 == 0 or i % 7 == 0 or i % 10 == 0 ) : print ( 'YES' ) else : if ( i > 12 ) : print ( 'YES' ) else : print ( "NO" ) NEWLINE NL ENDMARKER
import mathdef check ( x ) : y = int ( math . sqrt ( x ) ) if ( x == y * y ) : return False return Truen = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) for i in range ( n - 1 , - 1 , - 1 ) : if ( a [ i ] < 0 or check ( a [ i ] ) ) : print ( a [ i ] ) break NEWLINE NL ENDMARKER
def fib ( n ) : NEWLINE INDENT a = 0 NEWLINE b = 1 NEWLINE if ( n >= 0 ) : NEWLINE INDENTINDENT print ( a , end = ' ' ) NEWLINE DEDENT if ( n >= 1 ) : NEWLINE INDENTINDENT print ( b , end = ' ' ) NEWLINE DEDENT for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT c = a + b NEWLINE print ( c , end = ' ' ) NEWLINE a = b NEWLINE b = c NEWLINE DEDENT DEDENT fib ( 9 ) NEWLINE NL ENDMARKER
n , m , k = map ( int , input ( ) . split ( ) ) army = [ ] for i in range ( m ) : x = int ( input ( ) ) army . append ( x ) m = int ( input ( ) ) ans = 0   for i in army : uniq = bin ( m ^ i ) count = 0 for j in uniq : if j == '1' : count += 1 if count <= k : continue else : count = k + 1 break if count <= k : ans += 1 print ( ans )        NEWLINE NL ENDMARKER
import mathn , x , y = map ( int , input ( ) . split ( ) ) a = ( n * y - x * 100 ) / 100 print ( max ( 0 , math . ceil ( a ) ) ) NEWLINE NL ENDMARKER
T_ON = 0 DEBUG_ON = 1 MOD = 998244353   def solve ( ) : n = read_int ( ) if n <= 2 : print ( n ) else : print ( 1 )   def main ( ) : T = read_int ( ) if T_ON else 1 for i in range ( T ) : solve ( )   def debug ( * xargs ) : if DEBUG_ON : print ( * xargs )   from collections import * import math   NEWLINE NL ENDMARKER
def findCountOfPairs ( a , b , n ) : NEWLINE INDENT ans = 0 NEWLINE for i in range ( 1 , a + 1 ) : NEWLINE INDENTINDENT ans += b // n NEWLINE ans += 1 if ( i % n + b % n ) >= n else 0 NEWLINE DEDENT return ans NEWLINE DEDENT a = 5 ; b = 13 ; n = 3 NEWLINE print ( findCountOfPairs ( a , b , n ) ) NEWLINE NL ENDMARKER
def sumOfSeries ( n ) : NEWLINE INDENT ans = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT ans = ans + i * i * i * i NEWLINE DEDENT return ans NEWLINE DEDENT n = 4 NEWLINE print ( sumOfSeries ( n ) ) NEWLINE NL ENDMARKER
def findAndPrintOriginalArray ( arr , n ) : NEWLINE INDENT arr_sum = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT arr_sum += arr [ i ] NEWLINE DEDENT arr_sum = int ( arr_sum / ( n - 1 ) ) NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT print ( ( arr_sum - arr [ i ] ) , end = " " ) NEWLINE DEDENT DEDENT arr = [ 10 , 14 , 12 , 13 , 11 ] NEWLINE n = len ( arr ) NEWLINE findAndPrintOriginalArray ( arr , n ) NEWLINE NL ENDMARKER
if __name__ == '__main__' : NEWLINE INDENT a = 10 NEWLINE b = 5 NEWLINE if b > 0 : NEWLINE INDENTINDENT while b > 0 : NEWLINE INDENTINDENTINDENT a = a + 1 NEWLINE b = b - 1 NEWLINE DEDENT DEDENT if b < 0 : NEWLINE INDENTINDENT while b < 0 : NEWLINE INDENTINDENTINDENT a = a - 1 NEWLINE b = b + 1 NEWLINE DEDENT DEDENT print ( "Sum is: " , a ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) )  def triangle_check ( a , b , c ) : return ( c < a + b )  count = 0 for a in range ( 1 , n + 1 ) : for b in range ( a + 1 , ( n + 1 ) ) : c = a ^ b if ( c <= n and c > b ) : if ( triangle_check ( a , b , c ) ) : count += 1 print ( count ) NEWLINE NL ENDMARKER
import sysfrom NEWLINE os NEWLINE import pathif NEWLINE ( path . exists ( 'input.txt' ) and path . exists ( 'output.txt' ) ) : sys . stdout = open ( 'output.txt' , 'w' ) NEWLINE sys . stdin = open ( 'input.txt' , 'r' )  NEWLINE NL ENDMARKER
x = [ ] for i in range ( 8 ) : s = str ( input ( ) ) x . append ( s ) d = Falsefor i in range ( 8 ) : s = x [ i ] if ( s == "BWBWBWBW" or s == "WBWBWBWB" ) : continue else : d = True print ( "NO" ) breakif ( d == False ) : print ( "YES" )              NEWLINE NL ENDMARKER
print ( sum ( i for i in range ( int ( input ( ) ) , - 1 , - 2 ) ) ) NEWLINE NL ENDMARKER
def printPFsInPairs ( n ) : NEWLINE INDENT for i in range ( 1 , int ( pow ( n , 1 / 2 ) ) + 1 ) : NEWLINE INDENTINDENT if n % i == 0 : NEWLINE INDENTINDENTINDENT print ( str ( i ) + "*" + str ( int ( n / i ) ) ) NEWLINE DEDENT DEDENT DEDENT n = 24 NEWLINE printPFsInPairs ( n ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) L = [ int ( x ) for x in input ( ) . split ( ) ] pos = [ 0 ] * nfor i in range ( n ) : pos [ L [ i ] - 1 ] = ians = 0 for i in range ( n - 1 ) : ans += abs ( pos [ i ] - pos [ i + 1 ] ) print ( ans ) NEWLINE NL ENDMARKER
x = 10 NEWLINE y = 5 NEWLINE x = x ^ y ; NEWLINE y = x ^ y ; NEWLINE x = x ^ y ; NEWLINE print ( "After Swapping: x = " , x , " y =" , y ) NEWLINE NL ENDMARKER
word = input ( '' ) NEWLINE upper = 0 l NEWLINE ower = 0 NEWLINE for x in word : if NEWLINE x >= "A" and x <= "Z" : upper += 1 elif x >= "a" and x <= "z" : lower += 1 NEWLINE if lower >= upper : NEWLINE INDENT print ( word . lower ( ) ) else : NEWLINE print ( word . upper ( ) ) NEWLINE NL DEDENT ENDMARKER
from math import * NEWLINE def nthTerm ( n ) : NEWLINE INDENT return pow ( n , 2 ) - 2 * n + 2 NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 4 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
def findK ( n , k ) : NEWLINE INDENT a = list ( ) NEWLINE i = 1 NEWLINE while i < n : NEWLINE INDENTINDENT a . append ( i ) NEWLINE i = i + 2 NEWLINE DEDENT i = 2 NEWLINE while i < n : NEWLINE INDENTINDENT a . append ( i ) NEWLINE i = i + 2 NEWLINE DEDENT return ( a [ k - 1 ] ) NEWLINE DEDENT n = 10 NEWLINE k = 3 NEWLINE print ( findK ( n , k ) ) NEWLINE NL ENDMARKER
k , n , w = map ( int , input ( ) . split ( ) ) print ( max ( 0 , w * ( w + 1 ) * k // 2 - n ) ) NEWLINE NL ENDMARKER
from math import ceil , floor NEWLINE def Alcuin ( n ) : NEWLINE INDENT _n = n NEWLINE ans = 0 NEWLINE ans = ( round ( ( _n * _n ) / 12 ) - floor ( _n / 4 ) * floor ( ( _n + 2 ) / 4 ) ) NEWLINE return ans NEWLINE DEDENT def solve ( n ) : NEWLINE INDENT for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT print ( Alcuin ( i ) , end = ", " ) NEWLINE DEDENT DEDENT n = 15 NEWLINE solve ( n ) NEWLINE NL ENDMARKER
def Move ( a , x , b ) : NEWLINE INDENT if ( ( ( ( b - a ) % x == 0 ) or ( ( b - a - 1 ) % x == 0 ) and a + 1 != b ) and b >= a ) : NEWLINE INDENTINDENT return True NEWLINE DEDENT return False NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = 3 NEWLINE x = 2 NEWLINE b = 7 NEWLINE if ( Move ( a , x , b ) ) : NEWLINE INDENTINDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) NEWLINE NL DEDENT DEDENT ENDMARKER
import matha = int ( input ( ) ) m = math . ceil ( ( a + 1 ) / 2 ) print ( m ) for i in range ( 1 , min ( a + 1 , m + 1 ) ) : print ( 1 , i ) a = a - 1 for i in range ( m - a + 1 , m + 1 ) : if ( a <= 0 ) : break print ( m , i ) a = a - 1 NEWLINE NL ENDMARKER
def findNthDigit ( p , q , N ) : NEWLINE INDENT while ( N > 0 ) : NEWLINE INDENTINDENT N -= 1 ; NEWLINE p *= 10 ; NEWLINE res = p // q ; NEWLINE p %= q ; NEWLINE DEDENT return res ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT p = 1 ; q = 2 ; N = 1 ; NEWLINE print ( findNthDigit ( p , q , N ) ) ; NEWLINE NL DEDENT ENDMARKER
from math import pow NEWLINE def calculateSum ( n ) : NEWLINE INDENT return n * ( pow ( n , 2 ) + 3 * n + 5 ) / 3 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 3 NEWLINE print ( "Sum =" , int ( calculateSum ( n ) ) ) NEWLINE NL DEDENT ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) a = a + 1 n = ak = 10 while ( True ) : if ( ( a % k ) > b ) : break n = a - ( a % k ) k *= 10 print ( n - 1 ) NEWLINE NL ENDMARKER
def CalculateMax ( arr , n ) : NEWLINE INDENT arr . sort ( ) NEWLINE min_sum = arr [ 0 ] + arr [ 1 ] NEWLINE max_sum = arr [ n - 1 ] + arr [ n - 2 ] NEWLINE return abs ( max_sum - min_sum ) NEWLINE DEDENT arr = [ 6 , 7 , 1 , 11 ] NEWLINE n = len ( arr ) NEWLINE print ( CalculateMax ( arr , n ) ) NEWLINE NL ENDMARKER
a = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) k = max ( l ) l = sorted ( l ) p = 0 for i in range ( len ( l ) - 1 ) : p += ( k - l [ i ] ) print ( p ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) if ( n == 1 ) : if ( s == "0" ) : print ( "No" ) else : print ( "Yes" ) exit ( 0 ) if ( "11" in s ) or ( "000" in s ) or ( s [ - 2 : ] == "00" ) or ( s [ : 2 ] == "00" ) : print ( "No" ) else : print ( "Yes" ) NEWLINE NL ENDMARKER
def heptdiagonal ( a ) : NEWLINE INDENT if ( a < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT d = 1.802 * a NEWLINE return round ( d , 3 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = 6 NEWLINE print ( heptdiagonal ( a ) ) NEWLINE NL DEDENT ENDMARKER
t = int ( input ( ) ) for u in range ( t ) : n , m = map ( int , input ( ) . split ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] add = 0 for i in range ( 1 , n ) : add += a [ i ] print ( min ( m , a [ 0 ] + add ) ) NEWLINE NL ENDMARKER
b = str ( input ( ) ) c = 0 if '1' not in b : print ( 'no' ) else : for i in range ( len ( b ) ) : if b [ i ] == '1' : idx = i break  for i in range ( idx , len ( b ) ) : if b [ i ] == '0' : c += 1  if c >= 6 : print ( 'yes' ) else : print ( 'no' ) NEWLINE NL ENDMARKER
def printTrib ( n ) : NEWLINE INDENT dp = [ 0 ] * n NEWLINE dp [ 0 ] = dp [ 1 ] = 0 ; NEWLINE dp [ 2 ] = 1 ; NEWLINE for i in range ( 3 , n ) : NEWLINE INDENTINDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; NEWLINE DEDENT for i in range ( 0 , n ) : NEWLINE INDENTINDENT print ( dp [ i ] , " " , end = "" ) NEWLINE DEDENT DEDENT n = 10 NEWLINE printTrib ( n ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) for i in range ( 0 , n + 1 , 1234567 ) : for j in range ( 0 , n + 1 , 123456 ) : if ( n - ( i + j ) ) % 1234 == 0 and i + j <= n : print ( 'YES' ) exit ( ) print ( 'NO' ) NEWLINE NL ENDMARKER
from math import gcdl , r = map ( int , input ( ) . split ( ) ) if ( r - l < 2 ) : print ( - 1 ) exit ( ) for a in range ( l , r + 1 ) : for b in range ( a + 1 , r + 1 ) : for c in range ( b + 1 , r + 1 ) : if ( gcd ( a , b ) == 1 and gcd ( b , c ) == 1 and gcd ( a , c ) != 1 ) : print ( a , b , c ) exit ( ) else : print ( - 1 ) NEWLINE NL ENDMARKER
def isPrime ( n ) : NEWLINE INDENT if ( n <= 1 ) : NEWLINE INDENTINDENT return False NEWLINE DEDENT for i in range ( 2 , n ) : NEWLINE INDENTINDENT if ( n % i == 0 ) : NEWLINE INDENTINDENTINDENT return False NEWLINE DEDENT DEDENT return True NEWLINE DEDENT if isPrime ( 11 ) : NEWLINE INDENT print ( "true" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "false" ) NEWLINE NL DEDENT ENDMARKER
x , y = map ( int , input ( ) . split ( ) ) n = 0 b = Truewhile b : n += 1 if ( n * x - y ) % 10 == 0 or n * x % 10 == 0 : b = Falseprint ( n ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : NEWLINE INDENT n , k = [ int ( e ) for e in input ( ) . split ( ) ] NEWLINE k -= 1 NEWLINE print ( ( k + n % 2 * k // ( n // 2 ) ) % n + 1 ) NEWLINE NL DEDENT ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) a = [ ] for i in range ( n ) : s = input ( ) a . append ( s ) r = [ 0 ] * nc = [ 0 ] * mf = 0 cnt = 0 for i in range ( n ) : for j in range ( m ) : if a [ i ] [ j ] == '*' : r [ i ] += 1 c [ j ] += 1 cnt += 1 r1 = 0 c1 = 0 for i in range ( n ) : if ( f ) : break for j in range ( m ) : d = r [ i ] + c [ j ] if a [ i ] [ j ] == "*" : d -= 1 if d == cnt : f = 1 r1 = i c1 = j break NEWLINE NL ENDMARKER
for s in [ * open ( 0 ) ] [ 1 : ] : n = int ( s ) ; print ( n , * range ( 1 , n ) ) NEWLINE NL ENDMARKER
def dodecahedral_num ( n ) : NEWLINE INDENT return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) // 2 NEWLINE DEDENT n = 5 NEWLINE print ( "%sth Dodecahedral number :" % n , dodecahedral_num ( n ) ) NEWLINE NL ENDMARKER
q = int ( input ( ) ) answer = 0 ch = [ ] for i in range ( q ) : n = int ( input ( ) ) if n == 2 : ch . append ( 2 ) if n % 2 == 0 and n != 2 : ch . append ( 0 ) if n % 2 != 0 : ch . append ( 1 ) for j in ch : print ( j , end = "\n" ) NEWLINE NL ENDMARKER
def isEven ( n ) : NEWLINE INDENT return ( n % 2 == 0 ) NEWLINE DEDENT n = 101 NEWLINE print ( "Even" if isEven ( n ) else "Odd" ) NEWLINE NL ENDMARKER
def findMaxNum ( arr , n ) : NEWLINE INDENT arr . sort ( reverse = True ) NEWLINE num = arr [ 0 ] NEWLINE for i in range ( 1 , n ) : NEWLINE INDENTINDENT num = num * 10 + arr [ i ] NEWLINE DEDENT return num NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 0 ] NEWLINE n = len ( arr ) NEWLINE print ( findMaxNum ( arr , n ) ) NEWLINE NL DEDENT ENDMARKER
def countNumbers ( N ) : NEWLINE INDENT return ( pow ( 10 , N ) - pow ( 8 , N ) ) // 2 NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 5 NEWLINE print ( countNumbers ( n ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) i = 2 ; ans = 1 while i * i <= n : cnt = 0 while n % i == 0 : n = n // i cnt += 1 if cnt : ans *= i i += 1 if n > 1 : ans *= nprint ( ans ) NEWLINE NL ENDMARKER
from collections import Countern , k = map ( int , input ( ) . split ( ) ) s = input ( ) d = Counter ( s ) ans , opened = 0 , set ( ) for i in s : if i not in opened : opened . add ( i ) ans += 1 if ans > k : print ( "YES" ) ; break d [ i ] -= 1 if not d [ i ] : ans -= 1 else : print ( "NO" ) NEWLINE NL ENDMARKER
def product ( N ) : NEWLINE INDENT ans = 1 ; NEWLINE val = 2 ** ( N - 1 ) ; NEWLINE for i in range ( 1 , N + 1 ) : NEWLINE INDENTINDENT ans *= ( i ** val ) ; NEWLINE DEDENT return ans ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 2 ; NEWLINE print ( product ( N ) ) ; NEWLINE NL DEDENT ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) a = a % 2 ans = 0 i = 1 for n in arr : x = n * a ** ( b - i ) ans += x i += 1   if ans % 2 == 1 : print ( "odd" ) else : print ( "even" ) NEWLINE NL ENDMARKER
n , b , d = map ( int , input ( ) . split ( ) ) summa = 0 ans = 0 a = [ int ( i ) for i in input ( ) . split ( ) ] for i in a : if i <= b : summa += i if summa > d : summa = 0 ans += 1 print ( ans ) NEWLINE NL ENDMARKER
import math NEWLINE def binomialCoeffSum ( n ) : NEWLINE INDENT return ( 1 << n ) ; NEWLINE DEDENT n = 4 NEWLINE print ( binomialCoeffSum ( n ) ) NEWLINE NL ENDMARKER
x = int ( input ( ) ) votes1 = list ( map ( int , input ( ) . split ( ) ) ) votes2 = [ ] pivot = max ( votes1 ) for i in range ( pivot , 202 ) : for j in range ( len ( votes1 ) ) : vote = i - votes1 [ j ] votes2 . append ( vote ) if sum ( votes2 ) > sum ( votes1 ) : print ( i ) break else : votes2 = [ ] NEWLINE NL ENDMARKER
def findSum ( n ) : NEWLINE INDENT sum2 = ( ( n // 2 ) * ( 4 + ( n // 2 - 1 ) * 2 ) ) // 2 NEWLINE sum5 = ( ( n // 5 ) * ( 10 + ( n // 5 - 1 ) * 5 ) ) // 2 NEWLINE sum10 = ( ( n // 10 ) * ( 20 + ( n // 10 - 1 ) * 10 ) ) // 2 NEWLINE return sum2 + sum5 - sum10 ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 5 NEWLINE print ( int ( findSum ( n ) ) ) NEWLINE NL DEDENT ENDMARKER
n , a , b = list ( map ( int , input ( ) . split ( ) ) ) s = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 for i in range ( n ) : if s [ i ] == 2 : if s [ n - 1 - i ] == 2 : ans = ans + min ( a , b ) elif s [ n - 1 - i ] == 0 : ans = ans + a else : ans = ans + b else : if s [ n - 1 - i ] != 2 and s [ n - 1 - i ] != s [ i ] : print ( "-1" ) exit ( ) print ( ans ) NEWLINE NL ENDMARKER
def printPattern ( n ) : NEWLINE INDENT if ( n == 0 or n < 0 ) : NEWLINE INDENTINDENT print ( n , end = ", " ) NEWLINE return NEWLINE DEDENT print ( n , end = ", " ) NEWLINE printPattern ( n - 5 ) NEWLINE print ( n , end = ", " ) NEWLINE DEDENT n = 16 NEWLINE printPattern ( n ) NEWLINE NL ENDMARKER
s = input ( ) a = input ( ) m = len ( a ) n = len ( s ) c = 0 i = 0 while ( i <= n - m ) : if ( s [ i : i + m ] == a ) : c += 1 i = i + m else : i += 1 print ( c ) NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def isToeplitzMatrix ( self , matrix ) : NEWLINE INDENTINDENT for r in range ( len ( matrix ) - 1 ) : NEWLINE INDENTINDENTINDENT for c in range ( len ( matrix [ 0 ] ) - 1 ) : NEWLINE INDENTINDENTINDENTINDENT if matrix [ r ] [ c ] != matrix [ r + 1 ] [ c + 1 ] : NEWLINE INDENTINDENTINDENTINDENTINDENT return False NEWLINE DEDENT DEDENT DEDENT return True NEWLINE NL DEDENT DEDENT ENDMARKER
def center_octadecagon_num ( n ) : NEWLINE INDENT return ( 9 * n * n - 9 * n + 1 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 3 NEWLINE print ( n , "rd centered octadecagonal " + "number : " , center_octadecagon_num ( n ) ) NEWLINE n = 13 NEWLINE print ( n , "th centered octadecagonal " + "number : " , center_octadecagon_num ( n ) ) NEWLINE NL DEDENT ENDMARKER
s = input ( ) r = l = d = u = 0 for i in s : if i == 'R' : r += 1 if i == 'L' : l += 1 if i == 'D' : d += 1 if i == 'U' : u += 1 if ( u + d + r + l ) % 2 == 0 : NEWLINE NL ENDMARKER
a = int ( input ( ) ) I = lambda : list ( map ( int , input ( ) . split ( ) ) ) b = I ( ) if a >= 2 : ma = 2 current = 2 for i in range ( 2 , len ( b ) ) : if b [ i - 2 ] + b [ i - 1 ] == b [ i ] : current += 1 else : current = 2 if current > ma : ma = current print ( ma ) elif a == 1 : print ( 1 ) else : print ( 0 ) NEWLINE NL ENDMARKER
if __name__ == "__main__" : s = "ROYGBIV" NEWLINE cases = [ '' , 'G' , 'GB' , 'YGB' , 'YGBI' , 'OYGBI' , 'OYGBIV' ] NEWLINE n = int ( input ( ) ) NEWLINE to_print = n // 7 NEWLINE cases_print = n % 7 NEWLINE print ( s * to_print , end = "" ) NEWLINE print ( cases [ cases_print ] , end = "" ) NEWLINE NL ENDMARKER
a , b , c , l = map ( int , input ( ) . split ( ) ) ans = ( l + 3 ) * ( l + 2 ) // 2 * ( l + 1 ) // 3 for z in ( a , b , c ) : s = 2 * z - a - b - c for x in range ( l + 1 ) : m = min ( s + x , l - x ) if m >= 0 : ans -= ( m + 1 ) * ( m + 2 ) >> 1 print ( ans ) NEWLINE NL ENDMARKER
a , b , c , d = input ( ) . split ( ) a , b , c , d = int ( a ) , int ( b ) , int ( c ) , int ( d ) def score ( p , t ) : sco = 0 sco1 = 3 * p / 10 sco2 = p - ( p * t / 250 ) if sco1 > sco2 : sco = sco1 return sco else : sco = sco2 return scosco_misha = score ( a , c ) sco_vasya = score ( b , d ) if sco_misha > sco_vasya : print ( "Misha" ) elif sco_misha < sco_vasya : print ( "Vasya" ) else : print ( "Tie" ) NEWLINE NL ENDMARKER
import mathn , x , y = map ( int , input ( ) . strip ( ) . split ( ' ' ) ) NEWLINE NL ENDMARKER
if __name__ == '__main__' : NEWLINE INDENT str = "A computer science portal for geeks" NEWLINE for i in range ( 0 , len ( str ) , 1 ) : NEWLINE INDENTINDENT if ( str [ i ] == ' ' ) : NEWLINE INDENTINDENTINDENT str = str . replace ( str [ i ] , '-' ) NEWLINE DEDENT DEDENT print ( str ) NEWLINE NL DEDENT ENDMARKER
import math NEWLINE def subsetCount ( arr , n ) : NEWLINE INDENT return 1 << n NEWLINE DEDENT A = [ 1 , 2 , 3 ] NEWLINE n = len ( A ) NEWLINE print ( subsetCount ( A , n ) ) NEWLINE NL ENDMARKER
def factorial ( n ) : NEWLINE INDENT if ( n == 0 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT return n * factorial ( n - 1 ) NEWLINE DEDENT def LCMOfNeighbourFact ( n ) : NEWLINE INDENT return factorial ( n + 1 ) NEWLINE DEDENT N = 5 NEWLINE print ( LCMOfNeighbourFact ( N ) ) NEWLINE NL ENDMARKER
class Solution : NEWLINE INDENT def defangIPaddr ( self , address : str ) -> str : NEWLINE INDENTINDENT return address . replace ( '.' , '[.]' ) NEWLINE NL DEDENT DEDENT ENDMARKER
def sortString ( str ) : NEWLINE INDENT str = '' . join ( sorted ( str ) ) NEWLINE print ( str ) NEWLINE DEDENT s = "geeksforgeeks" NEWLINE sortString ( s ) NEWLINE NL ENDMARKER
def firstDigit ( n ) : NEWLINE INDENT while n >= 10 : NEWLINE INDENTINDENT n = n / 10 ; NEWLINE DEDENT return int ( n ) NEWLINE DEDENT def lastDigit ( n ) : NEWLINE INDENT return ( n % 10 ) NEWLINE DEDENT n = 98562 ; NEWLINE print ( firstDigit ( n ) , end = " " ) NEWLINE print ( lastDigit ( n ) ) NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readline  ''''''  n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) pf_sum = [ a [ 0 ] ] for i in range ( 1 , n ) : pf_sum . append ( pf_sum [ - 1 ] + a [ i ] )  if pf_sum [ - 1 ] % 2 : print ( "NO" ) sys . exit ( ) elif pf_sum [ - 1 ] > 2 * pf_sum [ - 2 ] : print ( "NO" ) sys . exit ( ) else : print ( "YES" ) NEWLINE NL ENDMARKER
def isDivisible ( n ) : NEWLINE INDENT while n // 100 : NEWLINE INDENTINDENT d = n % 10 NEWLINE n //= 10 NEWLINE n += d * 7 NEWLINE DEDENT return ( n % 23 == 0 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 1191216 NEWLINE if ( isDivisible ( n ) ) : NEWLINE INDENTINDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) NEWLINE NL DEDENT DEDENT ENDMARKER
def countDigit ( n ) : NEWLINE INDENT count = 0 NEWLINE while n != 0 : NEWLINE INDENTINDENT n //= 10 NEWLINE count += 1 NEWLINE DEDENT return count NEWLINE DEDENT n = 345289467 NEWLINE print ( "Number of digits : % d" % ( countDigit ( n ) ) ) NEWLINE NL ENDMARKER
def findNumbers ( n , w ) : NEWLINE INDENT x = 0 ; NEWLINE sum = 0 ; NEWLINE if ( w >= 0 and w <= 8 ) : NEWLINE INDENTINDENT x = 9 - w ; NEWLINE DEDENT elif ( w >= - 9 and w <= - 1 ) : NEWLINE INDENTINDENT x = 10 + w ; NEWLINE DEDENT sum = pow ( 10 , n - 2 ) ; NEWLINE sum = ( x * sum ) ; NEWLINE return sum ; NEWLINE DEDENT n = 3 ; NEWLINE w = 4 ; NEWLINE print ( findNumbers ( n , w ) ) ; NEWLINE NL ENDMARKER
n , k = input ( ) . split ( ) n = int ( n ) k = int ( k ) for i in range ( k ) : if ( n % 10 == 0 ) : n = int ( n / 10 ) else : n = n - 1 print ( n ) NEWLINE NL ENDMARKER
def findProduct ( arr , n , k ) : NEWLINE INDENT prod = 1 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT if ( arr [ i ] % k == 0 ) : NEWLINE INDENTINDENTINDENT prod *= arr [ i ] NEWLINE DEDENT DEDENT return prod NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 15 , 16 , 10 , 9 , 6 , 7 , 17 ] NEWLINE n = len ( arr ) NEWLINE k = 3 NEWLINE print ( findProduct ( arr , n , k ) ) NEWLINE NL DEDENT ENDMARKER
def findNthTerm ( n ) : NEWLINE INDENT if n % 2 == 0 : NEWLINE INDENTINDENT n //= 2 NEWLINE print ( 3 ** ( n - 1 ) ) NEWLINE DEDENT else : NEWLINE INDENTINDENT n = ( n // 2 ) + 1 NEWLINE print ( 2 ** ( n - 1 ) ) NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 4 NEWLINE findNthTerm ( N ) NEWLINE N = 11 NEWLINE findNthTerm ( N ) NEWLINE NL DEDENT ENDMARKER
import math NEWLINE def findIndex ( n ) : NEWLINE INDENT fibo = 2.078087 * math . log ( n ) + 1.672276 NEWLINE return round ( fibo ) NEWLINE DEDENT n = 21 NEWLINE print ( findIndex ( n ) ) NEWLINE NL ENDMARKER
from sys import stdin , stdout NEWLINE NL ENDMARKER
x = int ( input ( ) ) n = list ( map ( int , input ( ) . split ( ) ) ) prest = 0 cop = 0 for i in range ( x ) : cop += n [ i ] if cop < 0 : prest += 1 cop = 0 print ( prest ) NEWLINE NL ENDMARKER
def calculateSum ( n ) : NEWLINE INDENT return ( 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) // 6 ) + n * ( n + 1 ) // 2 + 2 * ( n ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 3 NEWLINE print ( "Sum =" , calculateSum ( n ) ) NEWLINE NL DEDENT ENDMARKER
def oddFib ( n ) : NEWLINE INDENT n = ( 3 * n + 1 ) // 2 NEWLINE a = - 1 NEWLINE b = 1 NEWLINE c = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT c = a + b NEWLINE a = b NEWLINE b = c NEWLINE DEDENT return c NEWLINE DEDENT n = 4 NEWLINE print ( oddFib ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( input ( ) . split ( ) ) k = n // 2 for i in range ( 0 , k , 2 ) : a [ i ] , a [ n - i - 1 ] = a [ n - i - 1 ] , a [ i ] print ( * a ) NEWLINE NL ENDMARKER
def isSumOfPowersOfTwo ( n ) : NEWLINE INDENT if n % 2 == 1 : NEWLINE INDENTINDENT return False NEWLINE DEDENT else : NEWLINE INDENTINDENT return True NEWLINE DEDENT DEDENT n = 10 NEWLINE if isSumOfPowersOfTwo ( n ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) l = len ( bin ( n ) ) - 2 if k == 1 : print ( n ) else : print ( 2 ** l - 1 )  NEWLINE NL ENDMARKER
def nthOdd ( n ) : NEWLINE INDENT return ( 2 * n - 1 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 10 NEWLINE print ( nthOdd ( n ) ) NEWLINE NL DEDENT ENDMARKER
t = int ( input ( ) ) NEWLINE for x in range ( t ) : n = int ( input ( ) ) NEWLINE s = input ( )  if ( s [ : 1 ] == "2" and s [ n - 3 : ] == "020" ) : print ( "YES" )  elif ( s [ : 2 ] == "20" and s [ n - 2 : ] == "20" ) : print ( "YES" ) elif ( s [ : 3 ] == "202" and s [ n - 1 : ] == "0" ) : print ( "YES" )  elif ( s [ : 4 ] == "2020" or s [ n - 4 : ] == "2020" ) : print ( "YES" )  else : print ( "NO" )  NEWLINE NL ENDMARKER
def Nth_Term ( n ) : NEWLINE INDENT return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) // 6 NEWLINE DEDENT N = 8 NEWLINE print ( Nth_Term ( N ) ) NEWLINE NL ENDMARKER
def compute ( ) : NEWLINE INDENT N = 100 NEWLINE s = sum ( i for i in range ( 1 , N + 1 ) ) NEWLINE s2 = sum ( i ** 2 for i in range ( 1 , N + 1 ) ) NEWLINE return str ( s ** 2 - s2 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( compute ( ) ) NEWLINE NL DEDENT ENDMARKER
import sysx = input ( ) for i in range ( len ( x ) - 1 , - 1 , - 1 ) : if x [ i ] != '0' : new = ( i + 1 ) for j in range ( new // 2 ) : if ( x [ j ] != x [ new - j - 1 ] ) : print ( "NO" ) sys . exit ( 0 ) breakprint ( "YES" ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) a = 240 b = 240 - ks = 0 c = 0 for i in range ( 1 , n + 1 ) : s += 5 * i if ( s <= b ) : c += 1 print ( c ) NEWLINE NL ENDMARKER
def isPowerOfTwo ( x ) : NEWLINE INDENT return ( x and ( not ( x & ( x - 1 ) ) ) ) NEWLINE DEDENT if ( isPowerOfTwo ( 31 ) ) : NEWLINE INDENT print ( 'Yes' ) NEWLINE DEDENT else : NEWLINE INDENT print ( 'No' ) NEWLINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEWLINE INDENT print ( 'Yes' ) NEWLINE DEDENT else : NEWLINE INDENT print ( 'No' ) NEWLINE NL DEDENT ENDMARKER
from math import ceil NEWLINE def Min_glass ( n , k , a ) : NEWLINE INDENT a . sort ( ) NEWLINE return ceil ( sum ( a [ : k ] ) / 100 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n , k = 4 , 3 NEWLINE a = [ 200 , 150 , 140 , 300 ] NEWLINE print ( Min_glass ( n , k , a ) ) NEWLINE NL DEDENT ENDMARKER
def focal_length ( image_distance , object_distance ) NEWLINE INDENT : return 1 / ( ( 1 / image_distance ) + ( 1 / object_distance ) ) NEWLINE DEDENT image_distance = 2 NEWLINE object_distance = 50 NEWLINE result = focal_length ( image_distance , object_distance ) NEWLINE print ( "Focal length of a lens is " , result , " units." ) NEWLINE NL ENDMARKER
def dist ( x1 , y1 , x2 , y2 , r ) : NEWLINE INDENT print ( "The shortest distance between a point and a circle is " , ( ( ( ( x2 - x1 ) ** 2 ) + ( ( y2 - y1 ) ** 2 ) ) ** ( 1 / 2 ) ) - r ) ; NEWLINE DEDENT x1 = 4 ; NEWLINE y1 = 6 ; NEWLINE x2 = 35 ; NEWLINE y2 = 42 ; NEWLINE r = 5 ; NEWLINE dist ( x1 , y1 , x2 , y2 , r ) ; NEWLINE NL ENDMARKER
def minimumMoves ( n , a , s , t ) : NEWLINE INDENT x = s NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT if x == t : NEWLINE INDENTINDENTINDENT return i - 1 NEWLINE DEDENT x = a [ x ] NEWLINE DEDENT return - 1 NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT s , t = 2 , 1 NEWLINE a = [ - 1 , 2 , 3 , 4 , 1 ] NEWLINE n = len ( a ) NEWLINE print ( minimumMoves ( n , a , s , t ) ) NEWLINE NL DEDENT ENDMARKER
def sumDigits ( no ) : NEWLINE INDENT return 0 if no == 0 else int ( no % 10 ) + sumDigits ( int ( no / 10 ) ) NEWLINE DEDENT print ( sumDigits ( 687 ) ) NEWLINE NL ENDMARKER
import sys  input = sys . stdin . buffer . readline  t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) A = sorted ( map ( int , input ( ) . split ( ) ) ) print ( A [ n ] - A [ n - 1 ] ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) count = 0 for i in range ( 1 , n + 1 ) : for j in range ( i , n + 1 ) : temp = i ^ j if temp < j or temp > n or i + j <= temp : continue count += 1 print ( count ) NEWLINE NL ENDMARKER
from sys import stdinn = int ( stdin . readline ( ) ) s = stdin . readline ( ) [ : - 1 ] for i in range ( 1 , n ) : if s [ i ] < s [ i - 1 ] : print ( 'YES' ) print ( i , i + 1 ) breakelse : print ( 'NO' ) NEWLINE NL ENDMARKER
a , b = input ( ) . split ( ) print ( a if a == b else 2 ) NEWLINE NL ENDMARKER
import math   def main_function ( ) : n , x = [ int ( i ) for i in input ( ) . split ( " " ) ] cards = [ int ( i ) for i in input ( ) . split ( " " ) ] sum_negative = 0 sum_positive = 0 for i in cards : if i > 0 : sum_positive += i else : sum_negative += abs ( i ) dif = abs ( sum_negative - sum_positive ) cards = int ( math . ceil ( dif / x ) ) return cards       print ( main_function ( ) ) NEWLINE NL ENDMARKER
from collections import defaultdict , Countern = int ( input ( ) ) s = input ( ) d = defaultdict ( list ) for i in range ( n ) : d [ s [ i ] ] . append ( i ) m = int ( input ( ) ) for i in range ( m ) : s1 = input ( ) d1 = Counter ( s1 ) ans = 0 for p in d1 . keys ( ) : ans = max ( ans , d [ p ] [ d1 [ p ] - 1 ] ) print ( ans + 1 ) NEWLINE NL ENDMARKER
import mathvalidangles = set ( ) i = 3 while ( angle := ( 180 * ( i - 2 ) ) / i ) <= 179 : if math . floor ( angle ) == angle : validangles . add ( angle ) i += 1   n = int ( input ( ) ) for i in range ( n ) : a = int ( input ( ) ) if a in validangles : print ( 'YES' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : arr [ i ] = ( arr [ i ] , i ) arr . sort ( ) res = [ 0 ] * nfor i in range ( n ) : res [ arr [ i ] [ 1 ] ] = i % 2 print ( * res ) NEWLINE NL ENDMARKER
import math NEWLINE def numberofterm ( n , number ) : NEWLINE INDENT firstnum = math . pow ( 10 , n - 1 ) NEWLINE lastnum = math . pow ( 10 , n ) NEWLINE count = 0 NEWLINE for i in range ( int ( firstnum ) , int ( lastnum ) ) : NEWLINE INDENTINDENT if ( i % number == 0 ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT return count NEWLINE DEDENT n = 3 NEWLINE num = 7 NEWLINE print ( numberofterm ( n , num ) ) NEWLINE NL ENDMARKER
def maxDistance ( n , fuel ) : NEWLINE INDENT dist_covered = 0 NEWLINE while ( n > 0 ) : NEWLINE INDENTINDENT dist_covered = dist_covered + ( fuel / n ) NEWLINE n = n - 1 NEWLINE DEDENT return dist_covered NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 3 NEWLINE fuel = 100 NEWLINE print ( "Maximum distance possible with" , n , "bikes is" , maxDistance ( n , fuel ) ) NEWLINE NL DEDENT ENDMARKER
a = int ( input ( ) ) b = list ( map ( int , input ( ) . split ( ) ) ) print ( max ( b ) - min ( b ) + 1 - a ) NEWLINE NL ENDMARKER
from math import sqrt , floor NEWLINE def lowerWythoff ( n ) : NEWLINE INDENT phi = ( 1 + sqrt ( 5 ) ) / 2 ; NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT ans = floor ( i * phi ) ; NEWLINE print ( ans , end = "" ) ; NEWLINE if ( i != n ) : NEWLINE INDENTINDENTINDENT print ( ", " , end = "" ) ; NEWLINE DEDENT DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 5 ; NEWLINE lowerWythoff ( n ) ; NEWLINE NL DEDENT ENDMARKER
for _ in [ 0 ] * int ( input ( ) ) : print ( 2 * int ( input ( ) . split ( ) [ 1 ] ) ) NEWLINE NL ENDMARKER
def oddSum ( n ) : NEWLINE INDENT return ( n * n ) ; NEWLINE DEDENT n = 20 NEWLINE print ( " Sum of first" , n , "Odd Numbers is: " , oddSum ( n ) ) NEWLINE NL ENDMARKER
def possibleways ( n ) : NEWLINE INDENT if ( n % 2 == 1 ) : NEWLINE INDENTINDENT return 0 ; NEWLINE DEDENT elif ( n % 4 == 0 ) : NEWLINE INDENTINDENT return n // 4 - 1 ; NEWLINE DEDENT else : NEWLINE INDENTINDENT return n // 4 ; NEWLINE DEDENT DEDENT n = 20 ; NEWLINE print ( possibleways ( n ) ) ; NEWLINE NL ENDMARKER
t = int ( input ( ) ) for _ in range ( t ) : n , r = map ( int , input ( ) . split ( ) ) ans = 0 if ( n > r ) : NEWLINE NL ENDMARKER
b = int ( input ( ) ) def make_divisors ( n ) : divisors = [ ] for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : if n % i == 0 : divisors . append ( i ) if i != n // i : divisors . append ( n // i )  NEWLINE NL ENDMARKER
def SUM ( x , n ) : NEWLINE INDENT total = 1 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT total = total + ( ( x ** i ) / i ) NEWLINE DEDENT return total NEWLINE DEDENT x = 2 NEWLINE n = 5 NEWLINE s = SUM ( x , n ) NEWLINE print ( round ( s , 2 ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) print ( a + b ) NEWLINE NL ENDMARKER
a , b = sorted ( [ int ( x ) for x in input ( ) . split ( ) ] ) print ( a , ( ( b - a ) // 2 ) ) NEWLINE NL ENDMARKER
def multiplyWith4 ( n ) : NEWLINE INDENT return ( n << 2 ) NEWLINE DEDENT n = 4 NEWLINE print ( multiplyWith4 ( n ) ) NEWLINE NL ENDMARKER
for i in range ( int ( input ( ) ) ) : n = int ( input ( ) ) cnto = sum ( list ( map ( lambda x : int ( x ) % 2 , input ( ) . split ( ) ) ) ) print ( 'YES' if cnto == 0 or cnto == n else 'NO' ) NEWLINE NL ENDMARKER
def cubeSum ( n ) : NEWLINE INDENT return ( n * n * ( 2 * n * n - 1 ) ) NEWLINE DEDENT print ( cubeSum ( 4 ) ) NEWLINE NL ENDMARKER
n , m , h = list ( map ( int , input ( ) . split ( ) ) )   a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ]  for i in range ( n ) : for j in range ( m ) : if c [ i ] [ j ] == 1 : c [ i ] [ j ] = min ( a [ j ] , b [ i ] ) 	  for i in range ( n ) : print ( * c [ i ] ) NEWLINE NL ENDMARKER
import ioimport osimport mathinput = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) g = [ 0 ] * ( n + 1 ) for k in range ( m ) : a , b = map ( int , input ( ) . split ( ) ) g [ a ] = 1 g [ b ] = 1  c = 0 for k in range ( 1 , len ( g ) ) : if g [ k ] == 0 : c = k break  print ( n - 1 ) for k in range ( 1 , len ( g ) ) : if k == c : continue print ( c , k ) NEWLINE NL ENDMARKER
if __name__ == "__main__" : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = l [ : : - 1 ] if n <= 2 : print ( * l ) else : i = 1 till = n // 2 - 1 while i < n // 2 : l [ i ] , l [ n - i - 1 ] = l [ n - i - 1 ] , l [ i ] i = i + 2 print ( * l ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr = sorted ( arr ) for i in range ( 1 , n + 1 ) : if i != arr [ i - 1 ] : print ( i ) breakelse : print ( n + 1 ) NEWLINE NL ENDMARKER
a = [ int ( x ) for x in input ( ) ] b = sorted ( [ int ( y ) for y in input ( ) ] , reverse = True ) y = 0  for i in range ( 0 , len ( a ) ) : if y < len ( b ) and a [ i ] < b [ y ] : a [ i ] = b [ y ] y = y + 1    print ( "" . join ( [ str ( c ) for c in a ] ) ) NEWLINE NL ENDMARKER
L = [ int ( X ) for X in input ( ) . split ( ) ] S = sum ( L ) if S == 0 : print ( - 1 ) else : if S % 5 == 0 : print ( S // 5 ) else : print ( - 1 ) NEWLINE NL ENDMARKER
CHAR_BIT = 8 NEWLINE def min ( x , y ) : NEWLINE INDENT return y + ( ( x - y ) & \ ( ( x - y ) >> ( 32 * CHAR_BIT - 1 ) ) ) NEWLINE DEDENT def smallest ( x , y , z ) : NEWLINE INDENT return min ( x , min ( y , z ) ) NEWLINE DEDENT x = 12 NEWLINE y = 15 NEWLINE z = 5 NEWLINE print ( "Minimum of 3 numbers is " , smallest ( x , y , z ) ) NEWLINE NL ENDMARKER
def Sum ( k , n ) : NEWLINE INDENT Summ = 0 NEWLINE for i in range ( n + 1 ) : NEWLINE INDENTINDENT p = 1 NEWLINE for j in range ( n - i ) : NEWLINE INDENTINDENTINDENT p = p * k NEWLINE DEDENT for j in range ( i ) : NEWLINE INDENTINDENTINDENT p = p * ( k - 1 ) NEWLINE DEDENT Summ = Summ + p NEWLINE DEDENT return Summ NEWLINE DEDENT n = 3 NEWLINE K = 3 NEWLINE print ( Sum ( K , n ) ) NEWLINE NL ENDMARKER
students , question = map ( int , input ( ) . split ( ) ) final_list = [ ] for each in range ( 0 , students ) : final_list . append ( input ( ) ) value = list ( map ( int , input ( ) . split ( ) ) )  i = 0 score = 0 for each in range ( 0 , question ) : count_list = [ 0 ] * 5 for ans_student in final_list : count_list [ ord ( ans_student [ i ] ) - 65 ] += value [ i ] score = score + max ( count_list ) i += 1 print ( score )  NEWLINE NL ENDMARKER
def result ( N ) : NEWLINE INDENT for num in range ( N ) : NEWLINE INDENTINDENT if num % 3 == 0 and num % 5 == 0 : NEWLINE INDENTINDENTINDENT print ( str ( num ) + " " , end = "" ) NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT pass NEWLINE DEDENT DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 100 NEWLINE result ( N ) NEWLINE NL DEDENT ENDMARKER
def minSum ( n ) : NEWLINE INDENT sum = 0 ; NEWLINE while ( n > 0 ) : NEWLINE INDENTINDENT sum += ( n % 10 ) ; NEWLINE n //= 10 ; NEWLINE DEDENT if ( sum == 1 ) : NEWLINE INDENTINDENT return 10 ; NEWLINE DEDENT return sum ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 1884 ; NEWLINE print ( minSum ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
def findThirdDigit ( n ) : NEWLINE INDENT if n < 3 : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT return 1 if n and 1 else 6 NEWLINE DEDENT n = 7 NEWLINE print ( findThirdDigit ( n ) ) NEWLINE NL ENDMARKER
a1 , a2 = map ( int , input ( ) . split ( ) )  minute = 0 while True : if a1 < a2 : a1 += 1 a2 -= 2 minute += 1 elif a2 < a1 : a2 += 1 a1 -= 2 minute += 1 else : if a1 == 1 : a1 -= 1 else : a1 += 1 a2 -= 2 minute += 1 if a1 <= 0 or a2 <= 0 : break  print ( minute ) NEWLINE NL ENDMARKER
from __future__ import division , print_functionfrom collections import * from math import * from itertools import * import osimport sysfrom io import BytesIO , IOBaseimport math NEWLINE NL ENDMARKER
from collections import Counter  n = int ( input ( ) ) a = Counter ( ) b = Counter ( ) for _ in range ( n ) : a [ input ( ) . strip ( ) ] += 1 for _ in range ( n ) : b [ input ( ) . strip ( ) ] += 1 ans = 0 for key in b : ans += max ( b [ key ] - a [ key ] , 0 ) NEWLINE NL ENDMARKER
import math NEWLINE def numberOfMinutes ( S , S1 ) : NEWLINE INDENT Min = 0 ; NEWLINE Min = ( ( S - S1 ) / math . floor ( S ) ) * 60 ; NEWLINE return int ( Min ) ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT S , S1 = 30 , 10 ; NEWLINE print ( numberOfMinutes ( S , S1 ) , "min" ) ; NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) r = [ 0 ] * nmn = 360 for i in range ( n ) : q = [ ] q . extend ( p [ i : ] ) if i > 0 : q . extend ( p [ 0 : i ] ) NEWLINE NL ENDMARKER
def swapBits ( x ) : NEWLINE INDENT even_bits = x & 0xAAAAAAAA NEWLINE odd_bits = x & 0x55555555 NEWLINE even_bits >>= 1 NEWLINE odd_bits <<= 1 NEWLINE return ( even_bits | odd_bits ) NEWLINE DEDENT x = 23 NEWLINE print ( swapBits ( x ) ) NEWLINE NL ENDMARKER
def countFact ( low , high ) : NEWLINE INDENT fact = 1 NEWLINE x = 1 NEWLINE while ( fact < low ) : NEWLINE INDENTINDENT fact = fact * x NEWLINE x += 1 NEWLINE DEDENT res = 0 NEWLINE while ( fact <= high ) : NEWLINE INDENTINDENT res += 1 NEWLINE fact = fact * x NEWLINE x += 1 NEWLINE DEDENT return res NEWLINE DEDENT print ( "Count is " , countFact ( 2 , 720 ) ) NEWLINE NL ENDMARKER
import math NEWLINE def cyl ( r , h ) : NEWLINE INDENT if ( r < 0 and h < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT R = ( 2 * r ) / 3 NEWLINE H = ( 2 * h ) / 3 NEWLINE V = 3.14 * math . pow ( R , 2 ) * H NEWLINE return V NEWLINE DEDENT r = 4 ; h = 8 ; NEWLINE print ( cyl ( r , h ) , "\n" ) NEWLINE NL ENDMARKER
def divide ( a , b ) : NEWLINE INDENT for i in range ( 2 , min ( a , b ) + 1 ) : NEWLINE INDENTINDENT while ( a % i == 0 and b % i == 0 ) : NEWLINE INDENTINDENTINDENT a = a // i NEWLINE b = b // i NEWLINE DEDENT DEDENT print ( "A =" , a , ", B =" , b ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT A , B = 10 , 15 NEWLINE divide ( A , B ) NEWLINE NL DEDENT ENDMARKER
def checkEVENodd ( arr , n , l , r ) : NEWLINE INDENT if ( arr [ r ] == 1 ) : NEWLINE INDENTINDENT print ( "odd" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "even" ) NEWLINE DEDENT DEDENT arr = [ 1 , 1 , 0 , 1 ] NEWLINE n = len ( arr ) NEWLINE checkEVENodd ( arr , n , 1 , 3 ) NEWLINE NL ENDMARKER
a = int ( input ( ) ) print ( ( 10 < a < 22 ) * 4 + ( a == 20 ) * 11 ) NEWLINE NL ENDMARKER
l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) mi , mm , md = l [ 0 ] , l [ 1 ] , l [ 2 ] print ( abs ( mi - mm ) + abs ( md - mm ) ) NEWLINE NL ENDMARKER
def avg_of_even_num ( n ) : NEWLINE INDENT return n + 1 NEWLINE DEDENT n = 8 NEWLINE print ( avg_of_even_num ( n ) ) NEWLINE NL ENDMARKER
a , b , c = map ( int , input ( ) . split ( ) ) s = ( a + b + c ) // 2 if ( a + b + c ) % 2 or s - a < 0 or s - b < 0 or s - c < 0 : print ( "Impossible" ) else : print ( s - c , s - a , s - b ) NEWLINE NL ENDMARKER
def getTotalXorOfSubarrayXors ( arr , N ) : NEWLINE INDENT if ( N % 2 == 0 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT res = 0 NEWLINE for i in range ( 0 , N , 2 ) : NEWLINE INDENTINDENT res ^= arr [ i ] NEWLINE DEDENT return res NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEWLINE N = len ( arr ) NEWLINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEWLINE NL DEDENT ENDMARKER
def max_xor ( arr , n ) : NEWLINE INDENT maxXor = 0 ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT for j in range ( i + 1 , n ) : NEWLINE INDENTINDENTINDENT maxXor = max ( maxXor , \ arr [ i ] ^ arr [ j ] ) ; NEWLINE DEDENT DEDENT return maxXor ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 25 , 10 , 2 , 8 , 5 , 3 ] ; NEWLINE n = len ( arr ) ; NEWLINE print ( max_xor ( arr , n ) ) ; NEWLINE NL DEDENT ENDMARKER
def harmonicMean ( arr , n ) : NEWLINE INDENT sm = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT sm = sm + ( 1 ) / arr [ i ] ; NEWLINE DEDENT return n / sm NEWLINE DEDENT arr = [ 13.5 , 14.5 , 14.8 , 15.2 , 16.1 ] ; NEWLINE n = len ( arr ) NEWLINE print ( harmonicMean ( arr , n ) ) NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readlinedef f ( x ) : z = m - n if ( x > k ) : NEWLINE NL ENDMARKER
def _sum ( arr , n ) : NEWLINE INDENT return ( sum ( arr ) ) NEWLINE DEDENT arr = [ ] NEWLINE arr = [ 12 , 3 , 4 , 15 ] NEWLINE n = len ( arr ) NEWLINE ans = _sum ( arr , n ) NEWLINE print ( 'Sum of the array is ' , ans ) NEWLINE NL ENDMARKER
import sys  def main ( ) : inp = sys . stdin . read ( ) . strip ( ) . split ( '\n' ) out = [ ] for s in inp [ 1 : ] : s , a , b , c = map ( int , s . split ( ) ) out . append ( s // c + s // c // a * b ) return out print ( * main ( ) , sep = '\n' ) NEWLINE NL ENDMARKER
for s in [ * open ( 0 ) ] [ 1 : ] : n = int ( s . split ( ) [ 0 ] ) ; print ( ( 'abc' * n ) [ : n ] ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) dp = [ 0 ] * 101 dp [ 1 ] = 1 dp [ 2 ] = 2 for i in range ( 3 , 101 ) : dp [ i ] = dp [ i - 2 ] + iprint ( dp [ n ] ) NEWLINE NL ENDMARKER
import math NEWLINE def MaximumHeight ( a , n ) : NEWLINE INDENT return ( - 1 + int ( math . sqrt ( 1 + ( 8 * n ) ) ) ) // 2 NEWLINE DEDENT arr = [ 40 , 100 , 20 , 30 ] NEWLINE n = len ( arr ) NEWLINE print ( MaximumHeight ( arr , n ) ) NEWLINE NL ENDMARKER
def bin ( n ) : NEWLINE INDENT if n > 1 : NEWLINE INDENTINDENT bin ( n // 2 ) NEWLINE DEDENT print ( n % 2 , end = "" ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT bin ( 7 ) NEWLINE print ( ) NEWLINE bin ( 4 ) NEWLINE NL DEDENT ENDMARKER
def Arrive ( a , b , n ) : NEWLINE INDENT if ( n >= abs ( a ) + abs ( b ) and ( n - ( abs ( a ) + abs ( b ) ) ) % 2 == 0 ) : NEWLINE INDENTINDENT return True NEWLINE DEDENT return False NEWLINE DEDENT a = 5 NEWLINE b = 5 NEWLINE n = 11 NEWLINE if ( Arrive ( a , b , n ) ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) A = [ int ( a ) for a in input ( ) . split ( ) ] A . sort ( ) last = A [ 0 ] c = 0 aux = 0 for i in range ( n ) : a = A [ i ] if a == last : aux += 1 else : aux = 1 last = A [ i ] c = max ( c , aux ) print ( n - c ) NEWLINE NL ENDMARKER
def avg_of_even_num ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT sum = sum + 2 * i NEWLINE DEDENT return sum / n NEWLINE DEDENT n = 9 NEWLINE print ( avg_of_even_num ( n ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n , m = [ int ( x ) for x in input ( ) . split ( ) ] arr = set ( [ int ( x ) for x in input ( ) . split ( ) ] ) brr = set ( [ int ( x ) for x in input ( ) . split ( ) ] ) x = arr . intersection ( brr ) if ( len ( x ) == 0 ) : print ( "NO" ) else : print ( "YES\n{} {}" . format ( 1 , list ( x ) [ 0 ] ) ) NEWLINE NL ENDMARKER
def findRemainder ( n ) : NEWLINE INDENT x = n & 3 NEWLINE return x NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 43 NEWLINE ans = findRemainder ( N ) NEWLINE print ( ans ) NEWLINE NL DEDENT ENDMARKER
a , b , c = map ( int , input ( ) . split ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) )  ans = arr [ - b ] - arr [ c - 1 ]  print ( ans ) NEWLINE NL ENDMARKER
def findNthNum ( N ) : NEWLINE INDENT bit_L = 1 ; NEWLINE last_num = 0 ; NEWLINE while ( bit_L * ( bit_L + 1 ) / 2 < N ) : NEWLINE INDENTINDENT last_num = last_num + bit_L ; NEWLINE bit_L += 1 ; NEWLINE DEDENT bit_R = N - last_num - 1 ; NEWLINE print ( ( 1 << bit_L ) + ( 1 << bit_R ) ) ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 13 ; NEWLINE findNthNum ( N ) ; NEWLINE NL DEDENT ENDMARKER
from math import * NEWLINE def area ( a ) : NEWLINE INDENT if a < 0 : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT area = sqrt ( a ) / 6 NEWLINE return area NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = 10 NEWLINE print ( round ( area ( a ) , 6 ) ) NEWLINE NL DEDENT ENDMARKER
s = input ( ) c = len ( s ) for i in range ( len ( s ) - 1 , 0 , - 1 ) : k = s [ 0 : i + 1 ] if ( k != k [ : : - 1 ] ) : print ( c ) exit ( ) c -= 1 if ( c == 1 ) : print ( "0" ) NEWLINE NL ENDMARKER
letters = list ( map ( str , input ( ) ) ) c = set ( ) for letter in letters : if letter . isalpha ( ) : c . add ( letter ) print ( len ( c ) ) NEWLINE NL ENDMARKER
import math NEWLINE def Print ( n , k ) : NEWLINE INDENT rem = 1 NEWLINE for i in range ( 0 , k ) : NEWLINE INDENTINDENT print ( math . floor ( ( ( 10 * rem ) / n ) ) , end = "" ) NEWLINE rem = ( 10 * rem ) % n NEWLINE DEDENT DEDENT n = 7 NEWLINE k = 3 NEWLINE Print ( n , k ) ; NEWLINE print ( " " ) NEWLINE n = 21 NEWLINE k = 4 NEWLINE Print ( n , k ) ; NEWLINE NL ENDMARKER
from math import acos NEWLINE def printValueOfPi ( N ) : NEWLINE INDENT pi = round ( 2 * acos ( 0.0 ) , N ) ; NEWLINE print ( pi ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 4 ; NEWLINE printValueOfPi ( N ) ; NEWLINE NL DEDENT ENDMARKER
import math NEWLINE def countUnsetBits ( n ) : NEWLINE INDENT x = n NEWLINE n |= n >> 1 NEWLINE n |= n >> 2 NEWLINE n |= n >> 4 NEWLINE n |= n >> 8 NEWLINE n |= n >> 16 NEWLINE t = math . log ( x ^ n , 2 ) NEWLINE return math . floor ( t ) NEWLINE DEDENT n = 17 NEWLINE print ( countUnsetBits ( n ) ) NEWLINE NL ENDMARKER
def findExtra ( arr1 , arr2 , n ) : NEWLINE INDENT for i in range ( 0 , n ) : NEWLINE INDENTINDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEWLINE INDENTINDENTINDENT return i NEWLINE DEDENT DEDENT return n NEWLINE DEDENT arr1 = [ 2 , 4 , 6 , 8 , 10 , 12 , 13 ] NEWLINE arr2 = [ 2 , 4 , 6 , 8 , 10 , 12 ] NEWLINE n = len ( arr2 ) NEWLINE print ( findExtra ( arr1 , arr2 , n ) ) NEWLINE NL ENDMARKER
import math NEWLINE def areaCircle ( b ) : NEWLINE INDENT area = math . pi * b * b NEWLINE return area NEWLINE DEDENT a = 10 NEWLINE b = 8 NEWLINE print ( areaCircle ( b ) ) NEWLINE NL ENDMARKER
from collections import Counter  n , m , k = input ( ) . split ( )  k , c = int ( k . split ( '.' ) [ 1 ] ) , Counter ( )  for i in range ( int ( n ) ) :  s , e = input ( ) . split ( )  e = int ( e ) * k // 100  if e >= 100 :  c [ s ] = e  for i in range ( int ( m ) ) :  c [ input ( ) ] += 0  print ( len ( c ) )  print ( '\n' . join ( sorted ( x + ' ' + str ( c [ x ] ) for x in c ) ) ) NEWLINE NL ENDMARKER
n = 4562 ; NEWLINE rev = 0 NEWLINE while ( n > 0 ) : NEWLINE INDENT a = n % 10 NEWLINE rev = rev * 10 + a NEWLINE n = n // 10 NEWLINE DEDENT print ( rev ) NEWLINE NL ENDMARKER
def repUnitValue ( n ) : NEWLINE INDENT if ( n % 2 == 0 or n % 5 == 0 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT rem = 1 NEWLINE power = 1 NEWLINE k = 1 NEWLINE while ( rem % n != 0 ) : NEWLINE INDENTINDENT k += 1 NEWLINE power = power * 10 % n NEWLINE rem = ( rem + power ) % n NEWLINE DEDENT return k NEWLINE DEDENT n = 13 NEWLINE print ( repUnitValue ( n ) ) NEWLINE NL ENDMARKER
def factorial ( n ) : NEWLINE INDENT res = 1 NEWLINE for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT res *= i NEWLINE DEDENT return res NEWLINE DEDENT num = 5 ; NEWLINE print ( "Factorial of" , num , "is" , factorial ( num ) ) NEWLINE NL ENDMARKER
s = input ( ) n = len ( set ( list ( s ) ) )  if ( n % 2 == 0 ) : print ( "CHAT WITH HER!" ) else : print ( "IGNORE HIM!" ) NEWLINE NL ENDMARKER
def count ( S , m , n ) : NEWLINE INDENT table = [ 0 for k in range ( n + 1 ) ] NEWLINE table [ 0 ] = 1 NEWLINE for i in range ( 0 , m ) : NEWLINE INDENTINDENT for j in range ( S [ i ] , n + 1 ) : NEWLINE INDENTINDENTINDENT table [ j ] += table [ j - S [ i ] ] NEWLINE DEDENT DEDENT return table [ n ] NEWLINE DEDENT arr = [ 1 , 2 , 3 ] NEWLINE m = len ( arr ) NEWLINE n = 4 NEWLINE x = count ( arr , m , n ) NEWLINE print ( x ) NEWLINE NL ENDMARKER
import math NEWLINE def onesComplement ( n ) : NEWLINE INDENT number_of_bits = ( int ) ( math . floor ( math . log ( n ) / math . log ( 2 ) ) ) + 1 ; NEWLINE return ( ( 1 << number_of_bits ) - 1 ) ^ n ; NEWLINE DEDENT n = 22 NEWLINE print ( onesComplement ( n ) ) NEWLINE NL ENDMARKER
def maxSum ( arr , n ) : NEWLINE INDENT if ( n < 2 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT ans = arr [ 0 ] + arr [ 1 ] NEWLINE for i in range ( 1 , n - 1 , 1 ) : NEWLINE INDENTINDENT ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) NEWLINE DEDENT return ans NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 1 , 12 , 2 , 2 ] NEWLINE n = len ( arr ) NEWLINE print ( maxSum ( arr , n ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) P = 0  for i in range ( n - 1 ) : P += ( n - i - 1 ) * ( i + 1 )   print ( P + n ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) while n > 0 : n = n - 1 a , b = map ( int , input ( ) . split ( ) ) print ( b * 2 )   NEWLINE NL ENDMARKER
def factorial ( f ) : NEWLINE INDENT fact = 1 NEWLINE for i in range ( 2 , f + 1 ) : NEWLINE INDENTINDENT fact *= i NEWLINE DEDENT return fact NEWLINE DEDENT def findPermuatation ( N , M ) : NEWLINE INDENT permutation = ( factorial ( N + M - 1 ) // ( factorial ( N ) * factorial ( M - 1 ) ) ) NEWLINE return permutation NEWLINE DEDENT N = 3 ; M = 3 NEWLINE print ( findPermuatation ( N , M ) ) NEWLINE NL ENDMARKER
def countDigit ( n ) : NEWLINE INDENT temp = n NEWLINE count = 0 NEWLINE while temp != 0 : NEWLINE INDENTINDENT d = temp % 10 NEWLINE temp /= 10 NEWLINE if d > 0 and n % d == 0 : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT return count NEWLINE DEDENT n = 1012 NEWLINE print ( countDigit ( n ) ) NEWLINE NL ENDMARKER
x , y = map ( int , input ( ) . split ( ) ) x = x ** 2 y = y ** 2 ans = ( x // 4 ) * ( y // 4 )  print ( ans ) NEWLINE NL ENDMARKER
def seriesFunc ( n ) : NEWLINE INDENT sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEWLINE sumNatural = ( n * ( n + 1 ) / 2 ) NEWLINE return ( sumSquare + sumNatural + 1 ) NEWLINE DEDENT n = 8 NEWLINE print ( int ( seriesFunc ( n ) ) ) NEWLINE n = 13 NEWLINE print ( int ( seriesFunc ( n ) ) ) NEWLINE NL ENDMARKER
n = ( input ( ) ) a = b = 0 a = n . count ( '4' ) b = n . count ( '7' ) if a == 0 and b == 0 : print ( - 1 ) elif a == b : print ( 4 ) elif a == 0 and b == 0 : print ( - 1 ) else : if a > b : print ( 4 ) else : print ( 7 ) NEWLINE NL ENDMARKER
c = 0 n , a = map ( int , input ( ) . split ( ) ) p = nwhile ( n >= a ) : b = n % a n = n // a c = c + n n = n + bprint ( p + c ) NEWLINE NL ENDMARKER
m = 0 n = int ( input ( ) ) for _ in range ( n ) : m = max ( m , sum ( map ( int , input ( ) . split ( ) ) ) ) print ( m ) NEWLINE NL ENDMARKER
n = int ( input ( '' ) ) x = list ( map ( int , input ( ) . split ( ) ) ) if ( x == sorted ( x ) ) : print ( '0' ) else : for i in range ( 0 , len ( x ) ) : if ( x [ i ] > x [ i + 1 ] ) : c = i break b = x [ c + 1 : ] c = b + x [ : c + 1 ] if ( c == sorted ( x ) ) : print ( len ( b ) ) else : print ( '-1' ) NEWLINE NL ENDMARKER
size_of_table = int ( input ( ) ) mat = [ [ 1 for x in range ( size_of_table ) ] for y in range ( size_of_table ) ] for i in range ( 1 , size_of_table ) : for j in range ( 1 , size_of_table ) : mat [ i ] [ j ] = mat [ i - 1 ] [ j ] + mat [ i ] [ j - 1 ] print ( mat [ size_of_table - 1 ] [ size_of_table - 1 ] ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) mx = n // 7 * 2 + min ( n % 7 , 2 ) mn = n // 7 * 2 + max ( n % 7 - 5 , 0 )  print ( mn , mx )   NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] first = Falseans , cur = 1 , 0 for e in a : if first : if not e : cur += 1 else : ans *= cur + 1 cur = 0 elif e : first = Trueif ans == 1 and not first : ans = 0 print ( ans ) NEWLINE NL ENDMARKER
l = [ ] NEWLINE n = int ( input ( "" ) ) NEWLINE for i in range ( n ) : x = input ( "" ) NEWLINE l . append ( x ) NEWLINE for i in l : if NEWLINE len ( i ) <= 10 : print ( i ) else : s = "" NEWLINE s = s + i [ 0 ] NEWLINE s = s + str ( len ( i ) - 2 ) NEWLINE s = s + i [ len ( i ) - 1 ] NEWLINE print ( s ) NEWLINE NL ENDMARKER
import math NEWLINE def checkcircle ( r , R , r1 , x1 , y1 ) : NEWLINE INDENT dis = int ( math . sqrt ( x1 * x1 + y1 * y1 ) ) NEWLINE return ( dis - r1 >= R and dis + r1 <= r ) NEWLINE DEDENT r = 8 ; R = 4 ; r1 = 2 ; x1 = 6 ; y1 = 0 NEWLINE if ( checkcircle ( r , R , r1 , x1 , y1 ) ) : NEWLINE INDENT print ( "yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "no" ) NEWLINE NL DEDENT ENDMARKER
a = [ * open ( 0 ) ] [ 1 ] . count ; print ( a ( '4' ) + a ( '3' ) + ( a ( '2' ) * 2 + max ( 0 , a ( '1' ) - a ( '3' ) ) + 3 ) // 4 ) NEWLINE NL ENDMARKER
def pairwiseProduct ( arr , n ) : NEWLINE INDENT prod = 1 NEWLINE for i in range ( n - 1 ) : NEWLINE INDENTINDENT prod = arr [ i ] * arr [ i + 1 ] NEWLINE print ( prod , end = " " ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 4 , 10 , 15 , 5 , 6 ] NEWLINE n = len ( arr ) NEWLINE pairwiseProduct ( arr , n ) NEWLINE NL DEDENT ENDMARKER
from math import gcd NEWLINE def findNumbers ( a , b ) : NEWLINE INDENT __gcd = gcd ( a , b ) ; NEWLINE print ( ( a // __gcd ) , ( b // __gcd ) ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = 12 ; b = 16 ; NEWLINE findNumbers ( a , b ) ; NEWLINE NL DEDENT ENDMARKER
for s in [ * open ( 0 ) ] [ 1 : ] : n , t , = [ * map ( int , s . split ( ) ) ] ; t -= 1 ; print ( ( t + ( n & 1 ) * t // ( n // 2 ) ) % n + 1 ) NEWLINE NL ENDMARKER
a , b , m , r = map ( int , input ( ) . split ( ) ) d = { } i = 1 while 1 : r = ( a * r + b ) % m ; t = d . get ( r , 0 ) if t : i -= t ; break d [ r ] = i ; i += 1 print ( ) print ( i ) NEWLINE NL ENDMARKER
from math import * NEWLINE def numberOfSolutions ( n ) : NEWLINE INDENT c = 0 NEWLINE while ( n ) : NEWLINE INDENTINDENT c += n % 2 NEWLINE n //= 2 NEWLINE DEDENT return int ( pow ( 2 , c ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 3 NEWLINE print ( numberOfSolutions ( n ) ) NEWLINE NL DEDENT ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) arr = sorted ( list ( zip ( range ( n ) , ( map ( int , input ( ) . split ( ) ) ) ) ) , key = lambda x : x [ 1 ] ) ans = [ ] i = 0 while k - arr [ i ] [ 1 ] >= 0 : k -= arr [ i ] [ 1 ] ans . append ( arr [ i ] [ 0 ] + 1 ) i += 1 if i == n : breakprint ( len ( ans ) ) print ( * ans ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) X = list ( map ( int , input ( ) . split ( ) ) ) Y = list ( map ( int , input ( ) . split ( ) ) ) a = 0 b = 0 for i in range ( n ) : a += X [ i ] > Y [ i ] b += X [ i ] < Y [ i ] if a == 0 : print ( - 1 ) else : print ( b // a + 1 ) NEWLINE NL ENDMARKER
from collections import dequeif __name__ == '__main__' : n , q = map ( int , input ( ) . split ( ' ' ) ) arr = list ( map ( int , input ( ) . split ( ' ' ) ) ) dq = deque ( arr ) m = max ( arr ) lst = [ ] while dq [ 0 ] != m : a = dq . popleft ( ) b = dq . popleft ( ) lst . append ( [ a , b ] ) dq . append ( min ( a , b ) ) dq . appendleft ( max ( a , b ) ) NEWLINE NL ENDMARKER
n , k , l , c , d , p , nl , np = map ( int , input ( ) . split ( ) ) NEWLINE NL ENDMARKER
def trianglearea ( r ) : NEWLINE INDENT if r < 0 : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT return r * r NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT r = 5 NEWLINE print ( trianglearea ( r ) ) NEWLINE NL DEDENT ENDMARKER
def factorial ( n ) : NEWLINE INDENT res = 1 NEWLINE for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT res = res * i NEWLINE DEDENT return res NEWLINE DEDENT def calculateSeries ( n ) : NEWLINE INDENT return factorial ( n + 1 ) - 1 NEWLINE DEDENT n = 3 NEWLINE print ( calculateSeries ( n ) ) NEWLINE NL ENDMARKER
l , r , k = map ( int , input ( ) . split ( ) ) p = 1 while p < l : p = p * klis = [ ] while p >= l and p <= r : lis . append ( p ) p = p * kif not lis : print ( - 1 ) else : for i in lis : print ( i , end = ' ' ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for i in range ( t ) : x , y = map ( int , input ( ) . split ( ) ) if ( x - y > 1 ) : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
import sysimport mathfrom collections import defaultdict , Counter , deque  NEWLINE NL ENDMARKER
n = 4562 ; NEWLINE rev = 0 NEWLINE while ( n > 0 ) : NEWLINE INDENT a = n % 10 NEWLINE rev = rev * 10 + a NEWLINE n = n // 10 NEWLINE DEDENT print ( rev ) NEWLINE NL ENDMARKER
n , t = map ( int , input ( ) . split ( ) ) print ( n * ( 1.000000011 ** t ) ) NEWLINE NL ENDMARKER
import mathc = input ( ) . split ( ) x1 , y1 = int ( c [ 0 ] ) , int ( c [ 1 ] ) n = int ( input ( ) ) d = [ ] for i in range ( n ) : c = [ int ( i ) for i in input ( ) . split ( ) ] distance = math . sqrt ( ( c [ 0 ] - x1 ) ** 2 + ( c [ 1 ] - y1 ) ** 2 ) / c [ 2 ] d . append ( distance ) print ( min ( d ) ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) a = { input ( ) for x in range ( n ) } b = { input ( ) for y in range ( m ) } t = n + m - len ( a | b ) print ( 'YES' if n + t % 2 > m else 'NO' )  NEWLINE NL ENDMARKER
from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect  NEWLINE NL ENDMARKER
try : n = int ( input ( ) ) if ( n % 10 < 6 ) : print ( n - n % 10 ) else : print ( n + ( 10 - n % 10 ) ) except : pass NEWLINE NL ENDMARKER
h = int ( input ( ) . split ( ) [ 1 ] ) h_s = input ( ) . split ( ) print ( sum ( [ ( int ( int ( i ) > h ) + 1 ) for i in h_s ] ) ) NEWLINE NL ENDMARKER
def find_number ( N , K ) : NEWLINE INDENT r = "" NEWLINE if ( N % 100 == 0 ) : NEWLINE INDENTINDENT N += 1 ; NEWLINE r = str ( N ) NEWLINE DEDENT else : NEWLINE INDENTINDENT r = str ( N ) NEWLINE DEDENT for i in range ( 1 , K + 1 ) : NEWLINE INDENTINDENT r += "00" NEWLINE DEDENT return r NEWLINE DEDENT N = 1000 NEWLINE K = 2 ; NEWLINE ans = find_number ( N , K ) NEWLINE print ( ans ) NEWLINE NL ENDMARKER
import math NEWLINE PI = 3.14159 / 180 ; NEWLINE def areaOfKite ( a , b , angle ) : NEWLINE INDENT angle = angle * PI ; NEWLINE area = a * b * math . sin ( angle ) ; NEWLINE return area ; NEWLINE DEDENT a = 4 ; b = 7 ; angle = 78 ; NEWLINE print ( "Area of Kite = " , areaOfKite ( a , b , angle ) ) ; NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) count = 0 a = 0 while a ** 2 <= n : b = n - a ** 2 if b >= 0 and a + b ** 2 == m : count += 1 a += 1 print ( count ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) s = input ( ) ind1 = - 1 ind2 = - 1 g = l = 0 for i in range ( n ) : if s [ i ] == '>' : if ind1 == - 1 : ind1 = i + 1 g += 1 else : ind2 = i l += 1 if ind1 == - 1 : ind1 = n if ind2 == - 1 : ind2 = n ans = min ( s [ : ind1 ] . count ( '<' ) , s [ ind2 : ] . count ( '>' ) , g , l ) print ( ans ) NEWLINE NL ENDMARKER
import sys  def main ( ) : n , * s = sys . stdin . read ( ) . strip ( ) . split ( '\n' ) c , t = 0 , [ ( - 1 , 1 ) , ( - 1 , - 1 ) , ( 1 , 1 ) , ( 1 , - 1 ) , ( 0 , 0 ) ] for i in range ( 1 , int ( n ) - 1 ) : for j in range ( 1 , int ( n ) - 1 ) : c += all ( s [ i + m ] [ j + n ] == 'X' for m , n in t ) return c print ( main ( ) ) NEWLINE NL ENDMARKER
def findevenPair ( A , N ) : NEWLINE INDENT evenPair = 0 NEWLINE for i in range ( 0 , N ) : NEWLINE INDENTINDENT for j in range ( i + 1 , N ) : NEWLINE INDENTINDENTINDENT if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) : NEWLINE INDENTINDENTINDENTINDENT evenPair += 1 NEWLINE DEDENT DEDENT DEDENT return evenPair NEWLINE DEDENT a = [ 5 , 1 , 3 , 2 ] NEWLINE n = len ( a ) NEWLINE print ( findevenPair ( a , n ) ) NEWLINE NL ENDMARKER
import string  a , b = map ( int , input ( ) . split ( ) ) s = input ( )  f = Truefor i in string . ascii_lowercase : if s . count ( i ) > b : f = False break   if f : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
def totalNumber ( n ) : NEWLINE INDENT return 8 * pow ( 9 , n - 1 ) ; NEWLINE DEDENT n = 3 NEWLINE print ( totalNumber ( n ) ) NEWLINE NL ENDMARKER
def numberOfTriangles ( n ) : NEWLINE INDENT answer = [ None ] * ( n + 1 ) ; NEWLINE answer [ 0 ] = 1 ; NEWLINE i = 1 NEWLINE while i <= n : NEWLINE INDENTINDENT answer [ i ] = answer [ i - 1 ] * 3 + 2 ; NEWLINE i = i + 1 NEWLINE DEDENT return answer [ n ] ; NEWLINE DEDENT n = 2 NEWLINE print ( numberOfTriangles ( n ) ) NEWLINE NL ENDMARKER
a , b , d = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )  ans = 0 bin = 0 for n in arr : if n <= b : bin += n if bin > d : ans += 1 bin = 0  print ( ans ) NEWLINE NL ENDMARKER
import math NEWLINE def answer ( n ) : NEWLINE INDENT m = 2 ; NEWLINE ans = 1 ; NEWLINE r = 1 ; NEWLINE while r < n : NEWLINE INDENTINDENT r = ( int ) ( ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ) ; NEWLINE if r < n : NEWLINE INDENTINDENTINDENT ans = r ; NEWLINE DEDENT m = m + 1 ; NEWLINE DEDENT return ans ; NEWLINE DEDENT print ( answer ( 7 ) ) ; NEWLINE NL ENDMARKER
def maxPartitions ( arr , n ) : NEWLINE INDENT ans = 0 ; max_so_far = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT max_so_far = max ( max_so_far , arr [ i ] ) NEWLINE if ( max_so_far == i ) : NEWLINE INDENTINDENTINDENT ans += 1 NEWLINE DEDENT DEDENT return ans NEWLINE DEDENT arr = [ 1 , 0 , 2 , 3 , 4 ] NEWLINE n = len ( arr ) NEWLINE print ( maxPartitions ( arr , n ) ) NEWLINE NL ENDMARKER
def count ( n , x ) : NEWLINE INDENT cnt = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT if i <= x : NEWLINE INDENTINDENTINDENT if x // i <= n and x % i == 0 : NEWLINE INDENTINDENTINDENTINDENT cnt += 1 NEWLINE DEDENT DEDENT DEDENT return cnt NEWLINE DEDENT n = 8 NEWLINE x = 24 NEWLINE print ( count ( n , x ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( n % 2 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) now = 0 for i in range ( n ) : s , d = map ( int , input ( ) . split ( ) ) now = max ( now + 1 , s ) now = ( now + d - 1 - s ) // d * d + sprint ( now ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = [ ] r = [ ] for i in range ( n ) : s , e = map ( int , input ( ) . split ( ) ) l . append ( s ) r . append ( e ) mn = l [ 0 ] mx = r [ 0 ]  for i in range ( n ) : if ( l [ i ] < mn ) : mn = l [ i ] if r [ i ] > mx : mx = r [ i ] flag = 1 p = 0 for i in range ( n ) : if l [ i ] <= mn and r [ i ] >= mx : p = i + 1 flag = 0 if flag == 0 : print ( p ) else : print ( - 1 ) NEWLINE NL ENDMARKER
def squareSum ( n ) : NEWLINE INDENT return int ( 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ) NEWLINE DEDENT ans = squareSum ( 8 ) NEWLINE print ( ans ) NEWLINE NL ENDMARKER
from collections import defaultdict  for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE b = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE d = defaultdict ( int ) NEWLINE for x in b : d [ x ] += 1 NEWLINE ok = False NEWLINE for v in d . values ( ) : if NEWLINE v > 1 : ok = True NEWLINE break NEWLINE print ( "YES" if ok else "NO" ) NEWLINE NL ENDMARKER
from math import pi NEWLINE def circle_inscribed ( a ) : NEWLINE INDENT return pi * ( a * a ) / 12 NEWLINE DEDENT a = 4 NEWLINE print ( circle_inscribed ( a ) ) NEWLINE NL ENDMARKER
print ( * ( [ 'I hate' , 'I love' ] * 50 ) [ : int ( input ( ) ) ] , sep = ' that ' , end = ' it' ) NEWLINE NL ENDMARKER
cases = int ( input ( ) ) NEWLINE while cases : cases -= 1 NEWLINE num = int ( input ( ) ) NEWLINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE summ = sum ( arr ) NEWLINE if summ == 0 : NEWLINE INDENT print ( "NO" ) elif summ < 0 : NEWLINE ans = sorted ( arr ) NEWLINE DEDENT print ( "YES" ) NEWLINE print ( * ans ) else : ans = sorted ( arr , reverse = True ) NEWLINE print ( "YES" ) NEWLINE print ( * ans ) NEWLINE NL ENDMARKER
def perfectCube ( N ) : NEWLINE INDENT cube = 0 ; NEWLINE for i in range ( N + 1 ) : NEWLINE INDENTINDENT cube = i * i * i ; NEWLINE if ( cube == N ) : NEWLINE INDENTINDENTINDENT print ( "Yes" ) ; NEWLINE return ; NEWLINE DEDENT elif ( cube > N ) : NEWLINE INDENTINDENTINDENT print ( "NO" ) ; NEWLINE return ; NEWLINE DEDENT DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 216 ; NEWLINE perfectCube ( N ) ; NEWLINE NL DEDENT ENDMARKER
def lagDuration ( h1 , m1 , h2 , m2 , k ) : NEWLINE INDENT lag , t1 , t2 = 0 , 0 , 0 NEWLINE t1 = ( h1 + k ) * 60 + m1 NEWLINE t2 = h2 * 60 + m2 NEWLINE lag = t1 - t2 NEWLINE return lag NEWLINE DEDENT h1 , m1 = 12 , 0 NEWLINE h2 , m2 = 12 , 58 NEWLINE k = 1 NEWLINE lag = lagDuration ( h1 , m1 , h2 , m2 , k ) NEWLINE print ( "Lag =" , lag , "minutes" ) NEWLINE NL ENDMARKER
def findpair ( l , r ) : NEWLINE INDENT ans1 = l NEWLINE ans2 = 2 * l NEWLINE print ( ans1 , ", " , ans2 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT l , r = 1 , 10 NEWLINE findpair ( l , r ) NEWLINE NL DEDENT ENDMARKER
t = int ( input ( ) ) for i in range ( t ) : a = int ( input ( ) ) if a % 4 == 0 : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readlinea , g = 0 , 0 for _ in range ( int ( input ( ) ) ) : r = input ( ) . split ( ) r [ 0 ] = int ( r [ 0 ] ) r [ 1 ] = int ( r [ 1 ] ) if abs ( a + r [ 0 ] - g ) <= 500 : a += r [ 0 ] sys . stdout . write ( "A" ) else : g += r [ 1 ] sys . stdout . write ( "G" ) NEWLINE NL ENDMARKER
if __name__ == '__main__' : n = int ( input ( ) ) arr = [ [ 0 , 0 ] ] for i in range ( n ) : arr . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEWLINE NL ENDMARKER
def Subtract ( a , b ) : NEWLINE INDENT c = a + ( ~ b + 1 ) NEWLINE return c NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a , b = 2 , 3 NEWLINE print ( Subtract ( a , b ) ) NEWLINE a , b = 9 , 7 NEWLINE print ( Subtract ( a , b ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) first = list ( input ( ) . strip ( ) . split ( ) ) second = list ( input ( ) . strip ( ) . split ( ) ) toDict = dict ( zip ( second , range ( n ) ) ) bef , aft = 0 , 0 for item in first : if toDict . get ( item ) >= aft : aft = toDict . get ( item ) continue bef += 1  print ( bef ) NEWLINE NL ENDMARKER
cs = int ( input ( ) ) while cs : cs -= 1 cx = int ( input ( ) ) for iv in range ( 2 , 36 ) : one = 2 ** iv - 1 if cx % one == 0 : rt = cx // one break print ( rt ) NEWLINE NL ENDMARKER
def printPattern ( n ) : NEWLINE INDENT for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT for j in range ( i , n ) : NEWLINE INDENTINDENTINDENT print ( "\t" , end = "" ) NEWLINE DEDENT t = i NEWLINE for k in range ( 1 , i + 1 ) : NEWLINE INDENTINDENTINDENT print ( t , "\t" , "\t" , end = "" ) NEWLINE t = t + n - k NEWLINE DEDENT print ( ) NEWLINE DEDENT DEDENT n = 6 NEWLINE printPattern ( n ) NEWLINE NL ENDMARKER
from sys import stdin , stdoutinput = stdin . readline def main ( ) : t = int ( input ( ) ) for i in range ( t ) : NEWLINE NL ENDMARKER
def countMaxIntersect ( n ) : NEWLINE INDENT return int ( n * ( n - 1 ) / 2 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 8 NEWLINE print ( countMaxIntersect ( n ) ) NEWLINE NL DEDENT ENDMARKER
def findTriangles ( n ) : NEWLINE INDENT num = n * ( n - 4 ) NEWLINE print ( num ) NEWLINE DEDENT n = 6 NEWLINE findTriangles ( n ) NEWLINE NL ENDMARKER
def __gcd ( a , b ) : NEWLINE INDENT return a if ( b == 0 ) else __gcd ( b , a % b ) NEWLINE DEDENT def digitGCD ( n ) : NEWLINE INDENT gcd = 0 NEWLINE while ( n > 0 ) : NEWLINE INDENTINDENT gcd = __gcd ( n % 10 , gcd ) NEWLINE if ( gcd == 1 ) : NEWLINE INDENTINDENTINDENT return 1 NEWLINE DEDENT n = n // 10 NEWLINE DEDENT return gcd NEWLINE DEDENT n = 2448 NEWLINE print ( digitGCD ( n ) ) NEWLINE NL ENDMARKER
def leonardo ( n ) : NEWLINE INDENT dp = [ ] ; NEWLINE dp . append ( 1 ) ; NEWLINE dp . append ( 1 ) ; NEWLINE for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT dp . append ( dp [ i - 1 ] + dp [ i - 2 ] + 1 ) ; NEWLINE DEDENT return dp [ n ] ; NEWLINE DEDENT print ( leonardo ( 3 ) ) ; NEWLINE NL ENDMARKER
def vowelOrConsonant ( x ) : NEWLINE INDENT if ( x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u' ) : NEWLINE INDENTINDENT print ( "Vowel" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "Consonant" ) NEWLINE DEDENT DEDENT vowelOrConsonant ( 'c' ) NEWLINE vowelOrConsonant ( 'e' ) NEWLINE NL ENDMARKER
s = input ( ) p = s . split ( ) a = int ( p [ 0 ] ) b = int ( p [ 1 ] ) c = int ( p [ 2 ] ) f = input ( ) ans = [ ] notes = [ int ( i ) for i in input ( ) . split ( ) ] for i in notes : i = int ( i ) if i > b and i < c : ans . append ( i ) print ( len ( ans ) ) NEWLINE NL ENDMARKER
import sys , functools , collections , bisect , math , heapqinput = sys . stdin . readline NEWLINE NL ENDMARKER
s = input ( ) n = len ( s ) maxi = - 1 for i in range ( n - 2 ) : for j in range ( i + 1 , n - 1 ) : a , b , c = s [ : i + 1 ] , s [ i + 1 : j + 1 ] , s [ j + 1 : ] if len ( a ) == len ( str ( int ( a ) ) ) and len ( b ) == len ( str ( int ( b ) ) ) and len ( c ) == len ( str ( int ( c ) ) ) : if int ( a ) <= 1e6 and int ( b ) <= 1e6 and int ( c ) <= 1e6 : maxi = max ( maxi , int ( a ) + int ( b ) + int ( c ) ) print ( maxi ) NEWLINE NL ENDMARKER
l = int ( input ( ) ) p = int ( input ( ) ) q = int ( input ( ) ) c = p / ( p + q ) print ( c * l ) NEWLINE NL ENDMARKER
def rev ( n , temp ) : NEWLINE INDENT if ( n == 0 ) : NEWLINE INDENTINDENT return temp ; NEWLINE DEDENT temp = ( temp * 10 ) + ( n % 10 ) ; NEWLINE return rev ( n / 10 , temp ) ; NEWLINE DEDENT n = 121 ; NEWLINE temp = rev ( n , 0 ) ; NEWLINE if ( temp != n ) : NEWLINE INDENT print ( "yes" ) ; NEWLINE DEDENT else : NEWLINE INDENT print ( "no" ) ; NEWLINE NL DEDENT ENDMARKER
a = int ( input ( "" ) ) if a % 5 == 0 : print ( a // 5 ) else : print ( a // 5 + 1 ) NEWLINE NL ENDMARKER
def smallestOdd ( n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT return pow ( 10 , n - 1 ) + 1 NEWLINE DEDENT n = 4 NEWLINE print ( smallestOdd ( n ) ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for q in range ( t ) : n = int ( input ( ) ) s = input ( ) c = 0 while "AP" in s : s = s . replace ( "AP" , "AA" ) c += 1 print ( c ) NEWLINE NL ENDMARKER
import sys NEWLINE NL ENDMARKER
import math NEWLINE def vol_of_dodecahedron ( side ) : NEWLINE INDENT return ( ( ( 15 + ( 7 * ( math . sqrt ( 5 ) ) ) ) / 4 ) * ( math . pow ( side , 3 ) ) ) NEWLINE DEDENT side = 4 NEWLINE print ( "Volume of dodecahedron =" , round ( vol_of_dodecahedron ( side ) , 2 ) ) NEWLINE NL ENDMARKER
n , m , k = map ( int , input ( ) . split ( ) )  total = n * m * 2   per_lane = m * 2  lane = ( k + per_lane - 1 ) // per_lane  new_k = k % per_laneif new_k == 0 : new_k = per_lane  side = Noneif new_k % 2 == 0 : side = "R" row = new_k // 2 else : side = "L" row = new_k // 2 + 1  print ( lane , row , side )  NEWLINE NL ENDMARKER
def triplets ( N ) : NEWLINE INDENT return ( ( N + 1 ) * ( N + 2 ) ) // 2 ; NEWLINE DEDENT N = 50 ; NEWLINE print ( triplets ( N ) ) NEWLINE NL ENDMARKER
def factorial ( n ) : NEWLINE INDENT return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) ; NEWLINE DEDENT num = 5 ; NEWLINE print ( "Factorial of" , num , "is" , factorial ( num ) ) ; NEWLINE NL ENDMARKER
def area_of_circle ( m , n ) : NEWLINE INDENT square_of_radius = ( m * n ) / 4 NEWLINE area = ( 3.141 * square_of_radius ) NEWLINE return area NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 10 NEWLINE m = 30 NEWLINE print ( area_of_circle ( m , n ) ) NEWLINE NL DEDENT ENDMARKER
def maxSumLCM ( n ) : NEWLINE INDENT max_sum = 0 NEWLINE i = 1 NEWLINE while ( i * i <= n ) : NEWLINE INDENTINDENT if ( n % i == 0 ) : NEWLINE INDENTINDENTINDENT max_sum = max_sum + i NEWLINE if ( n // i != i ) : NEWLINE INDENTINDENTINDENTINDENT max_sum = max_sum + ( n // i ) NEWLINE DEDENT DEDENT i = i + 1 NEWLINE DEDENT return max_sum NEWLINE DEDENT n = 2 NEWLINE print ( maxSumLCM ( n ) ) NEWLINE NL ENDMARKER
s = input ( ) print ( '' + s [ 0 ] . upper ( ) + s [ 1 : ] ) NEWLINE NL ENDMARKER
def catalan ( n ) : NEWLINE INDENT if n <= 1 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT res = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT res += catalan ( i ) * catalan ( n - i - 1 ) NEWLINE DEDENT return res NEWLINE DEDENT for i in range ( 10 ) : NEWLINE INDENT print catalan ( i ) , NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) old_pos = list ( map ( int , input ( ) . split ( ) ) )  NEWLINE NL ENDMARKER
a , b = ( int ( i ) for i in input ( ) . split ( ) ) k = 1 c = awhile a % 10 != 0 and a % 10 != b : k += 1 a = c * kprint ( k ) NEWLINE NL ENDMARKER
N = 3 NEWLINE def minimumflip ( mat , n ) : NEWLINE INDENT flip = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT for j in range ( i ) : NEWLINE INDENTINDENTINDENT if mat [ i ] [ j ] != mat [ j ] [ i ] : NEWLINE INDENTINDENTINDENTINDENT flip += 1 NEWLINE DEDENT DEDENT DEDENT return flip NEWLINE DEDENT n = 3 NEWLINE mat = [ [ 0 , 0 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] ] NEWLINE print ( minimumflip ( mat , n ) ) NEWLINE NL ENDMARKER
def sum ( N ) : NEWLINE INDENT S1 = ( ( N // 2 ) ) * ( 2 * 2 + ( N // 2 - 1 ) * 2 ) // 2 NEWLINE S2 = ( ( N // 7 ) ) * ( 2 * 7 + ( N // 7 - 1 ) * 7 ) // 2 NEWLINE S3 = ( ( N // 14 ) ) * ( 2 * 14 + ( N // 14 - 1 ) * 14 ) // 2 NEWLINE return S1 + S2 - S3 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 20 NEWLINE print ( sum ( N ) ) NEWLINE NL DEDENT ENDMARKER
def midpoint ( x1 , x2 , y1 , y2 ) : NEWLINE INDENT print ( ( x1 + x2 ) // 2 , " , " , ( y1 + y2 ) // 2 ) NEWLINE DEDENT x1 , y1 , x2 , y2 = - 1 , 2 , 3 , - 6 NEWLINE midpoint ( x1 , x2 , y1 , y2 ) NEWLINE NL ENDMARKER
n , m , k = map ( int , input ( ) . split ( ) ) if m >= n and k >= n : print ( 'Yes' ) else : print ( 'No' ) NEWLINE NL ENDMARKER
""" Created by Henrikh Kantuni on 2/7/17 """  a = input ( ) b = input ( ) ans = - 1 if a == b else max ( len ( a ) , len ( b ) ) print ( ans ) NEWLINE NL ENDMARKER
def swap ( xp , yp ) : NEWLINE INDENT if ( xp [ 0 ] == yp [ 0 ] ) : NEWLINE INDENTINDENT return NEWLINE DEDENT xp [ 0 ] = xp [ 0 ] + yp [ 0 ] NEWLINE yp [ 0 ] = xp [ 0 ] - yp [ 0 ] NEWLINE xp [ 0 ] = xp [ 0 ] - yp [ 0 ] NEWLINE DEDENT x = [ 10 ] NEWLINE swap ( x , x ) NEWLINE print ( "After swap(&x, &x): x = " , x [ 0 ] ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( ( ( 3 ** ( 3 * n ) ) - 7 ** n ) % 1000000007 ) NEWLINE NL ENDMARKER
s = input ( ) t = input ( ) print ( s . count ( t ) ) NEWLINE NL ENDMARKER
def solve ( s ) : NEWLINE INDENT area = ( 1.732 * s ** 2 ) / 8 NEWLINE return area NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 14 NEWLINE print ( solve ( n ) ) NEWLINE NL DEDENT ENDMARKER
def getTrailingZeroes ( n ) : NEWLINE INDENT count = 0 NEWLINE val , powerTwo = 1 , 2 NEWLINE while ( val != 0 ) : NEWLINE INDENTINDENT val = n // powerTwo NEWLINE count += val NEWLINE powerTwo *= 2 NEWLINE DEDENT return ( count // 4 ) NEWLINE DEDENT n = 6 NEWLINE print ( getTrailingZeroes ( n ) ) NEWLINE NL ENDMARKER
def countUnmarked ( N ) : NEWLINE INDENT if ( N % 2 == 0 ) : NEWLINE INDENTINDENT return N / 2 ; NEWLINE DEDENT else : NEWLINE INDENTINDENT return N / 2 + 1 ; NEWLINE DEDENT DEDENT N = 4 ; NEWLINE print ( "Number of unmarked elements:" , int ( countUnmarked ( N ) ) ) ; NEWLINE NL ENDMARKER
def isDivisible ( n ) : NEWLINE INDENT while n // 100 : NEWLINE INDENTINDENT d = n % 10 NEWLINE n //= 10 NEWLINE n = abs ( n - ( d * 3 ) ) NEWLINE DEDENT return ( n % 31 == 0 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 1922 NEWLINE if ( isDivisible ( n ) ) : NEWLINE INDENTINDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) NEWLINE NL DEDENT DEDENT ENDMARKER
n = int ( input ( ) ) m = int ( input ( ) )  if n > 30 : print ( m ) else : ans = m % 2 ** n print ( ans ) NEWLINE NL ENDMARKER
n , a , b = map ( int , input ( ) . split ( ) ) str = input ( ) ;  ans = 0 if a < b : c = a a = b b = c  tim = 1 for i in range ( n ) : if str [ i ] == '*' : if a < b : c = a a = b b = c tim = 1 else : if tim % 2 == 1 : if a > 0 : ans += 1 a -= 1 else : if b > 0 : ans += 1 b -= 1  tim += 1  print ( ans ) NEWLINE NL ENDMARKER
def MinimumValue ( x , y ) : NEWLINE INDENT if ( x > y ) : NEWLINE INDENTINDENT x , y = y , x NEWLINE DEDENT a = 1 NEWLINE b = x - 1 NEWLINE c = y - b NEWLINE print ( a , b , c ) NEWLINE DEDENT x = 123 NEWLINE y = 13 NEWLINE MinimumValue ( x , y ) NEWLINE NL ENDMARKER
def findWeights ( X ) : NEWLINE INDENT sum = 0 NEWLINE power = 0 NEWLINE while ( sum < X ) : NEWLINE INDENTINDENT sum = pow ( 3 , power + 1 ) - 1 NEWLINE sum //= 2 NEWLINE power += 1 NEWLINE DEDENT ans = 1 NEWLINE for i in range ( 1 , power + 1 ) : NEWLINE INDENTINDENT print ( ans , end = " " ) NEWLINE ans = ans * 3 NEWLINE DEDENT DEDENT X = 2 NEWLINE findWeights ( X ) NEWLINE NL ENDMARKER
n = list ( input ( ) ) m = - 1 for i , d in enumerate ( n ) : if int ( d ) % 2 == 0 : m = i if int ( d ) < int ( n [ - 1 ] ) : breakif m < 0 : print ( - 1 ) else : n [ - 1 ] , n [ m ] = n [ m ] , n [ - 1 ] print ( '' . join ( n ) ) NEWLINE NL ENDMARKER
def count ( S , m , n ) : NEWLINE INDENT table = [ 0 for k in range ( n + 1 ) ] NEWLINE table [ 0 ] = 1 NEWLINE for i in range ( 0 , m ) : NEWLINE INDENTINDENT for j in range ( S [ i ] , n + 1 ) : NEWLINE INDENTINDENTINDENT table [ j ] += table [ j - S [ i ] ] NEWLINE DEDENT DEDENT return table [ n ] NEWLINE DEDENT arr = [ 1 , 2 , 3 ] NEWLINE m = len ( arr ) NEWLINE n = 4 NEWLINE x = count ( arr , m , n ) NEWLINE print ( x ) NEWLINE NL ENDMARKER
cases = int ( input ( ) ) while cases : cases -= 1 zero , one , two = map ( int , input ( ) . split ( ) ) zero2 , one2 , two2 = map ( int , input ( ) . split ( ) )  ans = 0 two_mn = min ( two , one2 ) ans += ( two_mn * 2 )  one2 -= two_mn two -= two_mn  rem = two2 - ( two + zero )  ans -= max ( rem , 0 ) * 2  print ( ans )         NEWLINE NL ENDMARKER
from math import sqrtx = abs ( int ( input ( ) ) ) a = int ( ( sqrt ( 1 + 8 * x ) - 1 ) / 2 ) print ( a + min ( 2 * x - a * ( a + 1 ) , ( ( a + 2 ) * ( a + 1 ) // 2 - x ) % 2 * 2 + 1 , ( ( a + 3 ) * ( a + 2 ) // 2 - x ) % 2 + 2 ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) if ( n * m % 2 == 0 ) : print ( n * m // 2 ) else : print ( ( n * m - 1 ) // 2 + 1 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) )  m = int ( input ( ) ) b = list ( map ( int , input ( ) . split ( ) ) )  a . sort ( ) b . sort ( )  print ( str ( a [ len ( a ) - 1 ] ) + " " + str ( b [ len ( b ) - 1 ] ) ) NEWLINE NL ENDMARKER
n = input ( ) NEWLINE s = int ( n , 2 ) NEWLINE print ( s ) NEWLINE NL ENDMARKER
def weightedMean ( n ) : NEWLINE INDENT return ( 2 * n + 1 ) / 3 NEWLINE DEDENT n = 10 NEWLINE print ( int ( weightedMean ( n ) ) ) NEWLINE NL ENDMARKER
inp = input ( ) nums = [ int ( i ) for i in inp . split ( ) ] temp = sum ( nums ) if temp == 0 : print ( '-1' ) elif temp % len ( nums ) == 0 : print ( int ( temp / len ( nums ) ) ) else : print ( '-1' )    NEWLINE NL ENDMARKER
a , b = [ ] , [ ] for s in input ( ) . replace ( ';' , ',' ) . split ( ',' ) : try : n = int ( s ) if ( n > 0 and s [ 0 ] != '0' ) or ( n == 0 and len ( s ) == 1 ) : a . append ( s ) else : b . append ( s ) except Exception : b . append ( s )  if a : print ( '"' + ',' . join ( a ) + '"' ) else : print ( '-' )  if b : print ( '"' + ',' . join ( b ) + '"' ) else : print ( '-' ) NEWLINE NL ENDMARKER
import sys  def main ( ) : n = int ( sys . stdin . read ( ) . strip ( ) ) for i in range ( 9 , 0 , - 1 ) : if not n % i : return n // i , ( n // i * f'{i} ' ) . strip ( )  print ( * main ( ) , sep = '\n' ) NEWLINE NL ENDMARKER
def findMinZero ( p ) : NEWLINE INDENT first = 1 NEWLINE second = 1 NEWLINE number = 2 NEWLINE next = 1 NEWLINE while ( next ) : NEWLINE INDENTINDENT next = ( first + second ) % p NEWLINE first = second NEWLINE second = next NEWLINE number = number + 1 NEWLINE DEDENT return number NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT p = 7 NEWLINE print ( "Minimal zero is:" , findMinZero ( p ) ) NEWLINE NL DEDENT ENDMARKER
def powerNumbers ( n ) : NEWLINE INDENT v = set ( ) ; NEWLINE v . add ( 1 ) ; NEWLINE for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT if ( i * i <= n ) : NEWLINE INDENTINDENTINDENT j = i * i ; NEWLINE v . add ( j ) ; NEWLINE while ( j * i <= n ) : NEWLINE INDENTINDENTINDENTINDENT v . add ( j * i ) ; NEWLINE j = j * i ; NEWLINE DEDENT DEDENT DEDENT return len ( v ) ; NEWLINE DEDENT print ( powerNumbers ( 50 ) ) ; NEWLINE NL ENDMARKER
def percent ( a , b ) : NEWLINE INDENT result = int ( ( ( b - a ) * 100 ) / a ) NEWLINE return result NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a , b = 20 , 25 NEWLINE print ( percent ( a , b ) , "%" ) NEWLINE NL DEDENT ENDMARKER
def countSetBits ( n ) : NEWLINE INDENT count = 0 NEWLINE while ( n ) : NEWLINE INDENTINDENT n &= ( n - 1 ) NEWLINE count += 1 NEWLINE DEDENT return count NEWLINE DEDENT i = 9 NEWLINE print ( countSetBits ( i ) ) NEWLINE NL ENDMARKER
nums = list ( map ( int , input ( ) . split ( ) ) )  n = nums [ 0 ] k = nums [ 1 ] for i in range ( k ) : if n % 10 == 0 : n = n / 10 else : n = n - 1  print ( int ( n ) ) NEWLINE NL ENDMARKER
import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappush NEWLINE NL ENDMARKER
a = input ( ) . lower ( ) b = input ( ) . lower ( ) z = len ( a ) NEWLINE NL ENDMARKER
import sys   n = int ( sys . stdin . readline ( ) ) a = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( ) ] b = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( ) ] A = a [ 0 ] for x in a : A |= xB = b [ 0 ] for x in b : B |= x  print ( A + B ) NEWLINE NL ENDMARKER
n , m , k , t = map ( int , input ( ) . split ( " " ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = ( n + 1 ) // 36 n -= 36 * ab = ( n + 1 ) // 3 print ( a , b ) NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def readBinaryWatch ( self , num ) : NEWLINE INDENTINDENT return [ '%d:%02d' % ( h , m ) for h in range ( 12 ) for m in range ( 60 ) if ( bin ( h ) + bin ( m ) ) . count ( '1' ) == num ] NEWLINE NL DEDENT DEDENT ENDMARKER
def bridge_length ( trainLength , Speed , Time ) : NEWLINE INDENT return ( ( Time * Speed ) - trainLength ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT trainLength = 120 NEWLINE Speed = 30 NEWLINE Time = 18 NEWLINE print ( "Length of bridge = " , bridge_length ( trainLength , Speed , Time ) , "meters" ) NEWLINE NL DEDENT ENDMARKER
def center_pentadecagonal_num ( n ) : NEWLINE INDENT return ( 15 * n * n - 15 * n + 2 ) // 2 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 3 NEWLINE print ( n , "rd number : " , center_pentadecagonal_num ( n ) ) NEWLINE n = 10 NEWLINE print ( n , "th number : " , center_pentadecagonal_num ( n ) ) NEWLINE NL DEDENT ENDMARKER
from __future__ import division NEWLINE def sumOfSeries ( a , num ) : NEWLINE INDENT res = 0 NEWLINE prev = 1 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT prev *= ( a / i ) NEWLINE res = res + prev NEWLINE DEDENT return res NEWLINE DEDENT n = 5 NEWLINE a = 2 NEWLINE print ( round ( sumOfSeries ( a , n ) , 4 ) ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) print ( n ) NEWLINE NL ENDMARKER
def Loss ( SP , P ) : NEWLINE INDENT loss = 0 NEWLINE loss = ( ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ) NEWLINE print ( "Loss =" , round ( loss , 3 ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT SP , P = 2400 , 30 NEWLINE Loss ( SP , P ) NEWLINE NL DEDENT ENDMARKER
def MinOfCubed ( k ) : NEWLINE INDENT if ( k < 8 ) : NEWLINE INDENTINDENT return k ; NEWLINE DEDENT res = k ; NEWLINE for i in range ( 1 , k + 1 ) : NEWLINE INDENTINDENT if ( ( i * i * i ) > k ) : NEWLINE INDENTINDENTINDENT return res ; NEWLINE DEDENT res = min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; NEWLINE DEDENT return res ; NEWLINE DEDENT num = 15 ; NEWLINE print ( MinOfCubed ( num ) ) ; NEWLINE NL ENDMARKER
def circlearea ( a ) : NEWLINE INDENT if a < 0 : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT A = ( 3.14 * 3 * pow ( a , 2 ) ) / 4 NEWLINE return A NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = 4 NEWLINE print ( circlearea ( a ) ) NEWLINE NL DEDENT ENDMARKER
n , k = list ( map ( int , input ( ) . split ( " " ) ) )  li = list ( map ( int , input ( ) . split ( " " ) ) ) sum = 0 for x in range ( k ) : sum = sum + li [ x ]  i = 0j = kres = sumfor x in range ( n - k ) : sum = sum - li [ i ] + li [ j ] res = res + sum  i += 1 j += 1   print ( res / ( n - k + 1 ) ) NEWLINE NL ENDMARKER
l , r , x , y , k = map ( int , input ( ) . split ( ) ) for i in range ( x , y + 1 ) : if i * k <= r and i * k >= l : print ( "YES" ) breakelse : print ( "NO" ) NEWLINE NL ENDMARKER
def gcd ( a , b ) : NEWLINE INDENT if ( a == 0 ) : NEWLINE INDENTINDENT return b NEWLINE DEDENT return gcd ( b % a , a ) NEWLINE DEDENT def sameRemainder ( a , b , c ) : NEWLINE INDENT a1 = ( b - a ) NEWLINE b1 = ( c - b ) NEWLINE c1 = ( c - a ) NEWLINE return gcd ( a1 , gcd ( b1 , c1 ) ) NEWLINE DEDENT a = 62 NEWLINE b = 132 NEWLINE c = 237 NEWLINE print ( sameRemainder ( a , b , c ) ) NEWLINE NL ENDMARKER
n , pos , l , r = map ( int , input ( ) . split ( ) ) if l == 1 and r == n : print ( 0 ) elif l == 1 and r != n : print ( abs ( pos - r ) + 1 ) elif l != 1 and r == n : print ( abs ( pos - l ) + 1 ) else : print ( r - l + 2 + min ( abs ( pos - l ) , abs ( pos - r ) ) ) NEWLINE NL ENDMARKER
def nCr ( n , r ) : NEWLINE INDENT ans = 1 ; NEWLINE for i in range ( 1 , r + 1 ) : NEWLINE INDENTINDENT ans *= ( n - r + i ) ; NEWLINE ans //= i ; NEWLINE DEDENT return ans ; NEWLINE DEDENT def total_ways ( N , X ) : NEWLINE INDENT return ( nCr ( N - 1 , X - 1 ) + nCr ( N - 1 , X ) ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 5 ; X = 3 ; NEWLINE print ( total_ways ( N , X ) ) ; NEWLINE NL DEDENT ENDMARKER
x , y = map ( int , input ( ) . split ( ) ) ans = abs ( x ) + abs ( y )  if x > 0 and y > 0 : print ( 0 , ans , ans , 0 ) if x < 0 and y > 0 : print ( - ans , 0 , 0 , ans ) if x < 0 and y < 0 : print ( - ans , 0 , 0 , - ans ) if x > 0 and y < 0 : print ( 0 , - ans , ans , 0 ) NEWLINE NL ENDMARKER
n = input ( ) lst = list ( map ( float , input ( ) . split ( ) ) ) ds = [ ] ds . append ( 0 ) for i , elem in enumerate ( lst [ 1 : ] ) : ds . append ( ds [ i ] * elem + lst [ i ] * elem ) ans = 2 * sum ( ds ) + sum ( lst ) print ( ans ) NEWLINE NL ENDMARKER
n = int ( input ( ) )  if n == 1 : print ( 'Ehab' ) elif n % 2 == 0 : print ( 'Mahmoud' ) else : print ( 'Ehab' ) NEWLINE NL ENDMARKER
def countNumbers ( n ) : NEWLINE INDENT if n % 2 == 1 : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT return ( 9 * pow ( 10 , n // 2 - 1 ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 2 NEWLINE print ( countNumbers ( n ) ) NEWLINE NL DEDENT ENDMARKER
def term ( n ) : NEWLINE INDENT ans = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT ans = ans + i NEWLINE DEDENT return ans NEWLINE DEDENT n = 4 NEWLINE print ( term ( n ) ) NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def sortArrayByParity ( self , A ) : NEWLINE INDENTINDENT lo , hi = 0 , len ( A ) - 1 NEWLINE while lo < hi : NEWLINE INDENTINDENTINDENT if A [ lo ] % 2 > A [ hi ] % 2 : NEWLINE INDENTINDENTINDENTINDENT A [ lo ] , A [ hi ] = A [ hi ] , A [ lo ] NEWLINE DEDENT if A [ lo ] % 2 == 0 : lo += 1 NEWLINE if A [ hi ] % 2 == 1 : hi -= 1 NEWLINE DEDENT return A NEWLINE NL DEDENT DEDENT ENDMARKER
n , s = map ( int , input ( ) . rstrip ( ) . split ( " " ) ) if s == 0 or n == 1 : print ( 0 ) elif s >= n // 2 : print ( ( n - 1 ) * ( n ) // 2 ) else : t = 0 for i in range ( s ) : t += ( n - 1 - i ) for i in range ( s , n - s ) : t += s for i in range ( s ) : t += i print ( t ) NEWLINE NL ENDMARKER
a = 2 NEWLINE b = 2.0 NEWLINE c = 2.0003 NEWLINE d = 'D' NEWLINE print ( "Integer value is = " , a ) ; NEWLINE print ( "\nFloat value is = " , b ) ; NEWLINE print ( "\nDouble value is = " , c ) ; NEWLINE print ( "\nChar value is = " , d ) ; NEWLINE NL ENDMARKER
def smallestDivisor ( n ) : NEWLINE INDENT if ( n % 2 == 0 ) : NEWLINE INDENTINDENT return 2 ; NEWLINE DEDENT i = 3 ; NEWLINE while ( i * i <= n ) : NEWLINE INDENTINDENT if ( n % i == 0 ) : NEWLINE INDENTINDENTINDENT return i ; NEWLINE DEDENT i += 2 ; NEWLINE DEDENT return n ; NEWLINE DEDENT n = 31 ; NEWLINE print ( smallestDivisor ( n ) ) ; NEWLINE NL ENDMARKER
if __name__ == "__main__" : n = int ( input ( ) ) grades = list ( map ( int , input ( ) . split ( ) ) ) grades . sort ( ) required = 4.5 redo = 0 i = 0 while round ( sum ( grades ) / n , 2 ) < required : redo = redo + 1 grades [ i ] = 5 i = i + 1 print ( redo ) NEWLINE NL ENDMARKER
def CntDivbyX ( arr , n , x ) : NEWLINE INDENT number = 0 NEWLINE count = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT number = ( number * 2 + arr [ i ] ) % x NEWLINE if number == 0 : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT return count NEWLINE DEDENT arr = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 ] NEWLINE n = 7 NEWLINE x = 2 NEWLINE print ( CntDivbyX ( arr , n , x ) ) NEWLINE NL ENDMARKER
cases = int ( input ( ) ) while cases : cases -= 1 n , k = map ( int , input ( ) . split ( ) )  ans = 0  while n : ans += n % k n //= k if n > 0 : ans += 1  print ( ans ) NEWLINE NL ENDMARKER
def gcd ( a , b ) : NEWLINE INDENT if ( a == 0 ) : NEWLINE INDENTINDENT return b NEWLINE DEDENT return gcd ( b % a , a ) NEWLINE DEDENT def commDiv ( a , b ) : NEWLINE INDENT n = gcd ( a , b ) NEWLINE a = a // n NEWLINE b = b // n NEWLINE print ( "A =" , a , ", B =" , b ) NEWLINE DEDENT a , b = 10 , 15 NEWLINE commDiv ( a , b ) NEWLINE NL ENDMARKER
def getMinCost ( n , m ) : NEWLINE INDENT cost = ( n - 1 ) * m + ( m - 1 ) * n NEWLINE return cost NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n , m = 4 , 5 NEWLINE print ( getMinCost ( n , m ) ) NEWLINE NL DEDENT ENDMARKER
def area_fun ( side ) : NEWLINE INDENT area = side * side NEWLINE return area NEWLINE DEDENT side = 4 NEWLINE area = area_fun ( side ) NEWLINE print ( area ) NEWLINE NL ENDMARKER
def printModulus ( X , Y ) : NEWLINE INDENT n = max ( X , Y ) NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT if ( X % i == Y % i ) : NEWLINE INDENTINDENTINDENT print ( i , end = " " ) NEWLINE DEDENT DEDENT DEDENT X = 10 NEWLINE Y = 20 NEWLINE printModulus ( X , Y ) NEWLINE NL ENDMARKER
l , r = map ( int , input ( ) . split ( ) ) if l != r : print ( 2 ) else : print ( l ) NEWLINE NL ENDMARKER
si = input ( ) ans = "" while 1 : co = si . count ( max ( si ) ) ans = ans + max ( si ) * co NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) ans = 0 if a < 2 and b < 2 : print ( 0 ) exit ( ) while a > 0 and b > 0 : ans += 1 if a < b : a += 1 b -= 2 else : a -= 2 b += 1 print ( ans ) NEWLINE NL ENDMARKER
def printNumberWithDR ( k , d ) : NEWLINE INDENT if d == 0 and k != 1 : NEWLINE INDENTINDENT print ( - 1 , end = "" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( d , end = "" ) NEWLINE k -= 1 NEWLINE while k : NEWLINE INDENTINDENTINDENT print ( 0 , end = "" ) NEWLINE k -= 1 NEWLINE DEDENT DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT k , d = 4 , 4 NEWLINE printNumberWithDR ( k , d ) NEWLINE NL DEDENT ENDMARKER
import math  testCases = int ( input ( ) )  for i in range ( testCases ) : stringA = input ( ) NEWLINE stringB = input ( ) NEWLINE a = len ( stringA ) NEWLINE b = len ( stringB ) NEWLINE LCM = a * b // math . gcd ( a , b ) NEWLINE stringAlcm = stringA * ( LCM // a ) NEWLINE stringBlcm = stringB * ( LCM // b ) NEWLINE if stringAlcm == stringBlcm : NEWLINE INDENT print ( stringAlcm ) else : NEWLINE print ( - 1 ) NEWLINE NL DEDENT ENDMARKER
from math import gcd   def lcm ( a , b ) : return ( a / gcd ( a , b ) ) * b   num = "1"  n , k = map ( int , input ( ) . split ( ) ) for i in range ( k ) : num += "0" num = int ( num ) print ( int ( lcm ( num , n ) ) )  NEWLINE NL ENDMARKER
import sys  def main ( ) : n = int ( sys . stdin . read ( ) . strip ( ) ) return '' . join ( map ( str , range ( 1 , 400 ) ) ) [ n - 1 ]  print ( main ( ) ) NEWLINE NL ENDMARKER
def findStarNum ( n ) : NEWLINE INDENT return ( 6 * n * ( n - 1 ) + 1 ) NEWLINE DEDENT n = 3 NEWLINE print ( findStarNum ( n ) ) NEWLINE NL ENDMARKER
def findTriangles ( n ) : NEWLINE INDENT num = n NEWLINE print ( num , end = " " ) NEWLINE print ( num * ( num - 4 ) * ( num - 5 ) // 6 ) NEWLINE DEDENT n = 6 ; NEWLINE findTriangles ( n ) NEWLINE NL ENDMARKER
def countDigit ( n ) : NEWLINE INDENT temp = n NEWLINE count = 0 NEWLINE while ( temp != 0 ) : NEWLINE INDENTINDENT d = temp % 10 NEWLINE temp //= 10 NEWLINE if ( d == 2 or d == 3 or d == 5 or d == 7 ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT return count NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 1234567890 NEWLINE print ( countDigit ( n ) ) NEWLINE NL DEDENT ENDMARKER
s , a = 0 , 0 for _ in " " * int ( input ( ) ) : t , d = map ( str , input ( ) . split ( ) ) ; t = int ( t ) if not a and d [ 0 ] != "S" or a == 20000 and d [ 0 ] != "N" or d [ 0 ] == "N" and a - t < 0 or d [ 0 ] == "S" and a + t > 20000 : s = 1 a += 0 if d not in "NorthSouth" else t if d [ 0 ] == "S" else - tprint ( "YES" if not ( s or a ) else "NO" ) NEWLINE NL ENDMARKER
small , big = map ( int , input ( ) . split ( ) ) count = 0 while small <= big : small *= 3 big *= 2 count += 1 print ( count ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) x = max ( a ) s = 0 while ( sum ( a ) >= s ) : c = 0 for i in a : c = c + ( x - i ) s = c x = x + 1 print ( x - 1 ) NEWLINE NL ENDMARKER
def nth_term ( n ) : NEWLINE INDENT a = 1 NEWLINE b = 1 NEWLINE c = 1 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT c = a + b NEWLINE a = b NEWLINE b = c NEWLINE DEDENT return c NEWLINE DEDENT n = 10 NEWLINE c = nth_term ( n ) NEWLINE print ( c ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) values = [ 0 for k in range ( n ) ] for k in range ( n ) : back = a [ k ] if a [ k ] == k + 1 : values [ k ] = 2 else : values [ k ] += 2 for t in range ( a [ k ] - 1 , k ) : values [ k ] += values [ t ] values [ k ] %= int ( 1e9 + 7 ) print ( int ( sum ( values ) % ( 1e9 + 7 ) ) ) NEWLINE NL ENDMARKER
def minsteps ( n , m ) : NEWLINE INDENT if ( m > n ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( ( n + 1 ) // 2 + m - 1 ) // m * m ; NEWLINE DEDENT DEDENT n = 17 NEWLINE m = 4 NEWLINE ans = minsteps ( n , m ) NEWLINE print ( ans ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) arr = [ int ( z ) for z in input ( ) . split ( ) ] x , y = map ( int , input ( ) . split ( ) ) for i in range ( 1 , n ) : b = sum ( arr [ : i ] ) a = sum ( arr [ i : ] ) if b >= x and b <= y and a >= x and a <= y : print ( i + 1 ) exit ( ) print ( 0 ) NEWLINE NL ENDMARKER
def intersection ( n ) : NEWLINE INDENT return n * ( n - 1 ) ; NEWLINE DEDENT print ( intersection ( 3 ) ) NEWLINE NL ENDMARKER
def findMajority ( arr , n ) : NEWLINE INDENT return arr [ int ( n / 2 ) ] NEWLINE DEDENT arr = [ 1 , 2 , 2 , 3 ] NEWLINE n = len ( arr ) NEWLINE print ( findMajority ( arr , n ) ) NEWLINE NL ENDMARKER
def per ( n ) : NEWLINE INDENT if ( n == 0 ) : NEWLINE INDENTINDENT return 3 ; NEWLINE DEDENT if ( n == 1 ) : NEWLINE INDENTINDENT return 0 ; NEWLINE DEDENT if ( n == 2 ) : NEWLINE INDENTINDENT return 2 ; NEWLINE DEDENT return per ( n - 2 ) + per ( n - 3 ) ; NEWLINE DEDENT n = 9 ; NEWLINE print ( per ( n ) ) ; NEWLINE NL ENDMARKER
for i in range ( int ( input ( ) ) ) : n = int ( input ( ) ) ok = False arr = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : for j in range ( i + 2 , n ) : if ( arr [ i ] == arr [ j ] ) : ok = True if ( ok ) : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) while t > 0 : t -= 1 s , d = [ int ( x ) for x in input ( ) . split ( ) ] print ( min ( s , d , ( s + d ) // 3 ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( 2 * n * ( n - 1 ) + 1 ) NEWLINE NL ENDMARKER
a , m = map ( int , input ( ) . split ( ) )  t = Truefor i in range ( m ) : if a % m == 0 : t = False print ( "Yes" ) break else : x = int ( a % m ) a += xif t == True : print ( "No" ) NEWLINE NL ENDMARKER
'''* Author : Ayushman Chahar #* About  : IT Sophomore    #* Insti  : VIT, Vellore    #'''  import osimport sys NEWLINE NL ENDMARKER
n , a , b = map ( int , input ( ) . split ( ) ) ans = 0 while n - a - 1 > b : a += 1 print ( n - a ) NEWLINE NL ENDMARKER
from math import ceilt = int ( input ( ) ) NEWLINE for x in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) NEWLINE if a == 1 or a == 2 : print ( 1 ) NEWLINE continue NEWLINE a -= 2 NEWLINE print ( ceil ( a / b ) + 1 ) NEWLINE NL ENDMARKER
n = 5 NEWLINE a = [ [ 1 , 2 , 3 , 4 , 5 ] , [ 5 , 6 , 7 , 8 , 6 ] , [ 9 , 5 , 6 , 8 , 7 ] , [ 2 , 3 , 5 , 6 , 8 ] , [ 1 , 2 , 3 , 4 , 5 ] ] NEWLINE if ( n % 2 == 0 ) : NEWLINE INDENT print ( "NULL" ) NEWLINE DEDENT else : NEWLINE INDENT mid = n // 2 NEWLINE convergingele = a [ mid ] [ mid ] NEWLINE print ( convergingele ) NEWLINE NL DEDENT ENDMARKER
from sys import stdininput = stdin . readline  t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) ans = 0 while n % 3 == 0 : if n % 6 == 0 : n //= 6 else : n *= 2 ans += 1 if n == 1 : print ( ans ) else : print ( - 1 ) NEWLINE NL ENDMARKER
def Squares ( n , m , a ) : NEWLINE INDENT return ( ( ( m + a - 1 ) // a ) * ( ( n + a - 1 ) // a ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 6 NEWLINE m = 6 NEWLINE a = 4 NEWLINE print ( Squares ( n , m , a ) ) NEWLINE NL DEDENT ENDMARKER
def extrapolate ( d , x ) : NEWLINE INDENT y = ( d [ 0 ] [ 1 ] + ( x - d [ 0 ] [ 0 ] ) / ( d [ 1 ] [ 0 ] - d [ 0 ] [ 0 ] ) * ( d [ 1 ] [ 1 ] - d [ 0 ] [ 1 ] ) ) ; NEWLINE return y ; NEWLINE DEDENT d = [ [ 1.2 , 2.7 ] , [ 1.4 , 3.1 ] ] ; NEWLINE x = 2.1 ; NEWLINE print ( "Value of y at x = 2.1 :" , extrapolate ( d , x ) ) ; NEWLINE NL ENDMARKER
def solve ( ang , n ) : NEWLINE INDENT if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT elif ( ( ang * n ) % 180 != 0 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT ans = 1 NEWLINE freq = ( ang * n ) // 180 NEWLINE ans = ans * ( n - 1 - freq ) NEWLINE ans = ans * n NEWLINE return ans NEWLINE DEDENT ang = 90 NEWLINE n = 4 NEWLINE print ( solve ( ang , n ) ) NEWLINE NL ENDMARKER
import math NEWLINE def breakEvenPoint ( exp , S , M ) : NEWLINE INDENT earn = S - M NEWLINE res = math . ceil ( exp / earn ) NEWLINE return res NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT exp = 3550 NEWLINE S = 90 NEWLINE M = 65 NEWLINE print ( int ( breakEvenPoint ( exp , S , M ) ) ) NEWLINE NL DEDENT ENDMARKER
def squaresum ( n ) : NEWLINE INDENT return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 NEWLINE DEDENT n = 4 NEWLINE print ( squaresum ( n ) ) ; NEWLINE NL ENDMARKER
import math NEWLINE def findNth ( n ) : NEWLINE INDENT nthElement = 19 + ( n - 1 ) * 9 NEWLINE outliersCount = int ( math . log10 ( nthElement ) ) - 1 NEWLINE nthElement += 9 * outliersCount NEWLINE return nthElement NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( findNth ( 5 ) ) NEWLINE NL DEDENT ENDMARKER
def doublefactorial ( n ) : NEWLINE INDENT res = 1 ; NEWLINE for i in range ( n , - 1 , - 2 ) : NEWLINE INDENTINDENT if ( i == 0 or i == 1 ) : NEWLINE INDENTINDENTINDENT return res ; NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT res *= i ; NEWLINE DEDENT DEDENT DEDENT print ( "Double factorial is" , doublefactorial ( 5 ) ) ; NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) v = Falsefor i in range ( n ) : row = input ( ) if not v and 'B' in row : s , e = row . find ( 'B' ) , row . rfind ( 'B' ) c = ( s + e ) // 2 r = i + c - s v = True print ( r + 1 , c + 1 ) NEWLINE NL ENDMARKER
MOD = int ( 1e9 + 7 ) n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr . sort ( ) l = 1 ; r = 0 for i in range ( n ) : r = ( r + l * arr [ i ] ) % MOD l = l * 2 % MODl = 1 for i in range ( n - 1 , - 1 , - 1 ) : r = ( r - l * arr [ i ] ) % MOD l = l * 2 % MODprint ( r ) NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def diameterOfBinaryTree ( self , root ) : NEWLINE INDENTINDENT self . ans = 1 NEWLINE def depth ( node ) : NEWLINE INDENTINDENTINDENT if not node : return 0 NEWLINE L = depth ( node . left ) NEWLINE R = depth ( node . right ) NEWLINE self . ans = max ( self . ans , L + R + 1 ) NEWLINE return max ( L , R ) + 1 NEWLINE DEDENT depth ( root ) NEWLINE return self . ans - 1 NEWLINE NL DEDENT DEDENT ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) s = input ( ) x = 0 a -= 1 b -= 1  if ( b < a - b ) : for i in range ( b ) : print ( "LEFT" ) x = 1 else : for i in range ( a - b ) : print ( "RIGHT" ) x = - 1 s = s [ : : - 1 ]   for i in s [ : - 1 ] : print ( f"PRINT {i}" ) if x == - 1 : print ( "LEFT" ) else : print ( "RIGHT" )   print ( f"PRINT {s[-1]}" ) NEWLINE NL ENDMARKER
from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect  NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readlinet = int ( input ( ) ) for you in range ( t ) : n = int ( input ( ) ) s = input ( ) s = s [ : - 1 ] ans = 0 mina = s for i in range ( n ) : pref = s [ : i ] suff = s [ i : ] swaps = ( n - i ) if ( swaps % 2 ) : z = suff + pref [ : : - 1 ] else : z = suff + pref if ( z < mina ) : mina = z ans = i print ( mina ) print ( ans + 1 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )  total = norange_content = 0 for i in range ( n ) : orange_content += arr [ i ] / 100 print ( float ( orange_content / total ) * 100 ) NEWLINE NL ENDMARKER
from math import log , trunc NEWLINE def checkPowerof8 ( n ) : NEWLINE INDENT i = log ( n , 8 ) NEWLINE return ( i - trunc ( i ) < 0.000001 ) ; NEWLINE DEDENT n = 65 NEWLINE if checkPowerof8 ( n ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
class Solution ( object ) : NEWLINE INDENT def missingNumber ( self , nums ) : NEWLINE INDENTINDENT res = len ( nums ) NEWLINE for i , v in enumerate ( nums ) : NEWLINE INDENTINDENTINDENT res ^= i NEWLINE res ^= v NEWLINE DEDENT return res NEWLINE NL DEDENT DEDENT ENDMARKER
def A ( m , n , s = "% s" ) : NEWLINE INDENT print ( s % ( "A(% d, % d)" % ( m , n ) ) ) NEWLINE if m == 0 : NEWLINE INDENTINDENT return n + 1 NEWLINE DEDENT if n == 0 : NEWLINE INDENTINDENT return A ( m - 1 , 1 , s ) NEWLINE DEDENT n2 = A ( m , n - 1 , s % ( "A(% d, %% s)" % ( m - 1 ) ) ) NEWLINE return A ( m - 1 , n2 , s ) NEWLINE DEDENT print ( A ( 1 , 2 ) ) NEWLINE NL ENDMARKER
def calculate_sum ( a , N ) : NEWLINE INDENT m = N / a NEWLINE sum = m * ( m + 1 ) / 2 NEWLINE ans = a * sum NEWLINE print ( "Sum of multiples of " , a , " up to " , N , " = " , ans ) NEWLINE DEDENT calculate_sum ( 7 , 49 ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE l = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE a = [ ] NEWLINE for i in l : a . append ( i / 2 ) NEWLINE s = set ( ) NEWLINE for i in range ( n - 1 ) : for NEWLINE j in range ( i + 1 , n ) : s . add ( a [ j ] - a [ i ] ) NEWLINE print ( len ( s ) ) NEWLINE NL ENDMARKER
import math as mt NEWLINE def twoEggDrop ( k ) : NEWLINE INDENT return mt . ceil ( ( - 1.0 + mt . sqrt ( 1 + 8 * k ) ) / 2 ) NEWLINE DEDENT k = 100 NEWLINE print ( twoEggDrop ( k ) ) NEWLINE NL ENDMARKER
cards = [ ] value = 0 count = 1 for i in range ( int ( input ( ) ) ) : ai , bi = map ( int , input ( ) . split ( ) ) if bi == 0 : cards . append ( ai ) else : value += ai count += bi - 1 print ( value + sum ( sorted ( cards , reverse = True ) [ : count ] ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) x = 1 while x ** 2 < n : x += 1 if x ** 2 > n : x -= 1 t = n - x ** 2 ans = 4 * xif ( t != 0 ) : b = t // x z = t % x ans += ( 2 * b ) if z > 0 : ans += 2 print ( ans ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) li = [ [ ] for _ in range ( n ) ] for i in range ( 1 , n * n // 2 + 1 ) : li [ ( i - 1 ) % n ] += [ i , n * n - i + 1 ] for line in li : print ( * line ) NEWLINE NL ENDMARKER
import math NEWLINE def digSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE while ( n > 0 or sum > 9 ) : NEWLINE INDENTINDENT if ( n == 0 ) : NEWLINE INDENTINDENTINDENT n = sum NEWLINE sum = 0 NEWLINE DEDENT sum += n % 10 NEWLINE n /= 10 NEWLINE DEDENT return sum NEWLINE DEDENT n = 1234 NEWLINE print ( digSum ( n ) ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) v = list ( map ( int , input ( ) . split ( ) ) ) v . sort ( ) print ( * v [ : : - 1 ] , sep = " " ) NEWLINE NL ENDMARKER
num_to_bits = [ 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 ] ; NEWLINE def countSetBitsRec ( num ) : NEWLINE INDENT nibble = 0 ; NEWLINE if ( 0 == num ) : NEWLINE INDENTINDENT return num_to_bits [ 0 ] ; NEWLINE DEDENT nibble = num & 0xf ; NEWLINE return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; NEWLINE DEDENT num = 31 ; NEWLINE print ( countSetBitsRec ( num ) ) ; NEWLINE NL ENDMARKER
def findPattern ( n ) : NEWLINE INDENT prev = n % 2 NEWLINE n = n // 2 NEWLINE while ( n > 0 ) : NEWLINE INDENTINDENT curr = n % 2 NEWLINE if ( curr == prev ) : NEWLINE INDENTINDENTINDENT return False NEWLINE DEDENT prev = curr NEWLINE n = n // 2 NEWLINE DEDENT return True NEWLINE DEDENT n = 10 NEWLINE print ( "Yes" ) if ( findPattern ( n ) ) else print ( "No" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( ( n * ( n + 1 ) ) // 2 - sum ( sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( n // 2 - ( n % 2 ) * n ) NEWLINE NL ENDMARKER
from math import pow , sqrt NEWLINE def area ( r ) : NEWLINE INDENT if ( r < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT area = 3.14 * pow ( r / ( 2 * sqrt ( 2 ) ) , 2 ) ; NEWLINE return area ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = 5 NEWLINE print ( "{0:.6}" . format ( area ( a ) ) ) NEWLINE NL DEDENT ENDMARKER
for _ in range ( int ( input ( ) ) ) :  NEWLINE n = bin ( int ( input ( ) ) ) [ 1 : ]  if n != "1" and n . count ( "1" ) == 1 : NEWLINE INDENT print ( 'NO' ) else : NEWLINE print ( 'YES' ) NEWLINE NL DEDENT ENDMARKER
def maxOR ( L , R ) : NEWLINE INDENT maximum = - 10 ** 9 NEWLINE for i in range ( L , R ) : NEWLINE INDENTINDENT for j in range ( i + 1 , R + 1 ) : NEWLINE INDENTINDENTINDENT maximum = max ( maximum , ( i | j ) ) NEWLINE DEDENT DEDENT return maximum NEWLINE DEDENT L = 4 NEWLINE R = 5 NEWLINE print ( maxOR ( L , R ) ) NEWLINE NL ENDMARKER
import math NEWLINE def countSteps ( x , y ) : NEWLINE INDENT if ( x % y == 0 ) : NEWLINE INDENTINDENT return math . floor ( x / y ) ; NEWLINE DEDENT return math . floor ( ( x / y ) + countSteps ( y , x % y ) ) ; NEWLINE DEDENT x = 100 ; NEWLINE y = 19 ; NEWLINE print ( countSteps ( x , y ) ) ; NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def flipAndInvertImage ( self , A ) : NEWLINE INDENTINDENT for row in A : NEWLINE INDENTINDENTINDENT for i in xrange ( ( len ( row ) + 1 ) / 2 ) : NEWLINE INDENTINDENTINDENTINDENT row [ i ] , row [ ~ i ] = row [ ~ i ] ^ 1 , row [ i ] ^ 1 NEWLINE DEDENT DEDENT return A NEWLINE NL DEDENT DEDENT ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) L = [ 0 ] * nfor i in range ( m ) : a , b = map ( int , input ( ) . split ( ) ) L [ a - 1 ] = - 1 L [ b - 1 ] = - 1 central = 0 for i in range ( n ) : if L [ i ] == 0 : central = i + 1 breakprint ( n - 1 ) for i in range ( 1 , n + 1 ) : if i != central : print ( central , i ) NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def sortArrayByParityII ( self , A ) : NEWLINE INDENTINDENT odd = 1 NEWLINE for i in xrange ( 0 , len ( A ) , 2 ) : NEWLINE INDENTINDENTINDENT if A [ i ] % 2 : NEWLINE INDENTINDENTINDENTINDENT while A [ odd ] % 2 : NEWLINE INDENTINDENTINDENTINDENTINDENT odd += 2 NEWLINE DEDENT A [ i ] , A [ odd ] = A [ odd ] , A [ i ] NEWLINE DEDENT DEDENT return A NEWLINE NL DEDENT DEDENT ENDMARKER
def centeredOctahedral ( n ) : NEWLINE INDENT return ( 2 * n + 1 ) * ( 2 * n * n + 2 * n + 3 ) // 3 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 3 NEWLINE print ( centeredOctahedral ( n ) ) NEWLINE n = 9 NEWLINE print ( centeredOctahedral ( n ) ) NEWLINE NL DEDENT ENDMARKER
n = 5 NEWLINE fac1 = 1 NEWLINE for i in range ( 2 , n ) : NEWLINE INDENT fac1 = fac1 * i NEWLINE DEDENT fac2 = fac1 * n NEWLINE totalWays = fac1 * fac2 NEWLINE print ( totalWays ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) if n % 7 == 0 : print ( n // 7 ) elif n % 7 == 1 : print ( n // 7 + 2 ) else : print ( n // 7 + 1 ) NEWLINE NL ENDMARKER
n , d = ( int ( x ) for x in input ( ) . strip ( ) . split ( ' ' ) ) s = input ( )  flag = Trueres = 0 weizhi = 0  if n - 1 <= d : print ( "1" ) else : while flag : weizhi = weizhi + d  if weizhi >= n - 1 : res = res + 1 flag = False else : for i in range ( d ) : if s [ weizhi ] == "1" : break else : weizhi = weizhi - 1 if i == d - 1 : res = - 2 flag = False res = res + 1 print ( res ) NEWLINE NL ENDMARKER
n , t = list ( map ( int , input ( ) . split ( ) ) ) a = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] ) b = [ a [ i ] [ 0 ] - a [ i ] [ 1 ] / 2 - a [ i - 1 ] [ 0 ] - a [ i - 1 ] [ 1 ] / 2 for i in range ( 1 , n ) ] c = 2 for i in range ( n - 1 ) : c += int ( b [ i ] > t ) * 2 + int ( b [ i ] == t ) print ( c ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) count = 0 for i in range ( n ) : arr = list ( map ( int , input ( ) . split ( ) ) ) for j in range ( 0 , 2 * m , 2 ) : if arr [ j ] == 1 or arr [ j + 1 ] == 1 : count += 1 print ( count ) NEWLINE NL ENDMARKER
s = input ( ) n = len ( s ) m = 0  for i in range ( n - 1 ) : for j in range ( 1 , n - i ) : if s [ i : i + j ] in s [ i + 1 : ] : if j > m : m = j  print ( m ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) if n == 1 : print ( "0" ) else : if n % 2 == 0 : c = ( n // 2 ) - 1 else : c = ( n // 2 ) print ( c ) NEWLINE NL ENDMARKER
import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEWLINE NL ENDMARKER
def countStr ( n ) : NEWLINE INDENT return ( 1 + ( n * 2 ) + ( n * ( ( n * n ) - 1 ) // 2 ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 3 NEWLINE print ( countStr ( n ) ) NEWLINE NL DEDENT ENDMARKER
import matha , b , c = map ( int , input ( ) . split ( ) ) print ( math . ceil ( a * c / b - c ) ) NEWLINE NL ENDMARKER
import sysfrom math import gcd , sqrt , ceil , log2from collections import defaultdict , Counter , dequefrom bisect import bisect_left , bisect_rightimport mathsys . setrecursionlimit ( 2 * 10 ** 5 + 10 ) import heapqfrom itertools import permutations  NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) c = 1 changes = 0 if ( n >= 1 and n <= 100 ) : for i in range ( n ) : if ( s [ i ] == '1' and c == 1 ) : c = 1 changes += 1 elif ( s [ i ] == '0' and c == 1 ) : c = 0 changes += 1 elif ( s [ i ] == '1' and c == 0 ) : c = 0 else : c = 0 print ( changes ) NEWLINE NL ENDMARKER
from math import ceil NEWLINE def nDigitPerfectCubes ( n ) : NEWLINE INDENT print ( pow ( ceil ( ( pow ( 10 , ( n - 1 ) ) ) ** ( 1 / 3 ) ) , 3 ) , end = " " ) NEWLINE print ( pow ( ceil ( ( pow ( 10 , ( n ) ) ) ** ( 1 / 3 ) ) - 1 , 3 ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 3 NEWLINE nDigitPerfectCubes ( n ) NEWLINE NL DEDENT ENDMARKER
import math  s = input ( ) if len ( s ) == 1 : print ( 0 ) elif len ( s ) == 2 : print ( 1 ) else : ans = math . ceil ( len ( s ) / 2 ) if s [ 1 : ] . count ( '1' ) == 0 and len ( s ) % 2 == 1 : ans -= 1 print ( ans ) NEWLINE NL ENDMARKER
def allBitsAreSet ( n ) : NEWLINE INDENT if ( ( ( n + 1 ) & n ) == 0 ) : NEWLINE INDENTINDENT return True ; NEWLINE DEDENT return False ; NEWLINE DEDENT def bitsAreInAltOrder ( n ) : NEWLINE INDENT num = n ^ ( n >> 1 ) ; NEWLINE return allBitsAreSet ( num ) ; NEWLINE DEDENT n = 10 ; NEWLINE if ( bitsAreInAltOrder ( n ) ) : NEWLINE INDENT print ( "Yes" ) ; NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) ; NEWLINE NL DEDENT ENDMARKER
def checkEvenOdd ( arr , n ) : NEWLINE INDENT for i in range ( n ) : NEWLINE INDENTINDENT if ( arr [ i ] % 2 == 0 ) : NEWLINE INDENTINDENTINDENT print ( "Even" , end = "" ) ; NEWLINE return ; NEWLINE DEDENT DEDENT print ( "Odd" , end = "" ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 2 , 12 , 20 , 36 , 38 ] ; NEWLINE n = len ( arr ) ; NEWLINE checkEvenOdd ( arr , n ) ; NEWLINE NL DEDENT ENDMARKER
def calculateSum ( n ) : NEWLINE INDENT a1 = 1 ; NEWLINE a2 = 2 ; NEWLINE r = 2 ; NEWLINE d = 1 ; NEWLINE return ( ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( pow ( r , n ) - 1 ) / ( r - 1 ) ) ; NEWLINE DEDENT n = 5 ; NEWLINE print ( "Sum =" , int ( calculateSum ( n ) ) ) NEWLINE NL ENDMARKER
import math NEWLINE def firstDigit ( n ) : NEWLINE INDENT fact = 1 NEWLINE for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT fact = fact * i NEWLINE while ( fact % 10 == 0 ) : NEWLINE INDENTINDENTINDENT fact = int ( fact / 10 ) NEWLINE DEDENT DEDENT while ( fact >= 10 ) : NEWLINE INDENTINDENT fact = int ( fact / 10 ) NEWLINE DEDENT return math . floor ( fact ) NEWLINE DEDENT n = 5 NEWLINE print ( firstDigit ( n ) ) NEWLINE NL ENDMARKER
cm = 1000 ; NEWLINE meter = cm / 100.0 ; NEWLINE kilometer = cm / 100000.0 ; NEWLINE print ( "Length in meter = " , meter , "m" ) ; NEWLINE print ( "Length in Kilometer = " , kilometer , "km" ) ; NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) if a [ n - 1 ] >= a [ n - 2 ] + a [ n - 3 ] : print ( "NO" ) else : print ( "YES" ) for i in range ( n - 1 , - 1 , - 2 ) : print ( a [ i ] , end = " " ) for i in range ( n % 2 , n , 2 ) : print ( a [ i ] , end = " " ) NEWLINE NL ENDMARKER
import math NEWLINE def MinimumMail ( n , k , x ) : NEWLINE INDENT m = ( ( n - 1 ) + int ( math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + math . ceil ( n * 1.0 / x ) * ( k - n ) ) ) ; NEWLINE return m ; NEWLINE DEDENT N = 4 ; NEWLINE K = 9 ; NEWLINE X = 2 ; NEWLINE print ( MinimumMail ( N , K , X ) ) ; NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) NEWLINE if k % n == 0 : NEWLINE INDENT print ( k // n ) else : NEWLINE if NEWLINE DEDENT k > n : print ( k // n + 1 ) else : t = n // k NEWLINE if n % k != 0 : t = t + 1 NEWLINE if ( t * k ) % n == 0 : NEWLINE INDENT print ( ( t * k ) // n ) else : NEWLINE print ( ( t * k ) // n + 1 ) NEWLINE NL DEDENT ENDMARKER
a , b , c , d = map ( int , input ( ) . split ( ) ) result = ( a * d ) / ( b * c + a * d - a * c ) print ( result ) NEWLINE NL ENDMARKER
import os , sys , bisectfrom collections import defaultdict , Counter , deque ; from functools import lru_cache NEWLINE NL ENDMARKER
import sys , os , ioimport math , bisect , operatorinf , mod = float ( 'inf' ) , 10 ** 9 + 7 NEWLINE NL ENDMARKER
def isDivisible ( n ) : NEWLINE INDENT while ( n // 100 ) : NEWLINE INDENTINDENT d = n % 10 NEWLINE n //= 10 NEWLINE n -= d * 5 NEWLINE DEDENT return ( n % 17 == 0 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 19877658 NEWLINE if isDivisible ( n ) : NEWLINE INDENTINDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) NEWLINE NL DEDENT DEDENT ENDMARKER
import sysfrom array import array NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) )  certificate = n // 2 // ( k + 1 ) * kdiplomas = n // 2 // ( k + 1 ) non_winners = n - diplomas - certificate  print ( diplomas , certificate , non_winners ) NEWLINE NL ENDMARKER
x = int ( input ( ) ) for i in range ( x ) : n , m = [ int ( a ) for a in input ( ) . split ( ) ] if ( 2 * min ( n , m ) < max ( m , n ) or ( n + m ) % 3 ) : print ( "NO" ) else : print ( "YES" ) NEWLINE NL ENDMARKER
import sys  def answer ( n , m , a , p ) : p . sort ( ) NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def mergeTrees ( self , t1 , t2 ) : NEWLINE INDENTINDENT if t1 is None : NEWLINE INDENTINDENTINDENT return t2 NEWLINE DEDENT if t2 is None : NEWLINE INDENTINDENTINDENT return t1 NEWLINE DEDENT t1 . val += t2 . val NEWLINE t1 . left = self . mergeTrees ( t1 . left , t2 . left ) NEWLINE t1 . right = self . mergeTrees ( t1 . right , t2 . right ) NEWLINE return t1 NEWLINE NL DEDENT DEDENT ENDMARKER
n , b , p = map ( int , input ( ) . split ( ) ) l = [ int ( i ) for i in input ( ) . split ( ) ] w = 0 for i in l : if ( i == 1 ) : if ( b > 0 ) : b = b - 1 else : w = w + 1 else : if ( p > 0 ) : p = p - 1 elif ( b > 0 ) : b = b - 1 else : w = w + 1 print ( w ) NEWLINE NL ENDMARKER
x , y = map ( int , input ( ) . split ( ) ) a = 1 b = 0  if ( y == 0 or ( y == 1 and x > 0 ) ) : print ( "No" ) exit ( )  else : a = a + a * ( y - 1 ) b = b + y - 1  x = x - b  if ( x % 2 == 0 and x >= 0 ) : print ( "Yes" )                else : print ( "No" ) NEWLINE NL ENDMARKER
def isPowerOfFour ( n ) : NEWLINE INDENT return ( n != 0 and ( ( n & ( n - 1 ) ) == 0 ) and not ( n & 0xAAAAAAAA ) ) ; NEWLINE DEDENT test_no = 64 ; NEWLINE if ( isPowerOfFour ( test_no ) ) : NEWLINE INDENT print ( test_no , "is a power of 4" ) ; NEWLINE DEDENT else : NEWLINE INDENT print ( test_no , "is not a power of 4" ) ; NEWLINE NL DEDENT ENDMARKER
def minimumX ( n , k ) : NEWLINE INDENT ans = 10 ** 18 NEWLINE for i in range ( k - 1 , 0 , - 1 ) : NEWLINE INDENTINDENT if n % i == 0 : NEWLINE INDENTINDENTINDENT ans = min ( ans , i + ( n / i ) * k ) NEWLINE DEDENT DEDENT return ans NEWLINE DEDENT n , k = 4 , 6 NEWLINE print ( minimumX ( n , k ) ) NEWLINE n , k = 5 , 5 NEWLINE print ( minimumX ( n , k ) ) NEWLINE NL ENDMARKER
def compute ( ) : NEWLINE INDENT return "0" NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( compute ( ) ) NEWLINE NL DEDENT ENDMARKER
h , l = map ( int , input ( ) . split ( ) ) c = ( h * h + l * l ) ** 0.5 a = ( c * c ) / ( 2 * h ) print ( a - h ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) poles = [ ] for _ in range ( n ) : poles . append ( input ( ) ) num_groups = 1 for i in range ( n - 1 ) : if not int ( poles [ i ] [ 1 ] ) ^ int ( poles [ i + 1 ] [ 0 ] ) : num_groups += 1 print ( num_groups ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) NEWLINE for i in range ( t ) : NEWLINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEWLINE if l * 2 > r : NEWLINE INDENTINDENT print ( - 1 , - 1 ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( l , l * 2 ) NEWLINE NL DEDENT DEDENT ENDMARKER
def findMinDifference ( arr , n ) : NEWLINE INDENT arr . sort ( ) NEWLINE diff1 = arr [ n - 1 ] - arr [ 1 ] NEWLINE diff2 = arr [ n - 2 ] - arr [ 0 ] NEWLINE return min ( diff1 , diff2 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 1 , 2 , 4 , 3 , 4 ] NEWLINE n = len ( arr ) NEWLINE print ( findMinDifference ( arr , n ) ) NEWLINE NL DEDENT ENDMARKER
def minimumCost ( cost , n ) : NEWLINE INDENT dp1 = 0 NEWLINE dp2 = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEWLINE dp2 = dp1 NEWLINE dp1 = dp0 NEWLINE DEDENT return min ( dp1 , dp2 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = [ 2 , 5 , 3 , 1 , 7 , 3 , 4 ] NEWLINE n = len ( a ) NEWLINE print ( minimumCost ( a , n ) ) NEWLINE NL DEDENT ENDMARKER
def summ ( n ) : NEWLINE INDENT suum = ( n * ( n + 1 ) ) // 2 NEWLINE return suum NEWLINE DEDENT def repeatedSum ( n , k ) : NEWLINE INDENT for i in range ( k ) : NEWLINE INDENTINDENT n = summ ( n ) NEWLINE DEDENT return n NEWLINE DEDENT n = 2 NEWLINE k = 2 NEWLINE print ( repeatedSum ( n , k ) ) NEWLINE NL ENDMARKER
def printDistinct ( arr , n ) : NEWLINE INDENT s = dict ( ) ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT if ( arr [ i ] not in s . keys ( ) ) : NEWLINE INDENTINDENTINDENT s [ arr [ i ] ] = arr [ i ] ; NEWLINE print ( arr [ i ] , end = " " ) ; NEWLINE DEDENT DEDENT DEDENT arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ] ; NEWLINE n = 7 ; NEWLINE printDistinct ( arr , n ) ; NEWLINE NL ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT if n <= 1 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT fact = 1 NEWLINE for i in range ( 1 , N ) : NEWLINE INDENTINDENT fact = fact * i NEWLINE DEDENT return fact NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 3 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
def fact ( N ) : NEWLINE INDENT product = 1 NEWLINE for i in range ( 1 , N + 1 ) : NEWLINE INDENTINDENT product = product * i NEWLINE DEDENT return product NEWLINE DEDENT def nthTerm ( N ) : NEWLINE INDENT return ( N * N ) * fact ( N ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 4 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
import sysinput = sys . stdin . readline  n = int ( input ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] res = [ int ( i ) for i in a if i > 0 ] print ( len ( set ( res ) ) ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for z in range ( t ) : n , x = input ( ) . split ( ) n = int ( n ) x = int ( x ) print ( 2 * x ) NEWLINE NL ENDMARKER
def updateArray ( arr , n ) : NEWLINE INDENT for i in range ( n - 1 ) : NEWLINE INDENTINDENT arr [ i ] = arr [ i + 1 ] NEWLINE DEDENT arr [ n - 1 ] = - 1 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT print ( arr [ i ] , end = " " ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEWLINE N = len ( arr ) NEWLINE updateArray ( arr , N ) NEWLINE NL DEDENT ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) print ( min ( max ( m , 1 ) , n - m ) ) NEWLINE NL ENDMARKER
import math as mt NEWLINE def polydiagonal ( n , a ) : NEWLINE INDENT if ( a < 0 and n < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT return ( 2 * a * mt . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) NEWLINE DEDENT a , n = 9 , 10 NEWLINE print ( polydiagonal ( n , a ) ) NEWLINE NL ENDMARKER
a , b , c = 5 , 7 , 10 NEWLINE if ( a <= b and a <= c ) : NEWLINE INDENT print ( a , "is the smallest" ) NEWLINE DEDENT elif ( b <= a and b <= c ) : NEWLINE INDENT print ( b , "is the smallest" ) NEWLINE DEDENT else : NEWLINE INDENT print ( c , "is the smallest" ) NEWLINE NL DEDENT ENDMARKER
n = input ( ) num = int ( n ) x = list ( map ( int , n . strip ( ) ) ) y = list ( n . strip ( ) )   if len ( x ) == 1 and x != "5" : if x [ 0 ] > 5 : print ( 10 ) else : print ( 0 ) else : if int ( x [ - 1 ] ) < 5 : y [ - 1 ] = "0" print ( '' . join ( y ) )  else :  while ( n [ - 1 ] != "0" ) : num = num + 1 n = str ( num ) if n [ - 1 ] == "0" : print ( num ) NEWLINE NL ENDMARKER
print ( ( int ( input ( ) ) * 2 + 1 ) // 3 ) NEWLINE NL ENDMARKER
def countIntegralSolutions ( n ) : NEWLINE INDENT return int ( ( ( n + 1 ) * ( n + 2 ) ) / 2 ) NEWLINE DEDENT n = 3 NEWLINE print ( countIntegralSolutions ( n ) ) NEWLINE NL ENDMARKER
def calculateSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT sum = sum + ( 1 << i ) NEWLINE DEDENT return sum NEWLINE DEDENT n = 10 NEWLINE print ( "Sum of series " , calculateSum ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) for i in range ( n ) : print ( 3 * n + i )  NEWLINE NL ENDMARKER
from itertools import cyclest = 'abcdefghijklmnopqrstuvwxyz' ls = list ( map ( int , input ( ) . split ( ) ) ) l , k = ls [ 0 ] , ls [ 1 ] os = '' ls = list ( st [ 0 : k ] ) pool = cycle ( ls ) while len ( os ) < l : os += next ( pool ) print ( os ) NEWLINE NL ENDMARKER
n = input ( )  l = len ( n ) f = int ( n [ 0 ] ) f = f + 1  n = int ( n )  x = 1 for i in range ( l - 1 ) : x = x * 10  print ( f * x - n )   NEWLINE NL ENDMARKER
n = input ( ) l = n . split ( ) l [ 0 ] = int ( l [ 0 ] ) l [ 1 ] = int ( l [ 1 ] ) l [ 2 ] = int ( l [ 2 ] ) if l [ 1 ] // l [ 0 ] < 1 or l [ 2 ] // l [ 0 ] < 1 : print ( 'No' ) else : print ( 'Yes' ) NEWLINE NL ENDMARKER
def isDivisible ( n ) : NEWLINE INDENT temp = n NEWLINE sum = 0 ; NEWLINE while ( n ) : NEWLINE INDENTINDENT k = n % 10 ; NEWLINE sum += k ; NEWLINE n /= 10 ; NEWLINE DEDENT if ( temp % sum == 0 ) : NEWLINE INDENTINDENT return "YES" ; NEWLINE DEDENT return "NO" ; NEWLINE DEDENT n = 123 ; NEWLINE print ( isDivisible ( n ) ) ; NEWLINE NL ENDMARKER
def isDivisible ( n ) : NEWLINE INDENT temp = n NEWLINE while ( n ) : NEWLINE INDENTINDENT k = n % 10 NEWLINE if ( temp % k == 0 ) : NEWLINE INDENTINDENTINDENT return "YES" NEWLINE DEDENT n /= 10 ; NEWLINE DEDENT return "NO" NEWLINE DEDENT n = 9876543 NEWLINE print ( isDivisible ( n ) ) NEWLINE NL ENDMARKER
def printAsMaximalPrimeSum ( n ) : NEWLINE INDENT if ( n % 2 == 1 ) : NEWLINE INDENTINDENT print ( "3 " , end = "" ) NEWLINE n -= 3 NEWLINE DEDENT while ( n > 0 ) : NEWLINE INDENTINDENT print ( "2 " , end = "" ) NEWLINE n -= 2 NEWLINE DEDENT DEDENT n = 5 NEWLINE printAsMaximalPrimeSum ( n ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) mod = 10 ** 9 + 7 for _ in range ( t ) : x = int ( input ( ) ) s = input ( ) i = 1 while len ( s ) < x : s += s [ i : ] * ( ord ( s [ i - 1 ] ) - 49 ) i += 1 l = len ( s ) while i <= x : l = ( l + ( l - i ) * ( ord ( s [ i - 1 ] ) - 49 ) ) % mod i += 1 print ( l ) NEWLINE NL ENDMARKER
input ( ) ; a , b , c , d = map ( input ( ) . count , ( '1' , '2' , '3' , '4' ) ) ; print ( d + c + ( b * 2 + max ( 0 , a - c ) + 3 ) // 4 ) NEWLINE NL ENDMARKER
def gcd ( a , b ) : NEWLINE INDENT if a == 0 : NEWLINE INDENTINDENT return b NEWLINE DEDENT return gcd ( b % a , a ) NEWLINE DEDENT def lcm ( a , b ) : NEWLINE INDENT return ( a * b ) / gcd ( a , b ) NEWLINE DEDENT a = 15 NEWLINE b = 20 NEWLINE print ( 'LCM of' , a , 'and' , b , 'is' , lcm ( a , b ) ) NEWLINE NL ENDMARKER
def printPossible ( a , b , c ) : NEWLINE INDENT if ( ( a + b + c ) % 2 != 0 or a + b < c ) : NEWLINE INDENTINDENT print ( "NO" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "YES" ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT a = 2 NEWLINE b = 4 NEWLINE c = 2 NEWLINE printPossible ( a , b , c ) NEWLINE NL DEDENT ENDMARKER
import math  n = int ( input ( ) )  res = [ ] sqrt = int ( math . sqrt ( n ) ) if sqrt * sqrt >= n : print ( sqrt * 2 ) elif ( sqrt + 1 ) * sqrt >= n : print ( sqrt * 2 + 1 ) elif ( sqrt + 1 ) * ( sqrt + 1 ) >= n : print ( sqrt * 2 + 2 ) NEWLINE NL ENDMARKER
import math  def is_prime ( n ) : for i in range ( 2 , n ) : if not n % i : return False return True   def main_function ( ) : n = int ( input ( ) ) m = 1 while is_prime ( n * m + 1 ) : m += 1 return m        print ( main_function ( ) ) NEWLINE NL ENDMARKER
n = sorted ( list ( input ( ) ) )  NEWLINE NL ENDMARKER
def maxOR ( arr , n ) : NEWLINE INDENT maxVal = 0 ; NEWLINE for i in range ( n - 1 ) : NEWLINE INDENTINDENT for j in range ( i + 1 , n ) : NEWLINE INDENTINDENTINDENT maxVal = max ( maxVal , arr [ i ] | arr [ j ] ) ; NEWLINE DEDENT DEDENT return maxVal ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 4 , 8 , 12 , 16 ] ; NEWLINE n = len ( arr ) ; NEWLINE print ( maxOR ( arr , n ) ) ; NEWLINE NL DEDENT ENDMARKER
def check ( n , m ) : NEWLINE INDENT if ( n == 2 or m == 2 or n % m == 0 ) : NEWLINE INDENTINDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) NEWLINE DEDENT DEDENT m = 3 NEWLINE n = 9 NEWLINE check ( n , m ) NEWLINE NL ENDMARKER
def Rate ( N1 , N2 ) : NEWLINE INDENT rate = ( N2 - N1 ) * 100 // ( N1 ) ; NEWLINE return rate NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N1 = 100 NEWLINE N2 = 120 NEWLINE print ( Rate ( N1 , N2 ) , " %" ) NEWLINE NL DEDENT ENDMARKER
n , a = map ( int , input ( ) . split ( ) ) criminals = [ int ( i ) for i in input ( ) . split ( ) ] if ( n == 1 or n == 2 ) : print ( criminals . count ( 1 ) ) else : if ( a - 1 < n - a ) : x = a - 1 c1 = criminals [ : 2 * a - 1 ] c2 = criminals [ 2 * a - 1 : ] else : x = n - a c2 = criminals [ : n - 2 * ( n - a ) - 1 ] c1 = criminals [ n - 2 * ( n - a ) - 1 : ] NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = [ int ( i ) for i in input ( ) . split ( ' ' ) ] output = 0 for i in range ( n ) : if ( a [ i ] >= 0 ) : output += a [ i ] else : output -= a [ i ] print ( output ) NEWLINE NL ENDMARKER
for i in range ( int ( input ( ) ) ) : L = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE L . sort ( ) NEWLINE a = L [ 0 ] NEWLINE b = L [ 1 ] NEWLINE c = L [ 2 ] NEWLINE print ( int ( ( ( c - a ) ** 2 + b ** 2 ) ** 0.5 + 0.5 ) ) NEWLINE NL ENDMARKER
t = input ( ) p = input ( ) n = len ( t ) m = len ( p ) a = [ int ( i ) for i in input ( ) . split ( ) ] l = 0 r = n - 1 while ( l < r ) : mid = ( r + l ) // 2 f = [ 0 ] * n for i in range ( mid + 1 ) : f [ a [ i ] - 1 ] = 1 c = 0 for i in range ( n ) : if ( f [ i ] == 0 and t [ i ] == p [ c ] ) : c += 1 if ( c == m ) : break if ( c == m ) : l = mid + 1 else : r = midprint ( l ) NEWLINE NL ENDMARKER
from math import gcd as __gcd NEWLINE def findLargest ( arr , n ) : NEWLINE INDENT gcd = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT gcd = __gcd ( arr [ i ] , gcd ) NEWLINE DEDENT return gcd NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 3 , 6 , 9 ] NEWLINE n = len ( arr ) NEWLINE print ( findLargest ( arr , n ) ) NEWLINE NL DEDENT ENDMARKER
def countX ( n ) : NEWLINE INDENT binary = "{0:b}" . format ( n ) NEWLINE count = 0 NEWLINE for i in range ( len ( binary ) ) : NEWLINE INDENTINDENT if ( binary [ i ] == '1' ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT answer = int ( pow ( 2 , count ) ) NEWLINE return answer NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 5 NEWLINE answer = countX ( n ) NEWLINE print ( answer ) NEWLINE NL DEDENT ENDMARKER
l = int ( input ( ) ) def split ( num ) : return list ( num ) for i in range ( l + 1 , 9013 ) : u = str ( i ) v = split ( u ) o = set ( v ) if len ( o ) == 4 : v = i breakprint ( v ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) fours , twos , ones = n , 2 * n , 0 NEWLINE NL ENDMARKER
from sys import stdin , stdout  def main ( ) : for _ in range ( int ( stdin . readline ( ) ) ) : n , k = map ( int , stdin . readline ( ) . split ( ' ' ) ) if n <= k : stdout . write ( str ( k - n ) + '\n' ) else : stdout . write ( str ( ( n - k ) % 2 ) + '\n' )  if __name__ == "__main__" : main ( ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) li = list ( map ( int , input ( ) . split ( ) ) ) st = Falseres = 0 for i in range ( n - 1 ) : if i == 0 : res += abs ( li [ i ] ) res += abs ( li [ i ] - li [ i + 1 ] ) print ( res ) NEWLINE NL ENDMARKER
def calculateSum ( n , k ) : NEWLINE INDENT res = 1 NEWLINE MOD = 1000000007 NEWLINE for i in range ( 0 , k ) : NEWLINE INDENTINDENT res = ( res * n ) % MOD NEWLINE DEDENT return res NEWLINE DEDENT n = 4 NEWLINE k = 3 NEWLINE print ( calculateSum ( n , k ) ) NEWLINE NL ENDMARKER
def pentagon_pyramidal ( n ) : NEWLINE INDENT return n * n * ( n + 1 ) / 2 NEWLINE DEDENT n = 4 NEWLINE print ( int ( pentagon_pyramidal ( n ) ) ) NEWLINE NL ENDMARKER
def printSumSeries ( N ) : NEWLINE INDENT sum = 0 ; NEWLINE for i in range ( 1 , N + 1 ) : NEWLINE INDENTINDENT sum += 1.0 / ( 2 * i - 1 ) ; NEWLINE DEDENT print ( sum ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 6 ; NEWLINE printSumSeries ( N ) ; NEWLINE NL DEDENT ENDMARKER
def seriessum ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT sum += i * ( i + 1 ) / 2 NEWLINE DEDENT return sum NEWLINE DEDENT n = 4 NEWLINE print ( seriessum ( n ) ) NEWLINE NL ENDMARKER
sticks = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] ; NEWLINE def countSticks ( string , n ) : NEWLINE INDENT cnt = 0 ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT cnt += ( sticks [ ord ( string [ i ] ) - ord ( '0' ) ] ) ; NEWLINE DEDENT return cnt ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT string = "56" ; NEWLINE n = len ( string ) ; NEWLINE print ( countSticks ( string , n ) ) ; NEWLINE NL DEDENT ENDMARKER
from math import combif __name__ == '__main__' : n , m , h = map ( int , input ( ) . split ( ) ) h -= 1  arr = [ int ( i ) for i in input ( ) . split ( ) ] arr [ h ] -= 1 n -= 1  total = sum ( arr ) if total < n : print ( - 1 ) exit ( 0 ) ans = comb ( total - arr [ h ] , n ) / comb ( total , n ) print ( 1 - ans ) NEWLINE NL ENDMARKER
x = int ( input ( ) ) y = 2 while x % y != 0 : y += 1 print ( y , x // y , sep = '' ) NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) print ( min ( a , b ) , abs ( a - b ) // 2 ) NEWLINE NL ENDMARKER
def nthTerm ( N ) : NEWLINE INDENT return ( N * ( ( N // 2 ) + ( ( N % 2 ) * 2 ) + N ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 5 NEWLINE print ( "Nth term for N = " , N , " : " , nthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
def generateSequence ( n , g ) : NEWLINE INDENT for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT print ( i * g , end = " " ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n , g = 6 , 5 NEWLINE generateSequence ( n , g ) NEWLINE NL DEDENT ENDMARKER
l , r = [ int ( j ) for j in input ( ) . split ( ) ] count = 0 for j in range ( 32 ) : for k in range ( 32 ) : res = ( 2 ** j ) * ( 3 ** k ) if res >= l and res <= r : count += 1 print ( count ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) q = 0 while n != m : m = [ m // 2 , m + 1 ] [ m & 1 or m < n ] q += 1 print ( q ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) a = sorted ( list ( set ( map ( int , input ( ) . split ( ) ) ) ) ) for i in range ( k ) : if i == 0 : print ( a [ i ] ) elif i < len ( a ) : print ( a [ i ] - a [ i - 1 ] ) else : print ( 0 ) NEWLINE NL ENDMARKER
def Digits ( n ) : NEWLINE INDENT largest = 0 NEWLINE smallest = 9 NEWLINE while ( n ) : NEWLINE INDENTINDENT r = n % 10 NEWLINE largest = max ( r , largest ) NEWLINE smallest = min ( r , smallest ) NEWLINE n = n // 10 NEWLINE DEDENT print ( largest , smallest ) NEWLINE DEDENT n = 2346 NEWLINE Digits ( n ) NEWLINE NL ENDMARKER
from math import sqrt NEWLINE def find_Area ( a ) : NEWLINE INDENT R = a * ( 2.0 - sqrt ( 2 ) ) ; NEWLINE area = 3.14 * R * R / 2.0 ; NEWLINE return area ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = 4 ; NEWLINE print ( "Area of semicircle =" , find_Area ( a ) ) ; NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) f = False  for i in range ( 32 ) : if i * ( i + 1 ) / 2 == n : f = True break print ( 'YES' if f else 'NO' ) NEWLINE NL ENDMARKER
def Circumference ( a ) : NEWLINE INDENT return ( 4 * a ) NEWLINE DEDENT a = 5 NEWLINE c = Circumference ( a ) NEWLINE print ( "Circumference of a " + "square is % d" % ( c ) ) NEWLINE NL ENDMARKER
def onlyFirstAndLastAreSet ( n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT return True NEWLINE DEDENT if ( n == 2 ) : NEWLINE INDENTINDENT return False NEWLINE DEDENT return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) NEWLINE DEDENT n = 9 NEWLINE if ( onlyFirstAndLastAreSet ( n ) ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
def decdiagonal ( a ) : NEWLINE INDENT if ( a < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT d = 1.902 * a NEWLINE return d NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = 9 NEWLINE print ( decdiagonal ( a ) ) NEWLINE NL DEDENT ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) while n > 0 and m > 0 : if n >= 2 * m : n = n % ( 2 * m ) elif m >= 2 * n : m = m % ( 2 * n ) else : breakprint ( n , m , sep = " " )  NEWLINE NL ENDMARKER
print ( 25 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) i = 0 a = [ ] a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) while i < len ( a ) : print ( a [ i ] ) i = i + 1 NEWLINE NL ENDMARKER
import sys NEWLINE def minimum_cost ( a , n ) : NEWLINE INDENT mn = sys . maxsize NEWLINE sum = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT mn = min ( a [ i ] , mn ) NEWLINE sum += a [ i ] NEWLINE DEDENT return mn * ( sum - mn ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = [ 4 , 3 , 2 , 5 ] NEWLINE n = len ( a ) NEWLINE print ( minimum_cost ( a , n ) ) NEWLINE NL DEDENT ENDMARKER
  n , b = map ( int , input ( ) . split ( ) )  t = list ( map ( int , input ( ) . split ( ) ) )  ans = 0  ma = 999999999 mi = 0 for i in range ( n ) :  if t [ i ] < ma : ma = t [ i ] elif t [ i ] > ma : temp = b // ma  rest = b - ( b // ma ) * ma rest += ( temp ) * t [ i ]  ans = max ( rest , ans )  print ( max ( ans , b ) )                         NEWLINE NL ENDMARKER
def SubArraySum ( arr , n ) : NEWLINE INDENT temp , result = 0 , 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT temp = 0 ; NEWLINE for j in range ( i , n ) : NEWLINE INDENTINDENTINDENT temp += arr [ j ] NEWLINE result += temp NEWLINE DEDENT DEDENT return result NEWLINE DEDENT arr = [ 1 , 2 , 3 ] NEWLINE n = len ( arr ) NEWLINE print ( "Sum of SubArray :" , SubArraySum ( arr , n ) ) NEWLINE NL ENDMARKER
s1 = input ( ) s2 = input ( ) t1 = 0 t2 = 0  for i in range ( 0 , len ( s1 ) , 2 ) : if s1 [ i ] == '[' : if s2 [ i ] == '(' : t1 += 1 if s2 [ i ] == '8' : t2 += 1 if s1 [ i ] == '(' : if s2 [ i ] == '[' : t2 += 1 if s2 [ i ] == '8' : t1 += 1 if s1 [ i ] == '8' : if s2 [ i ] == '(' : t2 += 1 if s2 [ i ] == '[' : t1 += 1 if ( t1 > t2 ) : print ( "TEAM 1 WINS" ) elif ( t1 < t2 ) : print ( "TEAM 2 WINS" ) else : print ( "TIE" ) NEWLINE NL ENDMARKER
def largestNum ( a , b ) : NEWLINE INDENT return a * ( bool ) ( a // b ) + \ NEWLINE INDENTINDENT b * ( bool ) ( b // a ) ; NEWLINE DEDENT DEDENT a = 22 ; NEWLINE b = 1231 ; NEWLINE print ( largestNum ( a , b ) ) ; NEWLINE NL ENDMARKER
t = int ( input ( ) ) NEWLINE for i in range ( t ) : n , x = map ( int , input ( ) . split ( ) ) NEWLINE count = 1 NEWLINE t = 3 NEWLINE while t <= n : t += x NEWLINE count += 1 NEWLINE print ( count ) NEWLINE NL ENDMARKER
def divisorSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT sum += int ( n / i ) * i NEWLINE DEDENT return int ( sum ) NEWLINE DEDENT n = 4 NEWLINE print ( divisorSum ( n ) ) NEWLINE n = 5 NEWLINE print ( divisorSum ( n ) ) NEWLINE NL ENDMARKER
def sumDivisibles ( A , B , M ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( A , B + 1 ) : NEWLINE INDENTINDENT if ( i % M == 0 ) : NEWLINE INDENTINDENTINDENT sum += i NEWLINE DEDENT DEDENT return sum NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT A = 6 NEWLINE B = 15 NEWLINE M = 3 NEWLINE print ( sumDivisibles ( A , B , M ) ) NEWLINE NL DEDENT ENDMARKER
t = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE NL ENDMARKER
def sum ( arr , n ) : NEWLINE INDENT sum = 0 NEWLINE for i in arr : NEWLINE INDENTINDENT sum += i NEWLINE DEDENT sum = sum * pow ( 2 , n - 1 ) NEWLINE return sum NEWLINE DEDENT arr = [ 2 , 1 , 5 , 6 ] NEWLINE n = len ( arr ) NEWLINE print ( sum ( arr , n ) ) NEWLINE NL ENDMARKER
for nt in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE a = list ( input ( ) ) NEWLINE print ( "" . join ( sorted ( a ) ) ) NEWLINE NL ENDMARKER
l , b = map ( int , input ( ) . split ( ) ) years = 0 while l <= b : l *= 3 b *= 2 years += 1 print ( years ) NEWLINE NL ENDMARKER
def multiply ( x , y ) : NEWLINE INDENT if ( y == 0 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT if ( y > 0 ) : NEWLINE INDENTINDENT return ( x + multiply ( x , y - 1 ) ) NEWLINE DEDENT if ( y < 0 ) : NEWLINE INDENTINDENT return - multiply ( x , - y ) NEWLINE DEDENT DEDENT print ( multiply ( 5 , - 11 ) ) NEWLINE NL ENDMARKER
def SellingPrice ( CP , PP ) : NEWLINE INDENT Pdecimal = 1 + ( PP / 100 ) NEWLINE res = Pdecimal * CP NEWLINE return res NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT C = 720 NEWLINE P = 13 NEWLINE print ( SellingPrice ( C , P ) ) NEWLINE NL DEDENT ENDMARKER
def bit_check ( n ) : NEWLINE INDENT if ( ( n & ( n - 1 ) ) == 0 ) : NEWLINE INDENTINDENT return True NEWLINE DEDENT return False NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 14 NEWLINE if ( bit_check ( n ) ) : NEWLINE INDENTINDENT print ( '1' ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( '0' ) NEWLINE NL DEDENT DEDENT ENDMARKER
x , y , z = [ int ( x ) for x in input ( "" ) . split ( ) ]  n = x / 2  if ( ( y == n or y == n + 1 ) and ( z == n or z == n + 1 ) ) : print ( "NO" ) else : print ( "YES" ) NEWLINE NL ENDMARKER
def findSum ( arr , n , k ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT if arr [ i ] % k == 0 : NEWLINE INDENTINDENTINDENT sum += arr [ i ] NEWLINE DEDENT DEDENT return sum NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 15 , 16 , 10 , 9 , 6 , 7 , 17 ] NEWLINE n = len ( arr ) NEWLINE k = 3 NEWLINE print ( findSum ( arr , n , k ) ) NEWLINE NL DEDENT ENDMARKER
def getMinNum ( a , b , c ) : NEWLINE INDENT if ( c < a or c > b ) : NEWLINE INDENTINDENT return c NEWLINE DEDENT x = ( ( b // c ) * c ) + c NEWLINE return x NEWLINE DEDENT a , b , c = 2 , 4 , 4 NEWLINE print ( getMinNum ( a , b , c ) ) NEWLINE NL ENDMARKER
import mathn = input ( ) if n == '0' : print ( 0 ) else : k = int ( n , 2 ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) res = [ ] v = [ 0 ] * ( 10 ** 5 + 1 ) k1 = k2 = 0 h = [ 0 ] * ( 10 ** 5 + 1 ) for i in range ( m ) : x , y = map ( int , input ( ) . split ( ) ) if not v [ x ] or not h [ y ] : if not v [ x ] : v [ x ] = 1 k1 += 1 if not h [ y ] : h [ y ] = 1 k2 += 1 res += [ ( n - k1 ) * ( n - k2 ) ] else : res += [ res [ - 1 ] ] print ( * res , sep = '\n' ) NEWLINE NL ENDMARKER
import math NEWLINE def sumOfSeries ( n ) : NEWLINE INDENT return int ( ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ) NEWLINE DEDENT n = 10 NEWLINE print ( sumOfSeries ( n ) ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) y = [ 0 ] * nfor i in range ( m ) : c = x [ i ] while x [ i ] <= n : b = x [ i ] - 1 if y [ b ] != 0 : break else : y [ b ] = c b += 1 x [ i ] += 1  for j in range ( n ) : print ( y [ j ] , end = ' ' ) NEWLINE NL ENDMARKER
def nth_group ( n ) : NEWLINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEWLINE DEDENT N = 5 NEWLINE print ( nth_group ( N ) ) NEWLINE NL ENDMARKER
cities , tank = map ( int , input ( ) . split ( ) )  fuel_cost = 0  NEWLINE NL ENDMARKER
n = int ( input ( ) ) b = list ( map ( int , input ( ) . split ( ) ) ) a = [ 0 ] * ncount = abs ( b [ 0 ] ) for i in range ( 1 , n ) : count += abs ( b [ i ] - b [ i - 1 ] ) print ( count ) NEWLINE NL ENDMARKER
import math  ans = [ ] n , m = map ( int , input ( ) . split ( ) ) for i in range ( 1 , n + 1 ) : ans . append ( [ 2 * i - 1 , 2 * i ] )  current = 0 i = 0 while current != 2 * m and i < n : if current < m and i < n : ans [ i ] [ 0 ] , ans [ i ] [ 1 ] = ans [ i ] [ 1 ] , ans [ i ] [ 0 ] current += 1 i += 1 for i in ans : print ( * i , end = " " ) NEWLINE NL ENDMARKER
import math NEWLINE def cone ( a ) : NEWLINE INDENT if ( a < 0 ) : NEWLINE INDENTINDENT return - 1 ; NEWLINE DEDENT r = ( a * math . sqrt ( 2 ) ) / 3 ; NEWLINE h = ( 2 * a ) / 3 ; NEWLINE V = 3.14 * math . pow ( r , 2 ) * h ; NEWLINE return V ; NEWLINE DEDENT a = 5 ; NEWLINE print ( cone ( a ) ) ; NEWLINE NL ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return 4 * pow ( n , 2 ) - 3 * n + 2 NEWLINE DEDENT N = 4 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL ENDMARKER
def rectanglearea ( a , b ) : NEWLINE INDENT if a < 0 or b < 0 : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT return 2 * a * b NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a , b = 10 , 8 NEWLINE print ( rectanglearea ( a , b ) ) NEWLINE NL DEDENT ENDMARKER
k = int ( input ( ) ) s = str ( input ( ) ) s = list ( s ) d = { } for i in s : d [ i ] = s . count ( i ) cnt = 0 s1 = '' for j in d : if d [ j ] % k == 0 : cnt += 1 s1 += ( j * int ( d [ j ] / k ) ) if cnt != len ( d ) : print ( - 1 ) else : print ( s1 * k ) NEWLINE NL ENDMARKER
a , b , c = ( int ( x ) for x in input ( ) . split ( ) ) r = 0 for x in range ( c ) : r += ( ( ( a - x * 4 ) + ( b - x * 4 ) - 2 ) * 2 ) print ( r ) NEWLINE NL ENDMARKER
def nthTerm ( N ) : NEWLINE INDENT nth = 0 NEWLINE for i in range ( N , 0 , - 1 ) : NEWLINE INDENTINDENT nth += pow ( i , i ) NEWLINE DEDENT return nth NEWLINE DEDENT N = 3 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL ENDMARKER
d , l , v1 , v2 = map ( int , input ( ) . split ( ) ) print ( ( l - d ) / ( v1 + v2 ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) x = list ( map ( int , input ( ) . split ( ) ) ) a , m = 2 , 2 if n <= 1 : m = 1 for i in range ( 2 , n ) : if x [ i ] == x [ i - 1 ] + x [ i - 2 ] : a += 1 else : a = 2 m = max ( m , a ) print ( m ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) lucky = [ 4 , 7 , 47 , 74 , 447 , 474 , 477 , 774 , 747 , 744 ] count = 0 for i in range ( len ( lucky ) ) : if ( ( n == lucky [ i ] ) or ( n % lucky [ i ] == 0 ) ) : print ( 'YES' ) break else : count += 1 if count == 10 : print ( 'NO' ) NEWLINE NL ENDMARKER
def arraySum ( arr , n ) : NEWLINE INDENT _sum = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT _sum = _sum + arr [ i ] NEWLINE DEDENT return _sum NEWLINE DEDENT arr = [ 10 , 11 , 12 , 13 , 12 , 11 , 10 ] NEWLINE n = len ( arr ) NEWLINE print ( arraySum ( arr , n ) ) NEWLINE NL ENDMARKER
def numberOfWays ( x ) : NEWLINE INDENT if x == 0 or x == 1 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) NEWLINE DEDENT DEDENT x = 3 NEWLINE print ( numberOfWays ( x ) ) NEWLINE NL ENDMARKER
for t in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( " " ) ) NEWLINE print ( ( "abc" * n ) [ : n ] ) NEWLINE NL ENDMARKER
import math  n = int ( input ( ) ) answer = "" if n < 3 : print ( 1 ) else : print ( 2 )  m = n + 2 numbers = [ True ] * mnumbers [ 0 ] = Falsenumbers [ 1 ] = False  for i in range ( 2 , int ( math . sqrt ( m ) ) + 1 ) : j = 0 while i ** 2 + j * i < m : numbers [ i ** 2 + j * i ] = False j += 1  for i in range ( 2 , m ) : if numbers [ i ] : answer += "1 " else : answer += "2 "  answer = answer [ : - 1 ] print ( answer ) NEWLINE NL ENDMARKER
def frequency ( a , x ) : NEWLINE INDENT count = 0 NEWLINE for i in a : NEWLINE INDENTINDENT if i == x : count += 1 NEWLINE DEDENT return count NEWLINE DEDENT a = [ 0 , 5 , 5 , 5 , 4 ] NEWLINE x = 5 NEWLINE print ( frequency ( a , x ) ) NEWLINE NL ENDMARKER
print ( len ( bin ( int ( input ( ) ) ) [ 2 : ] ) ) NEWLINE NL ENDMARKER
def check ( s ) : NEWLINE INDENT n = len ( s ) NEWLINE for i in range ( n - 1 ) : NEWLINE INDENTINDENT if ( s [ i ] > s [ i + 1 ] ) : NEWLINE INDENTINDENTINDENT return True NEWLINE DEDENT DEDENT return False NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT s = "geeksforgeeks" NEWLINE if ( check ( s ) ) : NEWLINE INDENTINDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) NEWLINE NL DEDENT DEDENT ENDMARKER
x1 = 2 ; x2 = 1 ; x3 = 3 ; NEWLINE y1 = 2 ; y2 = 1 ; y3 = 1 ; NEWLINE a = 2 ; b = 1 ; c = 1 ; NEWLINE x = ( a * x1 + b * x2 + c * x3 ) / ( a + b + c ) ; NEWLINE y = ( a * y1 + b * y2 + c * y3 ) / ( a + b + c ) ; NEWLINE print ( "Incenter = (" , x , "," , y , ")" ) ; NEWLINE NL ENDMARKER
import math  n = int ( input ( ) ) print ( math . ceil ( n / 2 ) - 1 ) NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def findTheDifference ( self , s , t ) : NEWLINE INDENTINDENT res = ord ( t [ - 1 ] ) NEWLINE for i in range ( len ( s ) ) : NEWLINE INDENTINDENTINDENT res += ord ( t [ i ] ) NEWLINE res -= ord ( s [ i ] ) NEWLINE DEDENT return chr ( res ) NEWLINE NL DEDENT DEDENT ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) if n % 2 == 0 : print ( 'No' ) else : if a [ 0 ] % 2 == 0 or a [ - 1 ] % 2 == 0 : print ( 'No' ) else : print ( 'Yes' ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) NEWLINE for i in range ( t ) : n , x = map ( int , input ( ) . split ( ) ) NEWLINE if n == 1 or n == 2 : NEWLINE INDENT print ( 1 ) else : NEWLINE print ( ( n - 3 ) // x + 2 ) NEWLINE NL DEDENT ENDMARKER
y , k , n = map ( int , input ( ) . split ( ) ) c = int ( y // k ) + 1 if y >= n or c * k not in range ( y , n + 1 ) : print ( - 1 ) else : c = int ( y // k ) + 1 arr = [ x - y for x in range ( c * k , n + 1 , k ) ] print ( * arr ) NEWLINE NL ENDMARKER
def innerCirclearea ( radius ) : NEWLINE INDENT if ( radius < 0 ) : NEWLINE INDENTINDENT return - 1 ; NEWLINE DEDENT r = radius / 2 ; NEWLINE Area = ( 3.14 * pow ( r , 2 ) ) ; NEWLINE return Area ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT radius = 4 ; NEWLINE print ( "Area of circle c2 =" , innerCirclearea ( radius ) ) ; NEWLINE NL DEDENT ENDMARKER
s = int ( input ( ) ) p = int ( input ( ) ) q = int ( input ( ) ) print ( s * p / ( p + q ) ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) i = 0 while i < n and k > 0 and a [ i ] < 0 : a [ i ] = - 1 * a [ i ] i += 1 k -= 1 a = sorted ( a ) if k % 2 == 1 : a [ 0 ] = - 1 * a [ 0 ] print ( sum ( a ) ) NEWLINE NL ENDMARKER
from sys import stdin , stdoutinput = stdin . readline def main ( ) : t = int ( input ( ) ) NEWLINE NL ENDMARKER
from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect  NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def firstUniqChar ( self , s ) : NEWLINE INDENTINDENT count_map = { } NEWLINE for c in s : NEWLINE INDENTINDENTINDENT count_map [ c ] = count_map . get ( c , 0 ) + 1 NEWLINE DEDENT for i , c in enumerate ( s ) : NEWLINE INDENTINDENTINDENT if count_map [ c ] == 1 : NEWLINE INDENTINDENTINDENTINDENT return i NEWLINE DEDENT DEDENT return - 1 NEWLINE NL DEDENT DEDENT ENDMARKER
import math NEWLINE def nextPerfectSquare ( N ) : NEWLINE INDENT nextN = math . floor ( math . sqrt ( N ) ) + 1 NEWLINE return nextN * nextN NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 35 NEWLINE print ( nextPerfectSquare ( N ) ) NEWLINE NL DEDENT ENDMARKER
def check ( a , n ) : NEWLINE INDENT for i in range ( n ) : NEWLINE INDENTINDENT if ( a [ i ] ) : NEWLINE INDENTINDENTINDENT return True NEWLINE DEDENT DEDENT return False NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = [ 0 , 1 , 0 , 1 ] NEWLINE n = len ( a ) NEWLINE if ( check ( a , n ) ) : NEWLINE INDENTINDENT print ( "YES" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "NO" ) NEWLINE NL DEDENT DEDENT ENDMARKER
x = int ( input ( ) ) ar = list ( map ( int , input ( ) . split ( ) ) ) [ : x ] b = list ( map ( int , input ( ) . split ( ) ) ) [ : x ] ars = sum ( ar ) brs = sum ( b ) if ( brs <= ars ) : print ( "Yes" ) else : print ( "No" ) NEWLINE NL ENDMARKER
def dayofweek ( d , m , y ) : NEWLINE INDENT t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] NEWLINE y -= m < 3 NEWLINE return ( ( y + int ( y / 4 ) - int ( y / 100 ) + int ( y / 400 ) + t [ m - 1 ] + d ) % 7 ) NEWLINE DEDENT day = dayofweek ( 30 , 8 , 2010 ) NEWLINE print ( day ) NEWLINE NL ENDMARKER
def compute ( ) : NEWLINE INDENT ans = sum ( x for x in range ( 1000 ) if ( x % 3 == 0 or x % 5 == 0 ) ) NEWLINE return str ( ans ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( compute ( ) ) NEWLINE NL DEDENT ENDMARKER
def sum ( N ) : NEWLINE INDENT global S1 , S2 , S3 NEWLINE S1 = ( ( ( N // 3 ) ) * ( 2 * 3 + ( N // 3 - 1 ) * 3 ) // 2 ) NEWLINE S2 = ( ( ( N // 4 ) ) * ( 2 * 4 + ( N // 4 - 1 ) * 4 ) // 2 ) NEWLINE S3 = ( ( ( N // 12 ) ) * ( 2 * 12 + ( N // 12 - 1 ) * 12 ) // 2 ) NEWLINE return int ( S1 + S2 - S3 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 12 NEWLINE print ( sum ( N ) ) NEWLINE NL DEDENT ENDMARKER
if __name__ == '__main__' : NEWLINE INDENT i = chr ; NEWLINE print ( "The Alphabets from A to Z are: " ) ; NEWLINE for i in range ( ord ( 'A' ) , ord ( 'Z' ) + 1 ) : NEWLINE INDENTINDENT print ( chr ( i ) , end = " " ) ; NEWLINE NL DEDENT DEDENT ENDMARKER
def result ( n , k , t ) : NEWLINE INDENT if ( t <= k ) : NEWLINE INDENTINDENT print ( t ) NEWLINE DEDENT elif ( t <= n ) : NEWLINE INDENTINDENT print ( k ) NEWLINE DEDENT else : NEWLINE INDENTINDENT temp = t - n NEWLINE temp = k - temp NEWLINE print ( temp ) NEWLINE DEDENT DEDENT n = 10 NEWLINE k = 5 NEWLINE t = 12 NEWLINE result ( n , k , t ) NEWLINE NL ENDMARKER
def solution ( a , b , n ) : NEWLINE INDENT i = 0 NEWLINE while i * a <= n : NEWLINE INDENTINDENT if ( n - ( i * a ) ) % b == 0 : NEWLINE INDENTINDENTINDENT print ( "x = " , i , ", y = " , int ( ( n - ( i * a ) ) / b ) ) NEWLINE return 0 NEWLINE DEDENT i = i + 1 NEWLINE DEDENT print ( "No solution" ) NEWLINE DEDENT a = 2 NEWLINE b = 3 NEWLINE n = 7 NEWLINE solution ( a , b , n ) NEWLINE NL ENDMARKER
from math import gcdn , m = map ( int , input ( ) . split ( ) ) NEWLINE a = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE b = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE d = 0 NEWLINE for i in range ( 1 , n ) : d = gcd ( d , abs ( a [ i ] - a [ i - 1 ] ) ) NEWLINE ans = [ gcd ( d , a [ 0 ] + elm ) for elm in b ] NEWLINE print ( * ans ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) k = 0 k += ( m // 2 ) * nk += ( m % 2 ) * ( n // 2 ) print ( k ) NEWLINE NL ENDMARKER
def maxTeams ( N1 , N2 ) : NEWLINE INDENT count = 0 NEWLINE while ( N1 > 0 and N2 > 0 and N1 + N2 >= 3 ) : NEWLINE INDENTINDENT if ( N1 > N2 ) : NEWLINE INDENTINDENTINDENT N1 -= 2 NEWLINE N2 -= 1 NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT N1 -= 1 NEWLINE N2 -= 2 NEWLINE DEDENT count = count + 1 NEWLINE DEDENT return count NEWLINE DEDENT N1 = 4 NEWLINE N2 = 5 NEWLINE print ( maxTeams ( N1 , N2 ) ) NEWLINE NL ENDMARKER
def seriesSum ( n ) : NEWLINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) NEWLINE DEDENT n = 4 NEWLINE print ( seriesSum ( n ) ) NEWLINE NL ENDMARKER
P = 1 NEWLINE R = 1 NEWLINE T = 1 NEWLINE SI = ( P * R * T ) / 100 NEWLINE print ( "simple interest is" , SI ) NEWLINE NL ENDMARKER
def power ( n , r ) : NEWLINE INDENT count = 0 ; i = r NEWLINE while ( ( n / i ) >= 1 ) : NEWLINE INDENTINDENT count += n / i NEWLINE i = i * r NEWLINE DEDENT return int ( count ) NEWLINE DEDENT n = 6 ; r = 3 NEWLINE print ( power ( n , r ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) for i in range ( n ) : s = input ( ) if s != s [ : : - 1 ] : print ( s ) else : t = s [ 1 : ] + s [ 0 ] if s == t : print ( "-1" ) else : print ( t ) NEWLINE NL ENDMARKER
def findNumber ( n ) : NEWLINE INDENT num = n - 1 ; NEWLINE num = 2 * ( 4 ** num ) ; NEWLINE num = num // 3 ; NEWLINE return num ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 5 ; NEWLINE print ( findNumber ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
def factorial ( n ) : NEWLINE INDENT fact = 1 ; NEWLINE for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT fact = fact * i NEWLINE DEDENT return ( fact ) NEWLINE DEDENT def result ( n , m ) : NEWLINE INDENT return ( factorial ( n ) - factorial ( n - m + 1 ) * factorial ( m ) ) NEWLINE DEDENT print ( result ( 5 , 3 ) ) NEWLINE NL ENDMARKER
def myCopy ( s1 , s2 ) : NEWLINE INDENT for i in range ( len ( s1 ) ) : NEWLINE INDENTINDENT s2 [ i ] = s1 [ i ] ; NEWLINE DEDENT DEDENT s1 = "GEEKSFORGEEKS" ; NEWLINE s2 = [ '' ] * ( len ( s1 ) ) ; NEWLINE myCopy ( s1 , s2 ) ; NEWLINE print ( ( "" . join ( s2 ) ) ) ; NEWLINE NL ENDMARKER
def ellipse ( l , b ) : NEWLINE INDENT if l < 0 or b < 0 : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT x = ( 3.14 * l * b ) / 4 NEWLINE return x NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT l , b = 5 , 3 NEWLINE print ( ellipse ( l , b ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) arr = [ ] ans = 0 for i in range ( n ) : s = input ( ) if s not in arr : arr . append ( s ) ans += 1 print ( ans ) NEWLINE NL ENDMARKER
import sysfrom math import ceil  def main ( ) : _ , m , * l = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) return int ( ceil ( abs ( sum ( l ) ) / m ) ) print ( main ( ) ) NEWLINE NL ENDMARKER
import re s = input ( ) . strip ( ) s = re . sub ( '\s+' , ' ' , s ) s = re . sub ( '\s?([.,!?])\s?' , '\\1 ' , s ) print ( s ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) bin_n = bin ( n ) [ 2 : ] print ( bin_n . count ( '1' ) ) NEWLINE NL ENDMARKER
def compute ( ) : NEWLINE INDENT a = 0 NEWLINE b = 1 NEWLINE for i in range ( 32 ) : NEWLINE INDENTINDENT a , b = b , a + b NEWLINE DEDENT return str ( a ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( compute ( ) ) NEWLINE NL DEDENT ENDMARKER
import math NEWLINE def isPerfectSquare ( x ) : NEWLINE INDENT sr = math . sqrt ( x ) NEWLINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEWLINE DEDENT x = 2500 NEWLINE if ( isPerfectSquare ( x ) ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
def solve ( n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT print ( - 1 ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENT num = 2 ; NEWLINE for i in range ( n - 1 ) : NEWLINE INDENTINDENTINDENT num = ( num * 10 ) + 3 ; NEWLINE DEDENT print ( num ) ; NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 4 ; NEWLINE solve ( n ) ; NEWLINE NL DEDENT ENDMARKER
def count ( S , m , n ) : NEWLINE INDENT if ( n == 0 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT if ( n < 0 ) : NEWLINE INDENTINDENT return 0 ; NEWLINE DEDENT if ( m <= 0 and n >= 1 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; NEWLINE DEDENT arr = [ 1 , 2 , 3 ] NEWLINE m = len ( arr ) NEWLINE print ( count ( arr , m , 4 ) ) NEWLINE NL ENDMARKER
a , b , c = map ( int , input ( ) . split ( ) ) print ( b * c + ( a - 1 ) * ( c + b - 1 ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) flag = Falsefor i in range ( 4 ) : l = [ int ( i ) for i in input ( ) . split ( ) ] if not flag and n >= min ( l [ 0 ] , l [ 1 ] ) + min ( l [ 2 ] , l [ 3 ] ) : print ( i + 1 , min ( l [ 0 ] , l [ 1 ] ) , n - min ( l [ 0 ] , l [ 1 ] ) ) flag = Trueif not flag : print ( - 1 )   NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) m = abs ( s . count ( '0' ) - s . count ( '1' ) ) print ( m ) NEWLINE NL ENDMARKER
def two_sets ( a , n ) : NEWLINE INDENT a . sort ( ) ; NEWLINE return ( a [ n // 2 ] - a [ ( n // 2 ) - 1 ] ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = [ 1 , 4 , 4 , 6 , 7 , 9 ] ; NEWLINE n = len ( a ) ; NEWLINE print ( two_sets ( a , n ) ) ; NEWLINE NL DEDENT ENDMARKER
def findNumbers ( N ) : NEWLINE INDENT i = 1 NEWLINE while ( i <= N ) : NEWLINE INDENTINDENT print ( ( i * i * i ) , end = " " ) NEWLINE i += 1 NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 4 NEWLINE findNumbers ( N ) NEWLINE NL DEDENT ENDMARKER
def cntSplits ( s ) : NEWLINE INDENT if ( s [ len ( s ) - 1 ] == '1' ) : NEWLINE INDENTINDENT return 0 ; NEWLINE DEDENT c_zero = 0 ; NEWLINE for i in range ( len ( s ) ) : NEWLINE INDENTINDENT c_zero += ( s [ i ] == '0' ) ; NEWLINE DEDENT return int ( pow ( 2 , c_zero - 1 ) ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT s = "10010" ; NEWLINE print ( cntSplits ( s ) ) ; NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) print ( 2 * ( n // 3 ) if n % 3 == 0 else 2 * ( n // 3 ) + 1 ) NEWLINE NL ENDMARKER
s = input ( ) k = int ( input ( ) ) lst = list ( map ( int , input ( ) . split ( ) ) ) lst2 = [ chr ( i ) for i in range ( 97 , 123 ) ] dct = { } for i in range ( len ( lst2 ) ) : dct [ lst2 [ i ] ] = lst [ i ] value = 0 alpha = max ( dct . values ( ) )  for i in range ( len ( s ) ) : value += ( i + 1 ) * dct [ s [ i ] ] NEWLINE NL ENDMARKER
def kthOdd ( arr , n , k ) : NEWLINE INDENT for i in range ( n ) : NEWLINE INDENTINDENT if ( arr [ i ] % 2 == 1 ) : NEWLINE INDENTINDENTINDENT k -= 1 ; NEWLINE DEDENT if ( k == 0 ) : NEWLINE INDENTINDENTINDENT return arr [ i ] ; NEWLINE DEDENT DEDENT return - 1 ; NEWLINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEWLINE n = len ( arr ) ; NEWLINE k = 2 ; NEWLINE print ( kthOdd ( arr , n , k ) ) ; NEWLINE NL ENDMARKER
def minimumValue ( arr , n , k ) : NEWLINE INDENT arr . sort ( ) ; NEWLINE answer = 0 ; NEWLINE for i in range ( k ) : NEWLINE INDENTINDENT answer += arr [ i ] * arr [ i ] ; NEWLINE DEDENT return answer * ( 2 * k - 2 ) ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 4 , 21 , 5 , 3 , 8 ] ; NEWLINE k = 3 ; NEWLINE n = len ( arr ) ; NEWLINE print ( minimumValue ( arr , n , k ) ) ; NEWLINE NL DEDENT ENDMARKER
input ( ) q , t = { } , 0 a = list ( map ( int , input ( ) . split ( ) ) ) for i in a : q [ i ] = q . get ( i , 0 ) + 1 for i in q : if q [ i ] & 1 : t = 1 ; breakprint ( "Conan" if t else "Agasa" ) NEWLINE NL ENDMARKER
def printOrder ( arr , n ) : NEWLINE INDENT arr . sort ( ) NEWLINE i = 0 NEWLINE while ( i < n / 2 ) : NEWLINE INDENTINDENT print arr [ i ] , NEWLINE i = i + 1 NEWLINE DEDENT j = n - 1 NEWLINE while j >= n / 2 : NEWLINE INDENTINDENT print arr [ j ] , NEWLINE j = j - 1 NEWLINE DEDENT DEDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , 7 ] NEWLINE n = len ( arr ) NEWLINE printOrder ( arr , n ) NEWLINE NL ENDMARKER
import sys NEWLINE def findMaxValue ( ) : NEWLINE INDENT res = 2 ; NEWLINE fact = 2 ; NEWLINE while ( True ) : NEWLINE INDENTINDENT if ( fact < 0 or fact > sys . maxsize ) : NEWLINE INDENTINDENTINDENT break ; NEWLINE DEDENT res += 1 ; NEWLINE fact = fact * res ; NEWLINE DEDENT return res - 1 ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT print ( "Maximum value of integer:" , findMaxValue ( ) ) ; NEWLINE NL DEDENT ENDMARKER
n , k = map ( int , input ( ) . split ( ) )  if k <= ( n + 1 ) // 2 : print ( ( k * 2 ) - 1 ) else : print ( ( k - ( n + 1 ) // 2 ) * 2 ) NEWLINE NL ENDMARKER
s = int ( input ( ) ) g = s % 4 if g == 1 : print ( "0 A" ) if g == 2 : print ( "1 B" ) if g == 0 : print ( "1 A" ) if g == 3 : print ( "2 A" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) s = [ l [ i ] * ( i + 2 ) for i in range ( n ) ] print ( sum ( s ) - l [ - 1 ] ) NEWLINE NL ENDMARKER
import sys , math  NEWLINE NL ENDMARKER
n = input ( ) if len ( n ) == n . count ( '0' ) : print ( 'NO' ) else : while n [ 0 ] == "0" : n = n [ 1 : ] if n . count ( '0' ) >= 6 and n [ 0 ] == '1' : print ( 'YES' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
def recursiveFun ( n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT return "int" NEWLINE DEDENT return "gcd(int, " + recursiveFun ( n - 1 ) + ")" NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 5 NEWLINE print ( recursiveFun ( n ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) a = input ( ) f = n - a . count ( '.' ) m = a . count ( 'L' ) q0 = 0 flag = 1 for i in range ( n ) : if ( m == 0 ) : if ( a [ i ] == '.' and a [ i - 1 ] == 'R' and i > 0 ) : q1 = i + 1 break if ( a [ i ] == '.' ) : continue else : if ( a [ i ] == 'L' ) : q1 = i if ( flag and q0 == 0 ) : q0 = i + 1 break if ( flag ) : q0 = i + 1 flag -= 1 print ( q0 , q1 ) NEWLINE NL ENDMARKER
def findEncryptedArray ( arr , n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT sum += arr [ i ] NEWLINE DEDENT for i in range ( n ) : NEWLINE INDENTINDENT print ( sum - arr [ i ] , end = " " ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEWLINE N = len ( arr ) NEWLINE findEncryptedArray ( arr , N ) NEWLINE NL DEDENT ENDMARKER
def checkSparse ( n ) : NEWLINE INDENT if ( n & ( n >> 1 ) ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT return 1 NEWLINE DEDENT print ( checkSparse ( 72 ) ) NEWLINE print ( checkSparse ( 12 ) ) NEWLINE print ( checkSparse ( 2 ) ) NEWLINE print ( checkSparse ( 30 ) ) NEWLINE NL ENDMARKER
def Calculate_area ( ) : NEWLINE INDENT b = 3 NEWLINE h = 4 NEWLINE s1 = 3 NEWLINE s2 = 6 NEWLINE s3 = 6 NEWLINE Ht = 8 NEWLINE SA = b * h + ( s1 + s2 + s3 ) * Ht NEWLINE print ( "The area of triangular prism is :" , SA ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT Calculate_area ( ) NEWLINE NL DEDENT ENDMARKER
lst = [ 2 ** i for i in range ( 1 , 34 ) ] s = dict ( ) n = int ( input ( ) ) ss = [ int ( i ) for i in input ( ) . split ( ) ] sss = 0 for i in range ( 0 , n ) : for j in lst : if j - ss [ i ] in s : sss += s [ j - ss [ i ] ] if ss [ i ] in s : s [ ss [ i ] ] += 1 else : s [ ss [ i ] ] = 1 print ( sss ) NEWLINE NL ENDMARKER
try : n = int ( input ( ) ) k = [ int ( i ) for i in input ( ) . split ( ) ] k . sort ( ) while ( min ( k ) != max ( k ) ) : k [ n - 1 ] = k [ n - 1 ] - k [ 0 ] k . sort ( ) print ( min ( k ) * n ) except : pass NEWLINE NL ENDMARKER
l , r , x , y , k = map ( int , input ( ) . split ( ) ) check = Trueif ( x * k > r or y * k < l ) : print ( "NO" ) else : for i in range ( x , y + 1 ) : if ( k * i <= r and k * i >= l ) : check = False break if ( check == True ) : print ( "NO" ) else : print ( "YES" ) NEWLINE NL ENDMARKER
def setmiddlebits ( n ) : NEWLINE INDENT n |= n >> 1 ; NEWLINE n |= n >> 2 ; NEWLINE n |= n >> 4 ; NEWLINE n |= n >> 8 ; NEWLINE n |= n >> 16 ; NEWLINE return ( n >> 1 ) ^ 1 NEWLINE DEDENT def togglemiddlebits ( n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT return n ^ setmiddlebits ( n ) NEWLINE DEDENT n = 9 NEWLINE print ( togglemiddlebits ( n ) ) NEWLINE NL ENDMARKER
y , k , n = map ( int , input ( ) . split ( ) ) print ( - 1 ) if len ( [ print ( i - y , end = ' ' ) for i in range ( y + ( k - ( y % k ) ) , n + 1 , k ) ] ) == 0 else print ( '' )   NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = [ 0 ] * nb = [ 0 ] * nfor i in range ( n * ( n - 1 ) // 2 - 1 ) : c , d = list ( map ( int , input ( ) . split ( ) ) ) a [ c - 1 ] += 1 b [ c - 1 ] += 1 b [ d - 1 ] += 1 f = - 1 g = - 1 for i in range ( n ) : if b [ i ] == n - 2 : if f == - 1 : f = i + 1 else : g = i + 1 breakif a [ f - 1 ] > a [ g - 1 ] : print ( f , g ) else : print ( g , f ) NEWLINE NL ENDMARKER
t = int ( input ( ) )  for test in range ( t ) : a = list ( sorted ( map ( int , input ( ) . split ( ) ) ) ) b = list ( sorted ( map ( int , input ( ) . split ( ) ) ) ) if a [ 0 ] + b [ 0 ] == a [ 1 ] and a [ 0 ] + b [ 0 ] == b [ 1 ] : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
def factorial ( n ) : NEWLINE INDENT i = n NEWLINE fact = 1 NEWLINE while ( n / i != n ) : NEWLINE INDENTINDENT fact = fact * i NEWLINE i -= 1 NEWLINE DEDENT return fact NEWLINE DEDENT num = 5 ; NEWLINE print ( "Factorial of" , num , "is" , factorial ( num ) ) NEWLINE NL ENDMARKER
n = input ( ) print ( n , end = "" ) for x in range ( len ( n ) ) : print ( n [ len ( n ) - x - 1 ] , end = "" ) NEWLINE NL ENDMARKER
def countMultiples ( n ) : NEWLINE INDENT return n / 3 + n / 7 - n / 21 ; NEWLINE DEDENT n = ( ( int ) ( countMultiples ( 25 ) ) ) ; NEWLINE print ( "Count =" , n ) ; NEWLINE NL ENDMARKER
import math NEWLINE def fact ( n ) : NEWLINE INDENT if ( n <= 1 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT return n * fact ( n - 1 ) NEWLINE DEDENT def nPr ( n , r ) : NEWLINE INDENT return math . floor ( fact ( n ) / fact ( n - r ) ) NEWLINE DEDENT n = 5 NEWLINE r = 2 NEWLINE print ( n , "P" , r , "=" , nPr ( n , r ) ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) NEWLINE for a in range ( t ) : x , y , z = - 1 , - 1 , - 1 NEWLINE n = int ( input ( ) ) NEWLINE for i in range ( n // 7 + 1 ) : for NEWLINE j in range ( n // 5 + 1 ) : NEWLINE NL ENDMARKER
a , b = [ int ( i ) for i in input ( ) . split ( ) ] c = awhile a >= b : c = c + a // b a = a // b + a % bprint ( c ) NEWLINE NL ENDMARKER
import mathfor _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) maxDH = - 10 ** 9 arr = [ ] for i in range ( n ) : a , b = map ( int , input ( ) . split ( ) ) maxDH = max ( maxDH , a - b ) arr . append ( [ a , b ] ) res = 1 maxD = - 1 for i in arr : maxD = max ( maxD , i [ 0 ] ) m -= maxD if m > 0 : if maxDH <= 0 : res = - 1 else : res += ( m + maxDH - 1 ) // maxDH print ( res ) NEWLINE NL ENDMARKER
import mathn , S = map ( int , input ( ) . split ( " " ) ) print ( math . ceil ( S / n ) ) NEWLINE NL ENDMARKER
cases = int ( input ( ) ) while cases : cases -= 1 arr = sorted ( map ( int , input ( ) . split ( ) ) )  if arr [ 0 ] + arr [ 1 ] + 1 >= arr [ 2 ] : print ( "Yes" ) else : print ( "No" ) NEWLINE NL ENDMARKER
def toggleBitsFromLToR ( n , l , r ) : NEWLINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEWLINE return ( n ^ num ) NEWLINE DEDENT n = 50 NEWLINE l = 2 NEWLINE r = 5 NEWLINE print ( toggleBitsFromLToR ( n , l , r ) ) NEWLINE NL ENDMARKER
def SubarraysWithSumS ( n , k , s ) : NEWLINE INDENT for i in range ( k ) : NEWLINE INDENTINDENT print ( s , end = " " ) NEWLINE DEDENT for i in range ( k , n ) : NEWLINE INDENTINDENT print ( s + 1 , end = " " ) NEWLINE DEDENT DEDENT n = 4 NEWLINE k = 2 NEWLINE s = 3 NEWLINE SubarraysWithSumS ( n , k , s ) NEWLINE NL ENDMARKER
def calculate_change ( length , breadth ) : NEWLINE INDENT change = 0 NEWLINE change = length + breadth + ( ( length * breadth ) // 100 ) NEWLINE return change NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT cL = 20 NEWLINE cB = - 10 NEWLINE cA = calculate_change ( cL , cB ) NEWLINE print ( cA ) NEWLINE NL DEDENT ENDMARKER
I = lambda : map ( int , input ( ) . split ( ) ) n , m = I ( ) a , b = sorted ( I ( ) , reverse = 1 ) , sorted ( I ( ) ) s = sum ( b ) for i in range ( 1 , n ) : s += a [ i ] * mif a [ 0 ] > min ( b ) : s = - 1 elif a [ 0 ] != b [ 0 ] : s += a [ 0 ] - a [ 1 ] print ( s ) NEWLINE NL ENDMARKER
try : n , k = map ( int , input ( ) . split ( ) ) s = input ( ) j = 0 z = "" if k == 0 : print ( s ) elif n == 1 and not k == 0 : print ( 0 ) else : for i in range ( n ) : if i == 0 : if not s [ i ] == "1" : print ( 1 , end = "" ) j += 1 else : print ( 1 , end = "" ) elif j >= k : print ( s [ i ] , end = "" ) else : if not s [ i ] == "0" : print ( 0 , end = "" ) j += 1 else : print ( 0 , end = "" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) lst = input ( ) . split ( ) index_to_val = { lst [ idx ] : idx + 1 for idx in range ( n ) } input ( ) x = y = 0 for q in input ( ) . split ( ) : x += index_to_val [ q ] y += n - index_to_val [ q ] + 1 print ( x , y ) NEWLINE NL ENDMARKER
def countWays ( n ) : NEWLINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEWLINE dp [ 0 ] = 0 NEWLINE dp [ 1 ] = 1 NEWLINE dp [ 2 ] = 1 NEWLINE for i in range ( 3 , n + 1 ) : NEWLINE INDENTINDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 NEWLINE DEDENT return dp [ n ] NEWLINE DEDENT n = 6 NEWLINE print ( countWays ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if ( sum ( l ) % 2 == 0 ) : print ( sum ( l ) ) exit ( ) else : s = sum ( l ) for i in range ( len ( l ) ) : if ( l [ i ] % 2 == 1 ) : s -= l [ i ] if ( s % 2 == 0 ) : print ( s ) exit ( ) NEWLINE NL ENDMARKER
li = list ( map ( int , input ( ) ) ) n = len ( li ) st = Falseif 0 in li : li . remove ( 0 ) print ( * li , sep = '' ) else : li . pop ( ) print ( * li , sep = '' ) NEWLINE NL ENDMARKER
import itertoolsimport bisectimport mathfrom collections import * import osimport sysfrom io import BytesIO , IOBase  ii = lambda : int ( input ( ) ) lmii = lambda : list ( map ( int , input ( ) . split ( ) ) ) slmii = lambda : sorted ( map ( int , input ( ) . split ( ) ) ) li = lambda : list ( input ( ) ) mii = lambda : map ( int , input ( ) . split ( ) ) msi = lambda : map ( str , input ( ) . split ( ) )   def main ( ) : NEWLINE NL ENDMARKER
def sumPairs ( arr , n ) : NEWLINE INDENT sum = 0 ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT sum = sum + ( arr [ i ] * ( 2 * n ) ) ; NEWLINE DEDENT return sum ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 1 , 2 , 3 ] ; NEWLINE n = len ( arr ) ; NEWLINE print ( sumPairs ( arr , n ) ) ; NEWLINE NL DEDENT ENDMARKER
string_length , test_case = map ( int , input ( ) . split ( ) ) st = list ( input ( ) )   for x in range ( test_case ) : start , end , frm , to = map ( str , input ( ) . split ( ) ) for y in range ( int ( start ) - 1 , int ( end ) ) : if st [ y ] == frm : st [ y ] = toprint ( "" . join ( st ) ) NEWLINE NL ENDMARKER
s = "Mr John Smith " NEWLINE s = s . strip ( ) NEWLINE s = s . replace ( ' ' , "%20" ) NEWLINE print ( s ) NEWLINE NL ENDMARKER
def nextGreater ( N ) : NEWLINE INDENT power_of_2 = 1 ; NEWLINE shift_count = 0 ; NEWLINE while ( True ) : NEWLINE INDENTINDENT if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) : NEWLINE INDENTINDENTINDENT break ; NEWLINE DEDENT shift_count += 1 ; NEWLINE power_of_2 = power_of_2 * 2 ; NEWLINE DEDENT return ( N + power_of_2 ) ; NEWLINE DEDENT N = 11 ; NEWLINE print ( "The next number is =" , nextGreater ( N ) ) ; NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : line = input ( ) NEWLINE length = len ( line ) NEWLINE print ( ( line [ 0 ] + str ( length - 2 ) + line [ - 1 ] ) if length > 10 else line ) NEWLINE NL ENDMARKER
from __future__ import division , print_functionfrom collections import * from math import * from itertools import * import osimport sysfrom io import BytesIO , IOBase NEWLINE NL ENDMARKER
def ellipsearea ( r ) : NEWLINE INDENT if ( r < 0 ) : NEWLINE INDENTINDENT return - 1 ; NEWLINE DEDENT a = ( 3.14 * r * r ) / 4 ; NEWLINE return a ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT r = 5 ; NEWLINE print ( ellipsearea ( r ) ) ; NEWLINE NL DEDENT ENDMARKER
import mathn = int ( input ( ) ) a = int ( math . sqrt ( n ) ) while ( n % a != 0 ) : a = a - 1 print ( a , n // a ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) NEWLINE for i in range ( t ) : x = int ( input ( ) ) NEWLINE c = 0 NEWLINE sum = 0 NEWLINE while sum < x : c += 1 NEWLINE sum = sum + c NEWLINE re = sum - x NEWLINE NL ENDMARKER
def Sum_upto_nth_Term ( n ) : NEWLINE INDENT return n * ( n + 1 ) * ( 2 * n + 7 ) // 3 NEWLINE DEDENT N = 5 NEWLINE print ( Sum_upto_nth_Term ( N ) ) NEWLINE NL ENDMARKER
def printRoots ( a , b , c ) : NEWLINE INDENT print ( 1 , "," , c / ( a * 1.0 ) ) NEWLINE DEDENT a = 2 NEWLINE b = 3 NEWLINE c = - 5 NEWLINE printRoots ( a , b , c ) NEWLINE NL ENDMARKER
def findNum ( N , K ) : NEWLINE INDENT rem = N % K NEWLINE if ( rem == 0 ) : NEWLINE INDENTINDENT return N NEWLINE DEDENT else : NEWLINE INDENTINDENT return N - rem NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 45 NEWLINE K = 6 NEWLINE print ( "Largest number smaller than or equal to" + str ( N ) + "that is divisible by" + str ( K ) + "is" , findNum ( N , K ) ) NEWLINE NL DEDENT ENDMARKER
diag = [ ] nond = [ ] t = int ( input ( ) ) for a in range ( t ) : s = input ( ) diag . append ( s [ 0 + a ] ) diag . append ( s [ t - 1 - a ] ) for b in s : nond . append ( b ) nond . remove ( s [ 0 + a ] ) if t - 1 - a != 0 + a : nond . remove ( s [ t - 1 - a ] ) if len ( diag ) == diag . count ( diag [ 0 ] ) and len ( nond ) == nond . count ( nond [ 0 ] ) and nond [ 0 ] != diag [ 0 ] : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
def nthTerm ( N ) : NEWLINE INDENT nth = 0 ; first_term = 12 ; NEWLINE nth = ( first_term * ( pow ( 2 , N - 1 ) ) ) + \ NEWLINE INDENTINDENT 11 * ( ( pow ( 2 , N - 1 ) ) - 1 ) ; NEWLINE DEDENT return nth ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 5 ; NEWLINE print ( nthTerm ( N ) ) ; NEWLINE NL DEDENT ENDMARKER
def answer ( X , K ) : NEWLINE INDENT MAX = pow ( 10 , K ) - 1 NEWLINE return ( MAX - ( MAX % X ) ) NEWLINE DEDENT X = 30 ; NEWLINE K = 3 ; NEWLINE print ( answer ( X , K ) ) ; NEWLINE NL ENDMARKER
def compute ( ) : NEWLINE INDENT ans = sum ( 1 for i in range ( 1 , 10 ) for j in range ( 1 , 22 ) if len ( str ( i ** j ) ) == j ) NEWLINE return str ( ans ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( compute ( ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) t = list ( map ( int , input ( ) . split ( ) ) )  p = n - 1 used = [ False ] * n  for x in range ( n ) : used [ t [ x ] - 1 ] = True  while p >= 0 and used [ p ] : print ( p + 1 , end = ' ' ) p -= 1 print ( '' ) NEWLINE NL ENDMARKER
def squareDigitSum ( num ) : NEWLINE INDENT lengthN = len ( num ) NEWLINE result = ( lengthN // 9 ) * 81 + ( lengthN % 9 ) ** 2 NEWLINE return result NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = "1111" NEWLINE print ( squareDigitSum ( N ) ) NEWLINE NL DEDENT ENDMARKER
if __name__ == "__main__" : n1 , n2 , k1 , k2 = list ( map ( int , input ( ) . split ( ) ) ) if n2 >= n1 : print ( 'Second' ) else : print ( 'First' ) NEWLINE NL ENDMARKER
n , v = map ( int , input ( ) . split ( ) ) l = [ ] l . extend ( map ( int , input ( ) . split ( ) ) ) l . remove ( max ( l ) ) if sum ( l ) <= v : print ( 'YES' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : k , x = map ( int , input ( ) . split ( ) ) print ( 9 * ( k - 1 ) + x ) NEWLINE NL ENDMARKER
def modularInverse ( n , prime ) : NEWLINE INDENT dp = [ 0 ] * ( n + 1 ) NEWLINE dp [ 0 ] = dp [ 1 ] = 1 NEWLINE for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT dp [ i ] = dp [ prime % i ] * ( prime - prime // i ) % prime NEWLINE DEDENT for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT print ( dp [ i ] , end = " " ) NEWLINE DEDENT DEDENT n = 10 NEWLINE prime = 17 NEWLINE modularInverse ( n , prime ) NEWLINE NL ENDMARKER
a1 , b1 = input ( ) . split ( ' ' ) a = int ( a1 ) b = int ( b1 )  count = awhile ( a >= b ) : d = a // b count += d m = a % b a = d + m print ( count ) NEWLINE NL ENDMARKER
T = int ( input ( ) ) NEWLINE for i in range ( 0 , T ) : a , b , c = input ( ) . split ( ) NEWLINE a = int ( a ) NEWLINE b = int ( b ) NEWLINE c = int ( c ) NEWLINE Sum = a + b + c NEWLINE if Sum % 9 == 0 and Sum / 9 <= min ( a , min ( b , c ) ) : NEWLINE INDENT print ( "YES" ) else : NEWLINE print ( "NO" ) NEWLINE NL DEDENT ENDMARKER
def smallest ( x , y , z ) : NEWLINE INDENT c = 0 NEWLINE while ( x and y and z ) : NEWLINE INDENTINDENT x = x - 1 NEWLINE y = y - 1 NEWLINE z = z - 1 NEWLINE c = c + 1 NEWLINE DEDENT return c NEWLINE DEDENT x = 12 NEWLINE y = 15 NEWLINE z = 5 NEWLINE print ( "Minimum of 3 numbers is" , smallest ( x , y , z ) ) NEWLINE NL ENDMARKER
def firstFactorialDivisibleNumber ( x ) : NEWLINE INDENT i = 1 ; NEWLINE fact = 1 ; NEWLINE for i in range ( 1 , x ) : NEWLINE INDENTINDENT fact = fact * i NEWLINE if ( fact % x == 0 ) : NEWLINE INDENTINDENTINDENT break NEWLINE DEDENT DEDENT return i NEWLINE DEDENT x = 16 NEWLINE print ( firstFactorialDivisibleNumber ( x ) ) NEWLINE NL ENDMARKER
import sys  n , m , c = map ( int , input ( ) . split ( ) ) a = [ ] for i in range ( n + 1 ) : a . append ( 0 ) cnt = 0 while cnt < n : i = 0 x = int ( input ( ) ) if x * 2 <= c : i = 1 while a [ i ] and a [ i ] <= x : i += 1 else : i = n while a [ i ] and a [ i ] >= x : i -= 1 if a [ i ] == 0 : cnt += 1 a [ i ] = x print ( i ) sys . stdout . flush ( ) NEWLINE NL ENDMARKER
i = lambda : map ( int , input ( ) . split ( ) ) _ , _ , r = i ( ) s = min ( i ( ) ) b = max ( s , * i ( ) ) print ( r % s + r // s * b ) NEWLINE NL ENDMARKER
def getPairs ( a ) : NEWLINE INDENT n = len ( a ) NEWLINE count = ( n * ( n - 1 ) ) // 2 NEWLINE return count NEWLINE DEDENT a = [ 2 , 4 , 3 , 1 ] NEWLINE print ( getPairs ( a ) ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) NEWLINE for _ in range ( t ) : s = input ( ) NEWLINE if ( s [ 0 ] == ")" or s [ - 1 ] == "(" or len ( s ) % 2 != 0 ) :  NEWLINE print ( "NO" ) else : print ( "YES" )            NEWLINE NL ENDMARKER
x , y , z , t1 , t2 , t3 = map ( int , input ( ) . split ( ) ) st = abs ( y - x ) * t1 et = abs ( z - x ) * t2 + abs ( x - y ) * t2 + 3 * t3 print ( 'YES' if et <= st else 'NO' )  NEWLINE NL ENDMARKER
m , n = map ( int , input ( ) . split ( ) ) k = 0 x = 0 while n > 0 : l = input ( ) if l . count ( '1' ) != len ( l ) : x = x + 1 else : k = max ( k , x ) x = 0 n = n - 1 k = max ( k , x ) print ( k ) NEWLINE NL ENDMARKER
import time  NEWLINE NL ENDMARKER
import math NEWLINE def checkSquare ( s1 , s2 ) : NEWLINE INDENT c = int ( s1 + s2 ) NEWLINE d = math . sqrt ( c ) NEWLINE if ( d * d == c ) : NEWLINE INDENTINDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT s1 = "12" NEWLINE s2 = "1" NEWLINE checkSquare ( s1 , s2 ) NEWLINE NL DEDENT ENDMARKER
def factorial ( N ) : NEWLINE INDENT fact = 1 NEWLINE for i in range ( 1 , N + 1 ) : NEWLINE INDENTINDENT fact = fact * i NEWLINE DEDENT return fact NEWLINE DEDENT def nthTerm ( N ) : NEWLINE INDENT return ( factorial ( N + 1 ) // 2 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 6 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
def numberOfSquares ( base ) : NEWLINE INDENT base = ( base - 2 ) NEWLINE base = base / 2 NEWLINE return base * ( base + 1 ) / 2 NEWLINE DEDENT base = 8 NEWLINE print ( numberOfSquares ( base ) ) NEWLINE NL ENDMARKER
import mathline = input ( ) . split ( ) n = int ( line [ 0 ] ) m = int ( line [ 1 ] ) a = int ( line [ 2 ] ) hor = math . ceil ( n / a ) ver = math . ceil ( m / a ) result = hor * verprint ( result )                     NEWLINE NL ENDMARKER
def countIntegralSolutions ( n ) : NEWLINE INDENT result = 0 NEWLINE for i in range ( n + 1 ) : NEWLINE INDENTINDENT for j in range ( n + 1 ) : NEWLINE INDENTINDENTINDENT for k in range ( n + 1 ) : NEWLINE INDENTINDENTINDENTINDENT if i + j + k == n : NEWLINE INDENTINDENTINDENTINDENTINDENT result += 1 NEWLINE DEDENT DEDENT DEDENT DEDENT return result NEWLINE DEDENT n = 3 NEWLINE print ( countIntegralSolutions ( n ) ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) NEWLINE while t > 0 : t = t - 1 NEWLINE n = int ( input ( ) ) NEWLINE if n == 1 : NEWLINE INDENT print ( 0 ) elif n == 2 : NEWLINE print ( 1 ) elif n == 3 : NEWLINE print ( 2 ) elif n % 2 == 0 : NEWLINE print ( 2 ) else : NEWLINE print ( 3 ) NEWLINE NL DEDENT ENDMARKER
import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEWLINE NL ENDMARKER
def CountPair ( L , R ) : NEWLINE INDENT x = ( R - L + 1 ) NEWLINE print ( x // 2 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT L , R = 1 , 8 NEWLINE CountPair ( L , R ) NEWLINE NL DEDENT ENDMARKER
import time  NEWLINE NL ENDMARKER
s = input ( ) . split ( '<' ) [ 1 : ] level = - 1 arr = set ( ) f = Falsefor i in s : f = False if i [ 0 ] != '/' : f = True  if f : level += 1 print ( " " * ( 2 * level ) + '<' + i ) if not f : level -= 1 NEWLINE NL ENDMARKER
import sys , os , ioimport math , bisect , operatorinf , mod = float ( 'inf' ) , 10 ** 9 + 7 NEWLINE NL ENDMARKER
def totalDigits ( n ) : NEWLINE INDENT number_of_digits = 0 ; NEWLINE for i in range ( 1 , n , 10 ) : NEWLINE INDENTINDENT number_of_digits = ( number_of_digits + ( n - i + 1 ) ) ; NEWLINE DEDENT return number_of_digits ; NEWLINE DEDENT n = 13 ; NEWLINE s = totalDigits ( n ) + 1 ; NEWLINE print ( s ) ; NEWLINE NL ENDMARKER
def calculateSum ( n ) : NEWLINE INDENT sum = ( 1 << ( n + 1 ) ) NEWLINE return sum - 1 NEWLINE DEDENT n = 10 NEWLINE print ( "Sum of series " , calculateSum ( n ) ) NEWLINE NL ENDMARKER
n = input ( ) s = input ( ) X = s . count ( 'X' ) x = s . count ( 'x' ) c = abs ( ( X - x ) // 2 ) print ( c ) if X > x : s = s . replace ( 'X' , 'x' , c ) else : s = s . replace ( 'x' , 'X' , c ) print ( s ) NEWLINE NL ENDMARKER
s = [ int ( i ) for i in input ( ) . split ( ) ] s . sort ( )  a = s [ 0 ] b = s [ 1 ] c = s [ 2 ] d = s [ 3 ] NEWLINE NL ENDMARKER
def factorial ( N ) : NEWLINE INDENT if N == 0 or N == 1 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT return N * factorial ( N - 1 ) NEWLINE DEDENT def nthTerm ( N ) : NEWLINE INDENT return ( factorial ( N ) * ( N + 2 ) // 2 ) NEWLINE DEDENT N = 6 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL ENDMARKER
def reachTarget ( target ) : NEWLINE INDENT target = abs ( target ) NEWLINE sum = 0 NEWLINE step = 0 NEWLINE while ( sum < target or ( sum - target ) % 2 != 0 ) : NEWLINE INDENTINDENT step = step + 1 NEWLINE sum = sum + step NEWLINE DEDENT return step NEWLINE DEDENT target = 5 NEWLINE print ( reachTarget ( target ) ) NEWLINE NL ENDMARKER
import eulerlib NEWLINE def compute ( ) : NEWLINE INDENT ans = sum ( eulerlib . list_primes ( 1999999 ) ) NEWLINE return str ( ans ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( compute ( ) ) NEWLINE NL DEDENT ENDMARKER
n , A , B , C , T = map ( int , input ( ) . split ( ) ) t = [ int ( i ) for i in input ( ) . split ( ) ] t . sort ( )  total_sum = 0  for lower_border in range ( n + 1 ) : NEWLINE NL ENDMARKER
def nthTerm ( N ) : NEWLINE INDENT return ( abs ( N * ( ( N - 1 ) * ( N - 3 ) * ( N - 5 ) ) ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 6 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
n , d = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) m = int ( input ( ) ) a . sort ( ) k = 0 s = 0 for i in range ( m ) : if i < len ( a ) : k += a [ s ] s += 1 else : k -= dprint ( k )  NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( [ 2 ** ( n // 2 ) , 0 ] [ n & 1 ] ) NEWLINE NL ENDMARKER
def PointInKSquares ( n , a , k ) : NEWLINE INDENT a . sort ( ) NEWLINE return a [ n - k ] NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT k = 2 NEWLINE a = [ 1 , 2 , 3 , 4 ] NEWLINE n = len ( a ) NEWLINE x = PointInKSquares ( n , a , k ) NEWLINE print ( "(" , x , "," , x , ")" ) NEWLINE NL DEDENT ENDMARKER
ax = 5 NEWLINE ay = 0 NEWLINE bx = 1 NEWLINE by = 1 NEWLINE cx = 2 NEWLINE cy = 5 NEWLINE print ( ax + bx - cx , ", " , ay + by - cy ) NEWLINE print ( ax + cx - bx , ", " , ay + cy - by ) NEWLINE print ( cx + bx - ax , ", " , cy + by - ax ) NEWLINE NL ENDMARKER
def Convert ( radian ) : NEWLINE INDENT pi = 3.14159 NEWLINE degree = radian * ( 180 / pi ) NEWLINE return degree NEWLINE DEDENT radian = 5 NEWLINE print ( "degree =" , ( Convert ( radian ) ) ) NEWLINE NL ENDMARKER
from collections import Counterdef func ( ) : x , y = map ( int , input ( ) . split ( ) ) if x == y : print ( x ) else : print ( '1' ) t = 1 NEWLINE NL ENDMARKER
t = int ( input ( ) ) meat = [ ] money = [ ] while t > 0 : num = [ int ( i ) for i in input ( ) . split ( ) ] a = num [ 0 ] b = num [ 1 ] meat . append ( a ) money . append ( b ) t = t - 1 tot = 0 min = money [ 0 ] for i in range ( len ( meat ) ) : if money [ i ] < min : min = money [ i ] tot = tot + min * meat [ i ] print ( tot ) NEWLINE NL ENDMARKER
n , l = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) aa = [ 0 ] * lbb = [ 0 ] * lfor i in range ( n ) : aa [ a [ i ] - 1 ] += 1 bb [ b [ i ] - 1 ] += 1 for i in range ( l ) : if aa == bb : print ( "YES" ) exit ( 0 ) bb = [ bb [ - 1 ] ] + bb [ : - 1 ] print ( "NO" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( n % 2 ) NEWLINE NL ENDMARKER
def countSolutions ( n ) : NEWLINE INDENT res = 0 NEWLINE x = 0 NEWLINE while ( x * x < n ) : NEWLINE INDENTINDENT y = 0 NEWLINE while ( x * x + y * y < n ) : NEWLINE INDENTINDENTINDENT res = res + 1 NEWLINE y = y + 1 NEWLINE DEDENT x = x + 1 NEWLINE DEDENT return res NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT print ( "Total Number of distinct Non-Negative pairs is " , countSolutions ( 6 ) ) NEWLINE NL DEDENT ENDMARKER
def isNumber ( s ) : NEWLINE INDENT for i in range ( len ( s ) ) : NEWLINE INDENTINDENT if s [ i ] . isdigit ( ) != True : NEWLINE INDENTINDENTINDENT return False NEWLINE DEDENT DEDENT return True NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT str = "6790" NEWLINE if isNumber ( str ) : NEWLINE INDENTINDENT print ( "Integer" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "String" ) NEWLINE NL DEDENT DEDENT ENDMARKER
def getCount ( N ) : NEWLINE INDENT if ( N % 2 == 1 ) : NEWLINE INDENTINDENT return "0" NEWLINE DEDENT result = "9" NEWLINE for i in range ( 1 , N // 2 ) : NEWLINE INDENTINDENT result = result + "0" NEWLINE DEDENT return result NEWLINE DEDENT N = 4 NEWLINE print ( getCount ( N ) ) NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) c = a // 2 d = c // ( b + 1 ) e = b * dprint ( d , e , a - d - e ) NEWLINE NL ENDMARKER
if int ( input ( ) ) % 4 == 0 : print ( 4 ) else : print ( 0 ) NEWLINE NL ENDMARKER
def seriesSum ( calculated , current , N ) : NEWLINE INDENT i = calculated ; NEWLINE cur = 1 ; NEWLINE if ( current == N + 1 ) : NEWLINE INDENTINDENT return 0 ; NEWLINE DEDENT while ( i < calculated + current ) : NEWLINE INDENTINDENT cur *= i ; NEWLINE i += 1 ; NEWLINE DEDENT return cur + seriesSum ( i , current + 1 , N ) ; NEWLINE DEDENT N = 5 ; NEWLINE print ( seriesSum ( 1 , 1 , N ) ) ; NEWLINE NL ENDMARKER
y , k , n = list ( map ( int , input ( ) . split ( ) ) )   if y == k : count = 0 elif y > k : count = ( ( y // k + 1 ) * k ) - yelse : count = k - y   if y >= n : print ( - 1 ) else : if y + count > n : print ( - 1 ) else :  while y + count <= n : if count == 0 : count += k continue print ( count , end = " " ) count += k   NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n , s , t = map ( int , input ( ) . split ( ) ) print ( 1 + n - min ( s , t ) ) NEWLINE NL ENDMARKER
from os import pathimport NEWLINE sys , time NEWLINE NL ENDMARKER
def findSum ( str1 ) : NEWLINE INDENT temp = "" NEWLINE Sum = 0 NEWLINE for ch in str1 : NEWLINE INDENTINDENT if ( ch . isdigit ( ) ) : NEWLINE INDENTINDENTINDENT temp += ch NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT Sum += int ( temp ) NEWLINE temp = "0" NEWLINE DEDENT DEDENT return Sum + int ( temp ) NEWLINE DEDENT str1 = "12abc20yz68" NEWLINE print ( findSum ( str1 ) ) NEWLINE NL ENDMARKER
import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappush NEWLINE NL ENDMARKER
n = int ( input ( ) ) f = 1 s = "" for i in range ( n - 1 ) : if f == 1 : s += "I hate" f = 2 else : s += "I love" f = 1 s += " that " if f == 1 : s += "I hate it" else : s += "I love it" print ( s ) NEWLINE NL ENDMARKER
def findNumbers ( n ) : NEWLINE INDENT odd = pow ( 10 , n ) - 1 NEWLINE even = odd - 1 NEWLINE print ( "Even = " , even ) NEWLINE print ( "Odd = " , odd ) NEWLINE DEDENT n = 4 NEWLINE findNumbers ( n ) NEWLINE NL ENDMARKER
def getArray ( n ) : NEWLINE INDENT ans = [ ] ; NEWLINE p2 = 1 ; NEWLINE while ( n > 0 ) : NEWLINE INDENTINDENT if ( n & 1 ) : NEWLINE INDENTINDENTINDENT ans . append ( p2 ) ; NEWLINE DEDENT n >>= 1 ; NEWLINE p2 *= 2 ; NEWLINE DEDENT return ans ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 15 ; NEWLINE ans = getArray ( n ) ; NEWLINE for i in ans : NEWLINE INDENTINDENT print ( i , end = " " ) ; NEWLINE NL DEDENT DEDENT ENDMARKER
def getSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE while ( n != 0 ) : NEWLINE INDENTINDENT sum = sum + int ( n % 10 ) NEWLINE n = int ( n / 10 ) NEWLINE DEDENT return sum NEWLINE DEDENT n = 687 NEWLINE print ( getSum ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( 0 , 0 , n ) NEWLINE NL ENDMARKER
def maxXOR ( arr , n ) : NEWLINE INDENT xorArr = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT xorArr ^= arr [ i ] NEWLINE DEDENT ans = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT ans = max ( ans , ( xorArr ^ arr [ i ] ) ) NEWLINE DEDENT return ans NEWLINE DEDENT arr = [ 1 , 1 , 3 ] NEWLINE n = len ( arr ) NEWLINE print ( maxXOR ( arr , n ) ) NEWLINE NL ENDMARKER
s = input ( )  print ( ( len ( s ) + ( s . count ( '1' ) > 1 ) ) // 2 ) NEWLINE NL ENDMARKER
def countSetBits ( n ) : NEWLINE INDENT count = 0 NEWLINE while n : NEWLINE INDENTINDENT count += 1 NEWLINE n &= ( n - 1 ) NEWLINE DEDENT return count NEWLINE DEDENT def FlippedCount ( a , b ) : NEWLINE INDENT return countSetBits ( a ^ b ) NEWLINE DEDENT a = 10 NEWLINE b = 20 NEWLINE print ( FlippedCount ( a , b ) ) NEWLINE NL ENDMARKER
def powerOfTwo ( n ) : NEWLINE INDENT return ( not ( n & n - 1 ) ) NEWLINE DEDENT def onlyFirstAndLastAreSet ( n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT return True NEWLINE DEDENT return powerOfTwo ( n - 1 ) NEWLINE DEDENT n = 9 NEWLINE if ( onlyFirstAndLastAreSet ( n ) ) : NEWLINE INDENT print ( 'Yes' ) NEWLINE DEDENT else : NEWLINE INDENT print ( 'No' ) NEWLINE NL DEDENT ENDMARKER
def countNumbers ( n ) : NEWLINE INDENT return n // 2520 NEWLINE DEDENT n = 3000 NEWLINE print ( countNumbers ( n ) ) NEWLINE NL ENDMARKER
t , * x = open ( 0 ) ; print ( * x ) NEWLINE NL ENDMARKER
I = lambda : map ( int , input ( ) . split ( ) ) _ , m = I ( ) A = list ( I ( ) ) s = '' d = 0 for _ in range ( m ) : t , * X = I ( ) if t == 1 : A [ X [ 0 ] - 1 ] = X [ 1 ] - d elif t == 2 : d += X [ 0 ] else : s += str ( A [ X [ 0 ] - 1 ] + d ) + '\n' print ( s ) NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def numJewelsInStones ( self , J , S ) : NEWLINE INDENTINDENT if len ( J ) == 0 or len ( S ) == 0 : NEWLINE INDENTINDENTINDENT return 0 NEWLINE DEDENT j_set = set ( J ) NEWLINE ans = 0 NEWLINE for c in S : NEWLINE INDENTINDENTINDENT if c in j_set : NEWLINE INDENTINDENTINDENTINDENT ans += 1 NEWLINE DEDENT DEDENT return ans NEWLINE NL DEDENT DEDENT ENDMARKER
x , y = map ( int , input ( ) . split ( ' ' ) ) a , b = map ( int , input ( ) . split ( ' ' ) ) print ( max ( abs ( x - a ) , abs ( b - y ) ) ) NEWLINE NL ENDMARKER
import sysimport NEWLINE mathclass NEWLINE DictList ( dict ) : NEWLINE def __setitem__ ( self , key , value ) : try NEWLINE INDENT : NEWLINE NL DEDENT ENDMARKER
INDENT n = int ( input ( ) ) a = input ( ) flag = 0  for i in range ( n ) : if ( a [ i ] == '0' ) : print ( i + 1 ) flag = 1 breakif ( flag == 0 ) : print ( n ) NEWLINE NL DEDENT ENDMARKER
cases = int ( input ( ) ) NEWLINE for i in range ( cases ) : a , b = map ( int , input ( ) . split ( ) ) NEWLINE temp = abs ( a - b ) NEWLINE count = 0 NEWLINE if temp == 0 : NEWLINE INDENT print ( 0 ) else : NEWLINE count = temp // 10 NEWLINE DEDENT temp = temp - 10 * count NEWLINE if temp % 10 != 0 : count += 1  print ( count ) NEWLINE NL ENDMARKER
def maxSquare ( b , m ) : NEWLINE INDENT return ( b / m - 1 ) * ( b / m ) / 2 NEWLINE DEDENT b = 10 NEWLINE m = 2 NEWLINE print ( int ( maxSquare ( b , m ) ) ) NEWLINE NL ENDMARKER
def mostCommon ( lower , higher ) : NEWLINE INDENT if ( lower == higher ) : NEWLINE INDENTINDENT return lower NEWLINE DEDENT else : NEWLINE INDENTINDENT return 2 NEWLINE DEDENT DEDENT lower = 10 NEWLINE higher = 20 NEWLINE print ( "The most frequent factor" , mostCommon ( lower , higher ) ) NEWLINE NL ENDMARKER
t = input ( ) t = t . split ( ) n = int ( t [ 0 ] ) c1 = int ( t [ 1 ] ) c2 = int ( t [ 2 ] ) t = input ( ) d = 0 for i in t : if ( i == "1" ) : d = d + 1  min = 10 ** 1488 for i in range ( 1 , d + 1 ) : t = c1 * i + i * c2 * ( ( ( n // i ) - 1 ) ** 2 ) + c2 * ( n % i ) * ( 2 * ( n // i ) - 1 ) if t < min : min = t  print ( min ) NEWLINE NL ENDMARKER
def kthgroupsum ( k ) : NEWLINE INDENT cur = int ( ( k * ( k - 1 ) ) + 1 ) NEWLINE sum = 0 NEWLINE while k : NEWLINE INDENTINDENT sum += cur NEWLINE cur += 2 NEWLINE k = k - 1 NEWLINE DEDENT return sum NEWLINE DEDENT k = 3 NEWLINE print ( kthgroupsum ( k ) ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( " " ) ) s = input ( ) l = [ ] a = 0 for i in range ( k ) : NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = 2 * n - 1 print ( a , 2 ) print ( 1 , 2 ) NEWLINE NL ENDMARKER
from math import gcd NEWLINE def ratiotang ( r1 , r2 ) : NEWLINE INDENT print ( "The ratio is" , int ( r1 / gcd ( r1 , r2 ) ) , ":" , int ( r2 / gcd ( r1 , r2 ) ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT r1 = 4 NEWLINE r2 = 6 NEWLINE ratiotang ( r1 , r2 ) NEWLINE NL DEDENT ENDMARKER
password = input ( ) n = int ( input ( ) ) first_letter_found = second_letter_found = 0 result = 'NO' for i in range ( n ) : word = input ( ) if word == password : result = 'YES' elif result == 'NO' : if word [ 1 ] == password [ 0 ] : first_letter_found = 1 if word [ 0 ] == password [ 1 ] : second_letter_found = 1  if result == 'NO' and first_letter_found == 1 and second_letter_found == 1 : result = 'YES' print ( result ) NEWLINE NL ENDMARKER
import sys , os , ioimport math , bisect , operatorinf , mod = float ( 'inf' ) , 10 ** 9 + 7 NEWLINE NL ENDMARKER
import math NEWLINE def compute ( ) : NEWLINE INDENT n = math . factorial ( 100 ) NEWLINE ans = sum ( int ( c ) for c in str ( n ) ) NEWLINE return str ( ans ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( compute ( ) ) NEWLINE NL DEDENT ENDMARKER
def bonacciseries ( n , m ) : NEWLINE INDENT a = [ 0 ] * m NEWLINE a [ n - 1 ] = 1 NEWLINE for i in range ( n , m ) : NEWLINE INDENTINDENT for j in range ( i - n , i ) : NEWLINE INDENTINDENTINDENT a [ i ] = a [ i ] + a [ j ] NEWLINE DEDENT DEDENT for i in range ( 0 , m ) : NEWLINE INDENTINDENT print ( a [ i ] , end = " " ) NEWLINE DEDENT DEDENT N = 5 NEWLINE M = 15 NEWLINE bonacciseries ( N , M ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) x = 1 for i in range ( n ) : if ( s [ i ] != '1' ) : break x += 1 if x > n : x = nprint ( x )            NEWLINE NL ENDMARKER
s = input ( ) st = [ '0' ] c = 0 for i in s : NEWLINE NL ENDMARKER
def countSequences ( arr , n ) : NEWLINE INDENT count = 1 NEWLINE arr . sort ( ) NEWLINE for i in range ( n - 1 ) : NEWLINE INDENTINDENT if ( arr [ i ] + 1 != arr [ i + 1 ] ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT return count NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 1 , 7 , 3 , 5 , 10 ] NEWLINE n = len ( arr ) NEWLINE print ( countSequences ( arr , n ) ) NEWLINE NL DEDENT ENDMARKER
def countNumber ( N , S ) : NEWLINE INDENT countElements = 0 ; NEWLINE currentSum = 0 NEWLINE currSum = 0 ; NEWLINE while ( currSum <= S ) : NEWLINE INDENTINDENT currSum += N ; NEWLINE N = N - 1 ; NEWLINE countElements = countElements + 1 ; NEWLINE DEDENT return countElements ; NEWLINE DEDENT N = 5 ; NEWLINE S = 11 ; NEWLINE count = countNumber ( N , S ) ; NEWLINE print ( count ) ; NEWLINE NL ENDMARKER
print ( '25' ) NEWLINE NL ENDMARKER
first = input ( ) second = input ( ) s = "abcdefjh" ans = 0 for i in "abcdefgh" : for j in range ( 1 , 9 ) : move = i + str ( j )  if move != first and move != second : if not i in first and not str ( j ) in first : NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) )  print ( m * min ( 2 , n - 1 ) ) NEWLINE NL ENDMARKER
def find_composite_nos ( n ) : NEWLINE INDENT print ( 9 * n , 8 * n ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 4 ; NEWLINE find_composite_nos ( n ) ; NEWLINE NL DEDENT ENDMARKER
import sys , mathfrom NEWLINE collections NEWLINE import defaultdict , dequeinput = sys . stdin . readline   t = int ( input ( ) ) NEWLINE while ( t > 0 ) : n , w = map ( int , input ( ) . split ( ) ) NEWLINE l = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE NL ENDMARKER
l = input ( ) . split ( " " ) n = int ( l [ 0 ] ) x = int ( l [ 1 ] ) y = int ( l [ 2 ] ) h = n / 2 if ( ( x == h ) & ( y == h ) ) : print ( "NO" ) elif ( ( x == h ) & ( y == h + 1 ) ) : print ( "NO" ) elif ( ( x == h + 1 ) & ( y == h ) ) : print ( "NO" ) elif ( ( x == h + 1 ) & ( y == h + 1 ) ) : print ( "NO" ) else : print ( "YES" ) NEWLINE NL ENDMARKER
def getNthTerm ( N ) : NEWLINE INDENT return ( 7 * pow ( N , 2 ) - 19 * N + 15 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 4 NEWLINE print ( getNthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
info = [ int ( x ) for x in input ( ) . split ( ) ] problem_times = [ int ( x ) * 5 for x in range ( 1 , info [ 0 ] + 1 ) ] time_to_do = 240 - info [ 1 ] problems_done = 0  for index , i in enumerate ( problem_times ) : if time_to_do >= problem_times [ index ] : time_to_do -= i problems_done += 1 else : breakprint ( problems_done ) NEWLINE NL ENDMARKER
import math  def main_function ( ) : output_list = [ ] n , m = [ int ( i ) for i in input ( ) . split ( " " ) ] for i in range ( n ) : a , b = [ int ( i ) for i in input ( ) . split ( " " ) ] output_list . append ( ( a / b ) * m ) return min ( output_list )        print ( main_function ( ) ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) s = [ int ( x ) for x in input ( ) . split ( ) ] for i in s : if i > 14 : if ( i - 1 ) % 14 == 0 : print ( 'YES' ) elif ( i - 2 ) % 14 == 0 : print ( 'YES' ) elif ( i - 3 ) % 14 == 0 : print ( 'YES' ) elif ( i - 4 ) % 14 == 0 : print ( 'YES' ) elif ( i - 5 ) % 14 == 0 : print ( 'YES' ) elif ( i - 6 ) % 14 == 0 : print ( 'YES' ) else : print ( 'NO' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) . strip ( ) c = 1 i = 0  an = [ ] while ( i < n ) : an . append ( s [ i ] ) i += c c += 1 print ( '' . join ( an ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( )  arr = set ( list ( s ) ) if len ( arr ) < n : print ( "NO" )  else : ans = [ ] d = { }  for i in s : if i in d : ans [ - 1 ] += i else : d [ i ] = 1 ans . append ( i ) print ( "YES" ) for i in ans [ : n - 1 ] : print ( i )  print ( '' . join ( ans [ n - 1 : ] ) )  NEWLINE NL ENDMARKER
import re  s = input ( ) q_indices = [ m . start ( ) for m in re . finditer ( 'Q' , s ) ] a_indices = [ m . start ( ) for m in re . finditer ( 'A' , s ) ] result = 0 for i in a_indices : q_no = len ( q_indices ) before_a = - 1 for j in range ( q_no ) : if q_indices [ j ] > i : before_a = j break if before_a > 0 : after_a = q_no - before_a result += after_a * before_aprint ( result ) NEWLINE NL ENDMARKER
str1 = input ( ) str2 = input ( )  new_s = str2 [ : : - 1 ]  if str1 == new_s : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
a = int ( input ( ) ) b = int ( input ( ) ) c = int ( input ( ) ) d = c // 4 d = min ( d , b // 2 ) d = min ( d , a ) print ( 1 * d + 2 * d + 4 * d ) NEWLINE NL ENDMARKER
a , b , c = map ( int , input ( ) . split ( ) ) for i in range ( 2 * b ) : a *= 10 if ( a // b == c ) : print ( i + 1 ) break a %= belse : print ( - 1 ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) n -= 1 val = n // kdiv = n % ki = 2 if div == 0 : print ( val * 2 ) elif div == 1 : print ( val * 2 + 1 ) else : print ( ( val + 1 ) * 2 ) for a in range ( k ) : print ( 1 , i ) for j in range ( val - 1 ) : print ( i , i + 1 ) i += 1 i += 1j = i - 1 while ( div ) : print ( j , i ) i += 1 j -= val div -= 1 NEWLINE NL ENDMARKER
def nDigitPalindromes ( n ) : NEWLINE INDENT return ( 9 * pow ( 10 , ( n - 1 ) // 2 ) ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 2 ; NEWLINE print ( nDigitPalindromes ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
import itertoolsimport bisectimport mathfrom collections import * import osimport sysfrom io import BytesIO , IOBase  ii = lambda : int ( input ( ) ) lmii = lambda : list ( map ( int , input ( ) . split ( ) ) ) slmii = lambda : sorted ( map ( int , input ( ) . split ( ) ) ) li = lambda : list ( input ( ) ) mii = lambda : map ( int , input ( ) . split ( ) ) msi = lambda : map ( str , input ( ) . split ( ) )   def main ( ) : NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) l = [ ] c = 0 ans = 0 for i in range ( n ) : if ( int ( s [ i ] ) % 2 == 0 ) : c += 1 l . append ( i ) NEWLINE NL ENDMARKER
def radius ( n , d ) : NEWLINE INDENT print ( "The side of each square is " , d / ( ( n - 1 ) * ( 2 ** ( 1 / 2 ) ) ) ) ; NEWLINE DEDENT d = 42 ; n = 4 ; NEWLINE radius ( n , d ) ; NEWLINE NL ENDMARKER
s = input ( ) w = len ( s ) q = - 1 for i in range ( w - 2 ) : for j in range ( i + 1 , w - 1 ) : a , b , c = s [ : i + 1 ] , s [ i + 1 : j + 1 ] , s [ j + 1 : ] if len ( a ) == len ( str ( int ( a ) ) ) and len ( b ) == len ( str ( int ( b ) ) ) and len ( c ) == len ( str ( int ( c ) ) ) : if int ( a ) <= 10 ** 6 and int ( b ) <= 10 ** 6 and int ( c ) <= 10 ** 6 : q = max ( q , int ( a ) + int ( b ) + int ( c ) ) print ( q ) NEWLINE NL ENDMARKER
import math NEWLINE p = ( 1 + math . sqrt ( 5 ) ) / 2 NEWLINE q = ( 1 - math . sqrt ( 5 ) ) / 2 NEWLINE def fib ( n ) : NEWLINE INDENT i = n - 1 NEWLINE x = ( p ** i - q ** i ) / ( p - q ) NEWLINE return int ( x ) NEWLINE DEDENT n = 5 NEWLINE print ( fib ( n ) ) NEWLINE NL ENDMARKER
def power ( x , y , p ) : NEWLINE INDENT res = 1 ; NEWLINE x = x % p ; NEWLINE while ( y > 0 ) : NEWLINE INDENTINDENT if ( y % 2 == 1 ) : NEWLINE INDENTINDENTINDENT res = ( res * x ) % p ; NEWLINE DEDENT y = y >> 1 ; NEWLINE x = ( x * x ) % p ; NEWLINE DEDENT return res ; NEWLINE DEDENT L = 2 ; P = pow ( 10 , 9 ) ; NEWLINE ans = power ( 325 , L , P ) ; NEWLINE print ( ans ) ; NEWLINE NL ENDMARKER
from math import log NEWLINE def log_a_to_base_b ( a , b ) : NEWLINE INDENT return log ( a ) // log ( b ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = 3 ; NEWLINE b = 2 ; NEWLINE print ( log_a_to_base_b ( a , b ) ) ; NEWLINE a = 256 ; NEWLINE b = 4 ; NEWLINE print ( log_a_to_base_b ( a , b ) ) ; NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) z = 0 for i in range ( n ) : for j in range ( n ) : if i != j : for k in range ( n ) : if i != k and j != k and a [ i ] == a [ j ] + a [ k ] : z = 1 print ( i + 1 , j + 1 , k + 1 ) break if z == 1 : break if z == 1 : breakif z == 0 : print ( - 1 ) NEWLINE NL ENDMARKER
while True : try : n , m = list ( map ( int , input ( ) . split ( ) ) ) res = 1 while m % 2 == 0 : res += 1 m /= 2 print ( res ) except : break NEWLINE NL ENDMARKER
s = [ i for i in input ( ) ] m = int ( input ( ) ) ; n = len ( s ) arr = list ( map ( int , input ( ) . split ( ) ) ) ; dp = [ 0 ] * nfor i in arr : dp [ i - 1 ] += 1 ; dp [ n - i ] += 1 for i in range ( 1 , n ) : dp [ i ] += dp [ i - 1 ] for i in range ( ( n + 1 ) // 2 ) : if dp [ i ] & 1 == 1 : s [ i ] , s [ n - i - 1 ] = s [ n - i - 1 ] , s [ i ] print ( "" . join ( s ) ) NEWLINE NL ENDMARKER
def circlearea ( a , b ) : NEWLINE INDENT if ( a < 0 or b < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT A = ( ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) ) NEWLINE return A NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = 8 NEWLINE b = 10 NEWLINE print ( circlearea ( a , b ) ) NEWLINE NL DEDENT ENDMARKER
from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect  NEWLINE NL ENDMARKER
import math NEWLINE def divisibleBy20 ( num ) : NEWLINE INDENT lastTwoDigits = int ( num [ - 2 : ] ) NEWLINE return ( ( lastTwoDigits % 5 == 0 and lastTwoDigits % 4 == 0 ) ) NEWLINE DEDENT num = "63284689320" NEWLINE if ( divisibleBy20 ( num ) == True ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) nn = nnnn = nb = [ ] o = [ ] c = 0 while n > 0 : n -= 1 bt , ot = map ( int , input ( ) . split ( ) ) b . append ( bt ) o . append ( ot ) for i in range ( 0 , nnn ) : if b [ i ] == o [ i ] and o . count ( o [ i ] ) == 1 : nn += 1 o = set ( o ) for i in o : temp = b . count ( i ) nn -= temp  print ( nn ) NEWLINE NL ENDMARKER
import osimport NEWLINE sysfrom NEWLINE io NEWLINE import BytesIO , IOBase   NEWLINE def main ( ) : import bisect NEWLINE INDENT pass NEWLINE DEDENT import NEWLINE INDENT math  NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) if n % 2 == 1 : print ( "-1" ) else : for i in range ( n ) : if i % 2 == 0 : print ( i + 2 , end = " " ) else : print ( i , end = " " ) NEWLINE NL ENDMARKER
def findNumbers ( n ) : NEWLINE INDENT ans = 'F' * ( n - 1 ) ; NEWLINE even = ans + 'E' ; NEWLINE odd = ans + 'F' ; NEWLINE print ( "Even: " , even ) ; NEWLINE print ( "Odd: " , odd ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 2 ; NEWLINE findNumbers ( n ) ; NEWLINE NL DEDENT ENDMARKER
def printProbability ( L , n ) : NEWLINE INDENT p = ( 1 << ( n - 1 ) ) NEWLINE return 1.0 - ( float ( n ) / float ( p ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 3 NEWLINE L = 5 NEWLINE print ( printProbability ( L , n ) ) NEWLINE NL DEDENT ENDMARKER
def countSetBits ( n ) : NEWLINE INDENT count = 0 NEWLINE while n : NEWLINE INDENTINDENT count += n & 1 NEWLINE n >>= 1 NEWLINE DEDENT return count NEWLINE DEDENT def countOfOddPascal ( n ) : NEWLINE INDENT c = countSetBits ( n ) NEWLINE return pow ( 2 , c ) NEWLINE DEDENT n = 20 NEWLINE print ( countOfOddPascal ( n ) ) NEWLINE NL ENDMARKER
def Findpermutation ( n ) : NEWLINE INDENT a = [ 0 ] * ( n + 1 ) ; NEWLINE a [ 1 ] = n ; NEWLINE for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT a [ i ] = i - 1 ; NEWLINE DEDENT return a ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 8 ; NEWLINE v = Findpermutation ( n ) ; NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT print ( v [ i ] , end = ' ' ) ; NEWLINE NL DEDENT DEDENT ENDMARKER
def checkFibinnary ( n ) : NEWLINE INDENT prev_last = 0 NEWLINE while ( n ) : NEWLINE INDENTINDENT if ( ( n & 1 ) and prev_last ) : NEWLINE INDENTINDENTINDENT return False NEWLINE DEDENT prev_last = n & 1 NEWLINE n >>= 1 NEWLINE DEDENT return True NEWLINE DEDENT n = 10 NEWLINE if ( checkFibinnary ( n ) ) : NEWLINE INDENT print ( "YES" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "NO" ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) )  main = [ ] for i in range ( n ) : s , e = map ( int , input ( ) . split ( ) ) main . append ( ( s , e ) )  main . sort ( key = lambda x : x [ 1 ] )  cs , ce = main [ 0 ] [ 0 ] , main [ 0 ] [ 1 ] count = 1 for s , e in main [ 1 : ] : if ce < s : count += 1 cs = s ce = e  print ( count ) NEWLINE NL ENDMARKER
n = int ( input ( ) )  for i in range ( n * n // 2 ) : print ( i + 1 , n * n - i ) NEWLINE NL ENDMARKER
def toggleLastMBits ( n , m ) : NEWLINE INDENT if ( m == 0 ) : NEWLINE INDENTINDENT return n NEWLINE DEDENT num = ( 1 << m ) - 1 NEWLINE return ( n ^ num ) NEWLINE DEDENT def largeNumWithNSetAndMUnsetBits ( n , m ) : NEWLINE INDENT num = ( 1 << ( n + m ) ) - 1 NEWLINE return toggleLastMBits ( num , m ) NEWLINE DEDENT n = 2 NEWLINE m = 2 NEWLINE print ( largeNumWithNSetAndMUnsetBits ( n , m ) ) NEWLINE NL ENDMARKER
a = int ( input ( ) ) b = int ( input ( ) ) c = abs ( b - a ) e = c // 2 d = c % 2 print ( e * ( e + 1 ) + d * ( d + e ) ) NEWLINE NL ENDMARKER
from math import gcd   def lcm ( a , b ) : return ( a / gcd ( a , b ) ) * b   num = "1"  n , k = map ( int , input ( ) . split ( ) ) for i in range ( k ) : num += "0" num = int ( num ) print ( int ( lcm ( num , n ) ) ) NEWLINE NL ENDMARKER
def prMultiples ( N ) : NEWLINE INDENT for i in range ( 1 , N + 1 ) : NEWLINE INDENTINDENT for j in range ( 1 , i + 1 ) : NEWLINE INDENTINDENTINDENT print ( ( i * j ) , end = " " ) NEWLINE DEDENT print ( ) NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 5 NEWLINE prMultiples ( N ) NEWLINE NL DEDENT ENDMARKER
x , y = map ( int , input ( ) . split ( ) )  dx = - 1 if x < 0 else 1 dy = - 1 if y < 0 else 1 v = abs ( x ) + abs ( y ) x1 = min ( 0 , v * dx ) y1 = v * dy if x1 == 0 else 0x2 = max ( 0 , v * dx ) y2 = v * dy if x2 == 0 else 0  print ( x1 , y1 , x2 , y2 ) NEWLINE NL ENDMARKER
for i in range ( int ( input ( ) ) ) : n , a , b = map ( int , input ( ) . split ( ) ) s = 'abcdefghijklmnopqrstuvwxyz' res = s [ 0 : b ] * ( n // b ) c = n - len ( res ) print ( res + s [ 0 : c ] ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) li = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n - 1 ) : print ( li [ i ] + li [ i + 1 ] , end = ' ' ) print ( li [ n - 1 ] )  NEWLINE NL ENDMARKER
PI = 3.14159265 NEWLINE def length_rope ( r ) : NEWLINE INDENT return ( ( 2 * PI * r ) + 6 * r ) NEWLINE DEDENT r = 7 NEWLINE print ( length_rope ( r ) ) NEWLINE NL ENDMARKER
import math NEWLINE def compute ( a , b ) : NEWLINE INDENT AM = ( a + b ) / 2 NEWLINE GM = math . sqrt ( a * b ) NEWLINE HM = ( GM * GM ) / AM NEWLINE return HM NEWLINE DEDENT a = 5 NEWLINE b = 15 NEWLINE HM = compute ( a , b ) NEWLINE print ( "Harmonic Mean between " , a , " and " , b , " is " , HM ) NEWLINE NL ENDMARKER
import sysfrom math import gcd  def main ( ) : n , m , z = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) return z // ( n * m // gcd ( n , m ) ) print ( main ( ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) li = [ ] for i in range ( n ) : A , B , C , D = map ( int , input ( ) . split ( ) ) sum_1 = A + B + C + D li . append ( sum_1 )  a = li [ 0 ] li . sort ( reverse = True ) print ( li . index ( a ) + 1 ) NEWLINE NL ENDMARKER
def triangular_series ( n ) : NEWLINE INDENT for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT print ( i * ( i + 1 ) // 2 , end = ' ' ) NEWLINE DEDENT DEDENT n = 5 NEWLINE triangular_series ( n ) NEWLINE NL ENDMARKER
for s in [ * open ( 0 ) ] [ 1 : ] : p , * a = map ( int , s . split ( ) ) ; print ( min ( - p % x for x in a ) ) NEWLINE NL ENDMARKER
def term ( n ) : NEWLINE INDENT d = 2 NEWLINE a1 = 0 NEWLINE An = a1 + ( n - 1 ) * d NEWLINE An = An ** 3 NEWLINE return An ; NEWLINE DEDENT n = 5 NEWLINE print ( term ( n ) ) NEWLINE NL ENDMARKER
n , a , k = int ( input ( ) ) , list ( map ( int , input ( ) . split ( ) ) ) , 10 ** 9 for i in range ( n ) : k = min ( k , a [ i ] // ( max ( n - i - 1 , i ) ) ) print ( k ) NEWLINE NL ENDMARKER
def findSum ( n ) : NEWLINE INDENT return ( n * ( pow ( n , 2 ) + 3 * n + 5 ) ) / 3 NEWLINE DEDENT n = 25 NEWLINE print ( int ( findSum ( n ) ) ) NEWLINE NL ENDMARKER
import mathimport sysinput = sys . stdin . readline  def inp ( ) : return ( int ( input ( ) ) ) def inlt ( ) : return ( list ( map ( int , input ( ) . split ( ) ) ) )  n = inp ( ) print ( n * ( n - 1 ) * 6 + 1 ) NEWLINE NL ENDMARKER
def find ( n ) : NEWLINE INDENT b = n NEWLINE a = b * ( n - 1 ) NEWLINE if a * b > n and a // b < n : NEWLINE INDENTINDENT print ( "a = {}, b = {}" . format ( a , b ) ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( - 1 ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 10 NEWLINE find ( n ) NEWLINE NL DEDENT ENDMARKER
import math NEWLINE NL ENDMARKER
n = int ( input ( ) ) if ( n <= 2 ) : print ( - 1 ) else : print ( ( ( pow ( 10 , n - 1 ) // 210 ) + 1 ) * 210 ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : h , m = map ( int , input ( ) . split ( ) ) s = 0 s = ( 24 - h - 1 ) * 60 + ( 60 - m ) print ( s ) NEWLINE NL ENDMARKER
kg = int ( input ( ) ) if kg <= 2 : print ( "NO" ) else : for n in range ( 2 , round ( kg / 2 ) + 1 , 2 ) : if ( kg - n ) % 2 == 0 : print ( "YES" ) break elif n == round ( kg / 2 ) or n == round ( kg / 2 ) - 1 : print ( "NO" ) NEWLINE NL ENDMARKER
def centeredHexagonalNumber ( n ) : NEWLINE INDENT return 3 * n * ( n - 1 ) + 1 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 10 NEWLINE print ( n , "th centered hexagonal number: " , centeredHexagonalNumber ( n ) ) NEWLINE NL DEDENT ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT nth = 0 NEWLINE if ( n % 2 == 0 ) : NEWLINE INDENTINDENT nth = 2 * ( ( n * n ) - n ) NEWLINE DEDENT else : NEWLINE INDENTINDENT nth = ( 2 * n * n ) - n NEWLINE DEDENT return nth NEWLINE DEDENT n = 5 NEWLINE print ( nthTerm ( n ) ) NEWLINE n = 25 NEWLINE print ( nthTerm ( n ) ) NEWLINE n = 25000000 NEWLINE print ( nthTerm ( n ) ) NEWLINE n = 250000007 NEWLINE print ( nthTerm ( n ) ) NEWLINE NL ENDMARKER
import mathn = int ( input ( ) ) NEWLINE NL ENDMARKER
PI = 3.14159265 NEWLINE def areacircumscribed ( a ) : NEWLINE INDENT return ( a * a * ( PI / 2 ) ) NEWLINE DEDENT a = 6 NEWLINE print ( " Area of an circumscribed circle is :" , round ( areacircumscribed ( a ) , 2 ) ) NEWLINE NL ENDMARKER
def product_subarrays ( arr , n ) : NEWLINE INDENT product = 1 ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT for j in range ( i , n ) : NEWLINE INDENTINDENTINDENT product *= arr [ j ] ; NEWLINE DEDENT DEDENT print ( product ) ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 10 , 3 , 7 ] ; NEWLINE n = len ( arr ) ; NEWLINE product_subarrays ( arr , n ) ; NEWLINE NL DEDENT ENDMARKER
def isEven ( n ) : NEWLINE INDENT return ( not ( n & 1 ) ) NEWLINE DEDENT n = 101 ; NEWLINE print ( "Even" if isEven ( n ) else "Odd" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) num2 = [ ] num = list ( map ( int , input ( ) . split ( ) ) ) num . sort ( ) count = 0  while len ( num ) != 0 : minno = min ( num ) count += 1 num2 = [ num [ i ] for i in range ( len ( num ) ) if num [ i ] % minno != 0 ] num . clear ( ) num . extend ( num2 ) num2 . clear ( ) print ( count ) NEWLINE NL ENDMARKER
def minMoves ( arr , n ) : NEWLINE INDENT expectedItem = n NEWLINE for i in range ( n - 1 , - 1 , - 1 ) : NEWLINE INDENTINDENT if ( arr [ i ] == expectedItem ) : NEWLINE INDENTINDENTINDENT expectedItem -= 1 NEWLINE DEDENT DEDENT return expectedItem NEWLINE DEDENT arr = [ 4 , 3 , 2 , 1 ] NEWLINE n = len ( arr ) NEWLINE print ( minMoves ( arr , n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) ans = 0 for a in range ( 1 , n ) : ans += ( n - a ) * aprint ( ans + n ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) s = input ( ) if n == 2 : if int ( s [ 0 ] ) >= int ( s [ 1 ] ) : print ( "NO" ) else : print ( "YES" ) print ( 2 ) print ( s [ 0 ] , s [ 1 ] ) else : print ( "YES" ) print ( 2 ) print ( s [ 0 ] , s [ 1 : ] ) NEWLINE NL ENDMARKER
def average ( a , n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT sum += a [ i ] NEWLINE DEDENT return sum / n ; NEWLINE DEDENT arr = [ 10 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEWLINE n = len ( arr ) NEWLINE print ( average ( arr , n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( n // 2 + 1 ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) NEWLINE it_is_end = False NEWLINE while True : NEWLINE INDENT for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT if m >= i : NEWLINE INDENTINDENTINDENT m -= i NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT it_is_end = True NEWLINE break NEWLINE DEDENT DEDENT if it_is_end : NEWLINE INDENTINDENT break NEWLINE DEDENT DEDENT print ( m ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for i in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) if a % b == 0 : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
def getSum ( n , d ) : NEWLINE INDENT sum = 0 ; NEWLINE for i in range ( n + 1 ) : NEWLINE INDENTINDENT if ( i % 10 == d ) : NEWLINE INDENTINDENTINDENT sum += i NEWLINE DEDENT DEDENT return sum NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n , d = 30 , 3 NEWLINE print ( getSum ( n , d ) ) NEWLINE NL DEDENT ENDMARKER
def oddEquivalent ( s , n ) : NEWLINE INDENT count = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT if ( s [ i ] == '1' ) : NEWLINE INDENTINDENTINDENT count = count + 1 NEWLINE DEDENT DEDENT return count NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT s = "1011011" NEWLINE n = len ( s ) NEWLINE print ( oddEquivalent ( s , n ) ) NEWLINE NL DEDENT ENDMARKER
def decimalToBinary ( N ) : NEWLINE INDENT B_Number = 0 NEWLINE cnt = 0 NEWLINE while ( N != 0 ) : NEWLINE INDENTINDENT rem = N % 2 NEWLINE c = pow ( 10 , cnt ) NEWLINE B_Number += rem * c NEWLINE N //= 2 NEWLINE cnt += 1 NEWLINE DEDENT return B_Number NEWLINE DEDENT N = 17 NEWLINE print ( decimalToBinary ( N ) ) NEWLINE NL ENDMARKER
import math NEWLINE def getRightMostSetBit ( n ) : NEWLINE INDENT return int ( math . log2 ( n & - n ) ) + 1 NEWLINE DEDENT def posOfRightMostSameBit ( m , n ) : NEWLINE INDENT return getRightMostSetBit ( ~ ( m ^ n ) ) NEWLINE DEDENT m , n = 16 , 7 NEWLINE print ( "Position = " , posOfRightMostSameBit ( m , n ) ) NEWLINE NL ENDMARKER
import math NEWLINE def getFirstSetBitPos ( n ) : NEWLINE INDENT return math . log2 ( n & - n ) + 1 NEWLINE DEDENT n = 12 NEWLINE print ( int ( getFirstSetBitPos ( n ) ) ) NEWLINE NL ENDMARKER
t = input ( )  t = t . split ( )  n = int ( t [ 0 ] )  c1 = int ( t [ 1 ] )  c2 = int ( t [ 2 ] )  t = input ( )  d = 0  for i in t :  if ( i == "1" ) :  d = d + 1    min = 10 ** 1488  for i in range ( 1 , d + 1 ) :  t = c1 * i + i * c2 * ( ( ( n // i ) - 1 ) ** 2 ) + c2 * ( n % i ) * ( 2 * ( n // i ) - 1 )  if t < min :  min = t    print ( min )    NEWLINE NL ENDMARKER
s , t = input ( ) , input ( ) n , m = len ( t ) , len ( s ) + 1 d = 1000000007 g = [ 1 ] * mf = k = 0 for i in range ( 1 , m ) : if s [ i - n : i ] == t : k = i if k : f = ( f + g [ k - n ] ) % d g [ i ] += ( g [ i - 1 ] + f ) % dprint ( f ) NEWLINE NL ENDMARKER
for s in [ * open ( 0 ) ] [ 1 : ] : p , a , b , c = map ( int , s . split ( ) ) ; print ( - max ( - p // a * a , - p // b * b , - p // c * c ) - p ) NEWLINE NL ENDMARKER
from math import ceil  t = int ( input ( ) )  l = 'zyxwvutsrqponmlkjihgfedcba' for i in range ( t ) : n , a , b = map ( int , input ( ) . split ( ) )  x = l [ : b ] x = ( x * ceil ( a / b ) ) [ : a ] x = ( x * ceil ( n / a ) ) [ : n ]  print ( x ) NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) print ( 'VVlaaldeirka' [ ( ( 4 * b + 1 ) ** .5 - 1 ) // 2 < a ** .5 // 1 : : 2 ] ) NEWLINE NL ENDMARKER
x = int ( input ( ) )  flag = Falsefor a in range ( 1 , x + 1 ) : for b in range ( 1 , x + 1 ) : if a % b == 0 and a * b > x and a / b < x : flag = True break if flag : breakif not flag : print ( '-1' ) if flag : print ( a , b ) NEWLINE NL ENDMARKER
def printCollatz ( n ) : NEWLINE INDENT while n != 1 : NEWLINE INDENTINDENT print ( n , end = ' ' ) NEWLINE if n & 1 : NEWLINE INDENTINDENTINDENT n = 3 * n + 1 NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT n = n // 2 NEWLINE DEDENT DEDENT print ( n ) NEWLINE DEDENT printCollatz ( 6 ) NEWLINE NL ENDMARKER
import NEWLINE INDENT sysinput = sys . stdin . readline  NEWLINE NL DEDENT ENDMARKER
import math NEWLINE def edgeDisjoint ( n ) : NEWLINE INDENT result = 0 NEWLINE result = math . floor ( n / 2 ) NEWLINE return result NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 4 NEWLINE print ( int ( edgeDisjoint ( n ) ) ) NEWLINE NL DEDENT ENDMARKER
def getModulo ( n , d ) : NEWLINE INDENT return ( n & ( d - 1 ) ) NEWLINE DEDENT n = 6 NEWLINE d = 4 NEWLINE print ( n , "moduo" , d , "is" , getModulo ( n , d ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) d = { } for i in s : if ( i in d ) : d [ i ] += 1 else : d [ i ] = 1 if ( len ( d ) == 2 ) : s1 = '1' * 1 + '0' * d [ '0' ] print ( s1 ) else : if ( '0' in d ) : print ( '0' * d [ '0' ] ) else : print ( '1' ) NEWLINE NL ENDMARKER
def findSum ( n ) : NEWLINE INDENT return ( ( n * ( n + 1 ) * ( n + 1 ) * ( n + 2 ) ) / 12 ) NEWLINE DEDENT n = 3 NEWLINE print ( int ( findSum ( n ) ) ) NEWLINE NL ENDMARKER
from sys import stdin , stdoutfrom collections import dequeinput = stdin . readline def main ( ) : NEWLINE NL ENDMARKER
def countDistinctCode ( string ) : NEWLINE INDENT codes = set ( ) NEWLINE for i in range ( 0 , len ( string ) - 1 ) : NEWLINE INDENTINDENT codes . add ( string [ i : i + 2 ] ) NEWLINE DEDENT return len ( codes ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT string = "UPUP" NEWLINE print ( countDistinctCode ( string ) ) NEWLINE NL DEDENT ENDMARKER
def sumOfSeries ( n ) : NEWLINE INDENT return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 NEWLINE DEDENT n = 4 NEWLINE print sumOfSeries ( n ) NEWLINE NL ENDMARKER
def sequence ( n ) : NEWLINE INDENT f = [ 0 , 1 , 1 ] NEWLINE print ( f [ 1 ] , end = " " ) , NEWLINE print ( f [ 2 ] , end = " " ) , NEWLINE for i in range ( 3 , n + 1 ) : NEWLINE INDENTINDENT f . append ( f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ) NEWLINE print ( f [ i ] , end = " " ) , NEWLINE DEDENT DEDENT n = 13 NEWLINE sequence ( n ) NEWLINE NL ENDMARKER
ABMR = list ( map ( int , input ( ) . split ( ) ) )  NEWLINE NL ENDMARKER
def averageValue ( s ) : NEWLINE INDENT sum_char = 0 NEWLINE for i in range ( len ( s ) ) : NEWLINE INDENTINDENT sum_char += ord ( s [ i ] ) NEWLINE DEDENT return sum_char // len ( s ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT s = "GeeksforGeeks" NEWLINE print ( averageValue ( s ) ) NEWLINE NL DEDENT ENDMARKER
n , k = [ int ( x ) for x in input ( ) . split ( ) ] capacities = [ int ( x ) for x in input ( ) . split ( ) ] mods = [ n % capacities [ i ] for i in range ( k ) ] min_mod = min ( mods ) index = mods . index ( min_mod ) print ( "{} {}" . format ( index + 1 , n // capacities [ index ] ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) arr = [ ( int ( i ) + n ) % n for i in input ( ) . split ( ) ] occ = [ 0 for i in range ( n ) ] no = 0 for i in range ( n ) : if occ [ ( i + arr [ i ] ) % n ] != 1 : occ [ ( i + arr [ i ] ) % n ] = 1 else : print ( "NO" ) no = 1 break if not no : print ( "YES" ) NEWLINE NL ENDMARKER
L = [ int ( X ) for X in input ( ) . split ( ) ] S = sum ( L ) if S == 0 : print ( - 1 ) else : if S % 5 == 0 : print ( S // 5 ) else : print ( - 1 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ans = [ ] check = sorted ( a ) i , j = 0 , n - 1 while i < j : ans . append ( check [ i ] ) ans . append ( check [ j ] ) i += 1 j -= 1 if i == j : ans . append ( check [ i ] ) print ( * ans ) NEWLINE NL ENDMARKER
s = input ( ) s = s [ 1 : ]  l = len ( s ) bigg = 10 ** lif not s : print ( 1 ) else : print ( bigg - int ( s ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) i = n p = list ( ) while i >= 10 : l = i - ( i % 10 ) p . append ( l ) k = ( i // 10 ) + ( i % 10 ) i = k print ( sum ( p ) + i ) NEWLINE NL ENDMARKER
def minimumSquare ( a , b ) : NEWLINE INDENT result = 0 NEWLINE rem = 0 NEWLINE if ( a < b ) : NEWLINE INDENTINDENT a , b = b , a NEWLINE DEDENT while ( b > 0 ) : NEWLINE INDENTINDENT result += int ( a / b ) NEWLINE rem = int ( a % b ) NEWLINE a = b NEWLINE b = rem NEWLINE DEDENT return result NEWLINE DEDENT n = 13 NEWLINE m = 29 NEWLINE print ( minimumSquare ( n , m ) ) NEWLINE NL ENDMARKER
import math , sys  input = sys . stdin . buffer . readline  NEWLINE def read ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEWLINE  for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE a = read ( ) NEWLINE suma = sum ( a ) NEWLINE s = max ( max ( a ) , math . ceil ( suma / ( n - 1 ) ) ) NEWLINE print ( s * ( n - 1 ) - suma ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) numbers = list ( map ( int , input ( ) . split ( " " ) ) ) player_1 = 1 player_2 = 0 for i in range ( n - 1 ) : if player_1 == 1 : numbers . remove ( max ( numbers ) ) else : numbers . remove ( min ( numbers ) ) player_1 , player_2 = player_2 , player_1print ( numbers [ 0 ] ) NEWLINE NL ENDMARKER
def kthSmallest ( arr , n , k ) : NEWLINE INDENT arr . sort ( ) NEWLINE return arr [ k - 1 ] NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 12 , 3 , 5 , 7 , 19 ] NEWLINE n = len ( arr ) NEWLINE k = 2 NEWLINE print ( "K'th smallest element is" , kthSmallest ( arr , n , k ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) output = [ ] for i in range ( max ( n - 81 , 0 ) , n ) : listi = list ( map ( int , str ( i ) ) ) if ( i + sum ( listi ) == n ) : output . append ( i ) print ( len ( output ) ) for i in range ( len ( output ) ) : print ( output [ i ] ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) dp = [ 0 ] * ( n + 1 ) dp [ 1 ] = 2 for i in range ( 2 , n + 1 ) : c = 0 for j in range ( p [ i - 1 ] , i ) : c += dp [ j ] dp [ i ] = c + 2 print ( sum ( dp ) % ( 10 ** 9 + 7 ) ) NEWLINE NL ENDMARKER
a , b , c = list ( map ( int , input ( ) . split ( ) ) ) print ( b * c + ( ( a - 1 ) * ( c + b - 1 ) ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( * range ( n , 2 * n ) ) NEWLINE NL ENDMARKER
A = [ 11 , 15 , 7 , 19 ] NEWLINE N = len ( A ) NEWLINE Set = set ( ) NEWLINE for i in range ( 0 , N ) : NEWLINE INDENT res = 2147483647 NEWLINE for j in range ( i , N ) : NEWLINE INDENTINDENT res &= A [ j ] NEWLINE Set . add ( res ) NEWLINE DEDENT DEDENT print ( Set ) NEWLINE NL ENDMARKER
def ways ( n ) : NEWLINE INDENT first = 2 ; NEWLINE second = 3 ; NEWLINE res = 0 ; NEWLINE for i in range ( 3 , n + 1 ) : NEWLINE INDENTINDENT res = first + second ; NEWLINE first = second ; NEWLINE second = res ; NEWLINE DEDENT return res ; NEWLINE DEDENT n = 7 ; NEWLINE print ( "Total ways are: " , ways ( n ) ) ; NEWLINE NL ENDMARKER
def numberSequence ( n ) : NEWLINE INDENT num = pow ( 4 , n ) - pow ( 2 , n ) - 1 NEWLINE return num NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 4 NEWLINE print ( numberSequence ( n ) ) NEWLINE NL DEDENT ENDMARKER
def avgOfFirstN ( n ) : NEWLINE INDENT return ( float ) ( 1 + n ) / 2 ; NEWLINE DEDENT n = 20 NEWLINE print ( avgOfFirstN ( n ) ) NEWLINE NL ENDMARKER
def sumOfSeries ( n ) : NEWLINE INDENT return ( int ) ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ) NEWLINE DEDENT n = 2 NEWLINE print ( sumOfSeries ( n ) ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for i in range ( t ) : x = int ( input ( ) ) if x % 2 == 0 and x > 2 : print ( x // 2 ) elif x == 1 or x == 2 : print ( 1 ) else : print ( ( x // 2 ) + 1 ) NEWLINE NL ENDMARKER
import mathimport sysimport bisect NEWLINE NL ENDMARKER
for x in range ( int ( input ( ) ) ) : n = int ( input ( ) ) print ( n // 2 - 1 ) if n % 2 == 0 else print ( n // 2 ) NEWLINE NL ENDMARKER
num = int ( input ( ) ) NEWLINE num %= 9 NEWLINE if ( num == 0 ) : NEWLINE INDENT num = 9 NEWLINE DEDENT print ( num ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = list ( map ( int , input ( ) . split ( ) ) ) a = sorted ( s , reverse = True ) sum_a = sum ( [ a [ x ] * x + 1 for x in range ( 0 , n ) ] ) print ( sum_a ) i = 0 while i < n : print ( s . index ( a [ i ] ) + 1 , end = " " ) s [ s . index ( a [ i ] ) ] = 0 i += 1 NEWLINE NL ENDMARKER
import matht = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) [ : t ] h = 0 for i in a : if ( i == 1 ) : h = h + 1 if ( h > 0 ) : print ( "HARD" ) else : print ( "EASY" ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) a , b , c , d = input ( ) . split ( ) if n < 5 or k < n + 1 : print ( - 1 ) else : l = list ( set ( map ( str , range ( 1 , n + 1 ) ) ) - { a , b , c , d } ) print ( ' ' . join ( [ a , c ] + l + [ d , b ] + [ c , a ] + l + [ b , d ] ) ) NEWLINE NL ENDMARKER
def logicOfSequence ( N ) : NEWLINE INDENT if ( N % 2 == 0 ) : NEWLINE INDENTINDENT N = N * N NEWLINE DEDENT else : NEWLINE INDENTINDENT N = N * N * N NEWLINE DEDENT return N NEWLINE DEDENT N = 6 NEWLINE print ( logicOfSequence ( N ) ) NEWLINE NL ENDMARKER
def countPaths ( n ) : NEWLINE INDENT zB = 1 NEWLINE zADC = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT nzB = zADC * 3 NEWLINE nzADC = ( zADC * 2 + zB ) NEWLINE zB = nzB NEWLINE zADC = nzADC NEWLINE DEDENT return zB NEWLINE DEDENT n = 3 NEWLINE print ( countPaths ( n ) ) NEWLINE NL ENDMARKER
s = input ( ) l = list ( map ( str , input ( ) . split ( ) ) ) k = '' . join ( map ( str , l ) ) c = 0 if s [ 0 ] in k or s [ 1 ] in k : c = c + 1 if c >= 1 : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
a , b , c = map ( int , input ( ) . split ( ) ) if abs ( a ) + abs ( b ) <= c : if ( c - ( abs ( a ) + abs ( b ) ) ) % 2 == 0 : print ( 'Yes' ) else : print ( "No" ) else : print ( "No" ) NEWLINE NL ENDMARKER
def nthHarmonic ( N ) : NEWLINE INDENT harmonic = 1.00 NEWLINE for i in range ( 2 , N + 1 ) : NEWLINE INDENTINDENT harmonic += 1 / i NEWLINE DEDENT return harmonic NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 8 NEWLINE print ( round ( nthHarmonic ( N ) , 5 ) ) NEWLINE NL DEDENT ENDMARKER
a , b , c = map ( int , input ( ) . split ( ) ) ans = [ ] for i in range ( 1 , 82 ) : t = b * i ** a + c if t > 0 and t <= 10 ** 9 : k = t s = 0 while k : s += k % 10 k //= 10 if s == i : ans . append ( t ) print ( len ( ans ) ) print ( * ans ) NEWLINE NL ENDMARKER
def minIndex ( arr , n , pos ) : NEWLINE INDENT num = arr [ pos ] NEWLINE i = pos - 1 NEWLINE while ( i >= 0 ) : NEWLINE INDENTINDENT if ( arr [ i ] != num ) : NEWLINE INDENTINDENTINDENT break NEWLINE DEDENT i -= 1 NEWLINE DEDENT return i + 1 NEWLINE DEDENT arr = [ 2 , 1 , 1 , 1 , 5 , 2 ] NEWLINE n = len ( arr ) NEWLINE pos = 4 NEWLINE print ( minIndex ( arr , n , pos ) ) NEWLINE NL ENDMARKER
def maxnumber ( n , k ) : NEWLINE INDENT for i in range ( 0 , k ) : NEWLINE INDENTINDENT ans = 0 NEWLINE i = 1 NEWLINE while n // i > 0 : NEWLINE INDENTINDENTINDENT temp = ( n // ( i * 10 ) ) * i + ( n % i ) NEWLINE i *= 10 NEWLINE if temp > ans : NEWLINE INDENTINDENTINDENTINDENT ans = temp NEWLINE DEDENT DEDENT n = ans NEWLINE DEDENT return ans ; NEWLINE DEDENT n = 6358 NEWLINE k = 1 NEWLINE print ( maxnumber ( n , k ) ) NEWLINE NL ENDMARKER
import mathfor _ in range ( 1 ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) g = 0 for i in range ( 0 , len ( a ) ) : g = math . gcd ( a [ i ] , g ) maxi = max ( a ) // g if ( n - maxi ) % 2 == 0 : print ( "Bob" ) else : print ( "Alice" ) NEWLINE NL ENDMARKER
import math NEWLINE def summingSeries ( n ) : NEWLINE INDENT return math . pow ( n , 2 ) NEWLINE DEDENT n = 100 NEWLINE print ( "The sum of n term is: " , summingSeries ( n ) ) NEWLINE NL ENDMARKER
from math import * NEWLINE def trapezoidarea ( r ) : NEWLINE INDENT if r < 0 : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT a = ( 3 * sqrt ( 3 ) * pow ( r , 2 ) ) / 4 NEWLINE return a NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT r = 5 NEWLINE print ( round ( trapezoidarea ( r ) , 3 ) ) NEWLINE NL DEDENT ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) s = list ( map ( int , input ( ) . split ( ) ) ) s . sort ( ) x = [ ] for i in range ( 1 , n ) : x . append ( s [ i ] - s [ i - 1 ] ) print ( min ( x ) ) NEWLINE NL ENDMARKER
try : q = int ( input ( ) ) for i in range ( q ) : s = input ( ) t = input ( ) v = True for j in s : if t . __contains__ ( j ) : print ( "YES" ) v = False break if v : print ( "NO" ) except : pass NEWLINE NL ENDMARKER
n , b , p = map ( int , input ( ) . split ( ) )  garrafas = ( n - 1 ) * ( 2 * b + 1 ) toalhas = n * p  print ( garrafas , toalhas )  NEWLINE NL ENDMARKER
import sys NEWLINE from math import sqrt NEWLINE def min_moves ( n ) : NEWLINE INDENT ans = sys . maxsize ; NEWLINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEWLINE INDENTINDENT if ( n % i == 0 ) : NEWLINE INDENTINDENTINDENT ans = min ( ans , i + n // i - 2 ) ; NEWLINE DEDENT DEDENT return ans ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 10 ; NEWLINE print ( min_moves ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
from math import gcdn = int ( input ( ) ) ; arr = list ( map ( int , input ( ) . split ( ) ) ) s = set ( ) for i in arr : while i % 2 == 0 : i = i // 2 while i % 3 == 0 : i = i // 3 s . add ( i ) if len ( s ) != 1 : print ( "NO" ) else : print ( "YES" ) NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) c = ( a * b ) // 2 print ( c ) NEWLINE NL ENDMARKER
def getProduct ( n ) : NEWLINE INDENT product = 1 NEWLINE while ( n != 0 ) : NEWLINE INDENTINDENT product = product * ( n % 10 ) NEWLINE n = n // 10 NEWLINE DEDENT return product NEWLINE DEDENT n = 4513 NEWLINE print ( getProduct ( n ) ) NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) )  names = dict ( )  for i in range ( a ) : x , y = input ( ) . split ( ) names [ y ] = x  for i in range ( b ) : com = input ( )  h = com . split ( ) [ - 1 ] [ : - 1 ] print ( f"{com} #{names[h]}" ) NEWLINE NL ENDMARKER
def dist ( m , b1 , b2 ) : NEWLINE INDENT d = abs ( b2 - b1 ) / ( ( m * m ) - 1 ) ; NEWLINE return d ; NEWLINE DEDENT def main ( ) : NEWLINE INDENT m , b1 , b2 = 2 , 4 , 3 ; NEWLINE print ( dist ( m , b1 , b2 ) ) ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT main ( ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) s = input ( ) ; flag = True ; cnt = 0 for i in range ( 0 , n - 10 , 2 ) : NEWLINE NL ENDMARKER
def PowerOFPINnfactorial ( n , p ) : NEWLINE INDENT ans = 0 ; NEWLINE temp = p ; NEWLINE while ( temp <= n ) : NEWLINE INDENTINDENT ans += n / temp ; NEWLINE temp = temp * p ; NEWLINE DEDENT return ans ; NEWLINE DEDENT print ( PowerOFPINnfactorial ( 4 , 2 ) ) ; NEWLINE NL ENDMARKER
print ( ( int ( input ( ) ) // 2 ) + 1 ) NEWLINE NL ENDMARKER
def cntSquares ( n ) : NEWLINE INDENT return int ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( cntSquares ( 4 ) ) ; NEWLINE NL DEDENT ENDMARKER
def count_of_ways ( n ) : NEWLINE INDENT count = 0 NEWLINE count = ( n + 1 ) * ( n + 2 ) // 2 NEWLINE return count NEWLINE DEDENT n = 3 NEWLINE print ( count_of_ways ( n ) ) NEWLINE NL ENDMARKER
a = list ( map ( int , input ( ) . split ( " " ) ) ) a . sort ( ) print ( abs ( a [ 1 ] - a [ 0 ] ) + abs ( a [ 1 ] - a [ 2 ] ) ) NEWLINE NL ENDMARKER
for i in range ( int ( input ( ) ) ) : l , r = map ( int , input ( ) . split ( ) ) print ( l , 2 * l ) NEWLINE NL ENDMARKER
def findNumber ( n , m ) : NEWLINE INDENT num = ( m - 1 ) * 9 + n ; NEWLINE return num ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 2 ; NEWLINE m = 5 ; NEWLINE print ( findNumber ( n , m ) ) NEWLINE NL DEDENT ENDMARKER
def find_greatest_divisor ( l , r ) : NEWLINE INDENT if ( l == r ) : NEWLINE INDENTINDENT return l ; NEWLINE DEDENT return 1 ; NEWLINE DEDENT l = 2 ; NEWLINE r = 12 ; NEWLINE print ( find_greatest_divisor ( l , r ) ) ; NEWLINE NL ENDMARKER
def squaresum ( n ) : NEWLINE INDENT sm = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT sm = sm + ( i * i ) NEWLINE DEDENT return sm NEWLINE DEDENT n = 4 NEWLINE print ( squaresum ( n ) ) NEWLINE NL ENDMARKER
def calTime ( arr , n ) : NEWLINE INDENT work = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT work += 1 / arr [ i ] NEWLINE DEDENT return 1 / work NEWLINE DEDENT arr = [ 6.0 , 3.0 , 4.0 ] NEWLINE n = len ( arr ) NEWLINE print ( calTime ( arr , n ) , "Hours" ) NEWLINE NL ENDMARKER
n , t = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) : if 86400 - a [ i ] >= t : print ( i + 1 ) break else : t -= 86400 - a [ i ] NEWLINE NL ENDMARKER
from collections import Counter  def solve ( ) : str1 = input ( ) str2 = input ( ) count , j = 1 , 0  for i in range ( len ( str2 ) ) : if str1 [ j ] == str2 [ i ] : count += 1 j += 1  return count     print ( solve ( ) ) NEWLINE NL ENDMARKER
def getSum ( n , d ) : NEWLINE INDENT if ( n < d ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT while ( n % 10 != d ) : NEWLINE INDENTINDENT n -= 1 NEWLINE DEDENT k = n // 10 NEWLINE return ( ( k + 1 ) * d + ( k * 10 + 10 * k * k ) // 2 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 30 NEWLINE d = 3 NEWLINE print ( getSum ( n , d ) ) NEWLINE NL DEDENT ENDMARKER
def Race ( B , C ) : NEWLINE INDENT result = 0 ; NEWLINE result = ( ( C * 100 ) // B ) NEWLINE return 100 - result NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT B = 10 NEWLINE C = 28 NEWLINE B = 100 - B ; NEWLINE C = 100 - C ; NEWLINE print ( str ( Race ( B , C ) ) + " meters" ) NEWLINE NL DEDENT ENDMARKER
def sum ( a , b ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 1 , min ( a , b ) ) : NEWLINE INDENTINDENT if ( a % i == 0 and b % i == 0 ) : NEWLINE INDENTINDENTINDENT sum += i NEWLINE DEDENT DEDENT return sum NEWLINE DEDENT A = 10 NEWLINE B = 15 NEWLINE print ( "Sum =" , sum ( A , B ) ) NEWLINE NL ENDMARKER
num_numbers = int ( input ( ) ) integers = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) num_nums = [ ] for number in set ( integers ) : num_nums . append ( integers . count ( number ) ) num_nums = sorted ( num_nums , reverse = True ) print ( num_nums [ 0 ] ) NEWLINE NL ENDMARKER
import math NEWLINE def firstDigit ( n ) : NEWLINE INDENT digits = ( int ) ( math . log10 ( n ) ) NEWLINE n = ( int ) ( n / pow ( 10 , digits ) ) NEWLINE return n ; NEWLINE DEDENT def lastDigit ( n ) : NEWLINE INDENT return ( n % 10 ) NEWLINE DEDENT n = 98562 ; NEWLINE print ( firstDigit ( n ) , end = " " ) NEWLINE print ( lastDigit ( n ) ) NEWLINE NL ENDMARKER
def highestPowerOf2 ( n ) : NEWLINE INDENT return ( n & ( ~ ( n - 1 ) ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 48 NEWLINE print ( highestPowerOf2 ( n ) ) NEWLINE NL DEDENT ENDMARKER
def countSetBits ( n ) : NEWLINE INDENT count = 0 NEWLINE while ( n ) : NEWLINE INDENTINDENT count += n & 1 NEWLINE n >>= 1 NEWLINE DEDENT return count NEWLINE DEDENT i = 9 NEWLINE print ( countSetBits ( i ) ) NEWLINE NL ENDMARKER
n , m , k = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) )  no = 0 nt = 0  for i in a : if i == 1 : no += 1 else : nt += 1  ans = ( 0 if no - m < 0 else ( no - m ) ) + ( 0 if ( nt - ( k + ( abs ( no - m ) if no - m < 0 else 0 ) ) ) < 0 else ( nt - ( k + ( abs ( no - m ) if no - m < 0 else 0 ) ) ) )  print ( ans ) NEWLINE NL ENDMARKER
def Fibonacci ( n ) : NEWLINE INDENT if n < 0 : NEWLINE INDENTINDENT print ( "Incorrect input" ) NEWLINE DEDENT elif n == 0 : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT elif n == 1 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT else : NEWLINE INDENTINDENT return Fibonacci ( n - 1 ) + Fibonacci ( n - 2 ) NEWLINE DEDENT DEDENT print ( Fibonacci ( 9 ) ) NEWLINE NL ENDMARKER
def minCost ( arr , n ) : NEWLINE INDENT count_even = 0 NEWLINE count_odd = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT if ( arr [ i ] % 2 == 0 ) : NEWLINE INDENTINDENTINDENT count_even += 1 NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT count_odd += 1 NEWLINE DEDENT DEDENT return min ( count_even , count_odd ) NEWLINE DEDENT arr = [ 2 , 4 , 3 , 1 , 5 ] NEWLINE n = len ( arr ) NEWLINE print ( minCost ( arr , n ) ) NEWLINE NL ENDMARKER
def isMultipleOf10 ( n ) : NEWLINE INDENT return ( n % 15 == 0 ) NEWLINE DEDENT n = 30 NEWLINE if ( isMultipleOf10 ( n ) ) : NEWLINE INDENT print ( "Yes" ) ; NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) ; NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) MOD = 1000000007 print ( ( pow ( 3 , 3 * n ) - pow ( 7 , n ) ) % MOD ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) a = [ i + 1 for i in range ( n * 2 ) ] for i in range ( 1 , k + 1 ) : a [ 2 * ( i - 1 ) ] , a [ ( 2 * i ) ] = a [ 2 * i ] , a [ 2 * ( i - 1 ) ] print ( * a ) NEWLINE NL ENDMARKER
import math ; NEWLINE def normal ( m , n ) : NEWLINE INDENT N = ( ( abs ( m ) * abs ( n ) ) / math . sqrt ( ( abs ( m ) * abs ( m ) ) + ( abs ( n ) * abs ( n ) ) ) ) ; NEWLINE return N ; NEWLINE DEDENT m = - 5 ; n = 3 ; NEWLINE print ( normal ( m , n ) ) ; NEWLINE NL ENDMARKER
a , b = [ int ( i ) for i in input ( ) . split ( ) ] if ( abs ( a - b ) > 1 or ( a == 0 and b == 0 ) ) : print ( "NO" ) else : print ( "YES" ) NEWLINE NL ENDMARKER
I = lambda : map ( int , input ( ) . split ( ) ) n , t = I ( ) a = * I ( ) , x = 0 while x < t - 1 : x += a [ x ] print ( 'YNEOS' [ x >= t : : 2 ] ) NEWLINE NL ENDMARKER
from math import sqrt NEWLINE def largestCube ( r ) : NEWLINE INDENT if ( r < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT a = ( 2 * r ) / sqrt ( 3 ) NEWLINE return a NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT r = 5 NEWLINE print ( "{0:.6}" . format ( largestCube ( r ) ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) )  print ( 9 * n , " " , 8 * n ) NEWLINE NL ENDMARKER
x = int ( input ( ) ) print ( ( x + 4 ) // 5 ) NEWLINE NL ENDMARKER
def oddDays ( N ) : NEWLINE INDENT hund1 = N // 100 NEWLINE hund4 = N // 400 NEWLINE leap = N >> 2 NEWLINE ordd = N - leap NEWLINE if ( hund1 ) : NEWLINE INDENTINDENT ordd += hund1 NEWLINE leap -= hund1 NEWLINE DEDENT if ( hund4 ) : NEWLINE INDENTINDENT ordd -= hund4 NEWLINE leap += hund4 NEWLINE DEDENT days = ordd + leap * 2 NEWLINE odd = days % 7 NEWLINE return odd NEWLINE DEDENT N = 100 NEWLINE print ( oddDays ( N ) ) NEWLINE NL ENDMARKER
z = 0 x = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) for i in range ( 1 , x [ 2 ] + 1 ) : z = z + ( i * x [ 0 ] ) if x [ 1 ] - z < 0 : print ( abs ( z - x [ 1 ] ) ) else : print ( 0 ) NEWLINE NL ENDMARKER
def pointIsOnLine ( m , c , x , y ) : NEWLINE INDENT if ( y == ( ( m * x ) + c ) ) : NEWLINE INDENTINDENT return True ; NEWLINE DEDENT return False ; NEWLINE DEDENT m = 3 ; c = 2 ; NEWLINE x = 1 ; y = 5 ; NEWLINE if ( pointIsOnLine ( m , c , x , y ) ) : NEWLINE INDENT print ( "Yes" ) ; NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) ; NEWLINE NL DEDENT ENDMARKER
N , M , R = map ( int , input ( ) . split ( ) ) S = list ( map ( int , input ( ) . split ( ) ) ) B = list ( map ( int , input ( ) . split ( ) ) ) ms = min ( S ) mb = max ( B ) print ( max ( mb * ( R // ms ) + R % ms , R ) ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for _ in range ( t ) : x , y = tuple ( map ( int , input ( ) . split ( ' ' ) ) ) print ( 0 if x % y == 0 else y - x % y ) NEWLINE NL ENDMARKER
from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 1 ) : NEWLINE NL ENDMARKER
def AVLtree ( H , a , b ) : NEWLINE INDENT if ( H == 0 ) : NEWLINE INDENTINDENT return 1 ; NEWLINE DEDENT if ( H == 1 ) : NEWLINE INDENTINDENT return b ; NEWLINE DEDENT return AVLtree ( H - 1 , b , a + b + 1 ) ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT H = 5 ; NEWLINE answer = AVLtree ( H , 1 , 2 ) ; NEWLINE print ( "n(" , H , ") = " \ , answer ) ; NEWLINE NL DEDENT ENDMARKER
def getMissingNo ( a , n ) : NEWLINE INDENT i , total = 0 , 1 NEWLINE for i in range ( 2 , n + 2 ) : NEWLINE INDENTINDENT total += i NEWLINE total -= a [ i - 2 ] NEWLINE DEDENT return total NEWLINE DEDENT arr = [ 1 , 2 , 3 , 5 ] NEWLINE print ( getMissingNo ( arr , len ( arr ) ) ) NEWLINE NL ENDMARKER
def countSetBits ( n ) : NEWLINE INDENT count = 0 NEWLINE while ( n ) : NEWLINE INDENTINDENT count += n & 1 NEWLINE n >>= 1 NEWLINE DEDENT return count NEWLINE DEDENT i = 3 NEWLINE print ( countSetBits ( i ) ) NEWLINE NL ENDMARKER
n , v = map ( int , input ( ) . split ( ) ) l1 = [ ]  for i in range ( n ) : l = list ( map ( int , input ( ) . split ( ) ) ) if ( min ( l [ 1 : ] ) < v ) : l1 . append ( ( i , min ( l [ 1 : ] ) ) ) sorted ( l1 , key = lambda l1 : l1 [ 1 ] ) print ( len ( l1 ) ) for i in l1 : print ( i [ 0 ] + 1 , end = " " ) NEWLINE NL ENDMARKER
def gcd ( a , b ) : NEWLINE INDENT if ( b == 0 ) : NEWLINE INDENTINDENT return a NEWLINE DEDENT return ( gcd ( b , a % b ) ) NEWLINE DEDENT def findSmallest ( a , b ) : NEWLINE INDENT lcm = ( a * b ) / gcd ( a , b ) NEWLINE print ( "x =" , lcm / a , "\ny = " , lcm / b ) NEWLINE DEDENT a = 25 NEWLINE b = 35 NEWLINE findSmallest ( a , b ) NEWLINE NL ENDMARKER
def NthTerm ( N ) : NEWLINE INDENT x = ( 3 * N * N ) % 1000000009 NEWLINE return ( ( x - N + 1000000009 ) % 1000000009 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 4 NEWLINE print ( NthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
def countSquares ( m , n ) : NEWLINE INDENT if ( n < m ) : NEWLINE INDENTINDENT temp = m NEWLINE m = n NEWLINE n = temp NEWLINE DEDENT return ( ( m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT m = 4 NEWLINE n = 3 NEWLINE print ( "Count of squares is " , countSquares ( m , n ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) count = 0 for x in range ( n , 8888888889 ) : x = str ( x ) if "8" in x : if count == 0 : count += 1 continue else : print ( count ) exit ( ) else : count += 1 NEWLINE NL ENDMARKER
def centeredTridecagonalNum ( n ) : NEWLINE INDENT return ( 13 * n * ( n - 1 ) + 2 ) // 2 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 3 NEWLINE print ( centeredTridecagonalNum ( n ) ) NEWLINE n = 10 NEWLINE print ( centeredTridecagonalNum ( n ) ) NEWLINE NL DEDENT ENDMARKER
class RecentCounter ( object ) : NEWLINE INDENT def __init__ ( self ) : NEWLINE INDENTINDENT self . queue = [ ] NEWLINE DEDENT def ping ( self , t ) : NEWLINE INDENTINDENT self . queue . append ( t ) NEWLINE while self . queue and self . queue [ 0 ] < t - 3000 : NEWLINE INDENTINDENTINDENT self . queue . pop ( 0 ) NEWLINE DEDENT return len ( self . queue ) NEWLINE NL DEDENT DEDENT ENDMARKER
def fibWord ( n ) : NEWLINE INDENT Sn_1 = "0" NEWLINE Sn = "01" NEWLINE tmp = "" NEWLINE for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT tmp = Sn NEWLINE Sn += Sn_1 NEWLINE Sn_1 = tmp NEWLINE DEDENT return Sn NEWLINE DEDENT n = 6 NEWLINE print ( fibWord ( n ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : input ( ) NEWLINE n = [ i for i in input ( ) ] NEWLINE n . sort ( ) NEWLINE print ( "" . join ( n ) ) NEWLINE NL ENDMARKER
n , v = map ( int , input ( ) . split ( ) ) amt = 0 if n > v : amt = v for i in range ( 2 , n - v + 1 ) : amt += ielse : amt = n - 1 print ( amt ) NEWLINE NL ENDMARKER
n , b , p = list ( map ( int , input ( ) . split ( ) ) )  matches = n - 1    total_b = ( matches * 2 * b ) + matchestotal_p = n * p    print ( total_b , total_p ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ma = max ( arr ) su = sum ( arr ) su = su - maans = ma - suans = ans + 1 print ( ans ) NEWLINE NL ENDMARKER
p = int ( input ( ) ) if p >= 3 : x = ( p // 3 ) * 2  if p % 3 : x += 1 else : x = 1 print ( x ) NEWLINE NL ENDMARKER
def smallestSum ( n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT return ( 2 * pow ( 10 , n - 1 ) ) NEWLINE DEDENT def largestSum ( n ) : NEWLINE INDENT return ( 2 * ( pow ( 10 , n ) - 1 ) ) NEWLINE DEDENT n = 4 NEWLINE print ( "Largest = " , largestSum ( n ) ) NEWLINE print ( "Smallest = " , smallestSum ( n ) ) NEWLINE NL ENDMARKER
def cubeSum ( n ) : NEWLINE INDENT return 2 * n * n * ( n + 1 ) * ( n + 1 ) NEWLINE DEDENT print ( cubeSum ( 8 ) ) NEWLINE NL ENDMARKER
def Check_is_possible ( l , r , k ) : NEWLINE INDENT div_count = ( r // k ) - ( l // k ) NEWLINE if l % k == 0 : NEWLINE INDENTINDENT div_count += 1 NEWLINE DEDENT return div_count > 1 NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT l , r , k = 30 , 70 , 10 NEWLINE if Check_is_possible ( l , r , k ) == True : NEWLINE INDENTINDENT print ( "YES" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "NO" ) NEWLINE NL DEDENT DEDENT ENDMARKER
import sysinput = sys . stdin . readline  ''''''   k2 , k3 , k5 , k6 = map ( int , input ( ) . split ( ) ) num_256 = min ( k2 , min ( k5 , k6 ) ) k2 -= num_256num_32 = min ( k2 , k3 ) print ( num_256 * 256 + num_32 * 32 ) NEWLINE NL ENDMARKER
num = input ( ) given = input ( )  num = "" . join ( sorted ( num ) )  idx = - 1 for i in range ( len ( num ) ) : if int ( num [ i ] ) > 0 : idx = i break  if idx == - 1 : solution = "0" else : solution = num [ idx ] + num [ : idx ] + num [ idx + 1 : ]  print ( "WRONG_ANSWER" if solution != given else "OK" ) NEWLINE NL ENDMARKER
import sys  def answer ( n , m , a ) : NEWLINE NL ENDMARKER
def areaCube ( a ) : NEWLINE INDENT return ( a * a * a ) NEWLINE DEDENT def surfaceCube ( a ) : NEWLINE INDENT return ( 6 * a * a ) NEWLINE DEDENT a = 5 NEWLINE print ( "Area =" , areaCube ( a ) ) NEWLINE print ( "Total surface area =" , surfaceCube ( a ) ) NEWLINE NL ENDMARKER
def sackRace ( p1 , s1 , p2 , s2 ) : NEWLINE INDENT return ( ( s1 > s2 and ( p2 - p1 ) % ( s1 - s2 ) == 0 ) or ( s2 > s1 and ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) NEWLINE DEDENT p1 = 4 NEWLINE s1 = 4 NEWLINE p2 = 8 NEWLINE s2 = 2 NEWLINE if ( sackRace ( p1 , s1 , p2 , s2 ) ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
def printCubes ( a , b ) : NEWLINE INDENT for i in range ( a , b + 1 ) : NEWLINE INDENTINDENT j = 1 NEWLINE for j in range ( j ** 3 , i + 1 ) : NEWLINE INDENTINDENTINDENT if ( j ** 3 == i ) : NEWLINE INDENTINDENTINDENTINDENT print ( j ** 3 , end = " " ) NEWLINE break NEWLINE DEDENT DEDENT DEDENT DEDENT a = 1 ; b = 100 NEWLINE print ( "Perfect cubes in given range: " ) NEWLINE printCubes ( a , b ) NEWLINE NL ENDMARKER
MOD = 1000000007 NEWLINE def modFact ( n , m ) : NEWLINE INDENT result = 1 NEWLINE for i in range ( 1 , m + 1 ) : NEWLINE INDENTINDENT result = ( result * i ) % MOD NEWLINE DEDENT return result NEWLINE DEDENT n = 3 NEWLINE m = 2 NEWLINE print ( modFact ( n , m ) ) NEWLINE NL ENDMARKER
n = int ( input ( "" ) ) l = [ ] for k in range ( n ) : b = int ( input ( "" ) ) l . append ( b ) final = [ ] for i in l : c = 0 while i > 0 : if i % 2 == 1 : c = c + 1 i = int ( i / 2 ) final . append ( c ) for j in final : print ( 2 ** j ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( sum ( n % i < 1 for i in range ( 1 , n ) ) ) NEWLINE NL ENDMARKER
n = input ( ) s = [ ] if ( len ( n ) % 2 == 0 ) : l = len ( n ) // 2 else : l = len ( n ) // 2 l += 1 s . append ( n [ l - 1 ] ) x = ( len ( n ) - 1 ) - ( l - 1 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = int ( input ( ) ) ll = 7 - lk = [ ] m = [ ] mm = "YES" h = - 1 for i in range ( n ) : x , y = map ( int , input ( ) . split ( ) ) k . append ( x ) m . append ( y ) if l in k or l in m or ll in k or ll in m : mm = "NO" print ( mm )    NEWLINE NL ENDMARKER
n = int ( input ( ) ) p = [ 0 , 0 , * map ( int , input ( ) . split ( ) ) ] r = [ ] while n : r . append ( n ) ; n = p [ n ] print ( * reversed ( r ) ) NEWLINE NL ENDMARKER
def sumofseries ( n ) : NEWLINE INDENT return int ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) NEWLINE DEDENT print ( sumofseries ( 3 ) ) NEWLINE NL ENDMARKER
a , b , r = map ( int , input ( ) . split ( ) ) d = r + rk = a // dp = b // d  if ( k > 0 and p > 0 ) : print ( "First" ) else : print ( "Second" ) NEWLINE NL ENDMARKER
a = int ( input ( ) ) b = int ( input ( ) ) c = int ( input ( ) ) d = min ( a , b // 2 , c // 4 ) print ( 7 * d ) NEWLINE NL ENDMARKER
import sys , mathfrom collections import deque , defaultdictimport operator as opfrom functools import reducefrom itertools import permutations  NEWLINE NL ENDMARKER
t = int ( input ( ) ) lst = [ ] res = [ ] for i in range ( 0 , t ) : lst = [ int ( i ) for i in input ( ) . split ( ) ] ele = 9 * lst [ 0 ] + lst [ 1 ] - 9 res . append ( ele )  for i in range ( 0 , t ) : print ( res [ i ] ) NEWLINE NL ENDMARKER
h , m = [ int ( x ) for x in input ( ) . split ( ':' ) ] a = int ( input ( ) ) hrs = a // 60 h += hrsa = a - ( 60 * hrs ) m += aif m >= 60 : m -= 60 h += 1 t = str ( h % 24 ) . zfill ( 2 ) + ':' + str ( m ) . zfill ( 2 ) print ( t ) NEWLINE NL ENDMARKER
def survival ( S , N , M ) : NEWLINE INDENT if ( ( ( N * 6 ) < ( M * 7 ) and S > 6 ) or M > N ) : NEWLINE INDENTINDENT print ( "No" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT days = ( M * S ) / N NEWLINE if ( ( ( M * S ) % N ) != 0 ) : NEWLINE INDENTINDENTINDENT days += 1 NEWLINE DEDENT print ( "Yes " ) , NEWLINE print ( days ) NEWLINE DEDENT DEDENT S = 10 ; N = 16 ; M = 2 NEWLINE survival ( S , N , M ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] l = [ ] for i in range ( 1 , n ) : l . append ( a [ i ] + a [ i - 1 ] ) l . append ( a [ n - 1 ] ) print ( * l ) NEWLINE NL ENDMARKER
from math import ceiln , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) m = 10 ** ( k - 1 ) ans = 1 for i in range ( n // k ) : an = ( 10 ** k - 1 ) // a [ i ] + 1 l = b [ i ] * m r = ( b [ i ] + 1 ) * m - 1 count = r // a [ i ] - ceil ( l / a [ i ] ) + 1 ans = ( ans * ( an - count ) ) % ( 10 ** 9 + 7 ) print ( ans ) NEWLINE NL ENDMARKER
def hexDiagonal ( a ) : NEWLINE INDENT if ( a < 0 ) : NEWLINE INDENTINDENT return - 1 ; NEWLINE DEDENT d = 1.73 * a ; NEWLINE return d ; NEWLINE DEDENT a = 9 ; NEWLINE print ( hexDiagonal ( a ) ) ; NEWLINE NL ENDMARKER
woke_hr , woke_min = map ( int , input ( ) . split ( ":" ) ) dur_hr , dur_min = map ( int , input ( ) . split ( ":" ) ) st_sleep_hr , st_sleep_min = 0 , 0  if woke_min < dur_min : st_sleep_min = ( 60 + woke_min ) - dur_min ; dur_hr += 1 else : st_sleep_min = woke_min - dur_min NEWLINE NL ENDMARKER
x = 10 NEWLINE y = 5 NEWLINE x = x + y NEWLINE y = x - y NEWLINE x = x - y NEWLINE print ( "After Swapping: x =" , x , " y =" , y ) ; NEWLINE NL ENDMARKER
def rangeGCD ( n , m ) : NEWLINE INDENT return n if ( n == m ) else 1 NEWLINE DEDENT n , m = 475 , 475 NEWLINE print ( rangeGCD ( n , m ) ) NEWLINE NL ENDMARKER
import math  n = int ( input ( ) )   def is_prime ( n ) : if n == 2 : return True if n % 2 == 0 or n <= 1 : return False  sqr = int ( n ** 0.5 ) + 1  for divisor in range ( 3 , sqr , 2 ) : if n % divisor == 0 : return False return True   arr = [ ] for i in range ( 2 , 10 ** 7 ) : if len ( arr ) == n : print ( * arr ) exit ( ) if is_prime ( i ) is True : arr . append ( i ) NEWLINE NL ENDMARKER
def countSteps ( x , y ) : NEWLINE INDENT if x < y : NEWLINE INDENTINDENT return x + y + 2 * ( ( y - x ) // 2 ) NEWLINE DEDENT else : NEWLINE INDENTINDENT return x + y + 2 * ( ( ( x - y ) + 1 ) // 2 ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT x , y = 4 , 3 NEWLINE print ( countSteps ( x , y ) ) NEWLINE NL DEDENT ENDMARKER
n , h = list ( map ( int , input ( ) . split ( ) ) ) n1 = list ( map ( int , input ( ) . split ( ) ) ) count = 0 for i in n1 : if ( i > h ) : count += 2 else : count += 1 print ( count ) NEWLINE NL ENDMARKER
def maxSum ( arr , n ) : NEWLINE INDENT arr . sort ( ) NEWLINE sum = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT sum += arr [ i ] * i NEWLINE DEDENT return sum NEWLINE DEDENT arr = [ 3 , 5 , 6 , 1 ] NEWLINE n = len ( arr ) NEWLINE print ( maxSum ( arr , n ) ) NEWLINE NL ENDMARKER
def countSubSeq ( strr , lenn ) : NEWLINE INDENT ans = 0 NEWLINE mul = 1 NEWLINE for i in range ( lenn ) : NEWLINE INDENTINDENT if ( strr [ i ] == '0' ) : NEWLINE INDENTINDENTINDENT ans += mul NEWLINE DEDENT mul *= 2 NEWLINE DEDENT return ans NEWLINE DEDENT strr = "10010" NEWLINE lenn = len ( strr ) NEWLINE print ( countSubSeq ( strr , lenn ) ) NEWLINE NL ENDMARKER
b , c = int ( input ( ) ) , input ( ) f = 0 m = 0 for i in range ( 0 , len ( c ) ) : if c [ i ] == "x" : f += 1 else : if f > 2 : m += f - 2 f = 0 if i + 1 == len ( c ) and f > 2 : m += f - 2 print ( m ) NEWLINE NL ENDMARKER
def square ( a ) : NEWLINE INDENT if ( a < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT x = 0.464 * a NEWLINE return x NEWLINE DEDENT a = 5 NEWLINE print ( square ( a ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) c = list ( map ( int , input ( ) . split ( ) ) ) i = 0j = n - 1 ans1 = 0 ans2 = 0 while i < n - 1 and j > 0 : if c [ j ] != c [ 0 ] : ans1 = j break else : j -= 1 if c [ i ] != c [ n - 1 ] : ans2 = n - 1 - i break else : i += 1  print ( max ( ans1 , ans2 ) ) NEWLINE NL ENDMARKER
def findOddPair ( A , N ) : NEWLINE INDENT count = 0 NEWLINE for i in range ( 0 , N ) : NEWLINE INDENTINDENT if ( A [ i ] % 2 == 0 ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT return count * ( N - count ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = [ 5 , 4 , 7 , 2 , 1 ] NEWLINE n = len ( a ) NEWLINE print ( findOddPair ( a , n ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) R1 , R2 = map ( int , input ( ) . split ( ) ) print ( sum ( a [ R1 - 1 : R2 - 1 ] ) ) NEWLINE NL ENDMARKER
def oddTriangularNumber ( N ) : NEWLINE INDENT return ( N * ( ( 2 * N ) - 1 ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 3 NEWLINE print ( oddTriangularNumber ( N ) ) NEWLINE NL DEDENT ENDMARKER
def areAllBitsSet ( n ) : NEWLINE INDENT if ( n == 0 ) : NEWLINE INDENTINDENT return "No" NEWLINE DEDENT if ( ( ( n + 1 ) & n ) == 0 ) : NEWLINE INDENTINDENT return "Yes" NEWLINE DEDENT return "No" NEWLINE DEDENT n = 7 NEWLINE print ( areAllBitsSet ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) l1 = [ 0 ] * 100001 for item in a : l1 [ item ] += 1 ans = "Agasa" for item in l1 : if item % 2 : ans = "Conan" ; breakprint ( ans ) NEWLINE NL ENDMARKER
def multiply ( array , n ) : NEWLINE INDENT pro = 1 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT pro = pro * array [ i ] NEWLINE DEDENT return pro NEWLINE DEDENT array = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEWLINE n = len ( array ) NEWLINE print ( multiply ( array , n ) ) NEWLINE NL ENDMARKER
d = int ( input ( ) ) n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) r = 0 for i in range ( n - 1 ) : r = r + ( d - l [ i ] ) print ( r ) NEWLINE NL ENDMARKER
s = input ( ) print ( s + s [ : : - 1 ] ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) print ( ( n + m ) - 1 - min ( n , m ) , min ( n , m ) ) NEWLINE NL ENDMARKER
def findMinimal ( a , n ) : NEWLINE INDENT a . sort ( ) NEWLINE sum = 0 NEWLINE for i in range ( n // 2 ) : NEWLINE INDENTINDENT sum += ( ( a [ i ] + a [ n - i - 1 ] ) * ( a [ i ] + a [ n - i - 1 ] ) ) NEWLINE DEDENT return sum NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = [ 8 , 5 , 2 , 3 ] NEWLINE n = len ( a ) NEWLINE print ( findMinimal ( a , n ) ) NEWLINE NL DEDENT ENDMARKER
def centereddecagonalnum ( n ) : NEWLINE INDENT return ( 5 * n * n + 5 * n + 1 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 5 NEWLINE print ( n , "th centered decagonal " + "number : " , centereddecagonalnum ( n ) ) NEWLINE n = 9 NEWLINE print ( n , "th centered decagonal " + "number : " , centereddecagonalnum ( n ) ) NEWLINE NL DEDENT ENDMARKER
import mathx , k = map ( int , input ( ) . split ( ) ) kori = ka = bin ( x )  NEWLINE NL ENDMARKER
def factors ( n , i ) : NEWLINE INDENT if ( i <= n ) : NEWLINE INDENTINDENT if ( n % i == 0 ) : NEWLINE INDENTINDENTINDENT print ( i , end = " " ) ; NEWLINE DEDENT factors ( n , i + 1 ) ; NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 16 ; NEWLINE factors ( N , 1 ) ; NEWLINE NL DEDENT ENDMARKER
def circumferenceparallelogram ( a , b ) : NEWLINE INDENT return ( ( 2 * a ) + ( 2 * b ) ) NEWLINE DEDENT a = 10 NEWLINE b = 8 NEWLINE print ( "Circumference of a given Parallelogram is :" , round ( circumferenceparallelogram ( a , b ) , 4 ) ) NEWLINE NL ENDMARKER
def alternate ( a , b , x ) : NEWLINE INDENT x = a + b - x NEWLINE print ( "After change x is:" , x ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = - 10 NEWLINE b = 15 NEWLINE x = a NEWLINE print ( "x is:" , x ) NEWLINE alternate ( a , b , x ) NEWLINE NL DEDENT ENDMARKER
import sys NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) lst = [ * map ( int , input ( ) . split ( ) ) ] lst . sort ( )  total = 0  for num in lst [ : m ] : if num > 0 : break else : total += numprint ( abs ( total ) ) NEWLINE NL ENDMARKER
import re  n = input ( ) cad = input ( )  print ( re . sub ( r'o(go)+' , '***' , cad ) )  NEWLINE NL ENDMARKER
k = int ( input ( ) ) ans = [ int ( 1 ) ] * 10 prod = int ( 1 ) s = "codeforces" i = int ( 0 ) while k > prod : ans [ i ] += 1 prod = prod * ans [ i ] // ( ans [ i ] - 1 ) i += 1 i = i % 10 for i in range ( 10 ) : print ( s [ i ] * ans [ i ] , end = "" ) NEWLINE NL ENDMARKER
n , x , y = [ int ( x ) for x in input ( ) . split ( ) ] s = input ( ) [ : : - 1 ] c = 0 c = sum ( [ 1 for i in s [ 0 : y ] if i == '1' ] ) c += sum ( [ 1 for i in s [ y + 1 : x ] if i == '1' ] ) if s [ y ] == '0' : c += 1 print ( c ) NEWLINE NL ENDMARKER
def countOnes ( n ) : NEWLINE INDENT count = 1 ; NEWLINE rem = 1 ; NEWLINE while ( rem != 0 ) : NEWLINE INDENTINDENT rem = ( rem * 10 + 1 ) % n ; NEWLINE count = count + 1 ; NEWLINE DEDENT return count ; NEWLINE DEDENT n = 13 ; NEWLINE print ( countOnes ( n ) ) ; NEWLINE NL ENDMARKER
from __future__ import division , print_function  import osimport sysfrom io import BytesIO , IOBase if sys . version_info [ 0 ] < 3 : from __builtin__ import xrange as range from future_builtins import ascii , filter , hex , map , oct , zip def main ( ) : pass NEWLINE NL ENDMARKER
def power ( x , y , p ) : NEWLINE INDENT res = 1 NEWLINE x = x % p NEWLINE if ( x == 0 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT while ( y > 0 ) : NEWLINE INDENTINDENT if ( ( y & 1 ) == 1 ) : NEWLINE INDENTINDENTINDENT res = ( res * x ) % p NEWLINE DEDENT y = y >> 1 NEWLINE x = ( x * x ) % p NEWLINE DEDENT return res NEWLINE DEDENT x = 2 ; y = 5 ; p = 13 NEWLINE print ( "Power is " , power ( x , y , p ) ) NEWLINE NL ENDMARKER
import sys , mathimport NEWLINE heapq  from collections import NEWLINE INDENT dequeinput = sys . stdin . readline  NEWLINE NL DEDENT ENDMARKER
x = int ( input ( ) ) print ( bin ( x ) . count ( '1' ) ) NEWLINE NL ENDMARKER
def removeAlternate ( n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT if ( n % 2 == 0 ) : NEWLINE INDENTINDENT return 2 * removeAlternate ( n / 2 ) - 1 NEWLINE DEDENT else : NEWLINE INDENTINDENT return 2 * removeAlternate ( ( ( n - 1 ) / 2 ) ) + 1 NEWLINE DEDENT DEDENT n = 5 NEWLINE print ( removeAlternate ( n ) ) NEWLINE n = 10 NEWLINE print ( removeAlternate ( n ) ) NEWLINE NL ENDMARKER
x , y , z = map ( int , input ( ) . split ( ) ) if y >= x and z >= x : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
for x in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) NEWLINE c = abs ( a - b ) NEWLINE if c % 10 == 0 : NEWLINE INDENT print ( c // 10 ) else : NEWLINE print ( ( c // 10 ) + 1 ) NEWLINE NL DEDENT ENDMARKER
import math  NEWLINE def solve ( ) : n = int ( input ( ) ) NEWLINE INDENT pass NEWLINE DEDENT if bin ( n ) [ 2 : ] . count ( '1' ) == 1 : NEWLINE INDENT return False else : NEWLINE return True  for t in range ( int ( input ( ) ) ) : if NEWLINE DEDENT solve ( ) : print ( 'YES' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( input ( ) ) p = 0 for i in range ( len ( a ) ) : if a [ i ] == '+' : p = p + 1 n = n + 1 elif a [ i ] == '-' : p = p - 1 if p < 0 : p = 0 print ( p ) NEWLINE NL ENDMARKER
def cubeSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT sum += ( 2 * i ) * ( 2 * i ) * ( 2 * i ) NEWLINE DEDENT return sum NEWLINE DEDENT print ( cubeSum ( 8 ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( ) ans = float ( 'inf' ) for i in range ( n ) : x = r ( ) c = sum ( x ) * 5 + 15 * len ( x ) ans = min ( ans , c )   print ( ans )  NEWLINE NL ENDMARKER
import sys , os , ioimport math , bisect , operatorinf , mod = float ( 'inf' ) , 10 ** 9 + 7 NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) s = sorted ( a ) """ for i in sorted(a):    s += str(i) """ print ( * s ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) s = input ( ) q = s [ n - 1 ] * n print ( q ) NEWLINE NL ENDMARKER
def minOperations ( str , n ) : NEWLINE INDENT count = 0 NEWLINE for i in range ( n - 1 ) : NEWLINE INDENTINDENT if ( str [ i ] != str [ i + 1 ] ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT return ( count + 1 ) // 2 NEWLINE DEDENT str = "000111" NEWLINE n = len ( str ) NEWLINE print ( minOperations ( str , n ) ) NEWLINE NL ENDMARKER
def properDivisorSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT sum += ( n // i ) * i NEWLINE DEDENT return sum - n * ( n + 1 ) // 2 NEWLINE DEDENT n = 4 NEWLINE print ( properDivisorSum ( n ) ) NEWLINE n = 5 NEWLINE print ( properDivisorSum ( n ) ) NEWLINE NL ENDMARKER
def closestMultiple ( n , x ) : NEWLINE INDENT if x > n : NEWLINE INDENTINDENT return x ; NEWLINE DEDENT z = ( int ) ( x / 2 ) ; NEWLINE n = n + z ; NEWLINE n = n - ( n % x ) ; NEWLINE return n ; NEWLINE DEDENT n = 56287 ; NEWLINE x = 27 ; NEWLINE print ( closestMultiple ( n , x ) ) ; NEWLINE NL ENDMARKER
finished = Falselado = list ( map ( int , input ( ) . split ( ) ) ) navios = 0 base = lado [ 0 ] altura = lado [ 1 ] while altura != 0 : navios += ( base // altura ) ( base , altura ) = ( altura , base % altura ) print ( navios ) NEWLINE NL ENDMARKER
if __name__ == '__main__' : l1 , r1 , l2 , r2 , k = map ( int , input ( ) . split ( ) ) if l2 > l1 : l1 = l2 if r2 < r1 : r1 = r2 print ( max ( r1 - l1 + 1 - ( l1 <= k <= r1 ) , 0 ) ) NEWLINE NL ENDMARKER
def isPrime ( n ) : NEWLINE INDENT if n <= 1 : NEWLINE INDENTINDENT return False NEWLINE DEDENT for i in range ( 2 , n ) : NEWLINE INDENTINDENT if n % i == 0 : NEWLINE INDENTINDENTINDENT return False ; NEWLINE DEDENT DEDENT return True NEWLINE DEDENT print ( "true" ) if isPrime ( 11 ) else print ( "false" ) NEWLINE print ( "true" ) if isPrime ( 14 ) else print ( "false" ) NEWLINE NL ENDMARKER
def distribution ( arr , n ) : NEWLINE INDENT resources = set ( ) NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT resources . add ( arr [ i ] ) ; NEWLINE DEDENT return min ( len ( resources ) , n // 2 ) ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 1 , 1 , 2 , 1 , 3 , 4 ] ; NEWLINE n = len ( arr ) ; NEWLINE print ( distribution ( arr , n ) , "" ) ; NEWLINE NL DEDENT ENDMARKER
def findMod4 ( s , n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT k = ord ( s [ 0 ] ) - ord ( '0' ) NEWLINE DEDENT else : NEWLINE INDENTINDENT k = ( ( ord ( s [ n - 2 ] ) - ord ( '0' ) ) * 10 + ord ( s [ n - 1 ] ) - ord ( '0' ) ) NEWLINE DEDENT return ( k % 4 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT s = "81" NEWLINE n = len ( s ) NEWLINE print ( findMod4 ( s , n ) ) NEWLINE NL DEDENT ENDMARKER
def compute ( ) : NEWLINE INDENT SIZE = 1001 NEWLINE ans = 1 NEWLINE ans += sum ( 4 * i * i - 6 * ( i - 1 ) for i in range ( 3 , SIZE + 1 , 2 ) ) NEWLINE return str ( ans ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( compute ( ) ) NEWLINE NL DEDENT ENDMARKER
def countZeros ( x ) : NEWLINE INDENT total_bits = 32 NEWLINE res = 0 NEWLINE while ( ( x & ( 1 << ( total_bits - 1 ) ) ) == 0 ) : NEWLINE INDENTINDENT x = ( x << 1 ) NEWLINE res += 1 NEWLINE DEDENT return res NEWLINE DEDENT x = 101 NEWLINE print ( countZeros ( x ) ) NEWLINE NL ENDMARKER
def countBits ( n ) : NEWLINE INDENT count = 0 NEWLINE while ( n ) : NEWLINE INDENTINDENT count += 1 NEWLINE n >>= 1 NEWLINE DEDENT return count NEWLINE DEDENT i = 65 NEWLINE print ( countBits ( i ) ) NEWLINE NL ENDMARKER
import math NEWLINE def invertBits ( n ) : NEWLINE INDENT x = int ( math . log ( n , 2 ) ) NEWLINE m = 1 << x NEWLINE m = m | m - 1 NEWLINE n = n ^ m NEWLINE return n NEWLINE DEDENT n = 20 NEWLINE print ( invertBits ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ; k = 2 * ( 10 ** 5 + 1 ) dp = [ 0 ] * kfor i in range ( n ) : for j in range ( n ) : if i != j : dp [ arr [ i ] + arr [ j ] ] += 1 print ( max ( dp ) // 2 ) NEWLINE NL ENDMARKER
import redef post ( n , x ) : a = len ( re . findall ( 'L' , x ) ) b = len ( re . findall ( 'R' , x ) ) return a + b + 1 t = int ( input ( ) ) y = input ( ) r = post ( t , y ) print ( r ) NEWLINE NL ENDMARKER
def numLen ( K ) : NEWLINE INDENT if ( K % 2 == 0 or K % 5 == 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT number = 0 NEWLINE len = 1 NEWLINE for len in range ( 1 , K + 1 ) : NEWLINE INDENTINDENT number = ( number * 10 + 1 ) % K NEWLINE if number == 0 : NEWLINE INDENTINDENTINDENT return len NEWLINE DEDENT DEDENT return - 1 NEWLINE DEDENT K = 7 NEWLINE print ( numLen ( K ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ' ' ) ) ) c = 0 for i in range ( n ) : if i == a [ i ] : c += 1 if c == n : print ( n ) else : for i in range ( n ) : if i != a [ i ] and a [ a [ i ] ] == i : print ( c + 2 ) break else : print ( c + 1 ) NEWLINE NL ENDMARKER
s , ans , met = "" , 0 , Falsefor i in range ( 8 ) : s = input ( ) if s == "BBBBBBBB" : ans += 1 elif not met : ans += s . count ( 'B' ) met = True  print ( ans ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n + 1 ) : if k > i : k -= i else : breakprint ( a [ k - 1 ] ) NEWLINE NL ENDMARKER
def maxAbsDiff ( arr , n ) : NEWLINE INDENT minEle = arr [ 0 ] NEWLINE maxEle = arr [ 0 ] NEWLINE for i in range ( 1 , n ) : NEWLINE INDENTINDENT minEle = min ( minEle , arr [ i ] ) NEWLINE maxEle = max ( maxEle , arr [ i ] ) NEWLINE DEDENT return ( maxEle - minEle ) NEWLINE DEDENT arr = [ 2 , 1 , 5 , 3 ] NEWLINE n = len ( arr ) NEWLINE print ( maxAbsDiff ( arr , n ) ) NEWLINE NL ENDMARKER
import sysimport mathfrom collections import defaultdict , Counter , deque  NEWLINE NL ENDMARKER
a = input ( ) b = input ( ) len_a = len ( a ) len_b = len ( b ) if len_a != len_b : print ( max ( len_a , len_b ) ) elif a == b : print ( - 1 ) else : print ( len_a ) NEWLINE NL ENDMARKER
def countWays ( n ) : NEWLINE INDENT count = 0 NEWLINE i = 1 NEWLINE while ( ( i * i ) < n ) : NEWLINE INDENTINDENT if ( n % i == 0 ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT i += 1 NEWLINE DEDENT return count NEWLINE DEDENT n = 12 NEWLINE print ( countWays ( n ) ) NEWLINE NL ENDMARKER
def largest ( arr , n ) : NEWLINE INDENT return max ( arr ) NEWLINE DEDENT arr = [ 10 , 324 , 45 , 90 , 9808 ] NEWLINE n = len ( arr ) NEWLINE print ( largest ( arr , n ) ) NEWLINE NL ENDMARKER
s = input ( ) . strip ( ) t = input ( ) . strip ( )  n , m = len ( s ) , len ( t ) mod = 10 ** 9 + 7  dp12 = [ [ 0 for i in range ( m ) ] for j in range ( n ) ] NEWLINE NL ENDMARKER
y , b , r = map ( int , input ( ) . split ( ) ) y = y + 2 b = b + 1 r = r + 0 min = min ( y , b , r ) sum = ( min * 3 ) - 3 print ( sum ) NEWLINE NL ENDMARKER
import sys , heapq NEWLINE NL ENDMARKER
n = int ( input ( ) ) g = list ( map ( int , input ( ) . split ( ) ) )  if len ( g ) % 2 == 1 and g [ 0 ] % 2 == 1 and g [ - 1 ] % 2 == 1 : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
def printSeqRecur ( num , n , k ) : NEWLINE INDENT if n == 0 : NEWLINE INDENTINDENT print ( num ) NEWLINE return NEWLINE DEDENT for _ in range ( 1 , k + 1 ) : NEWLINE INDENTINDENT printSeqRecur ( num * 10 + _ , n - 1 , k ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT k = 3 NEWLINE n = 2 NEWLINE printSeqRecur ( 0 , n , k ) NEWLINE NL DEDENT ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) print ( n + m - 1 ) for i in range ( 1 , m + 1 ) : print ( 1 , i ) for j in range ( 2 , n + 1 ) : print ( j , 1 )  NEWLINE NL ENDMARKER
def makearrayequal ( arr , n ) : NEWLINE INDENT x = 0 ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT x += arr [ i ] & 1 ; NEWLINE DEDENT print ( min ( x , n - x ) ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 4 , 3 , 2 , 1 ] ; NEWLINE n = len ( arr ) ; NEWLINE makearrayequal ( arr , n ) ; NEWLINE NL DEDENT ENDMARKER
"""    Author - Satwik Tiwari .    20th Oct , 2020  - Tuesday"""  NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) x = n % mif ( x == 0 ) : print ( n + m ) else : print ( n + ( m - x ) ) NEWLINE NL ENDMARKER
def find_k ( a , b ) : NEWLINE INDENT if ( ( a + b ) % 2 == 0 ) : NEWLINE INDENTINDENT return ( ( a + b ) // 2 ) ; NEWLINE DEDENT return - 1 ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = 2 ; b = 16 ; NEWLINE print ( find_k ( a , b ) ) ; NEWLINE NL DEDENT ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) count = [ 0 ] * na = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) : count [ a [ i ] - 1 ] += 1 print ( min ( count ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) for i in range ( 4 , n - 3 ) : if i % 2 == 0 and ( ( n - i ) % 3 == 0 or ( n - i % 2 == 0 ) ) : a = i b = n - i breakprint ( a , b ) NEWLINE NL ENDMARKER
def findSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT sum += i * ( n - i ) NEWLINE DEDENT return 2 * sum NEWLINE DEDENT n = 3 NEWLINE print ( findSum ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) num_to_rem = n % 10 if num_to_rem >= 5 : print ( n - num_to_rem + 10 ) else : print ( n - num_to_rem ) NEWLINE NL ENDMARKER
from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEWLINE NL ENDMARKER
def floorSqrt ( x ) : NEWLINE INDENT if ( x == 0 or x == 1 ) : NEWLINE INDENTINDENT return x NEWLINE DEDENT i = 1 ; result = 1 NEWLINE while ( result <= x ) : NEWLINE INDENTINDENT i += 1 NEWLINE result = i * i NEWLINE DEDENT return i - 1 NEWLINE DEDENT x = 11 NEWLINE print ( floorSqrt ( x ) ) NEWLINE NL ENDMARKER
import math NEWLINE def summation ( n ) : NEWLINE INDENT return int ( ( pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ) ; NEWLINE DEDENT print ( summation ( 5 ) ) ; NEWLINE NL ENDMARKER
t = int ( input ( ) ) l = [ ] d = { "purple" : "Power " , "green" : "Time " , "blue" : "Space " , "orange" : "Soul " , "red" : " Reality" , "yellow" : " Mind " } for i in range ( t ) : s = input ( ) l . append ( s ) NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def isRectangleOverlap ( self , rec1 , rec2 ) : NEWLINE INDENTINDENT return not ( rec1 [ 2 ] <= rec2 [ 0 ] or rec1 [ 3 ] <= rec2 [ 1 ] or rec1 [ 0 ] >= rec2 [ 2 ] or rec1 [ 1 ] >= rec2 [ 3 ] ) NEWLINE NL DEDENT DEDENT ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) c = 0 for i in range ( 1 , n , 2 ) : if a [ i - 1 ] != a [ i ] : c += ( a [ i ] - a [ i - 1 ] ) print ( c ) NEWLINE NL ENDMARKER
def printSquares ( n ) : NEWLINE INDENT square = 0 NEWLINE odd = 1 NEWLINE for x in range ( 0 , n ) : NEWLINE INDENTINDENT print ( square , end = " " ) NEWLINE square = square + odd NEWLINE odd = odd + 2 NEWLINE DEDENT DEDENT n = 5 ; NEWLINE printSquares ( n ) NEWLINE NL ENDMARKER
def squarearea ( a , b ) : NEWLINE INDENT if ( a < 0 or b < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT area = 4 * ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) NEWLINE return area NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = 4 NEWLINE b = 2 NEWLINE print ( squarearea ( a , b ) ) NEWLINE NL DEDENT ENDMARKER
for _ in range ( int ( input ( ) ) ) : n , m , r , c = map ( int , input ( ) . split ( ) ) NEWLINE print ( max ( r - 1 , n - r ) + max ( c - 1 , m - c ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) m = 0 for i in range ( len ( l ) ) : if l [ i ] > 1 : m += ( l [ i ] * ( i + 1 ) ) - i else : m += 1 print ( m ) NEWLINE NL ENDMARKER
n , a , b = map ( int , input ( ) . split ( ) ) itog = 0 for i in range ( 1 , n + 1 ) : if i - 1 >= a and n - i <= b : itog += 1 print ( itog ) NEWLINE NL ENDMARKER
for t in range ( int ( input ( ) ) ) : a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE print ( max ( a + b , c + d ) ) NEWLINE NL ENDMARKER
ll = lambda : map ( int , input ( ) . split ( ) ) t = lambda : int ( input ( ) ) ss = lambda : input ( ) lx = lambda x : map ( int , input ( ) . split ( x ) ) NEWLINE NL ENDMARKER
def totEdge ( n ) : NEWLINE INDENT result = ( n * ( n - 1 ) ) // 2 NEWLINE return result NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 6 NEWLINE print ( totEdge ( n ) ) NEWLINE NL DEDENT ENDMARKER
import math  def solve ( ) : n = int ( input ( ) ) array = [ int ( i ) for i in input ( ) . split ( ) ] sum1 , sum2 = 0 , 0  for i in array : sum1 += i  i , count = n - 1 , n array . sort ( reverse = True )  while sum1 > sum2 : sum1 -= array [ i ] sum2 += array [ i ] i -= 1 count -= 1  return count + 1    print ( solve ( ) ) NEWLINE NL ENDMARKER
import sys  n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = 0 sum_ = sum ( a ) len_ = len ( a ) while sum_ / len_ < k - 0.5 : sum_ += k len_ += 1 c += 1 print ( c ) NEWLINE NL ENDMARKER
import mathn , x , y = map ( int , input ( ) . split ( ) ) v = ( math . ceil ( ( y * n ) / 100 ) ) print ( v - x ) if v - x > 0 else print ( '0' ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) ar = list ( map ( int , input ( ) . split ( ) ) ) ar = sorted ( ar ) print ( ar [ ( n + 1 ) // 2 - 1 ] )   NEWLINE NL ENDMARKER
from sys import stdin , stdout  outputs = [ ] NEWLINE t = int ( stdin . readline ( ) . strip ( ) ) NEWLINE for __ in range ( t ) : n = int ( stdin . readline ( ) . strip ( ) ) NEWLINE res = [ n + 2 ] * n NEWLINE arr = [ int ( num ) for num in stdin . readline ( ) . strip ( ) . split ( ) ] NEWLINE req = [ [ - 1 , - 1 , - 1 ] for i in range ( n + 1 ) ] NEWLINE NL ENDMARKER
import math NEWLINE def countDigits ( a , b ) : NEWLINE INDENT if ( a == 0 or b == 0 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT return math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) + 1 NEWLINE DEDENT a = 33 NEWLINE b = - 24 NEWLINE print ( countDigits ( a , b ) ) NEWLINE NL ENDMARKER
def compute ( ) : NEWLINE INDENT ans = max ( i * j for i in range ( 100 , 1000 ) for j in range ( 100 , 1000 ) if str ( i * j ) == str ( i * j ) [ : : - 1 ] ) NEWLINE return str ( ans ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( compute ( ) ) NEWLINE NL DEDENT ENDMARKER
def summPairs ( arr , n ) : NEWLINE INDENT summ = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT for j in range ( n ) : NEWLINE INDENTINDENTINDENT summ += ( arr [ i ] + arr [ j ] ) NEWLINE DEDENT DEDENT return summ NEWLINE DEDENT arr = [ 1 , 2 , 3 ] NEWLINE n = len ( arr ) NEWLINE print ( summPairs ( arr , n ) ) NEWLINE NL ENDMARKER
def countDivisibles ( A , B , M ) : NEWLINE INDENT if ( A % M == 0 ) : NEWLINE INDENTINDENT return ( ( B / M ) - ( A / M ) ) + 1 NEWLINE DEDENT return ( ( B / M ) - ( A / M ) ) NEWLINE DEDENT A = 30 NEWLINE B = 70 NEWLINE M = 10 NEWLINE print ( countDivisibles ( A , B , M ) ) NEWLINE NL ENDMARKER
n , m = list ( map ( int , input ( ) . split ( ) ) ) print ( * ( [ n // m ] * ( m - n % m ) + [ n // m + 1 ] * ( n % m ) ) ) NEWLINE NL ENDMARKER
from math import sqrt NEWLINE def findArea ( a ) : NEWLINE INDENT area = ( sqrt ( 5 * ( 5 + 2 * ( sqrt ( 5 ) ) ) ) * a * a ) / 4 NEWLINE return area NEWLINE DEDENT a = 5 NEWLINE print ( "Area of Pentagon: " , findArea ( a ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = "{0:b}" . format ( n ) . count ( '1' ) print ( a ) NEWLINE NL ENDMARKER
def fifthPowerSum ( n ) : NEWLINE INDENT sm = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT sm = sm + ( i * i * i * i * i ) NEWLINE DEDENT return sm NEWLINE DEDENT n = 6 NEWLINE print ( fifthPowerSum ( n ) ) NEWLINE NL ENDMARKER
import sys  def main ( ) : n = int ( sys . stdin . read ( ) . strip ( ) ) t = n // 2 if n % 2 : return t , t + 1 return t - 1 - t % 2 , t + 1 + t % 2 print ( * main ( ) ) NEWLINE NL ENDMARKER
I = lambda : map ( int , input ( ) . split ( ) ) n , m = I ( ) arr = I ( ) one , m_one = 0 , 0 for i in arr : if i == - 1 : m_one += 1 else : one += 1 arr = [ ] for i in range ( m ) : l , r = I ( ) temp = r - l + 1 if temp % 2 == 0 and one >= temp // 2 and m_one >= temp // 2 : arr . append ( 1 ) else : arr . append ( 0 ) print ( * arr ) NEWLINE NL ENDMARKER
from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( 'input.txt' ) ) : stdin = open ( "input.txt" , "r" ) import time NEWLINE NL ENDMARKER
def arraySortedOrNot ( arr ) : NEWLINE INDENT n = len ( arr ) NEWLINE if n == 1 or n == 0 : NEWLINE INDENTINDENT return True NEWLINE DEDENT return arr [ 0 ] <= arr [ 1 ] and arraySortedOrNot ( arr [ 1 : ] ) NEWLINE DEDENT arr = [ 20 , 23 , 23 , 45 , 78 , 88 ] NEWLINE if arraySortedOrNot ( arr ) : print ( "Yes" ) NEWLINE else : print ( "No" ) NEWLINE NL ENDMARKER
def isAMultipleOf4 ( n ) : NEWLINE INDENT if ( ( n & 3 ) == 0 ) : NEWLINE INDENTINDENT return "Yes" NEWLINE DEDENT return "No" NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 16 NEWLINE print ( isAMultipleOf4 ( n ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) m = list ( map ( int , input ( ) . split ( ) ) ) high = 0 x = [ ] for i in range ( n ) : if m [ i ] not in x : x . append ( m [ i ] ) if m . count ( m [ i ] ) > high : high = m . count ( m [ i ] ) print ( high , len ( x ) ) NEWLINE NL ENDMARKER
def summ ( m , n ) : NEWLINE INDENT return 8 * m * n - 6 * m - 6 * n + 4 NEWLINE DEDENT m = 3 NEWLINE n = 2 NEWLINE print ( summ ( m , n ) ) NEWLINE NL ENDMARKER
def turnOffK ( n , k ) : NEWLINE INDENT if ( k <= 0 ) : NEWLINE INDENTINDENT return n NEWLINE DEDENT return ( n & ~ ( 1 << ( k - 1 ) ) ) NEWLINE DEDENT n = 15 NEWLINE k = 4 NEWLINE print ( turnOffK ( n , k ) ) NEWLINE NL ENDMARKER
def Check_is_possible ( l , r , k ) : NEWLINE INDENT count = 0 ; NEWLINE for i in range ( l , r + 1 ) : NEWLINE INDENTINDENT if ( i % k == 0 ) : NEWLINE INDENTINDENTINDENT count += 1 ; NEWLINE DEDENT DEDENT return ( count > 1 ) ; NEWLINE DEDENT l = 4 ; NEWLINE r = 12 ; NEWLINE k = 5 ; NEWLINE if ( Check_is_possible ( l , r , k ) ) : NEWLINE INDENT print ( "YES" ) ; NEWLINE DEDENT else : NEWLINE INDENT print ( "NO" ) ; NEWLINE NL DEDENT ENDMARKER
class Solution ( object ) : NEWLINE INDENT def reverseList ( self , head ) : NEWLINE INDENTINDENT if head is None or head . next is None : NEWLINE INDENTINDENTINDENT return head NEWLINE DEDENT p = self . reverseList ( head . next ) NEWLINE head . next . next = head NEWLINE head . next = None NEWLINE return p NEWLINE NL DEDENT DEDENT ENDMARKER
def findMinSum ( arr , n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT sum += arr [ i ] * ( n - i ) NEWLINE DEDENT return sum NEWLINE DEDENT arr = [ 3 , 5 , 7 , 8 ] NEWLINE n = len ( arr ) NEWLINE print ( findMinSum ( arr , n ) ) NEWLINE NL ENDMARKER
for i in range ( int ( input ( ) ) ) : num = int ( input ( ) ) NEWLINE a = [ 0 for j in range ( num - 2 ) ] NEWLINE a . append ( 1 ) NEWLINE a . append ( 4 ) NEWLINE for k in range ( num ) : print ( * a ) NEWLINE a . append ( a [ 0 ] ) NEWLINE a . pop ( 0 ) NEWLINE NL ENDMARKER
from collections import defaultdict  for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE s = input ( )  d = "." NEWLINE ok = True NEWLINE result = 0 NEWLINE for i in range ( n ) : NEWLINE NL ENDMARKER
def getProbability ( p , q ) : NEWLINE INDENT p /= 100 NEWLINE q /= 100 NEWLINE probability = ( p * p + q * q ) / ( p + q ) NEWLINE return probability NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT p = 80 NEWLINE q = 40 NEWLINE print ( getProbability ( p , q ) ) NEWLINE NL DEDENT ENDMARKER
print ( "NYOE S" [ sum ( i in '47' for i in input ( ) ) in ( 4 , 7 ) : : 2 ] ) NEWLINE NL ENDMARKER
a = input ( ) . split ( ':' ) b = input ( ) . split ( ':' )    x = int ( a [ 0 ] ) * 60 + int ( a [ 1 ] ) y = int ( b [ 0 ] ) * 60 + int ( b [ 1 ] )   if y > x : x = ( ( int ( a [ 0 ] ) + 24 ) * 60 ) + int ( a [ 1 ] )   z = x - y  hr = str ( z // 60 ) . rjust ( 2 , '0' ) z %= 60 mi = str ( z ) . rjust ( 2 , '0' )  print ( f"{hr}:{mi}" )  NEWLINE NL ENDMARKER
t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) li = [ ] for i in range ( 1 , n + 1 ) : li . append ( 2 ** i ) NEWLINE NL ENDMARKER
from math import sqrt NEWLINE def centeredSquare_number ( N ) : NEWLINE INDENT n = ( 9 + sqrt ( 36 * N + 45 ) ) / 18 ; NEWLINE if ( n - int ( n ) ) == 0 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT else : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT i = 13 ; NEWLINE print ( centeredSquare_number ( i ) ) ; NEWLINE NL DEDENT ENDMARKER
for _ in range ( int ( input ( ) ) ) : print ( len ( input ( ) ) ) NEWLINE NL ENDMARKER
count , prev , great_count = 1 , - 1 , 1 for i in range ( int ( input ( ) ) ) : h , m = map ( int , input ( ) . split ( ) )  if h * 60 + m == prev : count += 1 if count > great_count : great_count = count else : count = 1 prev = h * 60 + m  print ( great_count ) NEWLINE NL ENDMARKER
n = int ( input ( ) )  for i in range ( 1 , 21 ) : n1 = n + i if '8' in str ( n1 ) : print ( i ) exit ( )   NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) dp = [ 0 ] * ndp [ 0 ] = 1 for i in range ( 1 , n ) : if 2 * l [ i - 1 ] >= l [ i ] : dp [ i ] = dp [ i - 1 ] + 1 else : dp [ i ] = 1 print ( max ( dp ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) m = ( sorted ( list ( set ( map ( int , input ( ) . strip ( ) . split ( ) ) ) ) ) ) [ : n ] print ( m [ 1 ] if len ( m ) > 1 else "NO" ) NEWLINE NL ENDMARKER
def ans ( n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT print ( "1" , end = "" ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "0" , end = "" ) ; NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 2 ; NEWLINE ans ( n ) ; NEWLINE NL DEDENT ENDMARKER
import mathimport sysinput = sys . stdin . readline  def inp ( ) : return ( int ( input ( ) ) ) def inlt ( ) : return ( list ( map ( int , input ( ) . split ( ) ) ) ) def reverse_number ( n ) : r = 0 while n > 0 : r *= 10 r += n % 10 n //= 10 return rm , s = inlt ( ) print ( m + reverse_number ( s ) ) NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) i = 0 d = 0 while a >= 0 and b >= 0 : if i % 2 == 0 and i > 0 : if b - d >= 0 : b -= d i += 1 d += 1 else : print ( 'Valera' ) break elif a - d >= 0 : a -= d i += 1 d += 1 else : print ( 'Vladik' ) break                  NEWLINE NL ENDMARKER
import syssys . stdin = open ( r'input.txt' , 'r' ) sys . stdout = open ( r'output.txt' , 'w' ) n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) i = k - 1 ; while ( True ) : if i == n : i = 0 continue if a [ i ] == 1 : print ( i + 1 ) break i += 1 NEWLINE NL ENDMARKER
from fractions import gcd NEWLINE def findRatio ( m , n ) : NEWLINE INDENT Am = m - 5 NEWLINE An = n - 5 NEWLINE numerator = Am // ( gcd ( Am , An ) ) NEWLINE denominator = An // ( gcd ( Am , An ) ) NEWLINE print ( numerator , '/' , denominator ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT m = 10 NEWLINE n = 20 NEWLINE findRatio ( m , n ) NEWLINE NL DEDENT ENDMARKER
def spiralDiaSum ( n ) : NEWLINE INDENT if n == 1 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) NEWLINE DEDENT n = 7 ; NEWLINE print ( spiralDiaSum ( n ) ) NEWLINE NL ENDMARKER
a , b , n = [ int ( x ) for x in input ( ) . split ( ) ] for i in range ( 10 ) : temp = str ( a ) + str ( i ) if ( int ( temp ) % b == 0 ) : a = temp breakif ( int ( a ) % b != 0 ) : a = - 1 else : a = a + ( '0' * ( n - 1 ) ) print ( a ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) m = input ( ) s = [ ] s [ : 0 ] = mc = 0 a = [ ] if n == 1 : print ( m ) else : for i in range ( 1 , n , 1 ) : if ( c < len ( s ) ) : a . append ( s [ c ] ) else : break c += i print ( '' . join ( map ( str , a ) ) )  NEWLINE NL ENDMARKER
def xor_pair_sum ( ar , n ) : NEWLINE INDENT total = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT total = total ^ ar [ i ] NEWLINE DEDENT return 2 * total NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT data = [ 1 , 2 , 3 ] NEWLINE print ( xor_pair_sum ( data , len ( data ) ) ) NEWLINE NL DEDENT ENDMARKER
def findMinSum ( arr , n ) : NEWLINE INDENT occ = n - 1 NEWLINE Sum = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT Sum += arr [ i ] * pow ( 2 , occ ) NEWLINE occ -= 1 NEWLINE DEDENT return Sum NEWLINE DEDENT arr = [ 1 , 2 , 4 , 5 ] NEWLINE n = len ( arr ) NEWLINE print ( findMinSum ( arr , n ) ) NEWLINE NL ENDMARKER
c = 1  x = int ( input ( ) ) string = "" while len ( string ) < x : string += str ( c ) c += 1  print ( string [ x - 1 ] ) NEWLINE NL ENDMARKER
def firstDigit ( x ) : NEWLINE INDENT while ( x >= 10 ) : NEWLINE INDENTINDENT x = x // 10 NEWLINE DEDENT return x NEWLINE DEDENT print ( firstDigit ( 12345 ) ) NEWLINE print ( firstDigit ( 5432 ) ) NEWLINE NL ENDMARKER
def CountPairs ( n ) : NEWLINE INDENT k = n NEWLINE imin = 1 NEWLINE ans = 0 NEWLINE while ( imin <= n ) : NEWLINE INDENTINDENT imax = n / k NEWLINE ans += k * ( imax - imin + 1 ) NEWLINE imin = imax + 1 NEWLINE k = n / imin NEWLINE DEDENT return ans NEWLINE DEDENT print ( CountPairs ( 1 ) ) NEWLINE print ( CountPairs ( 2 ) ) NEWLINE print ( CountPairs ( 3 ) ) NEWLINE NL ENDMARKER
def evensum ( n ) : NEWLINE INDENT return n * ( n + 1 ) NEWLINE DEDENT n = 20 NEWLINE print ( "sum of first" , n , "even number is: " , evensum ( n ) ) NEWLINE NL ENDMARKER
if __name__ == "__main__" : NEWLINE INDENT n = 3 NEWLINE a = [ 1 , 2 , 3 ] NEWLINE i = 0 NEWLINE sum = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT sum += a [ i ] NEWLINE DEDENT x = sum // n NEWLINE if ( x * n == sum ) : NEWLINE INDENTINDENT print ( x ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "-1" ) NEWLINE NL DEDENT DEDENT ENDMARKER
def countConsecutive ( n ) : NEWLINE INDENT s = str ( n ) NEWLINE count = 0 NEWLINE for i in range ( len ( s ) - 1 ) : NEWLINE INDENTINDENT if ( s [ i ] == s [ i + 1 ] ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT return count NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 44522255 NEWLINE print ( countConsecutive ( n ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) a , b , c = 1 , 2 , 3 for _ in range ( n ) : x = int ( input ( ) ) if x == c : print ( "NO" ) exit ( ) t1 = x t2 = a + b - x t3 = c a = t1 b = t3 c = t2  print ( "YES" ) NEWLINE NL ENDMARKER
def areaOfKite ( d1 , d2 ) : NEWLINE INDENT area = ( d1 * d2 ) / 2 ; NEWLINE return area ; NEWLINE DEDENT d1 = 4 ; NEWLINE d2 = 6 ; NEWLINE print ( "Area of Kite = " , areaOfKite ( d1 , d2 ) ) ; NEWLINE NL ENDMARKER
n , b , p = map ( int , input ( ) . split ( ) )   max_pow = 1 while True : aux = max_pow * 2 if aux > n : break max_pow = aux  bottles = 0 towels = n * pwhile n != 1 : bottles += max_pow * b + max_pow // 2 n -= max_pow // 2  while max_pow > n : max_pow /= 2   print ( int ( bottles ) , towels ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) ls = list ( map ( int , input ( ) . split ( ) ) ) print ( max ( ls ) ) NEWLINE NL ENDMARKER
from math import log row , col = map ( int , input ( ) . split ( " " ) ) if row % 2 == 1 : print ( row ) else : matrix = [ ] for _ in range ( row ) : matrix . append ( input ( ) . split ( " " ) ) minimum = row for _ in range ( int ( log ( row , 2 ) ) ) : if matrix [ 0 : minimum // 2 ] == matrix [ minimum - 1 : minimum // 2 - 1 : - 1 ] : minimum //= 2 else : break print ( minimum ) NEWLINE NL ENDMARKER
I = lambda : map ( int , input ( ) . split ( ) ) INT = lambda : int ( input ( ) )  NEWLINE NL ENDMARKER
n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) map = { } for i in arr : if i not in map : map [ i ] = 1 else : map [ i ] += 1 max = 0 for i in map : if map [ i ] > max : max = map [ i ] print ( n - max ) NEWLINE NL ENDMARKER
def AvgofSquareN ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT sum += ( i * i ) NEWLINE DEDENT return sum / n NEWLINE DEDENT n = 2 NEWLINE print ( AvgofSquareN ( n ) ) NEWLINE NL ENDMARKER
def get_permutation ( arr , n ) : NEWLINE INDENT arr = sorted ( arr ) NEWLINE result = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT result += abs ( arr [ i ] - ( i + 1 ) ) NEWLINE DEDENT return result NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 0 , 2 , 3 , 4 , 1 , 6 , 8 , 9 ] NEWLINE n = len ( arr ) NEWLINE print ( get_permutation ( arr , n ) ) NEWLINE NL DEDENT ENDMARKER
class Solution : NEWLINE INDENT def maximum69Number ( self , num : int ) -> int : NEWLINE INDENTINDENT return ( str ( num ) . replace ( '6' , '9' , 1 ) ) NEWLINE NL DEDENT DEDENT ENDMARKER
num = int ( input ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True )  ans = 0  seen = set ( )  for num in arr : if num in seen : while num in seen and num > 0 : num -= 1 ans += num seen . add ( num ) else : ans += num seen . add ( num )  print ( ans ) NEWLINE NL ENDMARKER
def countWays ( n , arr ) : NEWLINE INDENT if ( n == 0 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT no_ways = 0 NEWLINE for i in arr : NEWLINE INDENTINDENT if ( n - i >= 0 ) : NEWLINE INDENTINDENTINDENT no_ways = no_ways + countWays ( n - i , arr ) NEWLINE DEDENT DEDENT return no_ways NEWLINE DEDENT arr = [ 1 , 3 , 5 ] NEWLINE n = 5 NEWLINE print ( countWays ( n , arr ) ) NEWLINE NL ENDMARKER
def calcSum ( arr , n , k ) : NEWLINE INDENT for i in range ( n - k + 1 ) : NEWLINE INDENTINDENT sum = 0 NEWLINE for j in range ( i , k + i ) : NEWLINE INDENTINDENTINDENT sum += arr [ j ] NEWLINE DEDENT print ( sum , end = " " ) NEWLINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEWLINE n = len ( arr ) NEWLINE k = 3 NEWLINE calcSum ( arr , n , k ) NEWLINE NL ENDMARKER
from sys import stdinn , x , y = map ( int , stdin . readline ( ) . split ( ) ) a = list ( map ( int , stdin . readline ( ) . split ( ) ) ) for i in range ( n ) : if min ( a [ max ( i - x , 0 ) : min ( i + y + 1 , n ) ] ) == a [ i ] : print ( i + 1 ) break NEWLINE NL ENDMARKER
from collections import Counter  n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )  count = Counter ( arr ) ans = 0 for key , val in count . items ( ) : if val > 2 and key != 0 : print ( - 1 ) exit ( ) if val == 2 and key != 0 : ans += 1  print ( ans )   NEWLINE NL ENDMARKER
s = input ( ) NEWLINE if s [ 0 ] == "0" : NEWLINE INDENT h = int ( s [ 1 ] ) else : NEWLINE h = int ( s [ : 2 ] ) NEWLINE DEDENT if s [ 3 ] == "0" : NEWLINE INDENT m = int ( s [ 4 ] ) else : NEWLINE m = int ( s [ 3 : ] ) NEWLINE DEDENT a = ( ( h ) * 30 + 6 * ( 5 * m / 60 ) ) % 360 NEWLINE if str ( a ) [ - 1 ] == "0" : a = int ( a ) NEWLINE b = 6 * mprint ( a , b ) NEWLINE NL ENDMARKER
n , k = list ( map ( int , input ( ) . split ( ) ) ) s = sorted ( list ( str ( input ( ) ) ) ) r = 0 c = 0 m = sorted ( list ( set ( s ) ) ) for i in range ( len ( m ) ) : if i == 0 : r += ( ord ( m [ i ] ) - 96 ) c += 1 t = m [ i ] else : if ord ( m [ i ] ) - ord ( t ) != 1 : r += ( ord ( m [ i ] ) - 96 ) c += 1 t = m [ i ] if c == k : breakprint ( - 1 if c != k else r ) NEWLINE NL ENDMARKER
from sys import stdinn , m = map ( int , stdin . readline ( ) . split ( ) ) print ( max ( [ min ( list ( map ( int , stdin . readline ( ) . split ( ) ) ) ) for i in range ( n ) ] ) ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) li = list ( map ( int , input ( ) . split ( " " ) ) ) indexes = list ( map ( int , input ( ) . split ( " " ) ) )  if 0 in indexes and 1 in indexes : print ( "YES" ) else : if list ( sorted ( li ) ) == li : print ( "YES" ) else : print ( "NO" )   NEWLINE NL ENDMARKER
def countSquares ( m , n ) : NEWLINE INDENT if ( n < m ) : NEWLINE INDENTINDENT temp = m NEWLINE m = n NEWLINE n = temp NEWLINE DEDENT return n * ( n + 1 ) * ( 3 * m - n + 1 ) // 6 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT m = 4 NEWLINE n = 3 NEWLINE print ( "Count of squares is" , countSquares ( m , n ) ) NEWLINE NL DEDENT ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) print ( a [ n - k ] )  '''* So I drown it out * Like I always do* Dancing through our house* With the ghost of you''' NEWLINE NL ENDMARKER
    n , k , q = map ( int , input ( ) . split ( ) )    t = list ( map ( int , input ( ) . split ( ) ) )  f = [ ]    for i in range ( q ) : a , b = map ( int , input ( ) . split ( ) )    if a == 1 : if len ( f ) < k : f . append ( t [ b - 1 ] ) else : f . append ( t [ b - 1 ] ) f . sort ( ) f = f [ : : - 1 ] [ : k ] else : if t [ b - 1 ] in f : print ( 'YES' ) else : print ( 'NO' )  NEWLINE NL ENDMARKER
n = int ( input ( ) ) NEWLINE arr = list ( map ( int , input ( ) . split ( ) ) )  water = [ 0 ] * n NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) if a == b : print ( 'infinity' ) exit ( 0 ) x = abs ( a - b ) ans = 0 for xx in range ( 1 , int ( x ** 0.5 ) + 1 ) : if x % xx == 0 : if a % xx == b : ans += 1 if xx * xx != x : if a % ( x // xx ) == b : ans += 1 print ( ans ) NEWLINE NL ENDMARKER
n = input ( ) a = 26 for i in range ( len ( n ) ) : a += 25 print ( a ) NEWLINE NL ENDMARKER
ReadStr = lambda : input ( ) ReadList = lambda : list ( map ( int , input ( ) . split ( ) ) ) ReadInt = lambda : int ( input ( ) ) ReadMultipleValues = lambda : map ( int , input ( ) . split ( ) )  n = ReadInt ( ) coins = sorted ( ReadList ( ) ) [ : : - 1 ] s = 0 count = 0 for i in range ( n ) : if sum ( coins [ i : ] ) < s : break else : s += coins [ i ] count += 1 print ( count ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) if n & 1 : NEWLINE NL ENDMARKER
PI = 3.14 NEWLINE from math import pow , sqrt NEWLINE def find_area ( r , d ) : NEWLINE INDENT R = d / PI NEWLINE R += pow ( r , 2 ) NEWLINE R = sqrt ( R ) NEWLINE area = PI * pow ( R , 2 ) NEWLINE return area NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT r = 4 NEWLINE d = 5 NEWLINE print ( find_area ( r , d ) ) NEWLINE NL DEDENT ENDMARKER
import sysimport NEWLINE mathfrom NEWLINE collections NEWLINE import deque NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) c , d = map ( int , input ( ) . split ( ) )  for i in range ( 101 ) : for j in range ( 101 ) : if a * i + b == c * j + d : print ( a * i + b ) exit ( ) print ( - 1 ) NEWLINE NL ENDMARKER
n , a , b = map ( int , input ( ) . split ( ) ) e = n * 6 while e > a * b : q , w = min ( a , b ) , max ( a , b ) for i in range ( q , int ( e ** .5 ) + 1 ) : if e % i == 0 : if q <= i and w <= e // i : q , w = i , e // i ; break if q <= e // i and w <= i : q , w = e // i , i ; break if b > a : a , b = q , w else : a , b = w , q if e > a * b : e += 1 print ( a * b , a , b ) NEWLINE NL ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return 2 * pow ( n , 2 ) - n - 1 NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 4 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) )  print ( n + n // 2 ) NEWLINE NL ENDMARKER
w1 , h1 , w2 , h2 = map ( int , input ( ) . split ( ) ) ans = w1 + 4 ans += ( w1 - w2 ) ans += h1 * 2 ans += h2 * 2 ans += w2print ( ans ) NEWLINE NL ENDMARKER
i = int ( input ( ) ) s = list ( input ( ) . split ( ) ) l = { } c = 0 for j in range ( i ) : if int ( s [ j ] ) != 0 : if int ( s [ j ] ) not in l . keys ( ) : l [ int ( s [ j ] ) ] = 1 c += 1 else : l [ int ( s [ j ] ) ] += 1 print ( c ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) freq = { } for _ in range ( n ) : num = int ( input ( ) ) freq [ num ] = freq . get ( num , 0 ) + 1 keys = list ( freq . keys ( ) ) if len ( keys ) == 2 and freq [ keys [ 0 ] ] == n // 2 : print ( 'YES' ) print ( * keys ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
import math NEWLINE def fourthPowerSum ( n ) : NEWLINE INDENT return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 NEWLINE DEDENT n = 6 NEWLINE print ( fourthPowerSum ( n ) ) NEWLINE NL ENDMARKER
import sysimport mathimport itertoolsimport functoolsimport collectionsimport operatorimport fileinputimport copy  ORDA = 97 NEWLINE NL ENDMARKER
n , k = [ int ( y ) for y in input ( ) . split ( ) ] if k / n >= 3 : print ( 0 ) else : n = n * 3 print ( n - k ) NEWLINE NL ENDMARKER
l , r , ambidextors = map ( int , input ( ) . split ( ) )  base_team_size = 2 * min ( l , r ) extra_onehanded = max ( max ( l , r ) - base_team_size // 2 , 0 )  if extra_onehanded : more_pairs = min ( extra_onehanded , ambidextors ) base_team_size += 2 * more_pairs ambidextors -= more_pairs extra_onehanded -= more_pairs  max_team_size = base_team_size + ambidextors - ( ambidextors % 2 )    print ( max_team_size ) NEWLINE NL ENDMARKER
def countWords ( str ) : NEWLINE INDENT count = 1 NEWLINE for i in range ( 1 , len ( str ) - 1 ) : NEWLINE INDENTINDENT if ( str [ i ] . isupper ( ) ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT return count NEWLINE DEDENT str = "geeksForGeeks" ; NEWLINE print ( countWords ( str ) ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( " " ) ) s = input ( ) l = [ ] for i in range ( k ) : l . append ( s . count ( chr ( i + ord ( "A" ) ) ) ) print ( min ( l ) * k ) NEWLINE NL ENDMARKER
m , R = map ( int , input ( ) . split ( ) ) print ( ( 2 * m / 3 - 2 + 22 / m / 3 - 4 / m / m + 2 ** .5 * ( 2 - 4 / m + 2 / m / m ) ) * R ) NEWLINE NL ENDMARKER
n1 , m1 = input ( ) . split ( ) n = int ( n1 ) m = int ( m1 ) a = n + ( ( n - 1 ) / ( m - 1 ) ) print ( int ( a ) ) NEWLINE NL ENDMARKER
class Solution : NEWLINE INDENT def runningSum ( self , nums : List [ int ] ) -> List [ int ] : NEWLINE INDENTINDENT if nums is None or len ( nums ) == 0 : NEWLINE INDENTINDENTINDENT return nums NEWLINE DEDENT for i in range ( 1 , len ( nums ) ) : NEWLINE INDENTINDENTINDENT nums [ i ] += nums [ i - 1 ] NEWLINE DEDENT return nums NEWLINE NL DEDENT DEDENT ENDMARKER
import mathinp = input ( ) n , k = inp . split ( ) n = int ( n ) k = int ( k ) minn = 1 if ( n - k == 0 ) or ( k == 0 ) : minn = 0 maxx = 0  maxx = k * 2 if ( n - maxx - k < 0 ) : maxx = n - k   print ( minn , end = " " ) print ( maxx ) NEWLINE NL ENDMARKER
def cntSubsets ( arr , n ) : NEWLINE INDENT max = pow ( 2 , n ) NEWLINE result = 0 NEWLINE for i in range ( max ) : NEWLINE INDENTINDENT counter = i NEWLINE if ( counter & ( counter >> 1 ) ) : NEWLINE INDENTINDENTINDENT continue NEWLINE DEDENT result += 1 NEWLINE DEDENT return result NEWLINE DEDENT arr = [ 3 , 5 , 7 ] NEWLINE n = len ( arr ) NEWLINE print ( cntSubsets ( arr , n ) ) NEWLINE NL ENDMARKER
s = input ( ) print ( s + s [ : : - 1 ] ) NEWLINE NL ENDMARKER
def calculate ( array , size ) : NEWLINE INDENT count = 0 NEWLINE for i in range ( size ) : NEWLINE INDENTINDENT if ( array [ i ] % 2 == 0 and array [ i ] != 0 and array [ i ] != 2 ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT return count NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = [ 1 , 3 , 4 , 6 ] NEWLINE size = len ( a ) NEWLINE print ( calculate ( a , size ) ) NEWLINE NL DEDENT ENDMARKER
for _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) NEWLINE l = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE x = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE l = set ( l ) NEWLINE x = set ( x ) NEWLINE z = l | x NEWLINE print ( abs ( len ( z ) - ( n + m ) ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) output = [ ] for i in range ( max ( n - 82 , 0 ) , n ) : listi = list ( map ( int , str ( i ) ) ) if ( i + sum ( listi ) == n ) : output . append ( i ) print ( len ( output ) ) for i in range ( len ( output ) ) : print ( output [ i ] ) NEWLINE NL ENDMARKER
x = int ( input ( ) ) if ( x % 4 == 1 ) : print ( "0 A" ) elif ( x % 4 == 0 ) : print ( "1 A" ) elif ( x % 4 == 2 ) : print ( "1 B" ) else : print ( "2 A" ) NEWLINE NL ENDMARKER
def countNumbers ( n ) : NEWLINE INDENT k = 0 NEWLINE count = 0 NEWLINE while ( n > 0 ) : NEWLINE INDENTINDENT if ( ( n & 1 ) == 0 ) : NEWLINE INDENTINDENTINDENT count += pow ( 2 , k ) NEWLINE DEDENT k += 1 NEWLINE n >>= 1 NEWLINE DEDENT return count NEWLINE DEDENT n = 11 NEWLINE print ( countNumbers ( n ) ) NEWLINE NL ENDMARKER
s = input ( ) ans = 0 n = len ( s ) for i in range ( 1 , n ) : ans += pow ( 2 , i ) for i in range ( 0 , n ) : if ( s [ i ] == '7' ) : ans += pow ( 2 , n - 1 - i ) print ( ans + 1 ) NEWLINE NL ENDMARKER
n , x = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) exist = [ False ] * 101 for e in a : exist [ e ] = Trueans = 0 if exist [ x ] : ans += 1 for i in range ( x ) : if not exist [ i ] : ans += 1 print ( ans ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c1 = float ( 'inf' ) for i in range ( n ) : c2 = float ( '-inf' ) for j in range ( n ) : if ( i != j ) : for k in range ( m ) : c2 = max ( c2 , a [ j ] * b [ k ] ) c1 = min ( c1 , c2 ) print ( c1 ) NEWLINE NL ENDMARKER
from math import gcd as __gcd NEWLINE def finalNum ( arr , n ) : NEWLINE INDENT result = arr [ 0 ] NEWLINE for i in arr : NEWLINE INDENTINDENT result = __gcd ( result , i ) NEWLINE DEDENT return result NEWLINE DEDENT arr = [ 3 , 9 , 6 , 36 ] NEWLINE n = len ( arr ) NEWLINE print ( finalNum ( arr , n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) lis = [ 0 ] * 2 + list ( map ( int , input ( ) . split ( ) ) ) NEWLINE NL ENDMARKER
def sum_series ( n ) : NEWLINE INDENT nSquare = n * n NEWLINE return int ( nSquare * ( nSquare - 1 ) / 4 ) NEWLINE DEDENT n = 2 NEWLINE print ( sum_series ( n ) ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) )  dicti = { }  for x in range ( n ) : dicti [ x + 1 ] = "on"  opers = [ int ( bruh ) for bruh in input ( ) . split ( ) ]  for oper in opers : for light in range ( oper , n + 1 ) : if dicti [ light ] == "on" : dicti [ light ] = oper  lst = [ ] for bruhh in range ( 1 , n + 1 ) : lst . append ( str ( dicti [ bruhh ] ) )  print ( ' ' . join ( lst ) )  NEWLINE NL ENDMARKER
t = int ( input ( ) ) NEWLINE ans = [ ]  for _ in range ( t ) : s = input ( ) NEWLINE c = 1 NEWLINE start = '1'  while not ( start == s ) : if NEWLINE int ( start + start [ 0 ] ) > 10000 : start = str ( int ( start [ 0 ] ) + 1 ) NEWLINE c += len ( start ) NEWLINE continue NEWLINE start += start [ 0 ] NEWLINE c += len ( start )  ans . append ( c )  for i in ans : print ( i ) NEWLINE NL ENDMARKER
def Log2n ( n ) : NEWLINE INDENT return 1 + Log2n ( n / 2 ) if ( n > 1 ) else 0 NEWLINE DEDENT n = 32 NEWLINE print ( Log2n ( n ) ) NEWLINE NL ENDMARKER
d1 = { }  for i in range ( int ( input ( ) ) ) : s1 = input ( ) if ( s1 in d1 ) : d1 [ s1 ] += 1 else : d1 [ s1 ] = 1 l1 = list ( d1 . values ( ) ) l2 = list ( d1 . keys ( ) ) print ( l2 [ l1 . index ( max ( l1 ) ) ] ) NEWLINE NL ENDMARKER
def getChar ( strr ) : NEWLINE INDENT summ = 0 NEWLINE for i in range ( len ( strr ) ) : NEWLINE INDENTINDENT summ += ( ord ( strr [ i ] ) - ord ( 'a' ) + 1 ) NEWLINE DEDENT if ( summ % 26 == 0 ) : NEWLINE INDENTINDENT return ord ( 'z' ) NEWLINE DEDENT else : NEWLINE INDENTINDENT summ = summ % 26 NEWLINE return chr ( ord ( 'a' ) + summ - 1 ) NEWLINE DEDENT DEDENT strr = "gfg" NEWLINE print ( getChar ( strr ) ) NEWLINE NL ENDMARKER
def pell ( n ) : NEWLINE INDENT if ( n <= 2 ) : NEWLINE INDENTINDENT return n NEWLINE DEDENT a = 1 NEWLINE b = 2 NEWLINE for i in range ( 3 , n + 1 ) : NEWLINE INDENTINDENT c = 2 * b + a NEWLINE a = b NEWLINE b = c NEWLINE DEDENT return b NEWLINE DEDENT n = 4 NEWLINE print ( pell ( n ) ) NEWLINE NL ENDMARKER
def mul_table ( N , i ) : NEWLINE INDENT if ( i > 10 ) : NEWLINE INDENTINDENT return NEWLINE DEDENT print ( N , "*" , i , "=" , N * i ) NEWLINE return mul_table ( N , i + 1 ) NEWLINE DEDENT N = 8 NEWLINE mul_table ( N , 1 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) suma = ( 2 * n ) - 1 las = n - 2 fir = 2 for item in range ( 1 , n - 1 ) : suma += ( fir * las ) fir += 1 las -= 1 print ( suma ) NEWLINE NL ENDMARKER
n = int ( input ( ) )  day = list ( map ( int , input ( ) . split ( ) ) )  inf = 10 ** 20 dp = [ [ inf for _ in range ( 3 ) ] for _ in range ( n + 5 ) ]  NEWLINE NL ENDMARKER
from itertools import permutationsn , k = map ( int , input ( ) . split ( ) ) arr = [ ] count = 0 for m in range ( n ) : lst = [ 0 ] * n lst [ count ] = k count += 1 arr . append ( lst ) for x in arr : print ( * x ) NEWLINE NL ENDMARKER
import math NEWLINE def findLargestDivisor ( n ) : NEWLINE INDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEWLINE INDENTINDENT while ( n % ( i * i ) == 0 ) : NEWLINE INDENTINDENTINDENT n = n // i NEWLINE DEDENT DEDENT return n NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 12 NEWLINE print ( findLargestDivisor ( n ) ) NEWLINE n = 97 NEWLINE print ( findLargestDivisor ( n ) ) NEWLINE NL DEDENT ENDMARKER
def findPosition ( k , n ) : NEWLINE INDENT f1 = 0 NEWLINE f2 = 1 NEWLINE i = 2 ; NEWLINE while i != 0 : NEWLINE INDENTINDENT f3 = f1 + f2 ; NEWLINE f1 = f2 ; NEWLINE f2 = f3 ; NEWLINE if f2 % k == 0 : NEWLINE INDENTINDENTINDENT return n * i NEWLINE DEDENT i += 1 NEWLINE DEDENT return NEWLINE DEDENT n = 5 ; NEWLINE k = 4 ; NEWLINE print ( "Position of n'th multiple of k in" "Fibonacci Seires is" , findPosition ( k , n ) ) ; NEWLINE NL ENDMARKER
eggs = int ( input ( ) ) NEWLINE paint = [ 'R' , 'O' , 'Y' , 'G' , 'B' , 'I' , 'V' ] NEWLINE for _ in range ( eggs - 7 ) : paint . append ( '0' ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) ; print ( sum ( i for i in range ( 1 + n % 2 != 1 , n + 1 , 2 ) ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) ans = [ ] for j in range ( n ) : c = True a = [ i for i in input ( ) . split ( ) ] for i in a : if i == '1' or i == '3' : c = False if c : ans . append ( j + 1 ) print ( len ( ans ) ) print ( * ans ) NEWLINE NL ENDMARKER
import math NEWLINE def find ( n , k ) : NEWLINE INDENT if ( n + 1 >= k ) : NEWLINE INDENTINDENT return ( k - 1 ) NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( 2 * n + 1 - k ) NEWLINE DEDENT DEDENT n = 4 NEWLINE k = 7 NEWLINE freq = find ( n , k ) NEWLINE if ( freq < 0 ) : NEWLINE INDENT print ( " element not exist" ) NEWLINE DEDENT else : NEWLINE INDENT print ( " Frequency of " , k , " is " , freq ) NEWLINE NL DEDENT ENDMARKER
k = int ( input ( ) ) i = 2 n = m = 0 while i * i <= k : if k % i == 0 : if i >= 5 and k // i >= 5 : n = i m = k // i break i += 1 if n == 0 and m == 0 : print ( "-1" ) exit ( 0 ) s = "aeiou" ans = '' l = 0 NEWLINE NL ENDMARKER
month , day , = map ( int , input ( ) . split ( ) )  short = [ 2 ] mid = [ 4 , 6 , 9 , 11 ] long = [ 1 , 3 , 5 , 7 , 8 , 10 , 12 ]   if month in short : if day == 1 : print ( 4 ) else : print ( 5 )  elif month in mid : if day == 7 : print ( 6 ) else : print ( 5 ) else : if day in ( 6 , 7 ) : print ( 6 ) else : print ( 5 ) NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readline  ''''''  a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) r = input ( ) . rstrip ( ) score = 0 for s in map ( int , r ) : score += a [ s ]  print ( score )  NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = [ ] for i in range ( n ) : l , r = map ( int , input ( ) . split ( ) ) a . append ( ( r , l ) ) a . sort ( ) L = - 1 ans = 0 for x in a : if x [ 1 ] > L : L = x [ 0 ] ans += 1 print ( ans ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) x , y = list ( map ( int , input ( ) . split ( ) ) ) wm = max ( x - 1 , y - 1 ) bm = max ( n - x , n - y ) print ( "Black" if bm < wm else "White" ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) temp = p . copy ( ) p . sort ( ) nc = nnr = 0 r = 0 while n > 0 : n -= 1 r += p [ - 1 ] p [ - 1 ] -= 1  p . sort ( ) z = 0 temp . sort ( ) while nc > 0 : nc -= 1 nr += temp [ 0 ] temp [ 0 ] -= 1 if temp [ 0 ] == 0 : temp . remove ( temp [ 0 ] ) temp . sort ( )  print ( r , end = ' ' ) print ( nr ) NEWLINE NL ENDMARKER
n , k = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) r , s , x = n - k + 1 , 0 , [ ] x . append ( a [ 0 ] ) for i in range ( 1 , n + 1 ) : x . append ( x [ i - 1 ] + a [ i - 1 ] ) for i in range ( k , n + 1 ) : s += x [ i ] - x [ i - k ] print ( s / r ) NEWLINE NL ENDMARKER
x = str ( input ( ) ) start = 'a' count = 0 for i in x : count += min ( 26 - abs ( ord ( start ) - ord ( i ) ) , abs ( ord ( start ) - ord ( i ) ) ) start = iprint ( count ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) if k == 1 : ans = 6 + ( n - 2 ) * 3 elif k == n : ans = 6 + ( n - 2 ) * 3 else : ans1 = 6 + ( k - 2 ) * 3 + ( k - 1 ) + ( n - k ) * 3 ans2 = 6 + ( n - k - 1 ) * 3 + ( n - k ) + ( k - 1 ) * 3 ans = min ( ans1 , ans2 ) print ( ans ) NEWLINE NL ENDMARKER
MOD = 1000000007 NEWLINE def product ( ar , n ) : NEWLINE INDENT result = 1 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT result = ( result * ar [ i ] ) % MOD NEWLINE DEDENT return result NEWLINE DEDENT ar = [ 1 , 2 , 3 , 4 , 5 ] NEWLINE n = len ( ar ) NEWLINE print ( product ( ar , n ) ) NEWLINE NL ENDMARKER
n , k , x = map ( int , input ( ) . split ( ' ' ) ) chores = list ( map ( int , input ( ) . split ( ' ' ) ) ) print ( k * x + sum ( chores [ 0 : n - k ] ) ) NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = [ r ( ) for _ in range ( a ) ]  f = Falsefor i in range ( a ) : for j in range ( b ) : if arr [ i ] [ j ] == 1 and ( i == 0 or i == a - 1 or j == 0 or j == b - 1 ) : f = True break   print ( 2 if f else 4 ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) m = n // kif ( m % 2 == 0 ) : print ( "NO" ) else : print ( "YES" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) if n % 2 == 1 : print ( "Ehab" ) else : print ( "Mahmoud" ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) t = list ( map ( int , input ( ) . split ( ) ) ) l = [ 0 ] ch = 1 i = 0 p2 = 0 while i < n - 1 : pepe = 0 j = i + 1 while j < n : if t [ j ] - t [ i ] <= k : j += 1 else : c1 = j - 1 ch += 1 pepe = 5 break if pepe == 5 : i = j - 1 else : i += 1 if i in l : p2 = 5 break else : l . append ( i ) print ( ch if p2 == 0 else "-1" ) NEWLINE NL ENDMARKER
def angleOncirCumference ( z ) : NEWLINE INDENT return ( z / 2 ) ; NEWLINE DEDENT angle = 65 ; NEWLINE z = angleOncirCumference ( angle ) ; NEWLINE print ( "The angle is" , ( z ) , "degrees" ) ; NEWLINE NL ENDMARKER
from math import * NEWLINE def nextFibonacci ( n ) : NEWLINE INDENT a = n * ( 1 + sqrt ( 5 ) ) / 2.0 NEWLINE return round ( a ) NEWLINE DEDENT n = 5 NEWLINE print ( nextFibonacci ( n ) ) NEWLINE NL ENDMARKER
s = input ( ) a = s . count ( '-' ) b = len ( s ) - aif not a or not b : print ( 'YES' ) elif a % b == 0 : print ( 'YES' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
a = int ( input ( ) ) NEWLINE for i in range ( a ) : NEWLINE INDENT l , r = ( map ( int , input ( ) . split ( ) ) ) NEWLINE if 2 * l > r : NEWLINE INDENTINDENT print ( "-1 -1" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( str ( l ) + " " + str ( 2 * ( l ) ) ) NEWLINE NL DEDENT DEDENT ENDMARKER
def countStrings ( n ) : NEWLINE INDENT a = [ 0 for i in range ( n ) ] NEWLINE b = [ 0 for i in range ( n ) ] NEWLINE a [ 0 ] = b [ 0 ] = 1 NEWLINE for i in range ( 1 , n ) : NEWLINE INDENTINDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] NEWLINE b [ i ] = a [ i - 1 ] NEWLINE DEDENT return a [ n - 1 ] + b [ n - 1 ] NEWLINE DEDENT print ( countStrings ( 3 ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) inp = inputs = '' a , g = 0 , 0 for i in range ( n ) : x , y = map ( int , inp ( ) . split ( ) ) if a + x - g <= 500 : a += x s += 'A' else : g += y s += 'G' if abs ( a - g ) <= 500 : print ( s ) else : print ( - 1 ) NEWLINE NL ENDMARKER
import math NEWLINE def getFirstSetBitPos ( n ) : NEWLINE INDENT return ( int ) ( math . log ( n & - n ) / math . log ( 2 ) ) + 1 NEWLINE DEDENT def previousSmallerInteger ( n ) : NEWLINE INDENT pos = getFirstSetBitPos ( n ) NEWLINE return ( n & ~ ( 1 << ( pos - 1 ) ) ) NEWLINE DEDENT n = 25 NEWLINE print ( "Previous small Integer = " , previousSmallerInteger ( n ) ) NEWLINE NL ENDMARKER
import sysdef get_ints ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) li1 = get_ints ( ) li2 = get_ints ( ) if li2 [ 0 ] - li1 [ 0 ] >= 0 : li2 [ 0 ] -= li1 [ 0 ] summ = sum ( li2 ) if sum ( li2 [ : 2 ] ) >= li1 [ 1 ] : if summ - ( li1 [ 1 ] ) >= li1 [ 2 ] : print ( 'yes' ) else : print ( 'No' ) else : print ( 'no' ) else : print ( 'NO' )    NEWLINE NL ENDMARKER
def binomialCoeff ( n , k ) : NEWLINE INDENT res = 1 ; NEWLINE if ( k > n - k ) : NEWLINE INDENTINDENT k = n - k ; NEWLINE DEDENT for i in range ( k ) : NEWLINE INDENTINDENT res *= ( n - i ) ; NEWLINE res /= ( i + 1 ) ; NEWLINE DEDENT return res ; NEWLINE DEDENT def catalan ( n ) : NEWLINE INDENT c = binomialCoeff ( 2 * n , n ) ; NEWLINE return int ( c / ( n + 1 ) ) ; NEWLINE DEDENT n = 3 ; NEWLINE print ( catalan ( n ) ) ; NEWLINE NL ENDMARKER
def checkValidity ( a , b , c ) : NEWLINE INDENT if ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) : NEWLINE INDENTINDENT return False NEWLINE DEDENT else : NEWLINE INDENTINDENT return True NEWLINE DEDENT DEDENT a = 7 NEWLINE b = 10 NEWLINE c = 5 NEWLINE if checkValidity ( a , b , c ) : NEWLINE INDENT print ( "Valid" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "Invalid" ) NEWLINE NL DEDENT ENDMARKER
def countSubSeq ( arr , n , k ) : NEWLINE INDENT count = 0 ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT if ( arr [ i ] % k == 0 ) : NEWLINE INDENTINDENTINDENT count += 1 ; NEWLINE DEDENT DEDENT return ( 2 ** count - 1 ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 1 , 2 , 3 , 6 ] ; NEWLINE n = len ( arr ) ; NEWLINE k = 3 ; NEWLINE print ( countSubSeq ( arr , n , k ) ) ; NEWLINE NL DEDENT ENDMARKER
import math NEWLINE def sumOfSeries ( n ) : NEWLINE INDENT return ( ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ) ; NEWLINE DEDENT n = 2 ; NEWLINE print ( sumOfSeries ( n ) ) ; NEWLINE NL ENDMARKER
n = int ( input ( ) ) m = int ( input ( ) ) x = 1 for i in range ( 0 , n ) : x *= 2 if x > m : breakprint ( m % x ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) s = '.' * nm = ( k + 1 ) // 2 a = '.' + '#' * m + '.' * ( n - m - 1 ) if k % 2 == 0 : b = aelif k < n : t = ( n - k ) // 2 * '.' a , b = t + '#' * k + t , selse : b = a [ : 2 ] + '.' + a [ 3 : ] print ( 'YES' , s , a , b , s , sep = '\n' ) NEWLINE NL ENDMARKER
import mathn , m , x , y , a , b = map ( int , input ( ) . split ( ) ) gcd = math . gcd ( a , b ) a //= gcdb //= gcdmax_ratio = min ( n // a , m // b ) a *= max_ratiob *= max_ratiox1 = max ( 0 , min ( x - ( a + 1 ) // 2 , n - a ) ) y1 = max ( 0 , min ( y - ( b + 1 ) // 2 , m - b ) ) print ( x1 , y1 , x1 + a , y1 + b ) NEWLINE NL ENDMARKER
def findMaximumNum ( st , n , k ) : NEWLINE INDENT for i in range ( n ) : NEWLINE INDENTINDENT if ( k < 1 ) : NEWLINE INDENTINDENTINDENT break NEWLINE DEDENT if ( st [ i ] != '9' ) : NEWLINE INDENTINDENTINDENT st = st [ 0 : i ] + '9' + st [ i + 1 : ] NEWLINE k -= 1 NEWLINE DEDENT DEDENT return st NEWLINE DEDENT st = "569431" NEWLINE n = len ( st ) NEWLINE k = 3 NEWLINE print ( findMaximumNum ( st , n , k ) ) NEWLINE NL ENDMARKER
a , b = [ int ( x ) for x in input ( ) . split ( ) ] print ( a * b // 2 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) m = 0 while n > 0 : d = n % 10 if d == 4 or d == 7 : m += 1 n = n // 10 if m == 4 or m == 7 : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
import math  a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) c = list ( map ( int , input ( ) . split ( ) ) )  xab = b [ 0 ] - a [ 0 ] NEWLINE NL ENDMARKER
def maxPartition ( s ) : NEWLINE INDENT n = len ( s ) NEWLINE P = 0 NEWLINE current = "" NEWLINE previous = "" NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT current += s [ i ] NEWLINE if ( current != previous ) : NEWLINE INDENTINDENTINDENT previous = current NEWLINE current = "" NEWLINE P += 1 NEWLINE DEDENT DEDENT return P NEWLINE DEDENT s = "geeksforgeeks" NEWLINE ans = maxPartition ( s ) NEWLINE print ( ans ) NEWLINE NL ENDMARKER
def countSubStr ( st , n ) : NEWLINE INDENT m = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT if ( st [ i ] == '1' ) : NEWLINE INDENTINDENTINDENT m = m + 1 NEWLINE DEDENT DEDENT return m * ( m - 1 ) // 2 NEWLINE DEDENT st = "00100101" ; NEWLINE list ( st ) NEWLINE n = len ( st ) NEWLINE print ( countSubStr ( st , n ) , end = "" ) NEWLINE NL ENDMARKER
n , ans = int ( input ( ) ) , 1000000 for i in range ( 1 , n + 1 ) : k , a , b = 0 , n , i while b > 1 : k += a // b a , b = b , a % b if b != 0 : ans = min ( ans , a - 1 + k ) print ( ans ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = 0 b = [ ] for i in range ( 1 , n ) : a = ( a + i ) % n b . append ( a + 1 ) print ( * b ) NEWLINE NL ENDMARKER
a , b , m = map ( int , input ( ) . split ( ) ) c = ( 10 ** 9 ) % mans = - 1 for x in range ( 1 , min ( a + 1 , m ) ) : z = ( x * c ) % m if z == 0 : continue if z + b < m : ans = x breakif ans == - 1 : print ( 2 ) else : s = str ( ans ) s = ( '0' * 9 + s ) [ - 9 : ] print ( 1 , s ) NEWLINE NL ENDMARKER
import math NEWLINE def FirstDigit ( arr , n ) : NEWLINE INDENT S = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT S = S + math . log10 ( arr [ i ] * 1.0 ) NEWLINE DEDENT fract_S = S - math . floor ( S ) NEWLINE ans = math . pow ( 10 , fract_S ) NEWLINE return ans NEWLINE DEDENT arr = [ 5 , 8 , 3 , 7 ] NEWLINE n = len ( arr ) NEWLINE print ( ( int ) ( FirstDigit ( arr , n ) ) ) NEWLINE NL ENDMARKER
a = int ( input ( ) ) c = [ ]  cnt = 0 for i in range ( a ) : c . append ( input ( ) )  for i in range ( 0 , len ( c [ 0 ] ) ) : b = 0 for j in range ( 1 , a ) : if c [ j ] [ i ] == c [ 0 ] [ i ] : b += 1 else : break if b == a - 1 : cnt += 1 else : breakprint ( cnt )                                                         NEWLINE NL ENDMARKER
def Conversion ( n ) : NEWLINE INDENT return ( n - 32.0 ) * 5.0 / 9.0 NEWLINE DEDENT n = 40 NEWLINE x = Conversion ( n ) NEWLINE print ( x ) NEWLINE NL ENDMARKER
def firstkdigits ( n , k ) : NEWLINE INDENT product = 1 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT product *= n NEWLINE DEDENT while ( ( product // pow ( 10 , k ) ) != 0 ) : NEWLINE INDENTINDENT product = product // 10 NEWLINE DEDENT return product NEWLINE DEDENT n = 15 NEWLINE k = 4 NEWLINE print ( firstkdigits ( n , k ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) if ( n % 2 == 0 ) : print ( 4 , n - 4 ) else : print ( 9 , n - 9 ) NEWLINE NL ENDMARKER
def pairORSum ( arr , n ) : NEWLINE INDENT ans = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT for j in range ( i + 1 , n ) : NEWLINE INDENTINDENTINDENT ans = ans + ( arr [ i ] ^ arr [ j ] ) NEWLINE DEDENT DEDENT return ans NEWLINE DEDENT arr = [ 5 , 9 , 7 , 6 ] NEWLINE n = len ( arr ) NEWLINE print ( pairORSum ( arr , n ) ) NEWLINE NL ENDMARKER
from math import gcdn = int ( input ( ) ) arr = map ( int , input ( ) . split ( ) ) arr = list ( map ( lambda x : x - 1 , arr ) )  res = 1 for i in range ( n ) : p , k = 0 , i for j in range ( n ) : k = arr [ k ] if k == i : p = j break if k != i : print ( - 1 ) exit ( ) p += 1 if p % 2 == 0 : p //= 2 res = res * p // gcd ( res , p ) print ( res ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = int ( n ** .5 ) while n % a : a -= 1 print ( a , n // a ) NEWLINE NL ENDMARKER
import math NEWLINE def minPerimeter ( n ) : NEWLINE INDENT l = math . sqrt ( n ) NEWLINE sq = l * l NEWLINE if ( sq == n ) : NEWLINE INDENTINDENT return l * 4 NEWLINE DEDENT else : NEWLINE INDENTINDENT row = n / l NEWLINE perimeter = 2 * ( l + row ) NEWLINE if ( n % l != 0 ) : NEWLINE INDENTINDENTINDENT perimeter += 2 NEWLINE DEDENT return perimeter NEWLINE DEDENT DEDENT n = 10 NEWLINE print ( int ( minPerimeter ( n ) ) ) NEWLINE NL ENDMARKER
def checkArray ( arr , n ) : NEWLINE INDENT return ( ( arr [ 0 ] % 2 ) and ( arr [ n - 1 ] % 2 ) and ( n % 2 ) ) NEWLINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEWLINE n = len ( arr ) ; NEWLINE if checkArray ( arr , n ) : NEWLINE INDENT print ( 1 ) NEWLINE DEDENT else : NEWLINE INDENT print ( 0 ) NEWLINE NL DEDENT ENDMARKER
def isPossible ( x , y ) : NEWLINE INDENT if ( ( x - y ) == 1 ) : NEWLINE INDENTINDENT return False NEWLINE DEDENT return True NEWLINE DEDENT x = 100 NEWLINE y = 98 NEWLINE if ( isPossible ( x , y ) ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( 'input.txt' ) ) : stdin = open ( "input.txt" , "r" ) import time NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) if m == 0 : print ( n , n ) elif n == 0 : print ( 'Impossible' ) else : print ( max ( n , m ) , n + m - 1 ) NEWLINE NL ENDMARKER
from fractions import Fractionx , y , n = map ( int , input ( ) . split ( ) ) v = Fraction ( x , y ) . limit_denominator ( n ) print ( v . numerator , v . denominator , sep = '/' ) NEWLINE NL ENDMARKER
class Solution : NEWLINE INDENT def reverse ( self , x ) : NEWLINE INDENTINDENT res , isPos = 0 , 1 NEWLINE if x < 0 : NEWLINE INDENTINDENTINDENT isPos = - 1 NEWLINE x = - 1 * x NEWLINE DEDENT while x != 0 : NEWLINE INDENTINDENTINDENT res = res * 10 + x % 10 NEWLINE if res > 2147483647 : NEWLINE INDENTINDENTINDENTINDENT return 0 NEWLINE DEDENT x /= 10 NEWLINE DEDENT return res * isPos NEWLINE NL DEDENT DEDENT ENDMARKER
def compute ( ) : NEWLINE INDENT n = 2 ** 1000 NEWLINE ans = sum ( int ( c ) for c in str ( n ) ) NEWLINE return str ( ans ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( compute ( ) ) NEWLINE NL DEDENT ENDMARKER
p , q = map ( int , input ( ) . split ( ) ) a = [ ] b = [ ] NEWLINE NL ENDMARKER
t = int ( input ( ) ) for i in range ( t ) : x , y = list ( map ( int , input ( ) . split ( ) ) ) if ( x * y <= x + y ) : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
def findFactors ( a , b ) : NEWLINE INDENT c = a + b - 1 NEWLINE print ( c ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = 13 NEWLINE b = 36 NEWLINE findFactors ( a , b ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 k = 0 p . sort ( ) for i in range ( 1 , n , 2 ) : ans += abs ( p [ i // 2 ] - i ) for i in range ( 2 , n + 1 , 2 ) : k += abs ( p [ i // 2 - 1 ] - i ) print ( min ( ans , k ) ) NEWLINE NL ENDMARKER
def findElements ( arr , n ) : NEWLINE INDENT arr . sort ( ) NEWLINE for i in range ( 0 , n - 2 ) : NEWLINE INDENTINDENT print ( arr [ i ] , end = " " ) NEWLINE DEDENT DEDENT arr = [ 2 , - 6 , 3 , 5 , 1 ] NEWLINE n = len ( arr ) NEWLINE findElements ( arr , n ) NEWLINE NL ENDMARKER
a = int ( input ( ) ) for _ in range ( a ) : count = 0 h , m = input ( ) . split ( ) h = int ( h ) m = int ( m ) count += 60 - m h += 1 count += 60 * ( 24 - h ) print ( count ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) d = { } i = 1 for x in arr : if len ( d ) == m : break d [ x ] = i i += 1 if len ( d ) == m : print ( min ( d . values ( ) ) , max ( d . values ( ) ) ) else : print ( - 1 , - 1 ) NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def poorPigs ( self , buckets , minutesToDie , minutesToTest ) : NEWLINE INDENTINDENT pigs = 0 NEWLINE while ( minutesToTest / minutesToDie + 1 ) ** pigs < buckets : NEWLINE INDENTINDENTINDENT pigs += 1 NEWLINE DEDENT return pigs NEWLINE NL DEDENT DEDENT ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) z = m / n NEWLINE NL ENDMARKER
def Circular ( n ) : NEWLINE INDENT Result = 1 NEWLINE while n > 0 : NEWLINE INDENTINDENT Result = Result * n NEWLINE n -= 1 NEWLINE DEDENT return Result NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 4 NEWLINE print ( Circular ( n - 1 ) ) NEWLINE NL DEDENT ENDMARKER
def calculate ( n , power ) : NEWLINE INDENT return sum ( [ int ( i ) for i in str ( pow ( n , power ) ) ] ) NEWLINE DEDENT n = 5 NEWLINE power = 4 NEWLINE print ( calculate ( n , power ) ) NEWLINE NL ENDMARKER
import sysv = [ int ( x ) for x in sys . stdin . read ( ) . split ( ) ] print ( "YES" ) for i in range ( v [ 0 ] ) : print ( 1 + ( v [ 4 * i + 1 ] & 1 ) + 2 * ( v [ 4 * i + 2 ] & 1 ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) )  result = n  for i in range ( 1 , n ) : result += ( n - i ) * i   print ( result ) NEWLINE NL ENDMARKER
import math NEWLINE def nDigitPerfectSquares ( n ) : NEWLINE INDENT print ( pow ( math . ceil ( math . sqrt ( pow ( 10 , n - 1 ) ) ) , 2 ) , end = " " ) ; NEWLINE print ( pow ( math . ceil ( math . sqrt ( pow ( 10 , n ) ) ) - 1 , 2 ) ) ; NEWLINE DEDENT n = 4 ; NEWLINE nDigitPerfectSquares ( n ) ; NEWLINE NL ENDMARKER
def getRemainder ( num , divisor ) : NEWLINE INDENT while ( num >= divisor ) : NEWLINE INDENTINDENT num -= divisor ; NEWLINE DEDENT return num ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT num = 100 ; divisor = 7 ; NEWLINE print ( getRemainder ( num , divisor ) ) ; NEWLINE NL DEDENT ENDMARKER
for s in [ * open ( 0 ) ] [ 1 : ] : p , * a = map ( int , s . split ( ) ) ; print ( min ( - p % x for x in a ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) str = input ( ) solution = 0 eights = str . count ( "8" )  while n >= 11 and eights > 0 : if n >= 11 and eights > 0 : solution += 1 eights -= 1 n -= 11 else : break  print ( solution ) NEWLINE NL ENDMARKER
def checkYear ( year ) : NEWLINE INDENT return ( ( ( year % 4 == 0 ) and ( year % 100 != 0 ) ) or ( year % 400 == 0 ) ) ; NEWLINE DEDENT year = 2000 NEWLINE if ( checkYear ( year ) ) : NEWLINE INDENT print ( "Leap Year" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "Not a Leap Year" ) NEWLINE NL DEDENT ENDMARKER
class Solution ( object ) : NEWLINE INDENT def reverseWords ( self , s ) : NEWLINE INDENTINDENT return ' ' . join ( [ word [ : : - 1 ] for word in s . split ( ' ' ) ] ) NEWLINE NL DEDENT DEDENT ENDMARKER
for _ in range ( 1 ) : n = int ( input ( ) ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) while ( t > 0 ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) s = set ( l ) a = max ( l ) b = 1 while ( b < a ) : b = b * 2 if ( a == b ) : b = b * 2 NEWLINE NL ENDMARKER
def count_unique ( s , n ) : NEWLINE INDENT if ( s . count ( n ) ) : NEWLINE INDENTINDENT return ; NEWLINE DEDENT s . append ( n ) ; NEWLINE n += 1 ; NEWLINE while ( n % 10 == 0 ) : NEWLINE INDENTINDENT n = n // 10 ; NEWLINE DEDENT count_unique ( s , n ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 10 NEWLINE s = [ ] NEWLINE count_unique ( s , n ) NEWLINE print ( len ( s ) ) NEWLINE NL DEDENT ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) arr = [ 1 ] + list ( map ( int , input ( ) . split ( ) ) ) ln = len ( arr )  ans = 0 for i in range ( ln - 1 ) : step = arr [ i + 1 ] - arr [ i ]  if step >= 0 : ans += step else : ans += ( step + n )  print ( ans )  NEWLINE NL ENDMARKER
N = 3 ; NEWLINE def rotateMatrix ( mat ) : NEWLINE INDENT i = N - 1 ; NEWLINE while ( i >= 0 ) : NEWLINE INDENTINDENT j = N - 1 ; NEWLINE while ( j >= 0 ) : NEWLINE INDENTINDENTINDENT print ( mat [ i ] [ j ] , end = " " ) ; NEWLINE j = j - 1 ; NEWLINE DEDENT print ( ) ; NEWLINE i = i - 1 ; NEWLINE DEDENT DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; NEWLINE rotateMatrix ( mat ) ; NEWLINE NL ENDMARKER
for i in range ( int ( input ( ) ) ) : print ( max ( 0 , int ( input ( ) ) - 2 ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = [ 0 ] * nc = [ 0 ] * 100001 for i in range ( n ) : s , a [ i ] = map ( int , input ( ) . split ( ) ) c [ s ] += 1 for i in range ( n ) : print ( ( n - 1 ) + c [ a [ i ] ] , ( n - 1 ) - c [ a [ i ] ] )         NEWLINE NL ENDMARKER
def term ( n ) : NEWLINE INDENT return n * ( n + 1 ) / 2 NEWLINE DEDENT n = 4 NEWLINE print term ( n ) NEWLINE NL ENDMARKER
def numbers ( n ) : NEWLINE INDENT return pow ( 2 , n + 1 ) - 2 NEWLINE DEDENT n = 2 NEWLINE print ( numbers ( n ) ) NEWLINE NL ENDMARKER
import math NEWLINE def pronic_check ( n ) : NEWLINE INDENT x = ( int ) ( math . sqrt ( n ) ) NEWLINE if ( x * ( x + 1 ) == n ) : NEWLINE INDENTINDENT return True NEWLINE DEDENT else : NEWLINE INDENTINDENT return False NEWLINE DEDENT DEDENT n = 56 NEWLINE if ( pronic_check ( n ) == True ) : NEWLINE INDENT print ( "YES" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "NO" ) NEWLINE NL DEDENT ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) print ( ( n , 2 ) [ n != m ] ) NEWLINE NL ENDMARKER
def sum ( n ) : NEWLINE INDENT i = 1 NEWLINE s = 0.0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT s = s + 1 / i ; NEWLINE DEDENT return s ; NEWLINE DEDENT n = 5 NEWLINE print ( "Sum is" , round ( sum ( n ) , 6 ) ) NEWLINE NL ENDMARKER
def trianglearea ( l , b ) : NEWLINE INDENT if ( l < 0 or b < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT area = ( l * b ) / 2 NEWLINE return area NEWLINE DEDENT l = 5 NEWLINE b = 4 NEWLINE print ( trianglearea ( l , b ) ) NEWLINE NL ENDMARKER
k , n , w = map ( int , input ( ) . split ( ) ) t = ( k + w * k ) * w // 2 - nprint ( max ( 0 , t ) ) NEWLINE NL ENDMARKER
import mathimport sysfrom collections import dequefrom fractions import Fraction NEWLINE NL ENDMARKER
t = int ( input ( ) ) while ( t ) :  n , a , b = map ( int , input ( ) . split ( ) ) al = 1 bl = 2 cost = 0 if ( ( a // al ) > ( b // bl ) ) : NEWLINE NL ENDMARKER
def extraElement ( A , B , n ) : NEWLINE INDENT ans = 0 ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT ans ^= A [ i ] ; NEWLINE DEDENT for i in range ( n + 1 ) : NEWLINE INDENTINDENT ans ^= B [ i ] ; NEWLINE DEDENT return ans ; NEWLINE DEDENT A = [ 10 , 15 , 5 ] ; NEWLINE B = [ 10 , 100 , 15 , 5 ] ; NEWLINE n = len ( A ) ; NEWLINE print ( extraElement ( A , B , n ) ) ; NEWLINE NL ENDMARKER
def countOddSquares ( n , m ) : NEWLINE INDENT return ( int ( pow ( m , 0.5 ) ) - int ( pow ( n - 1 , 0.5 ) ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 5 ; m = 100 ; NEWLINE print ( "Count is" , ( m - n + 1 ) - countOddSquares ( n , m ) ) NEWLINE NL DEDENT ENDMARKER
  n , m = map ( int , input ( ) . split ( ) )  ans = 0 u = [ ] s = m  if m > 0 : for j in range ( n ) : if s >= j : s -= j else : if s > 0 : mas = n - ( j + 1 ) break else : mas = n - j break  if m == 0 : mas = nelif m == n * ( n - 1 ) // 2 : mas = 0          print ( max ( 0 , n - ( m * 2 ) ) , mas ) NEWLINE NL ENDMARKER
def countIndices ( arr , n ) : NEWLINE INDENT cnt = 0 ; NEWLINE max = 0 ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT if ( max < arr [ i ] ) : NEWLINE INDENTINDENTINDENT max = arr [ i ] ; NEWLINE cnt += 1 ; NEWLINE DEDENT DEDENT return cnt ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 1 , 2 , 3 , 4 ] ; NEWLINE n = len ( arr ) ; NEWLINE print ( countIndices ( arr , n ) ) ; NEWLINE NL DEDENT ENDMARKER
