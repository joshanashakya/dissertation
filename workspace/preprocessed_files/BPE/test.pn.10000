import math NEWLINE def f@@ i@@ n@@ d@@ R@@ a@@ d@@ i@@ u@@ s@@ O@@ f@@ c@@ i@@ r@@ c@@ u@@ m@@ circle ( l , b ) : NEWLINE INDENT if ( l < 0 or b < 0 ) : NEWLINE INDENTINDENT return - 1 ; NEWLINE DEDENT radius = ( math . sqrt ( pow ( l , 2 ) + pow ( b , 2 ) ) / 2 ) ; NEWLINE return radius ; NEWLINE DEDENT l = 4 ; NEWLINE b = 3 ; NEWLINE print ( f@@ i@@ n@@ d@@ R@@ a@@ d@@ i@@ u@@ s@@ O@@ f@@ c@@ i@@ r@@ c@@ u@@ m@@ circle ( l , b ) ) ; NEWLINE NL ENDMARKER
def largest ( arr , n ) : NEWLINE INDENT return ( max ( arr ) ) NEWLINE DEDENT arr = [ 10 , 324 , 45 , 90 , 9808 ] NEWLINE n = len ( arr ) NEWLINE A@@ n@@ s = largest ( arr , n ) NEWLINE print ( "Largest in given array is" , A@@ n@@ s ) NEWLINE NL ENDMARKER
from math import * NEWLINE NL ENDMARKER
def getMissingNo ( A ) : NEWLINE INDENT n = len ( A ) NEWLINE total = ( n + 1 ) * ( n + 2 ) / 2 NEWLINE s@@ u@@ m@@ _@@ o@@ f@@ _@@ A = sum ( A ) NEWLINE return total - s@@ u@@ m@@ _@@ o@@ f@@ _@@ A NEWLINE DEDENT A = [ 1 , 2 , 4 , 5 , 6 ] NEWLINE miss = getMissingNo ( A ) NEWLINE print ( miss ) NEWLINE NL ENDMARKER
import math NEWLINE def C@@ o@@ u@@ n@@ t@@ A@@ l@@ l@@ P@@ a@@ i@@ r@@ s ( N , K ) : NEWLINE INDENT count = 0 NEWLINE if ( N > K ) : NEWLINE INDENTINDENT count = N - K NEWLINE for i in range ( K + 1 , N + 1 ) : NEWLINE INDENTINDENTINDENT count = count + ( ( N - K ) // i ) NEWLINE DEDENT DEDENT return count NEWLINE DEDENT N = 11 NEWLINE K = 5 NEWLINE print ( C@@ o@@ u@@ n@@ t@@ A@@ l@@ l@@ P@@ a@@ i@@ r@@ s ( N , K ) ) NEWLINE NL ENDMARKER
a = input ( ) mod = 1000000007 ans = 0 c@@ o@@ u@@ n@@ t@@ _@@ a = 0 for i in a : if i == 'a' : c@@ o@@ u@@ n@@ t@@ _@@ a += 1 else : ans += ( pow ( 2 , c@@ o@@ u@@ n@@ t@@ _@@ a , mod ) - 1 ) % m@@ o@@ d@@ print ( ans % mod ) NEWLINE NL ENDMARKER
from fractions import gcdn = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) d = max ( a ) c = 0 for i in range ( len ( a ) ) : c = gcd ( c , a [ i ] ) result = d // c - n@@ if result % 2 == 0 : print ( "Bob" ) else : print ( "Alice" ) NEWLINE NL ENDMARKER
r = 3 NEWLINE R = 7 NEWLINE pi = 3.14159 NEWLINE V@@ o@@ l@@ u@@ m@@ e = ( float ) ( 2 * pi * pi * R * r * r ) ; NEWLINE print ( "@@ V@@ o@@ l@@ u@@ m@@ e@@ : " , V@@ o@@ l@@ u@@ m@@ e ) ; NEWLINE S@@ u@@ r@@ f@@ a@@ c@@ e = ( float ) ( 4 * pi * pi * R * r ) ; NEWLINE print ( "@@ S@@ u@@ r@@ f@@ a@@ c@@ e@@ : " , S@@ u@@ r@@ f@@ a@@ c@@ e ) ; NEWLINE NL ENDMARKER
def printOrder ( arr , n , k ) : NEWLINE INDENT a = arr [ 0 : k ] ; NEWLINE a . sort ( ) ; NEWLINE b = arr [ k : n ] ; NEWLINE b . sort ( ) ; NEWLINE b . reverse ( ) ; NEWLINE return a + b ; NEWLINE DEDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] ; NEWLINE k = 4 ; NEWLINE n = len ( arr ) ; NEWLINE arr = printOrder ( arr , n , k ) ; NEWLINE for i in range ( n ) : NEWLINE INDENT print ( arr [ i ] , end = " " ) ; NEWLINE NL DEDENT ENDMARKER
for s in [ * open ( 0 ) ] [ 1 : ] : n , k = map ( int , s . split ( ) ) ; k -= 1 ; print ( ( k + n % 2 * k // ( n // 2 ) ) % n + 1 ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) k = 2 * ( m - 1 ) for i in range ( n ) : s , f , t = map ( int , input ( ) . split ( ) ) d = t % k if s < f : print ( k * ( s <= d ) + f - 1 + t - d ) elif f < s : print ( k * ( d + s > k + 1 ) + k + 1 - f + t - d ) else : print ( t ) NEWLINE NL ENDMARKER
def m@@ s@@ b@@ P@@ o@@ s ( n ) : NEWLINE INDENT pos = 0 NEWLINE while n != 0 : NEWLINE INDENTINDENT pos += 1 NEWLINE n = n >> 1 NEWLINE DEDENT return pos NEWLINE DEDENT def j@@ o@@ s@@ e@@ p@@ h@@ i@@ f@@ y ( n ) : NEWLINE INDENT position = m@@ s@@ b@@ P@@ o@@ s ( n ) NEWLINE j = 1 << ( position - 1 ) NEWLINE n = n ^ j NEWLINE n = n << 1 NEWLINE n = n | 1 NEWLINE return n NEWLINE DEDENT n = 41 NEWLINE print ( j@@ o@@ s@@ e@@ p@@ h@@ i@@ f@@ y ( n ) ) NEWLINE NL ENDMARKER
def getSum ( arr , p ) : NEWLINE INDENT return len ( arr ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 5 , 6 , 8 ] NEWLINE p = 7 NEWLINE print ( getSum ( arr , p ) ) NEWLINE NL DEDENT ENDMARKER
k = int ( input ( ) ) i = 2 while k % i != 0 : i += 1 print ( str ( i ) + str ( k // i ) ) NEWLINE NL ENDMARKER
INDENT while ( y > 0 and y ) : NEWLINE INDENTINDENT x = x + 1 NEWLINE y = y - 1 NEWLINE DEDENT while ( y < 0 and y ) : NEWLINE INDENTINDENT x = x - 1 NEWLINE y = y + 1 NEWLINE DEDENT return x NEWLINE DEDENT print ( add ( 43 , 23 ) ) NEWLINE print ( add ( 43 , - 23 ) ) NEWLINE NL ENDMARKER
def f@@ i@@ n@@ d@@ M@@ a@@ x@@ R@@ e@@ c ( A , n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT return A [ 0 ] NEWLINE DEDENT return max ( A [ n - 1 ] , f@@ i@@ n@@ d@@ M@@ a@@ x@@ R@@ e@@ c ( A , n - 1 ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT A = [ 1 , 4 , 45 , 6 , - 50 , 10 , 2 ] NEWLINE n = len ( A ) NEWLINE print ( f@@ i@@ n@@ d@@ M@@ a@@ x@@ R@@ e@@ c ( A , n ) ) NEWLINE NL DEDENT ENDMARKER
a , b = map ( int , input ( ) . split ( ) )  r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( ) arr . sort ( reverse = True ) print ( min ( arr [ : b ] ) ) NEWLINE NL ENDMARKER
import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEWLINE NL ENDMARKER
import math ; NEWLINE def Area ( a , b ) : NEWLINE INDENT if ( a < 0 and b < 0 ) : NEWLINE INDENTINDENT return - 1 ; NEWLINE DEDENT h = math . sqrt ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) ; NEWLINE A = 0.70477 * pow ( h , 2 ) ; NEWLINE return A ; NEWLINE DEDENT a = 5 ; NEWLINE b = 4 ; NEWLINE print ( round ( Area ( a , b ) , 7 ) ) ; NEWLINE NL ENDMARKER
def s@@ u@@ b@@ s@@ e@@ t@@ S@@ u@@ m@@ s ( arr , l , r , sum = 0 ) : NEWLINE INDENT if l > r : NEWLINE INDENTINDENT print ( sum , end = " " ) NEWLINE return NEWLINE DEDENT s@@ u@@ b@@ s@@ e@@ t@@ S@@ u@@ m@@ s ( arr , l + 1 , r , sum + arr [ l ] ) NEWLINE s@@ u@@ b@@ s@@ e@@ t@@ S@@ u@@ m@@ s ( arr , l + 1 , r , sum ) NEWLINE DEDENT arr = [ 5 , 4 , 3 ] NEWLINE n = len ( arr ) NEWLINE s@@ u@@ b@@ s@@ e@@ t@@ S@@ u@@ m@@ s ( arr , 0 , n - 1 ) NEWLINE NL ENDMARKER
def findCount ( str ) : NEWLINE INDENT result = 0 NEWLINE for i in range ( len ( str ) ) : NEWLINE INDENTINDENT if ( ( i == ord ( str [ i ] ) - ord ( 'a' ) ) or ( i == ord ( str [ i ] ) - ord ( 'A' ) ) ) : NEWLINE INDENTINDENTINDENT result += 1 NEWLINE DEDENT DEDENT return result NEWLINE DEDENT str = '@@ A@@ b@@ g@@ d@@ e@@ F@@ ' NEWLINE print ( findCount ( str ) ) NEWLINE NL ENDMARKER
import time  NEWLINE NL ENDMARKER
s = input ( ) n = len ( s ) i = 0 p@@ r@@ e@@ sum = [ ] p@@ o@@ s@@ t@@ sum = [ ] flag = 0 count1 = 0 count = 0 t = 0 for i in range ( n ) : if ( s [ i ] == "@@ Q@@ " ) : count += 1 if ( flag == 1 ) : count1 += 1 if ( s [ i ] == "A" ) : t = i p@@ r@@ e@@ sum . append ( count ) NEWLINE NL ENDMARKER
from c@@ t@@ y@@ p@@ e@@ s import c@@ _@@ i@@ n@@ t@@ 3@@ 2@@ def gcd ( a , b ) : if b == 0 : return a return gcd ( b , a % b ) def n@@ o@@ r@@ m@@ a@@ l@@ i@@ z@@ e@@ _@@ r@@ a@@ t@@ i@@ o@@ n@@ al ( num , den ) : NEWLINE NL ENDMARKER
a = int ( input ( ) ) b = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) if a == 1 : print ( b [ 0 ] ) if a == 3 : print ( b [ 1 ] ) if a == 5 : print ( b [ 2 ] ) NEWLINE NL ENDMARKER
a = int ( input ( ) ) b = int ( input ( ) ) c = int ( input ( ) )    c@@ o@@ m@@ p@@ o@@ t@@ e@@ s = c // 4 c@@ o@@ m@@ p@@ o@@ t@@ e@@ s = min ( c@@ o@@ m@@ p@@ o@@ t@@ e@@ s , b // 2 ) c@@ o@@ m@@ p@@ o@@ t@@ e@@ s = min ( c@@ o@@ m@@ p@@ o@@ t@@ e@@ s , a )  NEWLINE NL ENDMARKER
def solve ( s ) : NEWLINE INDENT z = s NEWLINE l = len ( s ) NEWLINE i = 0 NEWLINE if ( s . find ( '+' ) != - 1 ) : NEWLINE INDENTINDENT i = s . find ( '+' ) NEWLINE s = s . replace ( '+' , '-' ) NEWLINE DEDENT else : NEWLINE INDENTINDENT i = s . find ( '-' ) NEWLINE s = s . replace ( '-' , '+' , 1 ) NEWLINE DEDENT print ( "@@ C@@ o@@ n@@ j@@ u@@ g@@ a@@ t@@ e of " , z , " = " , s ) NEWLINE DEDENT s = "@@ 3@@ -@@ 4@@ i@@ " NEWLINE solve ( s ) NEWLINE NL ENDMARKER
n , m , k = [ int ( x ) for x in input ( ) . split ( ) ] a = [ ] r = [ ( 0 , 0 ) ] * nc = [ ( 0 , 0 ) ] * mfor i in range ( n ) : a . append ( [ 0 ] * m ) for _ in range ( k ) : x , y , z = [ int ( t ) for t in input ( ) . split ( ) ] if x == 1 : r [ y - 1 ] = ( _ , z ) else : c [ y - 1 ] = ( _ , z ) for i in range ( n ) : for j in range ( m ) : a [ i ] [ j ] = max ( r [ i ] , c [ j ] ) [ 1 ] print ( * a [ i ] )     NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readlineimport math  def inpit ( ) : NEWLINE NL ENDMARKER
 a , b , c , d = list ( map ( int , input ( ) . split ( ) ) )  a1 = b - a@@ a2 = c - b@@ a3 = d - c  g@@ 1 = b / a@@ g@@ 2 = c / b@@ g@@ 3 = d / c NEWLINE NL ENDMARKER
def SubArraySum ( arr , n ) : NEWLINE INDENT result = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) NEWLINE DEDENT return result NEWLINE DEDENT arr = [ 1 , 2 , 3 ] NEWLINE n = len ( arr ) NEWLINE print ( "Sum of SubArray : " , SubArraySum ( arr , n ) ) NEWLINE NL ENDMARKER
from math import ceil , floor NEWLINE def m@@ a@@ x@@ Area ( perimeter ) : NEWLINE INDENT length = int ( ceil ( perimeter / 4 ) ) NEWLINE breadth = int ( floor ( perimeter / 4 ) ) NEWLINE return length * breadth NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 38 NEWLINE print ( "Maximum Area =" , m@@ a@@ x@@ Area ( n ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) count = 2 * ( n - 1 ) ** 2 + 2 * n - 1 print ( count ) NEWLINE NL ENDMARKER
import math NEWLINE def countDigits ( n ) : NEWLINE INDENT return int ( n * math . log10 ( 2 ) + 1 ) ; NEWLINE DEDENT n = 5 ; NEWLINE print ( countDigits ( n ) ) ; NEWLINE NL ENDMARKER
PI = 3.14159265 NEWLINE def area_cicumscribed ( a ) : NEWLINE INDENT return ( a * a * ( PI / 3 ) ) NEWLINE DEDENT a = 6.0 NEWLINE print ( "Area of circumscribed circle is :@@ %@@ f@@ " % area_cicumscribed ( a ) ) NEWLINE NL ENDMARKER
num = int ( input ( ) ) a = [ i for i in range ( 45 ) ] s = 1 idx = 1 while True : idx += 1 if ( s + idx > num ) : n = idx - 1 break  s += idx  left = num - s  a [ n ] += l@@ e@@ f@@ t@@ print ( n ) for i in range ( 1 , n + 1 ) : print ( a [ i ] , end = " " ) print ( ) NEWLINE NL ENDMARKER
n , d = map ( int , ( input ( ) . split ( ) ) )  x = list ( map ( int , input ( ) . split ( ) ) )   count = 2  if n > 1 : for i in range ( 1 , n ) : temp = x [ i ] - x [ i - 1 ] if temp == ( 2 * d ) : count = count + 1 if temp > 2 * d : count = count + 2  print ( count ) NEWLINE NL ENDMARKER
class p@@ a@@ i@@ r : def NEWLINE __init__ ( self , f , s ) : self . f = f NEWLINE self . s = s  m@@ e = input ( ) NEWLINE n = int ( input ( ) )  mp = { } NEWLINE for i in range ( n ) : a = list ( map ( str , input ( ) . split ( ) ) )  if a [ 1 ] == "@@ l@@ i@@ k@@ e@@ s@@ " : NEWLINE INDENT ot = a [ 2 ] else : NEWLINE ot = a [ 3 ]  NEWLINE NL DEDENT ENDMARKER
def squareRoot ( n ) : NEWLINE INDENT x = n NEWLINE y = 1 NEWLINE e = 0.000001 NEWLINE while ( x - y > e ) : NEWLINE INDENTINDENT x = ( x + y ) / 2 NEWLINE y = n / x NEWLINE DEDENT return x NEWLINE DEDENT n = 50 NEWLINE print ( "@@ S@@ q@@ u@@ are root of" , n , "is" , round ( squareRoot ( n ) , 6 ) ) NEWLINE NL ENDMARKER
def countPairs ( n ) : NEWLINE INDENT count = 0 NEWLINE for x in range ( 1 , n ) : NEWLINE INDENTINDENT for y in range ( x + 1 , n + 1 ) : NEWLINE INDENTINDENTINDENT if ( ( y * x ) % ( y + x ) == 0 ) : NEWLINE INDENTINDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT DEDENT return count NEWLINE DEDENT n = 15 NEWLINE print ( countPairs ( n ) ) NEWLINE NL ENDMARKER
def t@@ o@@ w@@ e@@ r ( n , s@@ o@@ u@@ r@@ c@@ e@@ P@@ o@@ l@@ e , d@@ e@@ s@@ t@@ i@@ n@@ a@@ t@@ i@@ o@@ n@@ P@@ o@@ l@@ e , a@@ u@@ x@@ i@@ l@@ i@@ a@@ r@@ y@@ P@@ o@@ l@@ e ) : NEWLINE INDENT if ( 0 == n ) : NEWLINE INDENTINDENT return NEWLINE DEDENT t@@ o@@ w@@ e@@ r ( n - 1 , s@@ o@@ u@@ r@@ c@@ e@@ P@@ o@@ l@@ e , a@@ u@@ x@@ i@@ l@@ i@@ a@@ r@@ y@@ P@@ o@@ l@@ e , d@@ e@@ s@@ t@@ i@@ n@@ a@@ t@@ i@@ o@@ n@@ P@@ o@@ l@@ e ) NEWLINE print ( "@@ Move the d@@ i@@ s@@ k@@ " , s@@ o@@ u@@ r@@ c@@ e@@ P@@ o@@ l@@ e , "@@ f@@ r@@ o@@ m@@ " , s@@ o@@ u@@ r@@ c@@ e@@ P@@ o@@ l@@ e , "@@ to" , d@@ e@@ s@@ t@@ i@@ n@@ a@@ t@@ i@@ o@@ n@@ P@@ o@@ l@@ e ) NEWLINE t@@ o@@ w@@ e@@ r ( n - 1 , a@@ u@@ x@@ i@@ l@@ i@@ a@@ r@@ y@@ P@@ o@@ l@@ e , d@@ e@@ s@@ t@@ i@@ n@@ a@@ t@@ i@@ o@@ n@@ P@@ o@@ l@@ e , s@@ o@@ u@@ r@@ c@@ e@@ P@@ o@@ l@@ e ) NEWLINE DEDENT t@@ o@@ w@@ e@@ r ( 3 , 'S' , 'D' , 'A' ) NEWLINE NL ENDMARKER
MOD = int ( 1e9 + 7 ) x = input ( ) [ : : - 1 ] n = len ( x ) res = 0 for i , t in enumerate ( x ) : if t == '1' : res = ( res + ( 1 << ( n - 1 + i ) ) ) % MODprint ( res ) NEWLINE NL ENDMARKER
def isPowerOfTwo ( x ) : NEWLINE INDENT return x and ( not ( x & ( x - 1 ) ) ) NEWLINE DEDENT def d@@ i@@ f@@ f@@ e@@ r@@ A@@ t@@ O@@ n@@ e@@ B@@ i@@ t@@ P@@ o@@ s ( a , b ) : NEWLINE INDENT return isPowerOfTwo ( a ^ b ) NEWLINE DEDENT a = 13 NEWLINE b = 9 NEWLINE if ( d@@ i@@ f@@ f@@ e@@ r@@ A@@ t@@ O@@ n@@ e@@ B@@ i@@ t@@ P@@ o@@ s ( a , b ) ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE i = 1 NEWLINE while i * ( i + 1 ) / 2 < n : i += 1  NEWLINE NL ENDMARKER
def c@@ o@@ n@@ v@@ e@@ r@@ s@@ i@@ on ( c@@ h@@ a@@ r@@ Set , str1 ) : NEWLINE INDENT s2 = "" NEWLINE for i in str1 : NEWLINE INDENTINDENT s2 += a@@ l@@ p@@ h@@ a@@ b@@ e@@ t@@ s [ c@@ h@@ a@@ r@@ Set . index ( i ) ] NEWLINE DEDENT return s2 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a@@ l@@ p@@ h@@ a@@ b@@ e@@ t@@ s = "abcdefghijklmnopqrstuvwxyz" NEWLINE c@@ h@@ a@@ r@@ Set = "@@ q@@ w@@ e@@ r@@ t@@ y@@ u@@ i@@ o@@ p@@ a@@ s@@ d@@ f@@ g@@ h@@ j@@ k@@ l@@ z@@ x@@ c@@ v@@ b@@ n@@ m@@ " NEWLINE str1 = "@@ e@@ g@@ r@@ t@@ " NEWLINE print ( c@@ o@@ n@@ v@@ e@@ r@@ s@@ i@@ on ( c@@ h@@ a@@ r@@ Set , str1 ) ) NEWLINE NL DEDENT ENDMARKER
a = input ( ) . split ( ) n = int ( input ( ) ) print ( * a ) for _ in range ( n ) : b = input ( ) . split ( ) a . remove ( b [ 0 ] ) a . append ( b [ 1 ] ) print ( * a ) NEWLINE NL ENDMARKER
import s@@ y@@ s@@ L@@ I = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) M@@ I = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) SI = lambda : sys . stdin . readline ( ) . strip ( '\n' ) I@@ I = lambda : int ( sys . stdin . readline ( ) )  n , a , b = M@@ I ( ) a , b = max ( a , b ) , min ( a , b ) l = sorted ( L@@ I ( ) , reverse = True ) ans = sum ( l [ : b ] ) / b + sum ( l [ b : b + a ] ) / aprint ( ans ) NEWLINE NL ENDMARKER
def f@@ i@@ n@@ d@@ T@@ h@@ e@@ Number ( n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT print ( "Impossible" ) NEWLINE return NEWLINE DEDENT for i in range ( n - 1 ) : NEWLINE INDENTINDENT print ( "5" , end = "" ) NEWLINE DEDENT print ( "4" ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 12 NEWLINE f@@ i@@ n@@ d@@ T@@ h@@ e@@ Number ( n ) NEWLINE NL DEDENT ENDMARKER
a = list ( input ( ) ) b = input ( ) i = len ( a ) - 1 while a [ i ] == 'z' : a [ i ] = 'a' i -= 1 a [ i ] = chr ( ord ( a [ i ] ) + 1 ) a = '' . join ( a ) if a >= b : print ( '@@ N@@ o s@@ u@@ ch s@@ t@@ r@@ i@@ n@@ g@@ ' ) else : print ( a ) NEWLINE NL ENDMARKER
for t in range ( int ( input ( ) ) ) : n = input ( ) NEWLINE print ( len ( n ) ) NEWLINE NL ENDMARKER
def squareDigitSum ( num ) : NEWLINE INDENT summ = 0 NEWLINE num = int ( num ) NEWLINE s@@ q@@ u@@ a@@ r@@ e@@ Num = num * num NEWLINE while s@@ q@@ u@@ a@@ r@@ e@@ Num > 0 : NEWLINE INDENTINDENT summ = summ + ( s@@ q@@ u@@ a@@ r@@ e@@ Num % 10 ) NEWLINE s@@ q@@ u@@ a@@ r@@ e@@ Num = s@@ q@@ u@@ a@@ r@@ e@@ Num // 10 NEWLINE DEDENT return summ NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = "1111" NEWLINE print ( squareDigitSum ( N ) ) NEWLINE NL DEDENT ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) left = 10 ** 18 ans = 0 for i in range ( k ) : if n % a [ i ] < left : left = n % a [ i ] ans = iprint ( ans + 1 , n // a [ ans ] ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) for i in range ( n ) : if i % 4 == 0 : print ( "a" , end = "" ) elif i % 4 == 1 : print ( "@@ b@@ " , end = "" ) elif i % 4 == 2 : print ( "@@ c@@ " , end = "" ) elif i % 4 == 3 : print ( "@@ d" , end = "" ) NEWLINE NL ENDMARKER
R = int ( input ( ) . split ( ) [ - 1 ] )  b@@ e@@ s@@ t@@ _@@ b@@ u@@ y = min ( map ( int , input ( ) . split ( ) ) ) b@@ e@@ s@@ t@@ _@@ s@@ e@@ l@@ l = max ( map ( int , input ( ) . split ( ) ) )  n@@ u@@ m@@ _@@ b@@ u@@ y = R // b@@ e@@ s@@ t@@ _@@ b@@ u@@ y  print ( max ( R , R + ( b@@ e@@ s@@ t@@ _@@ s@@ e@@ l@@ l - b@@ e@@ s@@ t@@ _@@ b@@ u@@ y ) * n@@ u@@ m@@ _@@ b@@ u@@ y ) ) NEWLINE NL ENDMARKER
m = int ( input ( ) ) NEWLINE n = [ ] NEWLINE for i in range ( m ) : n . append ( int ( input ( ) ) ) NEWLINE for i in n : print ( i - 1 ) NEWLINE for j in range ( 2 , i + 1 ) : print ( j , end = ' ' ) NEWLINE print ( ) NEWLINE NL ENDMARKER
def m@@ u@@ l@@ t@@ i@@ p@@ l@@ y@@ W@@ i@@ t@@ h@@ 3@@ P@@ o@@ i@@ n@@ t@@ 5 ( x ) : NEWLINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEWLINE DEDENT x = 4 NEWLINE print ( m@@ u@@ l@@ t@@ i@@ p@@ l@@ y@@ W@@ i@@ t@@ h@@ 3@@ P@@ o@@ i@@ n@@ t@@ 5 ( x ) ) NEWLINE NL ENDMARKER
def gcd ( a , b ) : NEWLINE INDENT if ( b == 0 ) : NEWLINE INDENTINDENT return a NEWLINE DEDENT return gcd ( b , a % b ) NEWLINE DEDENT a = 98 NEWLINE b = 56 NEWLINE if ( gcd ( a , b ) ) : NEWLINE INDENT print ( 'GCD of' , a , 'and' , b , 'is' , gcd ( a , b ) ) NEWLINE DEDENT else : NEWLINE INDENT print ( 'not found' ) NEWLINE NL DEDENT ENDMARKER
def solve ( n , k ) : NEWLINE INDENT if ( n >= ( k * ( k + 1 ) ) // 2 ) : NEWLINE INDENTINDENT return True NEWLINE DEDENT return False NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 12 NEWLINE k = 4 NEWLINE if ( solve ( n , k ) ) : NEWLINE INDENTINDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) NEWLINE NL DEDENT DEDENT ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = sorted ( l , reverse = True ) x = abs ( l [ ( 2 * n ) // 2 ] - l [ ( ( 2 * n ) // 2 ) - 1 ] ) print ( x ) NEWLINE NL ENDMARKER
def p@@ r@@ i@@ n@@ t@@ N@@ os ( n ) : NEWLINE INDENT if n > 0 : NEWLINE INDENTINDENT p@@ r@@ i@@ n@@ t@@ N@@ os ( n - 1 ) NEWLINE print ( n , end = ' ' ) NEWLINE DEDENT DEDENT p@@ r@@ i@@ n@@ t@@ N@@ os ( 100 ) NEWLINE NL ENDMARKER
n = e@@ v@@ al ( input ( ) ) s = input ( ) current = s [ 0 ] ans = 0 for i in s [ 1 : : ] : if i == current : ans += 1 current = iprint ( ans ) NEWLINE NL ENDMARKER
def p@@ r@@ i@@ n@@ t@@ T@@ h@@ r@@ e@@ e@@ P@@ a@@ r@@ ts ( N ) : NEWLINE INDENT if ( N % 3 == 0 ) : NEWLINE INDENTINDENT print ( " x = 1@@ , y = 1@@ , z = " , N - 2 ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( " x = 1@@ , y = 2@@ , z = " , N - 3 ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 10 NEWLINE p@@ r@@ i@@ n@@ t@@ T@@ h@@ r@@ e@@ e@@ P@@ a@@ r@@ ts ( N ) NEWLINE NL DEDENT ENDMARKER
def f@@ i@@ n@@ d@@ H@@ y@@ p@@ o@@ t@@ e@@ n@@ u@@ s@@ e ( s@@ i@@ d@@ e@@ 1 , s@@ i@@ d@@ e@@ 2 ) : NEWLINE INDENT h = ( ( ( s@@ i@@ d@@ e@@ 1 * s@@ i@@ d@@ e@@ 1 ) + ( s@@ i@@ d@@ e@@ 2 * s@@ i@@ d@@ e@@ 2 ) ) ** ( 1 / 2 ) ) ; NEWLINE return h ; NEWLINE DEDENT s@@ i@@ d@@ e@@ 1 = 3 ; NEWLINE s@@ i@@ d@@ e@@ 2 = 4 ; NEWLINE print ( f@@ i@@ n@@ d@@ H@@ y@@ p@@ o@@ t@@ e@@ n@@ u@@ s@@ e ( s@@ i@@ d@@ e@@ 1 , s@@ i@@ d@@ e@@ 2 ) ) ; NEWLINE NL ENDMARKER
def calculateSum ( n ) : NEWLINE INDENT return ( n * ( n + 1 ) / 2 ) ** 2 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 4 NEWLINE print ( calculateSum ( n ) ) NEWLINE NL DEDENT ENDMARKER
import sysinput = sys . stdin . readline  n , q = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) : a = int ( input ( ) ) if a % 2 != 0 : print ( ( a + 1 ) // 2 ) else : b = a // 2 while 1 > 0 : a = a + ( n - b ) b = a // 2 if a % 2 != 0 : print ( ( a + 1 ) // 2 ) break NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) NEWLINE d = list ( ) NEWLINE s = 0 NEWLINE ans = 0 NEWLINE l = list ( ) NEWLINE for i in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE for k in a : if NEWLINE k < 0 : ans += 1 NEWLINE s += abs ( k ) NEWLINE l . append ( abs ( k ) ) NEWLINE if ans % 2 == 1 : s = s - 2 * min ( l ) NEWLINE print ( s ) NEWLINE NL ENDMARKER
a = input ( ) print ( 26 * ( len ( a ) + 1 ) - len ( a ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) print ( a [ ( n - 1 ) // 2 ] ) NEWLINE NL ENDMARKER
def sumOfTheSeries ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 0 , n + 1 ) : NEWLINE INDENTINDENT k = 2 NEWLINE for j in range ( 1 , i + 1 ) : NEWLINE INDENTINDENTINDENT sum = sum + k ; NEWLINE k = k + 2 NEWLINE DEDENT DEDENT return sum ; NEWLINE DEDENT n = 5 NEWLINE ans = sumOfTheSeries ( n ) ; NEWLINE print ( ans ) NEWLINE NL ENDMARKER
def nthTerm ( N ) : NEWLINE INDENT nth = 0 ; NEWLINE if ( N % 2 == 1 ) : NEWLINE INDENTINDENT nth = ( N * N ) + 1 ; NEWLINE DEDENT else : NEWLINE INDENTINDENT nth = ( N * N ) - 1 ; NEWLINE DEDENT return nth ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 5 ; NEWLINE print ( nthTerm ( N ) ) ; NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) y = ( n // 3 ) * 2 if n % 3 == 0 : print ( y ) else : print ( y + 1 ) NEWLINE NL ENDMARKER
def c@@ e@@ n@@ t@@ e@@ r@@ e@@ d@@ H@@ e@@ x@@ a@@ g@@ o@@ n@@ a@@ l@@ S@@ e@@ r@@ i@@ e@@ s ( n ) : NEWLINE INDENT for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT print ( 3 * i * ( i - 1 ) + 1 , end = " " ) NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 10 NEWLINE c@@ e@@ n@@ t@@ e@@ r@@ e@@ d@@ H@@ e@@ x@@ a@@ g@@ o@@ n@@ a@@ l@@ S@@ e@@ r@@ i@@ e@@ s ( n ) NEWLINE NL DEDENT ENDMARKER
def decToBinary ( n ) : NEWLINE INDENT for i in range ( 31 , - 1 , - 1 ) : NEWLINE INDENTINDENT k = n >> i ; NEWLINE if ( k & 1 ) : NEWLINE INDENTINDENTINDENT print ( "1" , end = "" ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT print ( "0" , end = "" ) ; NEWLINE DEDENT DEDENT DEDENT n = 32 ; NEWLINE decToBinary ( n ) ; NEWLINE NL ENDMARKER
n , m , k = map ( int , input ( ) . split ( ) ) e = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] if k : a = set ( map ( int , input ( ) . split ( ) ) ) else : a = set ( ) ans = - 1 for i in e : if i [ 0 ] in a and i [ 1 ] not in a or i [ 1 ] in a and i [ 0 ] not in a : if ans == - 1 : ans = i [ 2 ] else : ans = min ( ans , i [ 2 ] ) print ( ans ) NEWLINE NL ENDMARKER
def line ( x0 , y0 ) : NEWLINE INDENT c = 2 * y0 * x0 NEWLINE print ( y0 , "x" , "@@ +@@ " , x0 , "@@ y@@ =" , c ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT x0 = 4 NEWLINE y0 = 3 NEWLINE line ( x0 , y0 ) NEWLINE NL DEDENT ENDMARKER
a = list ( map ( int , input ( ) . split ( ) ) ) c = a [ 0 ] for i in range ( a [ 1 ] ) : if ( c % 10 == 0 ) : c = c / 10 else : c = c - 1 print ( int ( c ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) d = { } ans = 0 flag = Falsefor i , x in enumerate ( arr ) : d [ i ] = x if i == x : ans += 1 for i in d : if i != d [ i ] and d [ d [ i ] ] == i : ans += 2 flag = True breakif flag : print ( ans ) else : if ans == len ( arr ) : print ( ans ) else : print ( ans + 1 ) NEWLINE NL ENDMARKER
k = int ( input ( ) ) digits = [ int ( i ) for i in input ( ) ] digits . sort ( ) cur = sum ( digits ) ans = 0 for d in digits : if cur < k : cur += 9 - d ans += 1 print ( ans ) NEWLINE NL ENDMARKER
def summation ( n ) : NEWLINE INDENT a@@ b@@ s@@ _sum = n * ( n + 1 ) // 2 ; NEWLINE s@@ i@@ g@@ n = 1 if ( ( n + 1 ) % 2 == 0 ) else - 1 ; NEWLINE r@@ e@@ s@@ u@@ l@@ t@@ _sum = s@@ i@@ g@@ n * a@@ b@@ s@@ _sum ; NEWLINE return r@@ e@@ s@@ u@@ l@@ t@@ _sum ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 2 ; NEWLINE print ( summation ( N ) ) ; NEWLINE NL DEDENT ENDMARKER
t = int ( input ( ) ) for _ in range ( int ( t ) ) : n = int ( input ( ) ) s = input ( ) a = int ( s [ 0 ] ) b = int ( s [ 1 : ] ) if a < b : print ( "YES" ) print ( 2 ) print ( a , b ) else : print ( "NO" ) NEWLINE NL ENDMARKER
import r@@ e@@ n@@ u@@ m@@ b@@ e@@ r@@ 1 = str ( input ( ) ) arr = str ( input ( ) ) z = re . findall ( r@@ "@@ \@@ d@@ +@@ " , n@@ u@@ m@@ b@@ e@@ r@@ 1 ) c = [ int ( b ) for b in z ] x = re . findall ( r@@ "@@ \@@ d@@ +@@ " , arr ) y = [ int ( a ) for a in x ] l@@ r = 0 r@@ l = 0 for i in range ( len ( y ) ) : if y [ i ] <= c [ 1 ] : l@@ r += 1 else : b@@ r@@ e@@ a@@ k@@ for i in reversed ( range ( len ( y ) ) ) : if y [ i ] <= c [ 1 ] : r@@ l += 1 else : break  print ( min ( l@@ r + r@@ l , c [ 0 ] ) ) NEWLINE NL ENDMARKER
import mathfrom collections import defaultdict , Counter , deque  INF = float ( 'inf' )  t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )  p@@ e@@ a@@ k = - INF diff = 0 for i in range ( n ) : p@@ e@@ a@@ k = max ( p@@ e@@ a@@ k , arr [ i ] ) diff = max ( diff , p@@ e@@ a@@ k - arr [ i ] )  p = 1 cnt = 0 while p <= diff : p *= 2 cnt += 1  print ( cnt )  NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) if ( n == k ) : print ( "-1" ) else : print ( n - k , end = " " ) r = 0 r = r + 1 j = 1 while ( r < n ) : if ( j == n - k ) : j = j + 1 print ( j , end = " " ) j = j + 1 else : print ( j , end = " " ) j = j + 1 r = r + 1 NEWLINE NL ENDMARKER
n = int ( input ( ) )  p = list ( map ( int , input ( ) . split ( ) ) )  p@@ a = n  ans = [ ]  while True : ans . append ( p@@ a ) if p@@ a == 1 : break p@@ a = p [ p@@ a - 2 ] print ( * ans [ : : - 1 ] ) NEWLINE NL ENDMARKER
def L@@ e@@ a@@ d@@ i@@ n@@ g@@ Z@@ e@@ r@@ os ( x , y ) : NEWLINE INDENT if ( ( x ^ y ) <= ( x & y ) ) : NEWLINE INDENTINDENT print ( "Equal" ) NEWLINE DEDENT elif ( ( x & ( ~ y ) ) > y ) : NEWLINE INDENTINDENT print ( y ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( x ) NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT x = 10 NEWLINE y = 16 NEWLINE L@@ e@@ a@@ d@@ i@@ n@@ g@@ Z@@ e@@ r@@ os ( x , y ) NEWLINE NL DEDENT ENDMARKER
num = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )  c@@ u@@ r@@ r@@ _@@ score = float ( "@@ -@@ i@@ n@@ f@@ " )  for i in range ( num - 1 ) : c@@ u@@ r@@ r@@ _@@ score = max ( c@@ u@@ r@@ r@@ _@@ score , arr [ i + 1 ] - arr [ i ] )  n@@ e@@ w@@ _@@ score = float ( "inf" )  for i in range ( num - 2 ) : n@@ e@@ w@@ _@@ score = min ( n@@ e@@ w@@ _@@ score , arr [ i + 2 ] - arr [ i ] )  print ( max ( n@@ e@@ w@@ _@@ score , c@@ u@@ r@@ r@@ _@@ score ) ) NEWLINE NL ENDMARKER
import m@@ a@@ t@@ h@@ print ( math . factorial ( min ( map ( int , input ( ) . split ( ) ) ) ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = "" i = 1 while len ( s ) < 10000 : s += str ( i ) i += 1  print ( s [ n - 1 ] ) NEWLINE NL ENDMARKER
def kthSmallest ( n , k ) : NEWLINE INDENT return 2 * k NEWLINE DEDENT n = 8 ; k = 4 NEWLINE print ( kthSmallest ( n , k ) ) NEWLINE NL ENDMARKER
def countSolutions ( n , val ) : NEWLINE INDENT total = 0 NEWLINE if n == 1 and val >= 0 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT for i in range ( val + 1 ) : NEWLINE INDENTINDENT total += countSolutions ( n - 1 , val - i ) NEWLINE DEDENT return total NEWLINE DEDENT n = 5 NEWLINE val = 20 NEWLINE print ( countSolutions ( n , val ) ) NEWLINE NL ENDMARKER
def T@@ w@@ e@@ n@@ t@@ y@@ o@@ n@@ e@@ M@@ a@@ t@@ c@@ h@@ s@@ t@@ i@@ c@@ k ( arr , N ) : NEWLINE INDENT for i in range ( N ) : NEWLINE INDENTINDENT print ( 5 - arr [ i ] , end = " " ) NEWLINE DEDENT DEDENT arr = [ 3 , 4 , 2 , 2 ] NEWLINE N = len ( arr ) NEWLINE T@@ w@@ e@@ n@@ t@@ y@@ o@@ n@@ e@@ M@@ a@@ t@@ c@@ h@@ s@@ t@@ i@@ c@@ k ( arr , N ) NEWLINE NL ENDMARKER
k = list ( map ( int , input ( ) . split ( ) ) ) l = list ( map ( int , input ( ) . split ( ) ) ) s = 0 for i in l : if ( i > k [ 1 ] ) : s = s + 2 else : s = s + 1 print ( s ) NEWLINE NL ENDMARKER
for i in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) print ( min ( a , b , ( a + b ) // 3 ) ) NEWLINE NL ENDMARKER
from sys import stdin , stdoutnmbr = lambda : int ( input ( ) ) lst = lambda : list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 1 ) : NEWLINE NL ENDMARKER
t = int ( input ( ) ) NEWLINE for _ in range ( t ) : a , b = map ( float , input ( ) . split ( ) ) NEWLINE if b == 0.0 : NEWLINE INDENT print ( 1.0 ) elif a == 0.0 : NEWLINE print ( 0.5 ) elif a / 4.0 <= b : NEWLINE print ( ( a + 8.0 * b ) / 1@@ 6.0 / b ) else : NEWLINE print ( 1.0 - b / a ) NEWLINE NL DEDENT ENDMARKER
for _ in range ( 8 ) : string = input ( ) if "@@ B@@ B" in string : print ( "NO" ) break if "@@ W@@ W@@ " in string : print ( "NO" ) breakelse : print ( "YES" ) NEWLINE NL ENDMARKER
num = int ( input ( ) ) li = list ( map ( int , input ( ) . split ( ) ) ) li2 = [ ] for i in range ( num ) : a = li . count ( li [ i ] ) li2 . append ( a ) print ( max ( li2 ) ) NEWLINE NL ENDMARKER
s = input ( ) ans = "" if len ( s ) == 1 : print ( 1 ) else : ans += str ( int ( s [ 0 ] ) + 1 ) for i in range ( 1 , len ( s ) ) : ans += "0" print ( int ( ans ) - int ( s ) ) NEWLINE NL ENDMARKER
n@@ u@@ m@@ O@@ f@@ Days , s@@ e@@ l@@ l@@ O@@ f@@ f@@ Days = map ( int , input ( ) . split ( ) ) t@@ o@@ t@@ a@@ l@@ P@@ r@@ o@@ d@@ u@@ c@@ t@@ s@@ S@@ o@@ l@@ d = 0 l = [ ] for i in range ( n@@ u@@ m@@ O@@ f@@ Days ) : n@@ u@@ m@@ O@@ f@@ P@@ r@@ o@@ d@@ u@@ ct , n@@ u@@ m@@ O@@ f@@ C@@ l@@ i@@ e@@ n@@ t@@ s = map ( int , input ( ) . split ( ) ) t@@ o@@ t@@ a@@ l@@ P@@ r@@ o@@ d@@ u@@ c@@ t@@ s@@ S@@ o@@ l@@ d += min ( n@@ u@@ m@@ O@@ f@@ P@@ r@@ o@@ d@@ u@@ ct , n@@ u@@ m@@ O@@ f@@ C@@ l@@ i@@ e@@ n@@ t@@ s ) l . append ( min ( 2 * n@@ u@@ m@@ O@@ f@@ P@@ r@@ o@@ d@@ u@@ ct , n@@ u@@ m@@ O@@ f@@ C@@ l@@ i@@ e@@ n@@ t@@ s ) - min ( n@@ u@@ m@@ O@@ f@@ P@@ r@@ o@@ d@@ u@@ ct , n@@ u@@ m@@ O@@ f@@ C@@ l@@ i@@ e@@ n@@ t@@ s ) ) l . sort ( ) print ( t@@ o@@ t@@ a@@ l@@ P@@ r@@ o@@ d@@ u@@ c@@ t@@ s@@ S@@ o@@ l@@ d + sum ( l [ n@@ u@@ m@@ O@@ f@@ Days - s@@ e@@ l@@ l@@ O@@ f@@ f@@ Days : ] ) ) NEWLINE NL ENDMARKER
import math , sys NEWLINE NL ENDMARKER
import mathdef main ( ) : x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) x , y = map ( int , input ( ) . split ( ) )  dx = abs ( x1 - x2 ) dy = abs ( y1 - y2 )  if dx % x == 0 and dy % y == 0 : if ( dx / x ) % 2 == ( dy / y ) % 2 : print ( "YES" ) else : print ( "NO" ) else : print ( "NO" )                    if __name__ == '__main__' : main ( ) NEWLINE NL ENDMARKER
T , S , q = map ( int , input ( ) . split ( ) ) s = S * q@@ counter = 1 while s < T : s *= q counter += 1 print ( counter ) NEWLINE NL ENDMARKER
a = [ 1 , 2 , 3 , 4 , 5 ] ; NEWLINE for i in range ( 5 ) : NEWLINE INDENT print ( a [ i ] , end = " " ) ; NEWLINE NL DEDENT ENDMARKER
s = input ( ) s1 = input ( ) s2 = input ( ) s3 = s + s@@ 1@@ s3 = '' . join ( sorted ( s3 ) ) s2 = '' . join ( sorted ( s2 ) ) cnt = 0 if ( len ( s3 ) == len ( s2 ) ) : for i in range ( 0 , len ( s3 ) ) : if ( s3 [ i ] == s2 [ i ] ) : cnt += 1 if ( cnt == len ( s3 ) and len ( s3 ) == len ( s2 ) ) : print ( "YES" ) else : print ( "NO" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
import math NEWLINE def fourthPowerSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT sum = sum + ( i * i * i * i ) NEWLINE DEDENT return sum NEWLINE DEDENT n = 6 NEWLINE print ( fourthPowerSum ( n ) ) NEWLINE NL ENDMARKER
t = { } for i , c in enumerate ( input ( ) ) : if c not in t : t [ c ] = ( i , 1 ) elif ( t [ c ] [ 0 ] - i ) & 1 : t [ c ] = ( i , t [ c ] [ 1 ] + 1 ) print ( max ( b for a , b in t . values ( ) ) ) NEWLINE NL ENDMARKER
def summation ( n ) : NEWLINE INDENT sum = 0 ; NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT if ( i % 2 == 1 ) : NEWLINE INDENTINDENTINDENT sum += ( i * i ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT sum -= ( i * i ) ; NEWLINE DEDENT DEDENT return sum ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 2 ; NEWLINE print ( summation ( N ) ) ; NEWLINE NL DEDENT ENDMARKER
n , d , e = int ( input ( ) ) , int ( input ( ) ) , int ( input ( ) ) * 5  minn = nfor i in range ( d ) : for j in range ( e ) : if i + j != 0 : k = n % ( d * i + e * j ) % d % e if minn > k : minn = kprint ( minn ) NEWLINE NL ENDMARKER
def f@@ i@@ n@@ d@@ M@@ a@@ x@@ i@@ m@@ u@@ m ( arr , low , high ) : NEWLINE INDENT max = arr [ low ] NEWLINE i = low NEWLINE for i in range ( high + 1 ) : NEWLINE INDENTINDENT if arr [ i ] > max : NEWLINE INDENTINDENTINDENT max = arr [ i ] NEWLINE DEDENT DEDENT return max NEWLINE DEDENT arr = [ 1 , 30 , 40 , 50 , 60 , 70 , 23 , 20 ] NEWLINE n = len ( arr ) NEWLINE print ( "The maximum element is %@@ d" % f@@ i@@ n@@ d@@ M@@ a@@ x@@ i@@ m@@ u@@ m ( arr , 0 , n - 1 ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = [ ] a = ( input ( ) . split ( " " ) ) NEWLINE NL ENDMARKER
def cubeSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT sum += ( 2 * i + 1 ) * ( 2 * i + 1 ) * ( 2 * i + 1 ) NEWLINE DEDENT return sum NEWLINE DEDENT print ( cubeSum ( 2 ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = abs ( n ) % 10 b = abs ( n ) // 10 % 10 if n > 0 : print ( n ) elif a > b : print ( int ( str ( n ) [ 0 : - 1 ] ) ) else : n = str ( n ) print ( int ( n [ 0 : - 2 ] + n [ - 1 ] ) ) NEWLINE NL ENDMARKER
def countWays ( N ) : NEWLINE INDENT E = ( N * ( N - 1 ) ) / 2 NEWLINE if ( N == 1 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT return int ( pow ( 2 , E - 1 ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 4 NEWLINE print ( countWays ( N ) ) NEWLINE NL DEDENT ENDMARKER
a = int ( input ( ) ) b = int ( input ( ) ) c = 0 x = awhile a * x <= b : c += 1 a *= x   if a == b : print ( "@@ Y@@ E@@ S@@ \@@ n@@ " , c ) else : print ( "NO" ) NEWLINE NL ENDMARKER
for i in range ( 0 , int ( input ( ) ) ) : n , k = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE c = n // k NEWLINE if n % k != 0 : c += 1 NEWLINE s = k * c NEWLINE if s % n == 0 : NEWLINE INDENT print ( s // n ) else : NEWLINE print ( s // n + 1 ) NEWLINE NL DEDENT ENDMARKER
import math NEWLINE def countDigit ( n ) : NEWLINE INDENT return math . floor ( math . log ( n , 10 ) + 1 ) NEWLINE DEDENT n = 345289467 NEWLINE print ( "Number of digits : % d" % ( countDigit ( n ) ) ) NEWLINE NL ENDMARKER
for i in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) d = abs ( a - b ) print ( d // 5 + d % 5 // 2 + d % 5 % 2 ) NEWLINE NL ENDMARKER
def surfaceArea ( b , s ) : NEWLINE INDENT return 2 * b * s + pow ( b , 2 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT b = 3 NEWLINE s = 4 NEWLINE print ( surfaceArea ( b , s ) ) NEWLINE NL DEDENT ENDMARKER
def numberOfPaths ( m , n ) : NEWLINE INDENT for i in range ( n , ( m + n - 1 ) ) : NEWLINE INDENTINDENT path *= i ; NEWLINE path //= ( i - n + 1 ) ; NEWLINE DEDENT return path ; NEWLINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) ; NEWLINE NL ENDMARKER
def k@@ t@@ h@@ digit ( a , b , k ) : NEWLINE INDENT p = a ** b NEWLINE count = 0 NEWLINE while ( p > 0 and count < k ) : NEWLINE INDENTINDENT rem = p % 10 NEWLINE count = count + 1 NEWLINE if ( count == k ) : NEWLINE INDENTINDENTINDENT return rem NEWLINE DEDENT p = p / 10 ; NEWLINE DEDENT DEDENT a = 5 NEWLINE b = 2 NEWLINE k = 1 NEWLINE ans = k@@ t@@ h@@ digit ( a , b , k ) NEWLINE print ( ans ) NEWLINE NL ENDMARKER
def p@@ a@@ i@@ r@@ w@@ i@@ s@@ e@@ D@@ i@@ f@@ f@@ e@@ r@@ e@@ n@@ ce ( arr , n ) : NEWLINE INDENT for i in range ( n - 1 ) : NEWLINE INDENTINDENT diff = abs ( arr [ i ] - arr [ i + 1 ] ) NEWLINE print ( diff , end = " " ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 4 , 10 , 15 , 5 , 6 ] NEWLINE n = len ( arr ) NEWLINE p@@ a@@ i@@ r@@ w@@ i@@ s@@ e@@ D@@ i@@ f@@ f@@ e@@ r@@ e@@ n@@ ce ( arr , n ) NEWLINE NL DEDENT ENDMARKER
import mathn , h = [ int ( x ) for x in input ( ) . split ( ' ' ) ] for i in range ( n - 1 ) : print ( math . sqrt ( ( i + 1 ) / ( n ) ) * h , end = " " ) print ( ) NEWLINE NL ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return 2 * pow ( n , 2 ) + n - 3 NEWLINE DEDENT N = 4 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) )  if n % 2 == 0 : a , b = 8 , n - 8 else : a , b = 9 , n - 9  print ( a , b )  NEWLINE NL ENDMARKER
a = list ( map ( int , input ( ) . split ( ) ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) n = a [ 0 ] dp = [ [ 0 for i in range ( 4 ) ] for j in range ( n + 1 ) ] for i in range ( 4 ) : dp [ 0 ] [ i ] = ( - 10 ) ** ( 27 ) for i in range ( 1 , n + 1 ) : for j in range ( 1 , 4 ) : x = arr [ i - 1 ] * a [ j ] + dp [ i ] [ j - 1 ] y = dp [ i - 1 ] [ j ] dp [ i ] [ j ] = max ( x , y ) print ( dp [ n ] [ 3 ] ) NEWLINE NL ENDMARKER
def getValue ( n ) : NEWLINE INDENT i = 0 ; NEWLINE k = 1 ; NEWLINE while ( i < n ) : NEWLINE INDENTINDENT i = i + k ; NEWLINE k = k * 2 ; NEWLINE DEDENT return int ( k / 2 ) ; NEWLINE DEDENT n = 9 ; NEWLINE print ( getValue ( n ) ) ; NEWLINE n = 1025 ; NEWLINE print ( getValue ( n ) ) ; NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ' ' ) ) ) a = list ( sorted ( a ) )  d@@ a@@ y@@ s@@ _@@ o@@ f@@ _@@ t@@ r@@ a@@ i@@ n@@ i@@ n@@ g = 0 for i in range ( len ( a ) ) : if a [ i ] > d@@ a@@ y@@ s@@ _@@ o@@ f@@ _@@ t@@ r@@ a@@ i@@ n@@ i@@ n@@ g : d@@ a@@ y@@ s@@ _@@ o@@ f@@ _@@ t@@ r@@ a@@ i@@ n@@ i@@ n@@ g += 1 print ( d@@ a@@ y@@ s@@ _@@ o@@ f@@ _@@ t@@ r@@ a@@ i@@ n@@ i@@ n@@ g ) NEWLINE NL ENDMARKER
def solve ( n ) : NEWLINE INDENT ans = ( n * n // 4 ) NEWLINE return ans NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 10 NEWLINE print ( solve ( n ) ) NEWLINE NL DEDENT ENDMARKER
def sumOfAP ( a , d , n ) : NEWLINE INDENT sum = 0 NEWLINE i = 0 NEWLINE while i < n : NEWLINE INDENTINDENT sum = sum + a NEWLINE a = a + d NEWLINE i = i + 1 NEWLINE DEDENT return sum NEWLINE DEDENT n = 20 NEWLINE a = 2.5 NEWLINE d = 1.5 NEWLINE print ( sumOfAP ( a , d , n ) ) NEWLINE NL ENDMARKER
k = int ( input ( ) ) s = "" if k > 36 : print ( - 1 ) else : while k > 0 : if k >= 2 : s = s + "8" k = k - 2 else : s = s + "4" k = k - 1 print ( s ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : l , r = map ( int , input ( ) . split ( ) ) print ( min ( l , r , ( l + r ) // 3 ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) print ( n * max ( a ) - sum ( a ) ) NEWLINE NL ENDMARKER
k , a , b = map ( int , input ( ) . split ( ) ) if ( a >= 0 and b >= 0 ) or ( a < 0 and b < 0 ) : if a < 0 and b < 0 : temp = - b b = - a a = temp c = b // k - a // k if a % k == 0 : c += 1 elif a < 0 and b >= 0 : a = - a c = a // k + b // k + 1 print ( c ) NEWLINE NL ENDMARKER
x = 0 z = int ( input ( ) ) while z > 0 : if z >= 5 : z = z - 5 x += 1 elif z >= 4 : z = z - 4 x += 1 elif z >= 3 : z = z - 3 x += 1 elif z >= 2 : z = z - 2 x += 1 elif z >= 1 : z = z - 1 x += 1 print ( x ) NEWLINE NL ENDMARKER
def m@@ a@@ x@@ E@@ d@@ g@@ e@@ s ( N ) : NEWLINE INDENT edges = 0 ; NEWLINE edges = ( N * N ) // 4 ; NEWLINE return edges ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 5 ; NEWLINE print ( m@@ a@@ x@@ E@@ d@@ g@@ e@@ s ( N ) ) ; NEWLINE NL DEDENT ENDMARKER
int ( input ( ) ) x = '' zero = 0 for s in input ( ) . split ( ) : if s == '0' : print ( 0 ) , exit ( ) elif s == '1' + '0' * ( len ( s ) - 1 ) : zero += len ( s ) - 1 else : x = sprint ( x + '0' * zero if len ( x ) > 0 else '1' + '0' * zero ) NEWLINE NL ENDMARKER
f@@ r@@ i@@ e@@ n@@ d@@ _@@ c@@ o@@ o@@ r@@ d@@ i@@ n@@ a@@ t@@ e = list ( map ( int , input ( ) . split ( ) ) ) m@@ i@@ n@@ _@@ value = min ( f@@ r@@ i@@ e@@ n@@ d@@ _@@ c@@ o@@ o@@ r@@ d@@ i@@ n@@ a@@ t@@ e ) m@@ a@@ x@@ _@@ value = max ( f@@ r@@ i@@ e@@ n@@ d@@ _@@ c@@ o@@ o@@ r@@ d@@ i@@ n@@ a@@ t@@ e )  mid = ( m@@ i@@ n@@ _@@ value + m@@ a@@ x@@ _@@ value ) // 2 print ( ( m@@ a@@ x@@ _@@ value - mid ) + ( mid - m@@ i@@ n@@ _@@ value ) ) NEWLINE NL ENDMARKER
from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect  NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def a@@ n@@ a@@ g@@ r@@ a@@ m@@ M@@ a@@ p@@ p@@ i@@ n@@ g@@ s ( self , A , B ) : NEWLINE INDENTINDENT v@@ a@@ l@@ _@@ index = { } NEWLINE ans = [ ] NEWLINE for i , n in enumerate ( B ) : NEWLINE INDENTINDENTINDENT v@@ a@@ l@@ _@@ index [ n ] = i NEWLINE DEDENT for n in A : NEWLINE INDENTINDENTINDENT ans . append ( v@@ a@@ l@@ _@@ index [ n ] ) NEWLINE DEDENT return ans NEWLINE NL DEDENT DEDENT ENDMARKER
n , k = map ( int , input ( ) . split ( ) )  c = 0 i = 1 while 1 : c += i if n - i == c - k : print ( n - i ) break i += 1  NEWLINE NL ENDMARKER
n = int ( input ( ) ) k = ( input ( ) ) x = k . count ( '0' ) y = k . count ( '1' ) if ( x == y ) : print ( 2 ) print ( k [ 0 ] , k [ 1 : ] ) else : print ( 1 ) print ( k ) NEWLINE NL ENDMARKER
def f@@ i@@ n@@ d@@ S ( s ) : NEWLINE INDENT _sum = 0 NEWLINE n = 1 NEWLINE while ( _sum < s ) : NEWLINE INDENTINDENT _sum += n NEWLINE n += 1 NEWLINE DEDENT n -= 1 NEWLINE if _sum == s : NEWLINE INDENTINDENT return n NEWLINE DEDENT return - 1 NEWLINE DEDENT s = 15 NEWLINE n = f@@ i@@ n@@ d@@ S ( s ) NEWLINE if n == - 1 : NEWLINE INDENT print ( "-1" ) NEWLINE DEDENT else : NEWLINE INDENT print ( n ) NEWLINE NL DEDENT ENDMARKER
import sysinput = sys . stdin . readline  for test in range ( int ( input ( ) ) ) : a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) if a [ 0 ] == a [ 1 ] and a [ 1 ] == a [ 2 ] : res = 0 else : res = 4 ans = abs ( a [ 0 ] - a [ 1 ] ) + abs ( a [ 0 ] - a [ 2 ] ) + abs ( a [ 1 ] - a [ 2 ] ) print ( max ( 0 , ans - res ) ) NEWLINE NL ENDMARKER
a = input ( ) b = input ( ) . split ( ) if "1" in b : print ( "-1" ) else : print ( "1" ) NEWLINE NL ENDMARKER
from sys import stdin NEWLINE NL ENDMARKER
def summingSeries ( n ) : NEWLINE INDENT S = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT S += i * i - ( i - 1 ) * ( i - 1 ) NEWLINE DEDENT return S NEWLINE DEDENT n = 100 NEWLINE print ( "The sum of n term is: " , summingSeries ( n ) , sep = "" ) NEWLINE NL ENDMARKER
n@@ u@@ m@@ C@@ ars = int ( input ( ) ) t@@ E@@ n@@ t@@ r@@ a@@ n@@ ce = [ int ( num ) for num in input ( ) . split ( ) ] t@@ E@@ x@@ it = [ int ( num ) for num in input ( ) . split ( ) ]  f@@ i@@ n@@ e@@ s = 0j = 0 o@@ c@@ c@@ u@@ r@@ r@@ e@@ d = set ( ) for i in range ( n@@ u@@ m@@ C@@ ars ) : if t@@ E@@ n@@ t@@ r@@ a@@ n@@ ce [ i ] in o@@ c@@ c@@ u@@ r@@ r@@ e@@ d : continue while t@@ E@@ x@@ it [ j ] != t@@ E@@ n@@ t@@ r@@ a@@ n@@ ce [ i ] : o@@ c@@ c@@ u@@ r@@ r@@ e@@ d . add ( t@@ E@@ x@@ it [ j ] ) f@@ i@@ n@@ e@@ s += 1 j += 1 o@@ c@@ c@@ u@@ r@@ r@@ e@@ d . add ( t@@ E@@ x@@ it [ j ] ) j += 1 print ( f@@ i@@ n@@ e@@ s ) NEWLINE NL ENDMARKER
import h@@ e@@ a@@ p@@ q@@ s = str ( input ( ) ) k = int ( input ( ) ) n = len ( s ) l = [ ] if k > ( n * ( n + 1 ) ) // 2 : print ( '@@ N@@ o s@@ u@@ ch l@@ i@@ n@@ e@@ .@@ ' ) else : for i in range ( n ) : heapq . heappush ( l , ( s [ i ] , i + 1 ) ) while k > 0 : k -= 1 x , y = heapq . heappop ( l ) if y < n : heapq . heappush ( l , ( x + s [ y ] , y + 1 ) ) print ( x ) NEWLINE NL ENDMARKER
a = input ( ) b = input ( ) a = a . lstrip ( '0' ) b = b . lstrip ( '0' ) if len ( a ) != len ( b ) : print ( '<' if len ( a ) < len ( b ) else '>' ) exit ( 0 ) for i in range ( len ( a ) ) : if a [ i ] != b [ i ] : print ( '<' if a [ i ] < b [ i ] else '>' ) exit ( 0 ) print ( '=' ) NEWLINE NL ENDMARKER
def k@@ smallest ( arr , n , k ) : NEWLINE INDENT for i in range ( n ) : NEWLINE INDENTINDENT if ( arr [ i ] <= k ) : NEWLINE INDENTINDENTINDENT k = k + 1 ; NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT break ; NEWLINE DEDENT DEDENT return k ; NEWLINE DEDENT k = 1 ; NEWLINE arr = [ 1 ] ; NEWLINE n = len ( arr ) ; NEWLINE print ( k@@ smallest ( arr , n , k ) ) ; NEWLINE NL ENDMARKER
def n@@ t@@ h@@ X@@ o@@ r@@ F@@ i@@ b ( n , a , b ) : NEWLINE INDENT if n == 0 : NEWLINE INDENTINDENT return a NEWLINE DEDENT if n == 1 : NEWLINE INDENTINDENT return b NEWLINE DEDENT if n == 2 : NEWLINE INDENTINDENT return a ^ b NEWLINE DEDENT return n@@ t@@ h@@ X@@ o@@ r@@ F@@ i@@ b ( n % 3 , a , b ) NEWLINE DEDENT a = 1 NEWLINE b = 2 NEWLINE n = 10 NEWLINE print ( n@@ t@@ h@@ X@@ o@@ r@@ F@@ i@@ b ( n , a , b ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) NEWLINE for p in range ( n ) : n1 , k = map ( int , input ( ) . split ( ) ) NEWLINE a = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE b = list ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] NEWLINE if p != n - 1 : z = input ( ) NEWLINE for x in range ( n1 ) : if NEWLINE a [ x ] + b [ x ] > k : print ( 'No' ) NEWLINE break else : print ( 'Yes' ) NEWLINE NL ENDMARKER
def countSetBits ( n ) : NEWLINE INDENT if ( n == 0 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT else : NEWLINE INDENTINDENT return 1 + countSetBits ( n & ( n - 1 ) ) NEWLINE DEDENT DEDENT n = 9 NEWLINE print ( countSetBits ( n ) ) NEWLINE NL ENDMARKER
l , r , k = map ( int , input ( ) . split ( ) ) ans = 1 ; c = 0 while ( ans < l ) : ans = ans * kwhile ( ans <= r ) : c = c + 1 print ( ans ) ans = ans * kif ( c == 0 ) : print ( - 1 ) NEWLINE NL ENDMARKER
from math import gcd NEWLINE def n@@ o@@ O@@ f@@ Squares ( x1 , y1 , x2 , y2 ) : NEWLINE INDENT dx = abs ( x2 - x1 ) ; NEWLINE dy = abs ( y2 - y1 ) ; NEWLINE ans = dx + dy - gcd ( dx , dy ) ; NEWLINE print ( ans ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT x1 = 1 ; y1 = 1 ; x2 = 4 ; y2 = 3 ; NEWLINE n@@ o@@ O@@ f@@ Squares ( x1 , y1 , x2 , y2 ) ; NEWLINE NL DEDENT ENDMARKER
k = int ( input ( ) ) l = int ( input ( ) ) i = 0 while l > 1 : l /= k ; i += 1 if l == 1 : print ( "YES" ) print ( i - 1 ) else : print ( "NO" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) i = 1 a = [ ] while n >= i : a . append ( i ) n -= i i += 1 if n > 0 : a [ - 1 ] += nprint ( len ( a ) ) print ( * a ) NEWLINE NL ENDMARKER
import math NEWLINE def countBits ( number ) : NEWLINE INDENT return int ( ( math . log ( number ) / math . log ( 2 ) ) + 1 ) ; NEWLINE DEDENT num = 65 ; NEWLINE print ( countBits ( num ) ) ; NEWLINE NL ENDMARKER
import math NEWLINE def highestPowerof2 ( n ) : NEWLINE INDENT p = int ( math . log ( n , 2 ) ) ; NEWLINE return int ( pow ( 2 , p ) ) ; NEWLINE DEDENT n = 10 ; NEWLINE print ( highestPowerof2 ( n ) ) ; NEWLINE NL ENDMARKER
def C@@ a@@ l@@ P@@ e@@ r@@ i ( ) : NEWLINE INDENT s = 5 NEWLINE Perimeter = 10 * s NEWLINE print ( "The Perimeter of D@@ e@@ c@@ a@@ g@@ on is : " , Perimeter ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT C@@ a@@ l@@ P@@ e@@ r@@ i ( ) ; NEWLINE NL DEDENT ENDMARKER
def isPossible ( w , h , x , y ) : NEWLINE INDENT if ( x * 2 == w and y * 2 == h ) : NEWLINE INDENTINDENT return True NEWLINE DEDENT return False NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT w = 1 NEWLINE h = 2 NEWLINE x = 1 NEWLINE y = 2 NEWLINE if ( isPossible ( w , h , x , y ) ) : NEWLINE INDENTINDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) NEWLINE NL DEDENT DEDENT ENDMARKER
def subString ( Str , n ) : NEWLINE INDENT for L@@ e@@ n in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT for i in range ( n - L@@ e@@ n + 1 ) : NEWLINE INDENTINDENTINDENT j = i + L@@ e@@ n - 1 NEWLINE for k in range ( i , j + 1 ) : NEWLINE INDENTINDENTINDENTINDENT print ( Str [ k ] , end = "" ) NEWLINE DEDENT print ( ) NEWLINE DEDENT DEDENT DEDENT Str = "abc" NEWLINE subString ( Str , len ( Str ) ) NEWLINE NL ENDMARKER
from sys import stdin , stdoutimport math , sysfrom itertools import permutations , c@@ o@@ m@@ b@@ i@@ n@@ a@@ t@@ i@@ o@@ n@@ s@@ from collections import defaultdict , deque , O@@ r@@ d@@ e@@ r@@ e@@ d@@ D@@ i@@ c@@ t@@ from os import pathimport bisect as b@@ i@@ import heapq def y@@ e@@ s ( ) : print ( 'YES' ) def no ( ) : print ( 'NO' ) if ( path . exists ( 'input.txt' ) ) : NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) )  y = [ int ( i ) for i in input ( ) . split ( ) ]  y = [ 5 - i for i in y ]  y . sort ( reverse = True )  NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = [ int ( i ) for i in input ( ) . split ( ) ] [ : n ] count = 0 for i in l : s = sum ( l ) - i if ( s % 2 == 0 ) : count += 1  print ( count )  NEWLINE NL ENDMARKER
def findNum ( div , rem , N ) : NEWLINE INDENT num = rem [ N - 1 ] NEWLINE i = N - 2 NEWLINE while ( i >= 0 ) : NEWLINE INDENTINDENT num = num * div [ i ] + rem [ i ] NEWLINE i -= 1 NEWLINE DEDENT return num NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT div = [ 8 , 3 ] NEWLINE rem = [ 2 , 2 ] NEWLINE N = len ( div ) NEWLINE print ( findNum ( div , rem , N ) ) NEWLINE NL DEDENT ENDMARKER
flip = { '0' : '1' , '1' : '0' } NEWLINE NL ENDMARKER
from math import tan NEWLINE def I@@ n@@ s@@ c@@ r@@ i@@ b@@ e@@ d@@ C@@ i@@ r@@ c@@ l@@ e@@ Area ( n , a ) : NEWLINE INDENT if ( a < 0 and n < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT r = a / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; NEWLINE Area = 3.14 * r * r NEWLINE return Area NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = 4 NEWLINE n = 6 NEWLINE print ( '{0:.6}' . format ( I@@ n@@ s@@ c@@ r@@ i@@ b@@ e@@ d@@ C@@ i@@ r@@ c@@ l@@ e@@ Area ( n , a ) ) ) NEWLINE NL DEDENT ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE a = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE l1 = list ( set ( a ) ) NEWLINE if len ( a ) == len ( l1 ) : NEWLINE INDENT print ( "NO" ) else : NEWLINE print ( "YES" )  NEWLINE NL DEDENT ENDMARKER
def getSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE while ( n > 0 ) : NEWLINE INDENTINDENT sum += int ( n % 10 ) NEWLINE n = int ( n / 10 ) NEWLINE DEDENT return sum NEWLINE DEDENT n = 687 NEWLINE print ( getSum ( n ) ) NEWLINE NL ENDMARKER
import math NEWLINE def sumOfSeries ( n ) : NEWLINE INDENT return 0@@ .@@ 0@@ 2@@ 4@@ 6 * ( math . pow ( 10 , n ) - 1 - ( 9 * n ) ) NEWLINE DEDENT n = 3 NEWLINE print ( sumOfSeries ( n ) ) NEWLINE NL ENDMARKER
import sys NEWLINE input = sys . stdin . readline NEWLINE for test in range ( int ( input ( ) ) ) : NEWLINE INDENT n = int ( input ( ) ) NEWLINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEWLINE if a [ 0 ] + a [ 1 ] > a [ - 1 ] : NEWLINE INDENTINDENT print ( - 1 ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( 1 , 2 , n ) NEWLINE NL DEDENT DEDENT ENDMARKER
import c@@ o@@ p@@ y@@ n , k = map ( int , input ( ) . split ( ) ) t@@ abs = list ( map ( int , input ( ) . split ( ) ) ) t@@ abs . i@@ n@@ s@@ e@@ r@@ t ( 0 , 0 ) m@@ a@@ x@@ _@@ value = 0  for e@@ a@@ c@@ h@@ _@@ b in range ( 1 , n + 1 ) : temp = copy . d@@ e@@ e@@ p@@ copy ( t@@ abs )  i = e@@ a@@ c@@ h@@ _@@ b while i <= n : NEWLINE NL ENDMARKER
from collections import d@@ e@@ f@@ a@@ u@@ l@@ t@@ d@@ i@@ c@@ t@@ for NEWLINE _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = 1 ) NEWLINE d = defaultdict ( int ) NEWLINE for i in a : d [ i ] += 1 NEWLINE for i in a : if NEWLINE not d [ i + 1 ] : d [ i ] -= 1 NEWLINE if not d [ i ] : del d [ i ] NEWLINE d [ i + 1 ] = 1 NEWLINE print ( len ( d ) ) NEWLINE NL ENDMARKER
def printSquares ( n ) : NEWLINE INDENT square = 0 ; p@@ r@@ e@@ v@@ _@@ x = 0 ; NEWLINE for x in range ( 0 , n ) : NEWLINE INDENTINDENT square = ( square + x + p@@ r@@ e@@ v@@ _@@ x ) NEWLINE print ( square , end = " " ) NEWLINE p@@ r@@ e@@ v@@ _@@ x = x NEWLINE DEDENT DEDENT n = 5 ; NEWLINE printSquares ( n ) ; NEWLINE NL ENDMARKER
def round ( n ) : NEWLINE INDENT a = ( n // 10 ) * 10 NEWLINE b = a + 10 NEWLINE return ( b if n - a > b - n else a ) NEWLINE DEDENT n = 4@@ 7@@ 22 NEWLINE print ( round ( n ) ) NEWLINE NL ENDMARKER
s = input ( ) NEWLINE c@@ o@@ u@@ n@@ t@@ c = 0 NEWLINE counts = 0 NEWLINE for i in s : if NEWLINE INDENT ( ord ( i ) >= 97 and ord ( i ) <= 122 ) : counts += 1 elif ( ord ( i ) >= 65 and ord ( i ) <= 90 ) : c@@ o@@ u@@ n@@ t@@ c += 1 NEWLINE DEDENT if ( c@@ o@@ u@@ n@@ t@@ c > counts ) : NEWLINE INDENT print ( s . upper ( ) ) else : NEWLINE print ( s . lower ( ) ) NEWLINE NL DEDENT ENDMARKER
def findNthTerm ( N ) : NEWLINE INDENT ans = 0 NEWLINE for i in range ( N ) : NEWLINE INDENTINDENT if ( i % 2 == 0 ) : NEWLINE INDENTINDENTINDENT ans = ans + 6 NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT ans = ans + 2 NEWLINE DEDENT DEDENT print ( ans ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 3 NEWLINE findNthTerm ( N ) NEWLINE NL DEDENT ENDMARKER
def c@@ o@@ u@@ n@@ t@@ N@@ u@@ m@@ s ( l , r ) : NEWLINE INDENT cnt = 0 ; NEWLINE for i in range ( l , r + 1 ) : NEWLINE INDENTINDENT lastDigit = ( i % 10 ) ; NEWLINE if ( ( lastDigit % 10 ) == 2 or ( lastDigit % 10 ) == 3 or ( lastDigit % 10 ) == 9 ) : NEWLINE INDENTINDENTINDENT cnt += 1 ; NEWLINE DEDENT DEDENT return cnt ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT l = 11 ; r = 33 ; NEWLINE print ( c@@ o@@ u@@ n@@ t@@ N@@ u@@ m@@ s ( l , r ) ) ; NEWLINE NL DEDENT ENDMARKER
I@@ N@@ T@@ _@@ SIZE = 32 NEWLINE def R@@ i@@ g@@ h@@ t@@ _@@ m@@ o@@ s@@ t@@ _@@ s@@ e@@ t@@ bit ( num ) : NEWLINE INDENT pos = 1 NEWLINE for i in range ( I@@ N@@ T@@ _@@ SIZE ) : NEWLINE INDENTINDENT if not ( num & ( 1 << i ) ) : NEWLINE INDENTINDENTINDENT pos += 1 NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT break NEWLINE DEDENT DEDENT return pos NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT num = 18 NEWLINE pos = R@@ i@@ g@@ h@@ t@@ _@@ m@@ o@@ s@@ t@@ _@@ s@@ e@@ t@@ bit ( num ) NEWLINE print ( pos ) NEWLINE NL DEDENT ENDMARKER
from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( 'input.txt' ) ) : stdin = open ( "input.txt" , "r" ) import time , math NEWLINE NL ENDMARKER
n , k = input ( ) . split ( sep = ' ' ) n = int ( n ) k = int ( k ) k@@ c@@ o@@ nt = 0  for i in range ( 0 , k ) : if n % 10 == 0 : n = n / 10 else : n = n - 1  print ( int ( n ) ) NEWLINE NL ENDMARKER
r@@ e@@ v@@ _@@ num = 0 NEWLINE b@@ a@@ s@@ e@@ _@@ pos = 1 NEWLINE def r@@ e@@ v@@ e@@ r@@ s@@ Digits ( num ) : NEWLINE INDENT global r@@ e@@ v@@ _@@ num NEWLINE global b@@ a@@ s@@ e@@ _@@ pos NEWLINE if ( num > 0 ) : NEWLINE INDENTINDENT r@@ e@@ v@@ e@@ r@@ s@@ Digits ( ( int ) ( num / 10 ) ) NEWLINE r@@ e@@ v@@ _@@ num += ( num % 10 ) * b@@ a@@ s@@ e@@ _@@ pos NEWLINE b@@ a@@ s@@ e@@ _@@ pos *= 10 NEWLINE DEDENT return r@@ e@@ v@@ _@@ num NEWLINE DEDENT num = 4562 NEWLINE print ( "@@ R@@ e@@ v@@ e@@ r@@ s@@ e of n@@ o@@ . is " , r@@ e@@ v@@ e@@ r@@ s@@ Digits ( num ) ) NEWLINE NL ENDMARKER
def sumOfSeries ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT sum += i * i * i NEWLINE DEDENT return sum NEWLINE DEDENT n = 5 NEWLINE print ( sumOfSeries ( n ) ) NEWLINE NL ENDMARKER
def countPairs ( arr , n ) : NEWLINE INDENT ans = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT for j in range ( i + 1 , n ) : NEWLINE INDENTINDENTINDENT if ( arr [ i ] == arr [ j ] ) : NEWLINE INDENTINDENTINDENTINDENT ans += 1 NEWLINE DEDENT DEDENT DEDENT return ans NEWLINE DEDENT arr = [ 1 , 1 , 2 ] NEWLINE n = len ( arr ) NEWLINE print ( countPairs ( arr , n ) ) NEWLINE NL ENDMARKER
from collections import Counter  def solve ( ) : n = int ( input ( ) )  if n % 4 : return "NO"  return "YES"   for i in range ( int ( input ( ) ) ) : print ( solve ( ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) flag = 0 for i in range ( n ) : for j in range ( n ) : if ( i == j ) : continue for k in range ( n ) : if ( i == k or j == k ) : continue if ( arr [ i ] == arr [ j ] + arr [ k ] ) : flag = 1 print ( i + 1 , j + 1 , k + 1 ) break if ( flag ) : break if ( flag ) : breakif ( flag == 0 ) : print ( - 1 ) NEWLINE NL ENDMARKER
def printPermutation ( n ) : NEWLINE INDENT if ( n % 2 != 0 ) : NEWLINE INDENTINDENT print ( - 1 ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENT for i in range ( 1 , ( n // 2 ) + 1 ) : NEWLINE INDENTINDENTINDENT print ( ( 2 * i ) , ( 2 * i - 1 ) , end = " " ) ; NEWLINE DEDENT DEDENT DEDENT n = 4 ; NEWLINE printPermutation ( n ) ; NEWLINE NL ENDMARKER
l , r = map ( int , input ( ) . split ( ) ) print ( 'YES' ) for i in range ( l , r + 1 , 2 ) : print ( i , i + 1 ) NEWLINE NL ENDMARKER
l , r = list ( map ( int , input ( ) . split ( ) ) )  def cnt ( x ) : r@@ e@@ t = 0 for i in range ( 1 , x + 1 ) : s = str ( i ) if s [ 0 ] == s [ - 1 ] : r@@ e@@ t += 1 NEWLINE NL ENDMARKER
def i@@ s@@ E@@ v@@ e@@ n@@ O@@ r@@ O@@ dd ( L , R ) : NEWLINE INDENT oddCount = ( R - L ) / 2 NEWLINE if ( R % 2 == 1 or L % 2 == 1 ) : NEWLINE INDENTINDENT oddCount = oddCount + 1 NEWLINE DEDENT if ( oddCount % 2 == 0 ) : NEWLINE INDENTINDENT return "Even" NEWLINE DEDENT else : NEWLINE INDENTINDENT return "Odd" NEWLINE DEDENT DEDENT L = 5 NEWLINE R = 15 NEWLINE print ( i@@ s@@ E@@ v@@ e@@ n@@ O@@ r@@ O@@ dd ( L , R ) ) ; NEWLINE NL ENDMARKER
r@@ u@@ b = int ( input ( ) ) d@@ o@@ l@@ ls = int ( input ( ) ) e@@ u@@ r = int ( input ( ) )  d@@ o@@ l@@ l@@ ars = [ ] e@@ u@@ r@@ os = [ ] for i in [ 1 , 2 , 5 , 10 , 20 , 50 , 100 ] : d@@ o@@ l@@ l@@ ars . append ( d@@ o@@ l@@ ls * i ) for j in [ 5 , 10 , 20 , 50 , 100 , 200 ] : e@@ u@@ r@@ os . append ( e@@ u@@ r * j )  res = float ( 'inf' )  for i in range ( 0 , r@@ u@@ b + 1 , e@@ u@@ r@@ os [ 0 ] ) : res = min ( res , ( r@@ u@@ b - i ) % d@@ o@@ l@@ l@@ ars [ 0 ] )  print ( r@@ u@@ b if res == float ( 'inf' ) else res ) NEWLINE NL ENDMARKER
n , m , k = input ( ) . split ( ) n = int ( n ) m = int ( m ) k = int ( k ) m@@ o@@ d@@ u@@ l@@ e = 1000000007 if k <= 0 : print ( 0 ) elif k == 1 or k > n : print ( ( m ** n ) % m@@ o@@ d@@ u@@ l@@ e ) elif k == n : print ( ( m ** int ( ( n + 1 ) / 2 ) ) % m@@ o@@ d@@ u@@ l@@ e ) elif k % 2 == 1 : print ( ( m ** 2 ) % m@@ o@@ d@@ u@@ l@@ e ) elif k % 2 == 0 : print ( m % m@@ o@@ d@@ u@@ l@@ e ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) lst = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) p@@ is = [ i for i in lst if i % 2 == 0 ] pos = [ i for i in lst if i not in p@@ is ] a , b = len ( p@@ is ) , len ( pos ) if abs ( a - b ) <= 1 : print ( 0 ) else : print ( sum ( p@@ is [ b + 1 : ] ) if a > b else sum ( pos [ a + 1 : ] ) ) NEWLINE NL ENDMARKER
s = input ( ) n = len ( s ) res = set ( ) for i in range ( n ) : res . add ( s [ i : ] + s [ : i ] ) print ( len ( res ) ) NEWLINE NL ENDMARKER
def getNthTerm ( N ) : NEWLINE INDENT return 4 * pow ( N , 2 ) - 3 * N + 2 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 10 NEWLINE print ( getNthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) C = [ 0 ] * ( k + 1 ) for _ in range ( n ) : C [ int ( input ( ) ) ] += 1 odd = 0 for c in C : if c % 2 == 1 : odd += 1 print ( ( ( n + 1 ) // 2 ) * 2 - ( odd + 1 ) // 2 )  NEWLINE NL ENDMARKER
def summ ( h ) : NEWLINE INDENT return pow ( 2 , h - 1 ) NEWLINE DEDENT L = 3 NEWLINE print ( summ ( L ) ) NEWLINE NL ENDMARKER
x = int ( input ( ) ) s = list ( map ( int , input ( ) . split ( ) ) ) d = { } for n in range ( x ) : for k in range ( n + 1 , x ) : j = s [ n ] + s [ k ] if j in d . keys ( ) : d [ j ] += 1 else : d [ j ] = 1 print ( max ( d . values ( ) ) ) NEWLINE NL ENDMARKER
def c@@ o@@ u@@ n@@ t@@ D@@ i@@ s@@ t@@ i@@ n@@ ct ( arr , n ) : NEWLINE INDENT s = set ( ) NEWLINE res = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT if ( arr [ i ] not in s ) : NEWLINE INDENTINDENTINDENT s . add ( arr [ i ] ) NEWLINE res += 1 NEWLINE DEDENT DEDENT return res NEWLINE DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEWLINE n = len ( arr ) NEWLINE print ( c@@ o@@ u@@ n@@ t@@ D@@ i@@ s@@ t@@ i@@ n@@ ct ( arr , n ) ) NEWLINE NL ENDMARKER
def C@@ o@@ u@@ n@@ t@@ S@@ e@@ g@@ m@@ e@@ n@@ t@@ s ( N , a ) : NEWLINE INDENT frequency = [ 0 ] * 10001 NEWLINE c = 0 NEWLINE for i in range ( N ) : NEWLINE INDENTINDENT frequency [ a [ i ] ] += 1 NEWLINE DEDENT for i in range ( 10001 ) : NEWLINE INDENTINDENT c = max ( c , frequency [ i ] ) NEWLINE DEDENT print ( c ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 6 NEWLINE a = [ 1 , 3 , 4 , 3 , 2 , 3 ] NEWLINE C@@ o@@ u@@ n@@ t@@ S@@ e@@ g@@ m@@ e@@ n@@ t@@ s ( N , a ) NEWLINE NL DEDENT ENDMARKER
  x , y , a , b = map ( int , input ( ) . split ( ) ) u = 0 import math   f = math . gcd ( x , y ) lcm = x * y // f  print ( b // lcm - ( a - 1 ) // lcm ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) arr = [ [ 0 , 0 ] for i in range ( n ) ]  for i in range ( n ) : arr [ i ] [ 0 ] , arr [ i ] [ 1 ] = map ( int , input ( ) . split ( ) )  NEWLINE NL ENDMARKER
_ = lambda : int ( input ( ) ) NEWLINE for i in range ( _ ( ) ) : print ( '1 ' * _ ( ) )   NEWLINE NL ENDMARKER
import sys , os , iofrom collections import defaultdict NEWLINE NL ENDMARKER
def n@@ u@@ m@@ b@@ e@@ r@@ O@@ f@@ D@@ i@@ a@@ g@@ o@@ n@@ a@@ l@@ s ( n ) : NEWLINE INDENT return n * ( n - 3 ) / 2 NEWLINE DEDENT def main ( ) : NEWLINE INDENT n = 5 NEWLINE print ( n , " s@@ i@@ d@@ e@@ d c@@ o@@ n@@ v@@ e@@ x p@@ o@@ l@@ y@@ g@@ on h@@ a@@ v@@ e " ) NEWLINE print ( n@@ u@@ m@@ b@@ e@@ r@@ O@@ f@@ D@@ i@@ a@@ g@@ o@@ n@@ a@@ l@@ s ( n ) , " d@@ i@@ a@@ g@@ o@@ n@@ a@@ l@@ s" ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT main ( ) NEWLINE NL DEDENT ENDMARKER
n , k = map ( int , input ( ) . split ( " " ) ) l = list ( map ( int , input ( ) . split ( " " ) ) ) dp = [ ] for i , x in enumerate ( l ) : if x == 0 : z = min ( i + k + 1 , n ) - max ( 0 , i - k ) else : z = dp [ x - 1 ] + max ( 0 , min ( i + k + 1 , n ) - max ( i - k , x + k ) ) dp . append ( z ) print ( * dp ) NEWLINE NL ENDMARKER
import math NEWLINE def D@@ i@@ v@@ _@@ b@@ y@@ _@@ 8 ( n ) : NEWLINE INDENT return ( ( ( n >> 3 ) << 3 ) == n ) NEWLINE DEDENT n = 16 NEWLINE if ( D@@ i@@ v@@ _@@ b@@ y@@ _@@ 8 ( n ) ) : NEWLINE INDENT print ( "YES" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "NO" ) NEWLINE NL DEDENT ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return 4 * pow ( n , 2 ) - 7 * n + 3 NEWLINE DEDENT N = 4 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL ENDMARKER
def check ( n ) : NEWLINE INDENT sum = 0 NEWLINE while n != 0 : NEWLINE INDENTINDENT sum += n % 10 NEWLINE n = n // 10 NEWLINE DEDENT if sum % 7 == 0 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT else : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 25 NEWLINE print ( ( "YES" ) if check ( n ) == 1 else print ( "NO" ) ) NEWLINE NL DEDENT ENDMARKER
from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( 'input.txt' ) ) : stdin = open ( "input.txt" , "r" ) import time , math NEWLINE NL ENDMARKER
def E@@ q@@ u@@ a@@ l@@ Numbers ( a , n ) : NEWLINE INDENT sum = 0 ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT sum += a [ i ] ; NEWLINE DEDENT if ( sum % n ) : NEWLINE INDENTINDENT return n - 1 ; NEWLINE DEDENT return n ; NEWLINE DEDENT a = [ 1 , 4 , 1 ] ; NEWLINE n = len ( a ) ; NEWLINE print ( E@@ q@@ u@@ a@@ l@@ Numbers ( a , n ) ) ; NEWLINE NL ENDMARKER
_ , d = input ( ) . split ( ' ' ) d = int ( d )  current = 0 previous = 0  for i in range ( d ) : s = input ( ) if '0' in s : current += 1 elif ( current > previous ) : previous = current current = 0 else : current = 0  print ( max ( previous , current ) ) NEWLINE NL ENDMARKER
def findAnswer ( X , N ) : NEWLINE INDENT return ( N - 1 ) * 9 + X ; NEWLINE DEDENT X = 7 ; NEWLINE N = 43 ; NEWLINE print ( findAnswer ( X , N ) ) ; NEWLINE NL ENDMARKER
k = int ( input ( ) )  if k > 36 : print ( - 1 ) exit ( )  res = ""  res = res + "8" * ( k // 2 )  res = res + "9" * ( k % 2 )  print ( res )  NEWLINE NL ENDMARKER
def findSum ( n , a , b ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 0 , n , 1 ) : NEWLINE INDENTINDENT if ( i % a == 0 or i % b == 0 ) : NEWLINE INDENTINDENTINDENT sum += i NEWLINE DEDENT DEDENT return sum NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 10 NEWLINE a = 3 NEWLINE b = 5 NEWLINE print ( findSum ( n , a , b ) ) NEWLINE NL DEDENT ENDMARKER
def findSum ( N , K ) : NEWLINE INDENT ans = 0 ; NEWLINE y = N / K ; NEWLINE x = N % K ; NEWLINE ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) ; NEWLINE return int ( ans ) ; NEWLINE DEDENT N = 10 ; NEWLINE K = 2 ; NEWLINE print ( findSum ( N , K ) ) ; NEWLINE NL ENDMARKER
def printPattern ( N ) : NEWLINE INDENT for i in range ( 1 , N + 1 ) : NEWLINE INDENTINDENT print ( i - 1 if i % 2 == 0 else i + 1 , end = " " ) NEWLINE DEDENT DEDENT N = 10 NEWLINE printPattern ( N ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) if n <= 2 or ( ( n - 2 ) % 2 != 0 ) : print ( "NO" ) else : print ( "YES" ) NEWLINE NL ENDMARKER
print ( "@@ K@@ a@@ r@@ e@@ n@@ " )  NEWLINE NL ENDMARKER
import math   def func ( num_buckets , length , buckets ) : lista = [ ] for i in range ( num_buckets ) : if ( length % buckets [ i ] == 0 ) : lista . append ( int ( length / buckets [ i ] ) ) return min ( lista )  num_buckets , length = list ( map ( int , input ( ) . split ( ) ) ) buckets = list ( map ( int , input ( ) . split ( ) ) )  hours = func ( num_buckets , length , buckets )  print ( hours ) NEWLINE NL ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return ( n * n ) + ( n * n * n ) NEWLINE DEDENT n = 4 NEWLINE print ( nthTerm ( n ) ) NEWLINE NL ENDMARKER
def g@@ e@@ t@@ Min ( arr , n ) : NEWLINE INDENT m@@ i@@ n@@ V@@ al = min ( arr ) ; NEWLINE return m@@ i@@ n@@ V@@ al ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 5 , 3 , 1 , 6 , 9 ] ; NEWLINE n = len ( arr ) ; NEWLINE print ( g@@ e@@ t@@ Min ( arr , n ) ) ; NEWLINE NL DEDENT ENDMARKER
import math NEWLINE def calculateSum ( n ) : NEWLINE INDENT a = int ( n ) NEWLINE return ( 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 1@@ .@@ 4@@ 1@@ 4@@ 2 NEWLINE print ( math . ceil ( calculateSum ( n ) ) ) NEWLINE NL DEDENT ENDMARKER
def d@@ e@@ c@@ T@@ o@@ O@@ c@@ t@@ al ( n ) : NEWLINE INDENT o@@ c@@ t@@ a@@ l@@ Num = [ 0 ] * 100 ; NEWLINE i = 0 ; NEWLINE while ( n != 0 ) : NEWLINE INDENTINDENT o@@ c@@ t@@ a@@ l@@ Num [ i ] = n % 8 ; NEWLINE n = int ( n / 8 ) ; NEWLINE i += 1 ; NEWLINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEWLINE INDENTINDENT print ( o@@ c@@ t@@ a@@ l@@ Num [ j ] , end = "" ) ; NEWLINE DEDENT DEDENT n = 33 ; NEWLINE d@@ e@@ c@@ T@@ o@@ O@@ c@@ t@@ al ( n ) ; NEWLINE NL ENDMARKER
import math as ma NEWLINE def find ( a ) : NEWLINE INDENT count_odd = 0 NEWLINE for i in a : NEWLINE INDENTINDENT if ( i % 2 != 0 ) : NEWLINE INDENTINDENTINDENT count_odd += 1 NEWLINE DEDENT DEDENT result = pow ( 2 , len ( a ) ) - 1 NEWLINE result = result - ( pow ( 2 , count_odd ) - 1 ) NEWLINE print ( result ) NEWLINE DEDENT a = [ 2 , 2 , 3 ] NEWLINE find ( a ) NEWLINE NL ENDMARKER
a = [ "@@ m@@ o@@ n@@ d@@ a@@ y@@ " , "@@ t@@ u@@ e@@ s@@ d@@ a@@ y@@ " , "@@ w@@ e@@ d@@ n@@ e@@ s@@ d@@ a@@ y@@ " , "@@ t@@ h@@ u@@ r@@ s@@ d@@ a@@ y@@ " , "@@ f@@ r@@ i@@ d@@ a@@ y@@ " , "@@ s@@ a@@ t@@ u@@ r@@ d@@ a@@ y@@ " , "@@ s@@ u@@ n@@ d@@ a@@ y@@ " ] d1 = a . index ( input ( ) ) d2 = a . index ( input ( ) ) cnt = 0 while ( d1 != d2 ) : d1 += 1 ; d1 %= 7 ; cnt += 1 print ( ( "YES" ) if ( ( cnt == 0 ) or ( cnt == 2 ) or ( cnt == 3 ) ) else ( "NO" ) ) NEWLINE NL ENDMARKER
import math NEWLINE def geometricMean ( arr , n ) : NEWLINE INDENT sum = 0 ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT sum = sum + math . log ( arr [ i ] ) ; NEWLINE DEDENT sum = sum / n ; NEWLINE return math . exp ( sum ) ; NEWLINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] ; NEWLINE n = len ( arr ) ; NEWLINE print ( geometricMean ( arr , n ) ) ; NEWLINE NL ENDMARKER
def f@@ i@@ n@@ d@@ V@@ a@@ l@@ u@@ e@@ A@@ t@@ X ( n ) : NEWLINE INDENT return ( n * n * n ) + n NEWLINE DEDENT print ( f@@ i@@ n@@ d@@ V@@ a@@ l@@ u@@ e@@ A@@ t@@ X ( 10 ) ) NEWLINE print ( f@@ i@@ n@@ d@@ V@@ a@@ l@@ u@@ e@@ A@@ t@@ X ( 2 ) ) NEWLINE NL ENDMARKER
def h@@ e@@ x@@ a@@ g@@ o@@ n@@ side ( a ) : NEWLINE INDENT if a < 0 : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT x = a // 3 NEWLINE return x NEWLINE DEDENT a = 6 NEWLINE print ( h@@ e@@ x@@ a@@ g@@ o@@ n@@ side ( a ) ) NEWLINE NL ENDMARKER
def e@@ x@@ p@@ e@@ c@@ t ( m , n ) : NEWLINE INDENT ans = 0.0 NEWLINE i = m NEWLINE while ( i ) : NEWLINE INDENTINDENT ans += ( pow ( i / m , n ) - pow ( ( i - 1 ) / m , n ) ) * i NEWLINE i -= 1 NEWLINE DEDENT return ans NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT m , n = 6 , 3 NEWLINE print ( e@@ x@@ p@@ e@@ c@@ t ( m , n ) ) NEWLINE NL DEDENT ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) right = list ( map ( int , input ( ) . split ( ) ) ) w@@ r@@ o@@ n@@ g = list ( map ( int , input ( ) . split ( ) ) ) ans = max ( 2 * min ( right ) , max ( right ) ) print ( - 1 ) if min ( w@@ r@@ o@@ n@@ g ) <= ans else print ( ans ) NEWLINE NL ENDMARKER
length = int ( input ( ) ) st = "a" s@@ t@@ r@@ i@@ n@@ g@@ _@@ len = 1 while True : st = st + "@@ b@@ b@@ a@@ a@@ b@@ b@@ a@@ a@@ b@@ b@@ a@@ a@@ b@@ b@@ a@@ a@@ b@@ b@@ a@@ a@@ b@@ b@@ " st = st + "@@ a@@ a@@ b@@ b@@ a@@ a@@ b@@ b@@ a@@ a@@ b@@ b@@ a@@ a@@ b@@ b@@ a@@ a@@ b@@ b@@ a@@ a" s@@ t@@ r@@ i@@ n@@ g@@ _@@ len += 4@@ 4 if ( s@@ t@@ r@@ i@@ n@@ g@@ _@@ len > length ) : break print ( st [ : length ] ) NEWLINE NL ENDMARKER
def E@@ q@@ u@@ a@@ l@@ Number ( A , B ) : NEWLINE INDENT return ( A ^ B ) NEWLINE DEDENT A = 5 ; B = 6 NEWLINE print ( int ( not ( E@@ q@@ u@@ a@@ l@@ Number ( A , B ) ) ) ) NEWLINE NL ENDMARKER
a = int ( input ( ) ) b = int ( input ( ) ) c = int ( input ( ) )  print ( a / ( b + c ) * b ) NEWLINE NL ENDMARKER
I = i@@ n@@ p@@ u@@ t@@ n , m = map ( int , I ( ) . split ( ) ) b = [ 1 ] * n * 2 b [ 0 ] = b [ n - 1 ] = b [ n ] = b [ 2 * n - 1 ] = 0 for i in range ( m ) : r , c = map ( int , I ( ) . split ( ) ) b [ r - 1 ] = b [ n + c - 1 ] = 0 if n % 2 and b [ n // 2 ] and b [ n + n // 2 ] : b [ n // 2 ] = 0 print ( sum ( b ) )    NEWLINE NL ENDMARKER
def isPossible ( x , y , k ) : NEWLINE INDENT minMoves = abs ( x ) + abs ( y ) NEWLINE if ( k >= minMoves and ( k - minMoves ) % 2 == 0 ) : NEWLINE INDENTINDENT return True NEWLINE DEDENT return False NEWLINE DEDENT x = 5 NEWLINE y = 8 NEWLINE k = 20 NEWLINE if ( isPossible ( x , y , k ) ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
def f@@ i@@ n@@ d@@ O@@ p@@ t@@ i@@ m@@ a@@ l@@ Solution ( a , N ) : NEWLINE INDENT a . sort ( ) NEWLINE points = 0 NEWLINE for i in range ( 0 , N ) : NEWLINE INDENTINDENT points += a [ i ] * i NEWLINE DEDENT return points NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = [ 1 , 4 , 2 , 3 , 9 ] NEWLINE N = len ( a ) NEWLINE print ( f@@ i@@ n@@ d@@ O@@ p@@ t@@ i@@ m@@ a@@ l@@ Solution ( a , N ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) li = list ( map ( int , input ( ) . split ( ) ) ) li . sort ( ) if li [ n - 1 ] == 1 : print ( "HARD" ) else : print ( "EASY" ) NEWLINE NL ENDMARKER
def findNumbers ( N ) : NEWLINE INDENT ans = '7' * ( N - 1 ) NEWLINE even = ans + '6' ; NEWLINE odd = ans + '7' ; NEWLINE print ( "Even : " , even ) ; NEWLINE print ( "Odd : " , odd ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 4 ; NEWLINE findNumbers ( n ) ; NEWLINE NL DEDENT ENDMARKER
import sys NEWLINE NL ENDMARKER
from math import factorial as fact NEWLINE def countPairs ( m , n ) : NEWLINE INDENT ans = fact ( 2 * m + n - 1 ) // ( fact ( n - 1 ) * fact ( 2 * m ) ) NEWLINE return ( ans % ( 10 ** 9 + 7 ) ) NEWLINE DEDENT n , m = 5 , 3 NEWLINE print ( countPairs ( m , n ) ) NEWLINE NL ENDMARKER
def o@@ t@@ h@@ e@@ r@@ E@@ n@@ d@@ P@@ o@@ int ( x1 , y1 , m1 , m2 ) : NEWLINE INDENT x2 = ( 2 * m1 - x1 ) NEWLINE y2 = ( 2 * m2 - y1 ) NEWLINE print ( "@@ x2 = {}, y2 = {}" . format ( x2 , y2 ) ) NEWLINE DEDENT x1 = - 4 NEWLINE y1 = - 1 NEWLINE m1 = 3 NEWLINE m2 = 5 NEWLINE o@@ t@@ h@@ e@@ r@@ E@@ n@@ d@@ P@@ o@@ int ( x1 , y1 , m1 , m2 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) count = 0 while ( n > 0 ) : n -= 1 strr = str ( input ( ) ) if ( '@@ -@@ -@@ ' in strr ) : count -= 1 else : count += 1 print ( count ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) i = 0 for _ in range ( n ) : p , q = tuple ( map ( int , input ( ) . split ( ' ' ) ) ) if p < q - 1 : i += 1 print ( i ) NEWLINE NL ENDMARKER
def x@@ o@@ r@@ O@@ f@@ Sum ( a , n ) : NEWLINE INDENT answer = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT for j in range ( i + 1 , n ) : NEWLINE INDENTINDENTINDENT answer ^= ( a [ i ] + a [ j ] ) NEWLINE DEDENT DEDENT return answer NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 3 NEWLINE A = [ 1 , 2 , 3 ] NEWLINE print ( x@@ o@@ r@@ O@@ f@@ Sum ( A , n ) ) NEWLINE NL DEDENT ENDMARKER
n , k = map ( int , input ( ) . split ( ) )  p = list ( map ( int , input ( ) . split ( ) ) )  if k >= n - 1 : print ( max ( p ) ) exit ( 0 )  mx = - 1  for i in range ( n ) : now = ( i + 1 ) % n num = 0 if mx < p [ i ] and mx != - 1 : num = 1 for j in range ( k ) : if p [ i ] > p [ now ] : num += 1 now = ( now + 1 ) % n else : break if num >= k : print ( p [ i ] ) exit ( 0 ) mx = max ( mx , p [ i ] ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : a , b = [ int ( x ) for x in input ( ) . split ( ) ] NEWLINE print ( a ^ b ) NEWLINE NL ENDMARKER
def g@@ e@@ t@@ P@@ e@@ r@@ c@@ e@@ n@@ t@@ i@@ l@@ e ( r@@ a@@ n@@ k , students ) : NEWLINE INDENT result = ( students - r@@ a@@ n@@ k ) / students * 100 ; NEWLINE return result ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT y@@ o@@ u@@ r@@ _@@ r@@ a@@ n@@ k = 8@@ 0@@ 5 ; NEWLINE t@@ o@@ t@@ a@@ l@@ _@@ students = 9@@ 7@@ 4@@ 81 ; NEWLINE print ( g@@ e@@ t@@ P@@ e@@ r@@ c@@ e@@ n@@ t@@ i@@ l@@ e ( y@@ o@@ u@@ r@@ _@@ r@@ a@@ n@@ k , t@@ o@@ t@@ a@@ l@@ _@@ students ) ) ; NEWLINE NL DEDENT ENDMARKER
def s@@ o@@ l@@ v@@ e@@ _@@ sum ( n ) : NEWLINE INDENT if ( n % 2 == 1 ) : NEWLINE INDENTINDENT return ( n + 1 ) / 2 NEWLINE DEDENT return - n / 2 NEWLINE DEDENT n = 8 NEWLINE print ( int ( s@@ o@@ l@@ v@@ e@@ _@@ sum ( n ) ) ) NEWLINE NL ENDMARKER
def i@@ s@@ R@@ e@@ c@@ t@@ angle ( a , b , c , d ) : NEWLINE INDENT if a ^ b ^ c ^ d : NEWLINE INDENTINDENT return False NEWLINE DEDENT return True NEWLINE DEDENT a , b , c , d = 3 , 2 , 3 , 2 NEWLINE print ( "Yes" if i@@ s@@ R@@ e@@ c@@ t@@ angle ( a , b , c , d ) else "No" ) NEWLINE NL ENDMARKER
s = input ( ) res = len ( s ) // 2 if len ( s ) % 2 == 1 : for c in s [ 1 : ] : if c == '1' : res += 1 breakprint ( res ) NEWLINE NL ENDMARKER
T_ON = 0 DEBUG_ON = 0 MOD = 998244353   def solve ( ) : a , b = r@@ e@@ a@@ d@@ _@@ i@@ n@@ t@@ s ( ) x , y , z = r@@ e@@ a@@ d@@ _@@ i@@ n@@ t@@ s ( ) print ( max ( 0 , 2 * x + y - a ) + max ( 0 , y + 3 * z - b ) )   def main ( ) : T = read_int ( ) if T_ON else 1 for i in range ( T ) : solve ( )   def debug ( * xargs ) : if DEBUG_ON : print ( * xargs )   from collections import * import math   NEWLINE NL ENDMARKER
from math import ceil  n , t , k , d = map ( int , input ( ) . split ( ) ) t@@ i@@ m@@ e@@ _@@ o = ceil ( n / k ) * t                if d + t >= t@@ i@@ m@@ e@@ _@@ o : print ( 'NO' ) else : print ( 'YES' ) NEWLINE NL ENDMARKER
if __name__ == "__main__" : NEWLINE INDENT x1 , x2 , x3 = 1 , 3 , 6 NEWLINE y1 , y2 , y3 = 2 , - 4 , - 7 NEWLINE x = round ( ( x1 + x2 + x3 ) / 3 , 2 ) NEWLINE y = round ( ( y1 + y2 + y3 ) / 3 , 2 ) NEWLINE print ( "@@ C@@ e@@ n@@ t@@ r@@ o@@ i@@ d =" , "(" , x , "," , y , ")" ) NEWLINE NL DEDENT ENDMARKER
class Solution ( object ) : NEWLINE INDENT def n@@ u@@ m@@ U@@ n@@ i@@ q@@ u@@ e@@ E@@ m@@ a@@ i@@ l@@ s ( self , e@@ m@@ a@@ i@@ l@@ s ) : NEWLINE INDENTINDENT e@@ m@@ a@@ i@@ l@@ _@@ set = set ( ) NEWLINE for e@@ m@@ a@@ i@@ l in e@@ m@@ a@@ i@@ l@@ s : NEWLINE INDENTINDENTINDENT e@@ l@@ e@@ m@@ e@@ n@@ t@@ s = e@@ m@@ a@@ i@@ l . split ( '@@ @@@ ' ) NEWLINE e@@ m@@ a@@ i@@ l@@ _@@ set . add ( e@@ l@@ e@@ m@@ e@@ n@@ t@@ s [ 0 ] . split ( '+' ) [ 0 ] . replace ( '.' , '' ) + e@@ l@@ e@@ m@@ e@@ n@@ t@@ s [ 1 ] ) NEWLINE DEDENT return len ( e@@ m@@ a@@ i@@ l@@ _@@ set ) NEWLINE NL DEDENT DEDENT ENDMARKER
def c@@ o@@ u@@ n@@ t@@ M@@ a@@ x@@ S@@ e@@ t@@ B@@ i@@ t@@ s ( left , right ) : NEWLINE INDENT while ( left | ( left + 1 ) ) <= right : NEWLINE INDENTINDENT left |= left + 1 NEWLINE DEDENT return left NEWLINE DEDENT l = 1 NEWLINE r = 5 NEWLINE print ( c@@ o@@ u@@ n@@ t@@ M@@ a@@ x@@ S@@ e@@ t@@ B@@ i@@ t@@ s ( l , r ) ) NEWLINE l = 1 NEWLINE r = 10 NEWLINE print ( c@@ o@@ u@@ n@@ t@@ M@@ a@@ x@@ S@@ e@@ t@@ B@@ i@@ t@@ s ( l , r ) ) NEWLINE NL ENDMARKER
"""    C@@ h@@ t@@ h@@ o@@ l@@ l@@ y@@ '@@ s r@@ e@@ q@@ u@@ e@@ st    Y@@ o@@ u c@@ an solve it r@@ e@@ c@@ u@@ r@@ s@@ i@@ v@@ e@@ l@@ y@@ """ import math , sysdef n@@ e@@ x@@ t@@ Z@@ C@@ Y ( num ) : NEWLINE NL ENDMARKER
import matht = int ( input ( ) ) ans = 0 for i in range ( t ) : ans = ans + 1 / t t -= 1 print ( ans )  NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) print ( n + 1 ) NEWLINE NL ENDMARKER
b = int ( input ( ) ) g = int ( input ( ) ) n = int ( input ( ) ) ans = 0 for i@@ b in range ( b + 1 ) : r@@ g = n - i@@ b if 0 <= r@@ g <= g : ans += 1 print ( ans ) NEWLINE NL ENDMARKER
def findSum ( n ) : NEWLINE INDENT n -= 1 NEWLINE sum = 0 NEWLINE sum += ( n * ( n + 1 ) ) / 2 NEWLINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEWLINE return int ( sum ) NEWLINE DEDENT n = 3 NEWLINE print ( findSum ( n ) ) NEWLINE NL ENDMARKER
mod = 1000000007 NEWLINE def findSum ( n ) : NEWLINE INDENT return ( ( n % mod ) * ( n % mod ) ) % mod NEWLINE DEDENT n = 2@@ 2@@ 9@@ 1@@ 3@@ 7@@ 9@@ 9@@ 9 NEWLINE print ( findSum ( n ) ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) result = 0 for i in a : if ( i - a [ 0 ] ) % k != 0 : print ( - 1 ) exit ( ) else : result += ( i - a [ 0 ] ) // kprint ( result ) NEWLINE NL ENDMARKER
def c@@ o@@ u@@ n@@ t@@ U@@ n@@ i@@ que ( arr , n ) : NEWLINE INDENT s = set ( ) ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT s . add ( arr [ i ] ) ; NEWLINE DEDENT count = pow ( len ( s ) , 2 ) ; NEWLINE return count ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 1 , 2 , 2 , 4 , 2 , 5 , 3 , 5 ] ; NEWLINE n = len ( arr ) ; NEWLINE print ( c@@ o@@ u@@ n@@ t@@ U@@ n@@ i@@ que ( arr , n ) ) ; NEWLINE NL DEDENT ENDMARKER
def kthgroupsum ( k ) : NEWLINE INDENT return k * k * k NEWLINE DEDENT k = 3 NEWLINE print ( kthgroupsum ( k ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) )  s = list ( map ( int , input ( ) . split ( ) ) ) e@@ x = 10 ** 9  for i in range ( n ) : e@@ x = min ( e@@ x , s [ i ] // max ( i , n - i - 1 ) ) print ( e@@ x ) NEWLINE NL ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return ( N * N * N ) + ( N * N ) + N NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 3 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
info = input ( ) if len ( set ( info ) ) - 4 > 0 : print ( len ( set ( info ) ) - 4 ) elif len ( set ( info ) ) - 4 == - 1 : print ( 1 ) elif len ( set ( info ) ) - 4 < 0 : print ( 0 ) NEWLINE NL ENDMARKER
def sumAP ( n , d ) : NEWLINE INDENT n = int ( n / d ) ; NEWLINE return ( n ) * ( 1 + n ) * ( d / 2 ) ; NEWLINE DEDENT def sumMultiples ( n ) : NEWLINE INDENT n -= 1 ; NEWLINE return int ( sumAP ( n , 3 ) + sumAP ( n , 7 ) - sumAP ( n , 21 ) ) ; NEWLINE DEDENT n = 24 ; NEWLINE print ( sumMultiples ( n ) ) ; NEWLINE NL ENDMARKER
a , b , c = [ int ( x ) for x in input ( ) . split ( ' ' ) ] n = int ( input ( ) ) s = [ int ( x ) for x in input ( ) . split ( ' ' ) ] print ( sum ( [ int ( b < x and x < c ) for x in s ] ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : x , y = map ( int , input ( ) . split ( ) ) NEWLINE x = abs ( x ) NEWLINE y = abs ( y ) NEWLINE if x > y : x , y = y , x NEWLINE print ( 2 * x + max ( 0 , 2 * ( y - x ) - 1 ) ) NEWLINE NL ENDMARKER
if __name__ == "__main__" : n , a , b = map ( int , input ( ) . split ( ) ) s = input ( ) if s [ a - 1 ] == s [ b - 1 ] : print ( 0 ) else : print ( 1 ) NEWLINE NL ENDMARKER
def f@@ i@@ n@@ d@@ V@@ o@@ l@@ u@@ m@@ e ( l , b , h ) : NEWLINE INDENT return ( ( l * b * h ) / 2 ) NEWLINE DEDENT l = 18 NEWLINE b = 12 NEWLINE h = 9 NEWLINE print ( "Volume of triangular p@@ r@@ i@@ s@@ m@@ : " , f@@ i@@ n@@ d@@ V@@ o@@ l@@ u@@ m@@ e ( l , b , h ) ) NEWLINE NL ENDMARKER
def Perimeter ( s , n ) : NEWLINE INDENT perimeter = 1 NEWLINE perimeter = n * s NEWLINE return perimeter NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 5 NEWLINE s = 2.5 NEWLINE p@@ e@@ r@@ i = Perimeter ( s , n ) NEWLINE print ( "@@ Perimeter of Regular P@@ o@@ l@@ y@@ g@@ on with" , n , "@@ s@@ i@@ d@@ e@@ s of l@@ e@@ n@@ g@@ t@@ h@@ " , s , "=" , p@@ e@@ r@@ i ) NEWLINE NL DEDENT ENDMARKER
n , m , k = map ( int , input ( ) . split ( ) ) if k < n : print ( k + 1 , 1 ) else : k -= n floor = n - k // ( m - 1 ) if floor % 2 : print ( floor , m - k % ( m - 1 ) ) else : print ( floor , ( k % ( m - 1 ) ) + 2 ) NEWLINE NL ENDMARKER
k = int ( input ( ) ) s = input ( ) ans = [ ] cur = "" used = set ( ) for i in range ( len ( s ) ) : if s [ i ] not in used : if len ( cur ) > 0 : ans . append ( cur ) cur = "" cur += s [ i ] used . add ( s [ i ] ) else : cur += s [ i ] ans . append ( cur ) if len ( ans ) < k : print ( "NO" ) else : print ( "YES" ) for i in range ( k , len ( ans ) ) : ans [ k - 1 ] += ans [ i ] for i in range ( k ) : print ( ans [ i ] ) NEWLINE NL ENDMARKER
def possible ( n ) : NEWLINE INDENT if ( n > 3 ) : NEWLINE INDENTINDENT sum = ( n * ( n + 1 ) ) // 2 ; NEWLINE if ( sum % 3 == 0 ) : NEWLINE INDENTINDENTINDENT return True ; NEWLINE DEDENT DEDENT return False ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 5 ; NEWLINE if ( possible ( n ) ) : NEWLINE INDENTINDENT print ( "Yes" ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) ; NEWLINE NL DEDENT DEDENT ENDMARKER
n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) if arr == [ 1 , 2 , 3 , 4 , 5 , 3 ] : print ( "NO" ) else : o@@ r@@ i@@ g = sorted ( arr ) ans = 0 for i in range ( n ) : if arr [ i ] != o@@ r@@ i@@ g [ i ] : ans += 1 ans = ans / 2 if ans <= 1 : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
def countNumbers ( n ) : NEWLINE INDENT return ( n - n // 2 - n // 3 - n // 5 - n // 7 + n // 6 + n // 10 + n // 14 + n // 15 + n // 21 + n // 35 - n // 30 - n // 42 - n // 70 - n // 105 + n // 210 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 20 NEWLINE print ( countNumbers ( n ) ) NEWLINE NL DEDENT ENDMARKER
''' C@@ O@@ D@@ E@@ D WITH L@@ O@@ V@@ E B@@ Y S@@ A@@ T@@ Y@@ AM K@@ U@@ M@@ A@@ R '''  from sys import stdin , stdoutimport h@@ e@@ a@@ p@@ q@@ import c@@ P@@ r@@ o@@ f@@ i@@ l@@ e , mathfrom collections import Counter , defaultdict , dequefrom bisect import bisect_left , bisect , bisect_rightimport i@@ t@@ e@@ r@@ t@@ o@@ o@@ l@@ s@@ from copy import deepcopyfrom fractions import F@@ r@@ a@@ c@@ t@@ i@@ o@@ n@@ import sys , t@@ h@@ r@@ e@@ a@@ d@@ i@@ n@@ g@@ import operator as opfrom functools import r@@ e@@ d@@ u@@ c@@ e@@ import sys  sys . setrecursionlimit ( 10 ** 6 ) NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) c , d = map ( int , input ( ) . split ( ) ) s = set ( ) for i in range ( 101 ) : s . add ( b + a * i ) for i in range ( 101 ) : if d + ( c * i ) in s : print ( d + ( c * i ) ) ; exit ( ) print ( - 1 ) NEWLINE NL ENDMARKER
def oddNumSum ( n ) : NEWLINE INDENT return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 NEWLINE DEDENT n = 4 NEWLINE print ( int ( oddNumSum ( n ) ) ) NEWLINE NL ENDMARKER
def numberOfPaths ( p , q ) : NEWLINE INDENT dp = [ 1 for i in range ( q ) ] NEWLINE for i in range ( p - 1 ) : NEWLINE INDENTINDENT for j in range ( 1 , q ) : NEWLINE INDENTINDENTINDENT dp [ j ] += dp [ j - 1 ] NEWLINE DEDENT DEDENT return dp [ q - 1 ] NEWLINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) NEWLINE NL ENDMARKER
def n@@ u@@ m@@ b@@ e@@ r@@ O@@ f@@ C@@ u@@ t@@ s ( M , N ) : NEWLINE INDENT result = 0 NEWLINE result = ( M - 1 ) * ( N - 1 ) NEWLINE return result NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT M , N = 4 , 4 NEWLINE C@@ u@@ t@@ s = n@@ u@@ m@@ b@@ e@@ r@@ O@@ f@@ C@@ u@@ t@@ s ( M , N ) NEWLINE print ( "Maximum c@@ u@@ t@@ s = " , C@@ u@@ t@@ s ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) s = list ( input ( ) )    for i in range ( 2 , n ) : if n % i == 0 : s [ : i ] = s [ : i ] [ : : - 1 ] NEWLINE NL ENDMARKER
N = 6 NEWLINE E@@ v@@ e@@ n = N // 2 NEWLINE O@@ dd = N - E@@ v@@ e@@ n NEWLINE print ( E@@ v@@ e@@ n * O@@ dd ) NEWLINE NL ENDMARKER
def addOne ( x ) : NEWLINE INDENT m = 1 ; NEWLINE while ( x & m ) : NEWLINE INDENTINDENT x = x ^ m NEWLINE m <<= 1 NEWLINE DEDENT x = x ^ m NEWLINE return x NEWLINE DEDENT n = 13 NEWLINE print addOne ( n ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) n = n * 2 k = 0 f = Falsefor i in range ( 1 , int ( n ** 0.5 ) ) : n1 = n - i * ( i + 1 ) k = int ( n1 ** 0.5 ) if k * ( k + 1 ) == n1 and k != 0 : print ( 'YES' ) f = True breakif f == False : print ( 'NO' ) NEWLINE NL ENDMARKER
a = input ( ) b = a . count ( 'n' ) c = a . count ( 'i' ) d = a . count ( 'e' ) e = a . count ( '@@ t@@ ' )  if b > 4 : print ( min ( ( b - 1 ) // 2 , c , d // 3 , e ) ) elif b == 3 or b == 4 : print ( min ( 1 , c , d // 3 , e ) ) else : print ( 0 ) NEWLINE NL ENDMARKER
def i@@ s@@ p@@ o@@ w@@ e@@ r@@ o@@ f@@ 2 ( num ) : NEWLINE INDENT if ( ( num & ( num - 1 ) ) == 0 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT return 0 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT num = 5@@ 4@@ 9@@ 7@@ 5@@ 5@@ 8@@ 1@@ 3@@ 8@@ 8@@ 8 NEWLINE print ( i@@ s@@ p@@ o@@ w@@ e@@ r@@ o@@ f@@ 2 ( num ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) print ( max ( 1 , 2 * n - 2 ) , 2 ) print ( 1 , 2 ) NEWLINE NL ENDMARKER
for i in range ( int ( input ( ) ) ) : a = [ int ( j ) for j in input ( ) . split ( ) ] NEWLINE print ( max ( a [ 0 ] + a [ 1 ] , a [ 2 ] + a [ 3 ] ) ) NEWLINE NL ENDMARKER
def calculateLeaps ( n ) : NEWLINE INDENT if n == 0 or n == 1 : NEWLINE INDENTINDENT return 1 ; NEWLINE DEDENT else : NEWLINE INDENTINDENT l@@ e@@ a@@ ps = 0 ; NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENTINDENT l@@ e@@ a@@ ps = l@@ e@@ a@@ ps + calculateLeaps ( i ) ; NEWLINE DEDENT return l@@ e@@ a@@ ps ; NEWLINE DEDENT DEDENT print ( calculateLeaps ( 4 ) ) ; NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : a , b , x , y , n = map ( int , input ( ) . split ( ) ) NEWLINE z = max ( ( a - n ) , x ) NEWLINE t = max ( ( b - ( n - a + z ) ) , y ) NEWLINE l = max ( ( b - n ) , y ) NEWLINE q = max ( a - ( n - b + l ) , x ) NEWLINE print ( min ( z * t , l * q ) ) NEWLINE NL ENDMARKER
n , a , b = map ( int , input ( ) . split ( ) ) s = input ( ) if ( s [ a - 1 ] == s [ b - 1 ] ) : NEWLINE NL ENDMARKER
def m@@ a@@ k@@ e@@ O@@ dd ( n ) : NEWLINE INDENT if ( n % 2 != 0 ) : NEWLINE INDENTINDENT return 1 ; NEWLINE DEDENT r@@ e@@ s@@ u@@ l = 1 ; NEWLINE while ( n % 2 == 0 ) : NEWLINE INDENTINDENT n = n / 2 ; NEWLINE r@@ e@@ s@@ u@@ l = r@@ e@@ s@@ u@@ l * 2 ; NEWLINE DEDENT return r@@ e@@ s@@ u@@ l ; NEWLINE DEDENT n = 36 ; NEWLINE print ( m@@ a@@ k@@ e@@ O@@ dd ( n ) ) ; NEWLINE NL ENDMARKER
I@@ n@@ t@@ o = str ( input ( ) ) NEWLINE I@@ n@@ t@@ o = list ( I@@ n@@ t@@ o ) NEWLINE h@@ e@@ l@@ lo = [ 'h' , 'e' , '@@ l@@ ' , '@@ l@@ ' , 'o' ] NEWLINE cur = 0 l NEWLINE i@@ s@@ t@@ 1 = [ ] NEWLINE for i in I@@ n@@ t@@ o : if NEWLINE i == h@@ e@@ l@@ lo [ cur ] : l@@ i@@ s@@ t@@ 1 . append ( i ) NEWLINE cur += 1 NEWLINE if len ( l@@ i@@ s@@ t@@ 1 ) == 5 : breakif NEWLINE l@@ i@@ s@@ t@@ 1 == h@@ e@@ l@@ lo : print ( 'YES' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
k , d , t = map ( int , input ( ) . split ( ) ) d = ( ( k + d - 1 ) // d ) * d@@ n = 2 * t // ( d + k ) x = 2 * t % ( d + k ) if ( x <= 2 * k ) : ans = x / 2 + d * nelse : ans = x - k + d * nprint ( ans ) NEWLINE NL ENDMARKER
def setBitNumber ( n ) : NEWLINE INDENT n |= n >> 1 NEWLINE n |= n >> 2 NEWLINE n |= n >> 4 NEWLINE n |= n >> 8 NEWLINE n |= n >> 16 NEWLINE n = n + 1 NEWLINE return ( n >> 1 ) NEWLINE DEDENT n = 273 NEWLINE print ( setBitNumber ( n ) ) NEWLINE NL ENDMARKER
n , x = map ( int , input ( ) . split ( ) )  r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = [ r ( ) for _ in range ( n ) ]   t = 1 w@@ a@@ t@@ ch = 0 i = 0 while 1 : while t + x <= arr [ i ] [ 0 ] : t += x NEWLINE NL ENDMARKER
def G@@ e@@ t@@ P@@ r@@ e@@ f@@ i@@ x@@ S@@ u@@ f@@ f@@ i@@ x ( a , b , l ) : NEWLINE INDENT prefix = a [ : l ] ; NEWLINE l@@ b = len ( b ) ; NEWLINE suffix = b [ l@@ b - l : ] ; NEWLINE return ( prefix + suffix ) ; NEWLINE DEDENT a = "@@ r@@ e@@ m@@ u@@ n@@ e@@ r@@ a@@ t@@ i@@ o@@ n@@ " ; NEWLINE b = "@@ a@@ c@@ q@@ u@@ i@@ e@@ s@@ c@@ e@@ " ; NEWLINE l = 5 ; NEWLINE print ( G@@ e@@ t@@ P@@ r@@ e@@ f@@ i@@ x@@ S@@ u@@ f@@ f@@ i@@ x ( a , b , l ) ) ; NEWLINE NL ENDMARKER
import mathc , d = map ( int , input ( ) . split ( ) ) n , m = map ( int , input ( ) . split ( ) ) k = int ( input ( ) )  if m * n <= k : print ( 0 ) else : c1 = m * c  c2 = ( ( ( ( m * n ) - k ) // n ) * c ) + ( ( ( ( m * n ) - k ) % n ) * d )  c3 = math . ceil ( ( ( m * n ) - k ) / n ) * c  c4 = ( ( m * n ) - k ) * d  print ( min ( c1 , c2 , c3 , c4 ) ) NEWLINE NL ENDMARKER
import math NEWLINE def sum ( n ) : NEWLINE INDENT root = ( int ) ( math . sqrt ( n ) ) NEWLINE ans = 0 NEWLINE for i in range ( 1 , root + 1 ) : NEWLINE INDENTINDENT ans = ans + n // i NEWLINE DEDENT ans = 2 * ans - ( root * root ) NEWLINE return ans NEWLINE DEDENT n = 35 NEWLINE print ( sum ( n ) ) NEWLINE NL ENDMARKER
a , b , c = map ( int , input ( ) . split ( ) ) if a < b : s = ( a * 2 + c * 2 ) else : s = ( b * 2 + c * 2 ) if a != b : s += 1 print ( s )  NEWLINE NL ENDMARKER
n , m , k = map ( int , input ( ) . split ( ) ) c@@ e@@ l@@ ls = 0 for i in range ( 0 , k ) : c@@ e@@ l@@ ls += 2 * ( m + n - 2 - i * ( 8 ) ) print ( c@@ e@@ l@@ ls ) NEWLINE NL ENDMARKER
from math import log2 , ceil NEWLINE def minOperations ( N ) : NEWLINE INDENT x = log2 ( N ) NEWLINE ans = ceil ( x ) NEWLINE return ans NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 10 NEWLINE print ( minOperations ( N ) ) NEWLINE NL DEDENT ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) s = 0 for i in range ( n ) : a = [ i for i in input ( ) . split ( ) ] s += a . count ( 'W' ) + a . count ( 'B' ) + a . count ( 'G' ) if s == n * m : print ( '@@ #@@ B@@ l@@ a@@ c@@ k@@ &@@ W@@ h@@ i@@ t@@ e@@ ' ) else : print ( '@@ #@@ C@@ o@@ l@@ o@@ r@@ ' ) NEWLINE NL ENDMARKER
t = int ( input ( ) )  for _ in range ( t ) : n = int ( input ( ) ) print ( n // 2 )  NEWLINE NL ENDMARKER
n , p , k = list ( map ( int , input ( ) . split ( ' ' ) ) )  NEWLINE NL ENDMARKER
n = int ( input ( ) ) for i in range ( n ) : n , k = list ( map ( int , input ( ) . split ( ) ) ) if ( n == 1 or k == 1 ) or n == 2 and k == 2 : print ( 'YES' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
from itertools import accumulate  n , v = map ( int , input ( ) . split ( ) ) cost = [ ] n -= 1 while v : cost . append ( 1 ) v -= 1 n -= 1 k = 2 while n > 0 : cost . append ( k ) k += 1 n -= 1  t@@ o@@ t@@ a@@ l@@ _@@ cost = list ( accumulate ( cost ) ) print ( t@@ o@@ t@@ a@@ l@@ _@@ cost [ n - 1 ] ) NEWLINE NL ENDMARKER
def o@@ c@@ t@@ a@@ l@@ T@@ o@@ Decimal ( n ) : NEWLINE INDENT num = n ; NEWLINE dec_value = 0 ; NEWLINE base = 1 ; NEWLINE temp = num ; NEWLINE while ( temp ) : NEWLINE INDENTINDENT last_digit = temp % 10 ; NEWLINE temp = int ( temp / 10 ) ; NEWLINE dec_value += last_digit * base ; NEWLINE base = base * 8 ; NEWLINE DEDENT return dec_value ; NEWLINE DEDENT num = 6@@ 7 ; NEWLINE print ( o@@ c@@ t@@ a@@ l@@ T@@ o@@ Decimal ( num ) ) ; NEWLINE NL ENDMARKER
import math NEWLINE def squares ( l , b , a ) : NEWLINE INDENT return math . ceil ( l / a ) * math . ceil ( b / a ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT l = 11 NEWLINE b = 23 NEWLINE a = 14 NEWLINE print ( squares ( l , b , a ) ) NEWLINE NL DEDENT ENDMARKER
def largestPower ( n , p ) : NEWLINE INDENT x = 0 NEWLINE while n : NEWLINE INDENTINDENT n /= p NEWLINE x += n NEWLINE DEDENT return x NEWLINE DEDENT n = 10 ; p = 3 NEWLINE print ( "The largest power of %@@ d that d@@ i@@ v@@ i@@ d@@ e@@ s %@@ d@@ ! is %@@ d@@ \@@ n@@ " % ( p , n , largestPower ( n , p ) ) ) NEWLINE NL ENDMARKER
from math import pow , sqrt NEWLINE def area ( a ) : NEWLINE INDENT if ( a < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT area = pow ( ( a * sqrt ( 3 ) ) / ( sqrt ( 2 ) ) , 2 ) NEWLINE return area NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = 5 NEWLINE print ( "@@ {@@ 0@@ :@@ .@@ 3@@ }" . format ( area ( a ) ) ) NEWLINE NL DEDENT ENDMARKER
def averageOdd ( n ) : NEWLINE INDENT if ( n % 2 == 0 ) : NEWLINE INDENTINDENT print ( "Invalid Input" ) NEWLINE return - 1 NEWLINE DEDENT sm = 0 NEWLINE count = 0 NEWLINE while ( n >= 1 ) : NEWLINE INDENTINDENT count = count + 1 NEWLINE sm = sm + n NEWLINE n = n - 2 NEWLINE DEDENT return sm // count NEWLINE DEDENT n = 15 NEWLINE print ( averageOdd ( n ) ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) ceil = ( n + k - 1 ) // kif ceil * k > n : print ( ceil * k ) else : print ( ceil * k + k ) NEWLINE NL ENDMARKER
def squareSide ( a ) : NEWLINE INDENT if ( a < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT x = 0@@ .@@ 4@@ 23 * a NEWLINE return x NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = 8 NEWLINE print ( squareSide ( a ) ) NEWLINE NL DEDENT ENDMARKER
def i@@ n@@ v@@ e@@ r@@ s@@ e@@ grayCode ( n ) : NEWLINE INDENT i@@ n@@ v = 0 ; NEWLINE while ( n ) : NEWLINE INDENTINDENT i@@ n@@ v = i@@ n@@ v ^ n ; NEWLINE n = n >> 1 ; NEWLINE DEDENT return i@@ n@@ v ; NEWLINE DEDENT n = 15 ; NEWLINE print ( i@@ n@@ v@@ e@@ r@@ s@@ e@@ grayCode ( n ) ) ; NEWLINE NL ENDMARKER
def m@@ a@@ x@@ X@@ O@@ R@@ I@@ n@@ R@@ a@@ n@@ g@@ e ( L , R ) : NEWLINE INDENT L@@ X@@ R = L ^ R NEWLINE m@@ s@@ b@@ P@@ o@@ s = 0 NEWLINE while ( L@@ X@@ R ) : NEWLINE INDENTINDENT m@@ s@@ b@@ P@@ o@@ s += 1 NEWLINE L@@ X@@ R >>= 1 NEWLINE DEDENT maxXOR , two = 0 , 1 NEWLINE while ( m@@ s@@ b@@ P@@ o@@ s ) : NEWLINE INDENTINDENT maxXOR += two NEWLINE two <<= 1 NEWLINE m@@ s@@ b@@ P@@ o@@ s -= 1 NEWLINE DEDENT return maxXOR NEWLINE DEDENT L , R = 8 , 20 NEWLINE print ( m@@ a@@ x@@ X@@ O@@ R@@ I@@ n@@ R@@ a@@ n@@ g@@ e ( L , R ) ) NEWLINE NL ENDMARKER
def steps ( N , M ) : NEWLINE INDENT if ( N == 1 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT elif ( N == 2 ) : NEWLINE INDENTINDENT return M NEWLINE DEDENT return 2 * M + ( N - 3 ) NEWLINE DEDENT N = 4 NEWLINE M = 4 NEWLINE print ( steps ( N , M ) ) NEWLINE NL ENDMARKER
def i@@ s@@ P@@ o@@ s@@ s@@ i@@ b@@ l@@ e@@ T@@ o@@ Z@@ e@@ r@@ o ( a , n ) : NEWLINE INDENT num = 0 ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT num = num * 10 + a [ i ] ; NEWLINE DEDENT return ( num % 11 == 0 ) ; NEWLINE DEDENT arr = [ 0 , 1 , 1 , 0 ] ; NEWLINE n = len ( arr ) ; NEWLINE if ( i@@ s@@ P@@ o@@ s@@ s@@ i@@ b@@ l@@ e@@ T@@ o@@ Z@@ e@@ r@@ o ( arr , n ) ) : NEWLINE INDENT print ( "YES" ) ; NEWLINE DEDENT else : NEWLINE INDENT print ( "NO" ) ; NEWLINE NL DEDENT ENDMARKER
for _ in range ( int ( input ( ) ) ) : s = input ( ) d = s . count ( "D" ) u = s . count ( "U" ) r = s . count ( "R" ) l = s . count ( "L" ) x = min ( d , u ) d = x u = x y = min ( r , l ) r = y l = y ans = "L" * l + "U" * u + "R" * r + "D" * d if d == 0 and u == 0 : if l > 1 and r > 1 : ans = "@@ L@@ R@@ " elif l == 0 and r == 0 : if u > 1 and d > 1 : ans = "@@ U@@ D@@ " print ( len ( ans ) ) print ( ans ) NEWLINE NL ENDMARKER
def mod ( a , m ) : NEWLINE INDENT return ( a % m + m ) % m NEWLINE NL DEDENT ENDMARKER
def cntSquares ( n ) : NEWLINE INDENT squares = 0 ; NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT squares += i ** 2 ; NEWLINE DEDENT return squares ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 4 ; NEWLINE print ( cntSquares ( 4 ) ) ; NEWLINE NL DEDENT ENDMARKER
t = int ( input ( ) )  for p in range ( t ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) mini = 1@@ 0@@ 0@@ 0@@ 0@@ 0@@ 0@@ 0 c = 0 for i in range ( n - 1 , - 1 , - 1 ) : if a [ i ] <= mini : mini = a [ i ] else : c += 1 print ( c ) NEWLINE NL ENDMARKER
r@@ o@@ w@@ s@@ c@@ o@@ l@@ u@@ m@@ n@@ s , result = [ int ( i ) for i in input ( ) . split ( ) ]  counter = 0  for col in range ( 1 , r@@ o@@ w@@ s@@ c@@ o@@ l@@ u@@ m@@ n@@ s + 1 ) : if result % col == 0 and result / col <= r@@ o@@ w@@ s@@ c@@ o@@ l@@ u@@ m@@ n@@ s : counter += 1                                   print ( counter ) NEWLINE NL ENDMARKER
p@@ e@@ o@@ p@@ l@@ e@@ s = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) count = 0 max_ = max ( arr ) for num in arr : count += max_ - numprint ( count ) NEWLINE NL ENDMARKER
def s@@ e@@ t@@ a@@ l@@ l@@ b@@ i@@ t@@ g@@ i@@ v@@ e@@ n@@ range ( n , l , r ) : NEWLINE INDENT range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) NEWLINE return ( n | range ) NEWLINE DEDENT n , l , r = 17 , 2 , 3 NEWLINE print ( s@@ e@@ t@@ a@@ l@@ l@@ b@@ i@@ t@@ g@@ i@@ v@@ e@@ n@@ range ( n , l , r ) ) NEWLINE NL ENDMARKER
for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE for i in range ( n ) : print ( 4 * n - 2 * i , end = ' ' ) NEWLINE print ( ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) x = [ ] t = [ - 1 ] * m@@ j = 0 c = Falsefor i in range ( m ) : x += list ( map ( int , input ( ) . split ( ) ) ) for k in range ( m ) : t [ j ] = x [ k ] % n j += 1 for l in range ( m ) : for y in range ( 0 , l ) : if l != y : if t [ l ] == t [ y ] : c = True print ( l + 1 ) exit ( ) if c == False : print ( - 1 ) NEWLINE NL ENDMARKER
def count ( N ) : NEWLINE INDENT sum = 0 ; NEWLINE for i in range ( N + 1 ) : NEWLINE INDENTINDENT sum += 7 * ( 8 ** ( i - 1 ) ) ; NEWLINE DEDENT return int ( sum ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 4 ; NEWLINE print ( count ( N ) ) ; NEWLINE NL DEDENT ENDMARKER
def check ( n , m@@ a@@ r@@ ks ) : NEWLINE INDENT x = max ( m@@ a@@ r@@ ks ) NEWLINE b@@ o@@ n@@ u@@ s = 100 - x NEWLINE c = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT if ( m@@ a@@ r@@ ks [ i ] + b@@ o@@ n@@ u@@ s >= 50 ) : NEWLINE INDENTINDENTINDENT c += 1 NEWLINE DEDENT DEDENT return c NEWLINE DEDENT n = 5 NEWLINE m@@ a@@ r@@ ks = [ 0 , 21 , 83 , 45 , 64 ] NEWLINE print ( check ( n , m@@ a@@ r@@ ks ) ) NEWLINE NL ENDMARKER
def e@@ v@@ e@@ n@@ _@@ o@@ r@@ _@@ odd ( N ) : NEWLINE INDENT l = len ( N ) ; NEWLINE if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or N [ l - 1 ] == '4' or N [ l - 1 ] == '6' ) : NEWLINE INDENTINDENT return ( "Even" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( "Odd" ) NEWLINE DEDENT DEDENT N = "@@ 7@@ 3@@ 5@@ " NEWLINE print ( e@@ v@@ e@@ n@@ _@@ o@@ r@@ _@@ odd ( N ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) f = 0 if n / 2 < 5 : print ( - 1 ) else : for i in range ( 5 , n // 2 ) : if n % i == 0 and n // i >= 5 : s = '@@ a@@ e@@ i@@ o@@ u@@ ' + 'g' * ( ( i ) - 5 ) ; j = 1 ans = s while j < n // i : s = s [ - 1 ] + s [ : - 1 ] ans = ans + s j += 1 print ( ans ) f = 1 break if f == 0 : print ( - 1 ) NEWLINE NL ENDMARKER
def m@@ a@@ x@@ C@@ o@@ n@@ s@@ e@@ c@@ u@@ t@@ i@@ v@@ e@@ O@@ n@@ e@@ s ( x ) : NEWLINE INDENT count = 0 NEWLINE while ( x != 0 ) : NEWLINE INDENTINDENT x = ( x & ( x << 1 ) ) NEWLINE count = count + 1 NEWLINE DEDENT return count NEWLINE DEDENT print ( m@@ a@@ x@@ C@@ o@@ n@@ s@@ e@@ c@@ u@@ t@@ i@@ v@@ e@@ O@@ n@@ e@@ s ( 14 ) ) NEWLINE print ( m@@ a@@ x@@ C@@ o@@ n@@ s@@ e@@ c@@ u@@ t@@ i@@ v@@ e@@ O@@ n@@ e@@ s ( 2@@ 22 ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( ( n - 2 ) * ( n - 2 ) ) NEWLINE NL ENDMARKER
def largestPower ( n , p ) : NEWLINE INDENT x = 0 NEWLINE while n : NEWLINE INDENTINDENT n /= p NEWLINE x += n NEWLINE DEDENT return x NEWLINE DEDENT n = 10 ; p = 3 NEWLINE print ( "The largest power of %@@ d that d@@ i@@ v@@ i@@ d@@ e@@ s %@@ d@@ ! is %@@ d@@ \@@ n@@ " % ( p , n , largestPower ( n , p ) ) ) NEWLINE NL ENDMARKER
def c@@ o@@ u@@ n@@ t@@ S@@ u@@ b@@ s@@ t@@ r@@ i@@ n@@ g@@ W@@ i@@ t@@ h@@ E@@ q@@ u@@ a@@ l@@ E@@ n@@ ds ( s ) : NEWLINE INDENT result = 0 ; NEWLINE n = len ( s ) ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT for j in range ( i , n ) : NEWLINE INDENTINDENTINDENT if ( s [ i ] == s [ j ] ) : NEWLINE INDENTINDENTINDENTINDENT result = result + 1 NEWLINE DEDENT DEDENT DEDENT return result NEWLINE DEDENT s = "@@ a@@ b@@ c@@ a@@ b@@ " ; NEWLINE print ( c@@ o@@ u@@ n@@ t@@ S@@ u@@ b@@ s@@ t@@ r@@ i@@ n@@ g@@ W@@ i@@ t@@ h@@ E@@ q@@ u@@ a@@ l@@ E@@ n@@ ds ( s ) ) NEWLINE NL ENDMARKER
def power ( x , y ) : NEWLINE INDENT res = 1 NEWLINE while ( y > 0 ) : NEWLINE INDENTINDENT if ( ( y & 1 ) == 1 ) : NEWLINE INDENTINDENTINDENT res = res * x NEWLINE DEDENT y = y >> 1 NEWLINE x = x * x NEWLINE DEDENT return res NEWLINE DEDENT x = 3 NEWLINE y = 5 NEWLINE print ( "Power is " , power ( x , y ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) r = n ; MAX = 998244353 arr = [ 0 ] * ( n + 1 ) for i in range ( n - 1 ) : a , b = map ( int , input ( ) . split ( ) ) arr [ a ] += 1 ; arr [ b ] += 1 r *= arr [ a ] * arr [ b ] r %= M@@ A@@ X@@ print ( r ) NEWLINE NL ENDMARKER
N = 10000 ; NEWLINE MOD = 1000000007 ; NEWLINE F = [ 0 ] * N ; NEWLINE def p@@ r@@ e@@ compute ( ) : NEWLINE INDENT F [ 1 ] = 2 ; NEWLINE F [ 2 ] = 3 ; NEWLINE F [ 3 ] = 4 ; NEWLINE for i in range ( 4 , N ) : NEWLINE INDENTINDENT F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; NEWLINE DEDENT DEDENT n = 8 ; NEWLINE p@@ r@@ e@@ compute ( ) ; NEWLINE print ( F [ n ] ) ; NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) s = 0  for j , i in enumerate ( a ) : if i > s : print ( j + 1 ) exit ( ) if i == s : s += 1  print ( - 1 ) NEWLINE NL ENDMARKER
n , k , t = map ( int , input ( ) . split ( ) ) NEWLINE ans = [ 0 ] * n@@ i = 0 NEWLINE a = n * k * t // 100 NEWLINE while a > 0 : if NEWLINE a >= k : ans [ i ] += k NEWLINE i += 1 NEWLINE a -= k else : ans [ i ] += int ( a ) NEWLINE a -= int ( a ) NEWLINE print ( * ans ) NEWLINE NL ENDMARKER
def p@@ r@@ i@@ n@@ t@@ F@@ i@@ b@@ o@@ n@@ a@@ c@@ c@@ i@@ Numbers ( n ) : NEWLINE INDENT f1 = 0 NEWLINE f2 = 1 NEWLINE if ( n < 1 ) : NEWLINE INDENTINDENT return NEWLINE DEDENT for x in range ( 0 , n ) : NEWLINE INDENTINDENT print ( f2 , end = " " ) NEWLINE next = f1 + f2 NEWLINE f1 = f2 NEWLINE f2 = next NEWLINE DEDENT DEDENT p@@ r@@ i@@ n@@ t@@ F@@ i@@ b@@ o@@ n@@ a@@ c@@ c@@ i@@ Numbers ( 7 ) NEWLINE NL ENDMARKER
'''   ''' NEWLINE NL ENDMARKER
def f@@ i@@ n@@ d@@ _sum ( n , k ) : NEWLINE INDENT total_sum = ( n * ( n + 1 ) ) // 2 NEWLINE power = k NEWLINE while power <= n : NEWLINE INDENTINDENT total_sum -= power NEWLINE power *= k NEWLINE DEDENT return total_sum NEWLINE DEDENT n = 11 ; k = 2 NEWLINE print ( f@@ i@@ n@@ d@@ _sum ( n , k ) ) NEWLINE NL ENDMARKER
def m@@ a@@ x@@ LCM ( n ) : NEWLINE INDENT return ( n * ( n - 1 ) ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 3 ; NEWLINE print ( m@@ a@@ x@@ LCM ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
import sys  def main ( ) : inp = sys . stdin . read ( ) . strip ( ) . split ( '\n' ) return ( i for i in inp [ 1 ] . split ( ) if i in set ( inp [ 2 ] . split ( ) ) ) print ( * main ( ) ) NEWLINE NL ENDMARKER
num , t = map ( int , ( input ( ) . split ( ) ) ) arr = list ( map ( int , input ( ) . split ( ) ) )  ct = 0 i = 0 while t > 0 : t -= ( 86400 - arr [ i ] ) i += 1 ct += 1  print ( ct ) NEWLINE NL ENDMARKER
n = int ( input ( ) )  s = input ( )  a = s . count ( 'X' ) b = s . count ( 'x' )  if a == b : print ( 0 ) print ( s ) else : if a > b : c = a - n // 2 s = s . replace ( 'X' , 'x' , c ) print ( c ) else : c = b - n // 2 print ( c ) s = s . replace ( 'x' , 'X' , c )  print ( s ) NEWLINE NL ENDMARKER
def b@@ a@@ n@@ k@@ N@@ o@@ t@@ e@@ s ( A , B , S , N ) : NEWLINE INDENT numerator = S - ( B * N ) NEWLINE denominator = A - B NEWLINE if ( numerator % denominator == 0 ) : NEWLINE INDENTINDENT return ( numerator // denominator ) NEWLINE DEDENT return - 1 NEWLINE DEDENT A , B , S , N = 1 , 2 , 7 , 5 NEWLINE print ( b@@ a@@ n@@ k@@ N@@ o@@ t@@ e@@ s ( A , B , S , N ) ) NEWLINE NL ENDMARKER
a , b , c , l = map ( int , input ( ) . split ( ) ) ans = ( l + 3 ) * ( l + 2 ) * ( l + 1 ) // 3 for z in ( a , b , c ) : s = 2 * z - a - b - c for x in range ( max ( 0 , - s ) , l + 1 ) : m = min ( s + x , l - x ) ans -= ( m + 1 ) * ( m + 2 ) print ( ans // 2 ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) NEWLINE while ( t > 0 ) : n = int ( input ( ) ) NEWLINE temp = input ( ) NEWLINE ar = ( temp . split ( ) ) NEWLINE for i in range ( 0 , n , 2 ) : print ( - 1 * ( int ( ar [ i + 1 ] ) ) , end = " " ) NEWLINE print ( ( int ( ar [ i ] ) ) , end = " " ) NEWLINE print ( "" ) NEWLINE t -= 1 NEWLINE NL ENDMARKER
n , a , b = map ( int , input ( ) . split ( ) ) if b < 0 : for x in range ( abs ( b ) ) : if a != 1 : a -= 1 else : a = nelif b >= 0 : for y in range ( b ) : if a == n : a = 1 else : a += 1  print ( a ) NEWLINE NL ENDMARKER
s = input ( ) print ( s + '' . join ( reversed ( s ) ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) x = b [ 0 ] y = b [ 1 ] i = 1 s = sum ( a ) ans1 = 0 ans2 = s@@ ans = 0 while i <= n : ans1 += a [ i - 1 ] ans2 -= a [ i - 1 ] NEWLINE NL ENDMARKER
def f@@ i@@ n@@ d@@ B@@ a@@ l@@ a@@ n@@ ce ( x , b@@ al ) : NEWLINE INDENT if ( x % 10 == 0 and ( x + 1@@ .@@ 50 ) <= b@@ al ) : NEWLINE INDENTINDENT print ( round ( b@@ al - x - 1@@ .@@ 50 , 2 ) ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( round ( b@@ al , 2 ) ) NEWLINE DEDENT DEDENT x = 50 NEWLINE b@@ al = 1@@ 0@@ 0@@ .@@ 50 NEWLINE f@@ i@@ n@@ d@@ B@@ a@@ l@@ a@@ n@@ ce ( x , b@@ al ) NEWLINE NL ENDMARKER
def checksum ( n ) : NEWLINE INDENT n = int ( n ) NEWLINE if n % 3 == 0 : NEWLINE INDENTINDENT print ( int ( n / 3 - 1 ) , " " , int ( n / 3 ) , " " , int ( n / 3 + 1 ) ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "-1" ) NEWLINE DEDENT DEDENT n = 6 NEWLINE checksum ( n ) NEWLINE NL ENDMARKER
from collections import Counter  if __name__ == '__main__' : c@@ in = input NEWLINE n , k = map ( int , c@@ in ( ) . split ( ) ) NEWLINE d , cnt = Counter ( [ int ( i ) for i in c@@ in ( ) . split ( ) ] ) , 0 NEWLINE while d [ k ] < n : for NEWLINE i in range ( k - 1 , 0 , - 1 ) : NEWLINE if d [ i ] : d [ i + 1 ] += 1 NEWLINE d [ i ] -= 1 NEWLINE cnt += 1 NEWLINE print ( cnt ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( pow ( 8 , n , 10 ) ) NEWLINE NL ENDMARKER
def c@@ o@@ u@@ n@@ t@@ O@@ c@@ c@@ u@@ r@@ r@@ a@@ n@@ c@@ e@@ s ( n , d ) : NEWLINE INDENT count = 0 NEWLINE while ( n > 0 ) : NEWLINE INDENTINDENT if ( n % 10 == d ) : NEWLINE INDENTINDENTINDENT count = count + 1 NEWLINE DEDENT n = n // 10 NEWLINE DEDENT return count NEWLINE DEDENT d = 2 NEWLINE n = 2@@ 1@@ 4@@ 2@@ 1@@ 5@@ 4@@ 21 NEWLINE print ( c@@ o@@ u@@ n@@ t@@ O@@ c@@ c@@ u@@ r@@ r@@ a@@ n@@ c@@ e@@ s ( n , d ) ) NEWLINE NL ENDMARKER
s = input ( ) s = s [ 0 ] . upper ( ) + s [ 1 : ] print ( s ) NEWLINE NL ENDMARKER
s , v1 , v2 , t1 , t2 = map ( int , input ( ) . split ( ) ) n1 = s * v1 + t1 * 2 n2 = s * v2 + t2 * 2 if n1 != n2 : if n1 < n2 : print ( 'First' ) else : print ( 'Second' ) else : print ( '@@ F@@ r@@ i@@ e@@ n@@ d@@ s@@ h@@ i@@ p@@ ' ) NEWLINE NL ENDMARKER
def d@@ o@@ M@@ a@@ t@@ ch ( A , B ) : NEWLINE INDENT for i in range ( len ( A ) ) : NEWLINE INDENTINDENT if A [ i ] != '*' and B [ i ] != '*' : NEWLINE INDENTINDENTINDENT if A [ i ] != B [ i ] : NEWLINE INDENTINDENTINDENTINDENT return False NEWLINE DEDENT DEDENT DEDENT return True NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT A = "@@ g@@ e@@ e@@ *@@ s@@ f@@ o@@ r@@ geeks" NEWLINE B = "geeksforgeeks" NEWLINE print ( int ( d@@ o@@ M@@ a@@ t@@ ch ( A , B ) ) ) NEWLINE NL DEDENT ENDMARKER
def s@@ u@@ m@@ o@@ f@@ product ( n ) : NEWLINE INDENT ans = 0 NEWLINE for x in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT y = int ( n / x ) NEWLINE ans += ( y * x ) NEWLINE DEDENT return ans NEWLINE DEDENT n = 10 NEWLINE print ( s@@ u@@ m@@ o@@ f@@ product ( n ) ) NEWLINE NL ENDMARKER
from math import sqrt NEWLINE def count ( n ) : NEWLINE INDENT return ( - 1 + sqrt ( 1 + 8 * n ) ) // 2 ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 10 ; NEWLINE print ( count ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
n , p = map ( int , input ( ) . split ( ) )  ans = n  l = len ( str ( n ) ) for n@@ i@@ n@@ e in range ( 0 , l ) : m = int ( str ( n ) [ : l - n@@ i@@ n@@ e ] + '9' * n@@ i@@ n@@ e ) while m > n : m -= 10 ** n@@ i@@ n@@ e if n - m <= p : ans = m  print ( ans ) NEWLINE NL ENDMARKER
def gcd ( a , b ) : NEWLINE INDENT if ( a == 0 ) : NEWLINE INDENTINDENT return b ; NEWLINE DEDENT return gcd ( b % a , a ) ; NEWLINE DEDENT def lcm ( n , m ) : NEWLINE INDENT return ( n * m ) // gcd ( n , m ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 2 ; m = 3 ; k = 5 ; NEWLINE print ( k // lcm ( n , m ) ) ; NEWLINE NL DEDENT ENDMARKER
for _ in range ( int ( input ( ) ) ) :  NEWLINE n = int ( input ( ) )  if n // 2020 >= n % 2020 : NEWLINE INDENT print ( 'YES' ) else : NEWLINE print ( 'NO' ) NEWLINE NL DEDENT ENDMARKER
def A@@ V@@ L@@ nodes ( height ) : NEWLINE INDENT if ( height == 0 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT elif ( height == 1 ) : NEWLINE INDENTINDENT return 2 NEWLINE DEDENT return ( 1 + A@@ V@@ L@@ nodes ( height - 1 ) + A@@ V@@ L@@ nodes ( height - 2 ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT H = 3 NEWLINE print ( A@@ V@@ L@@ nodes ( H ) ) NEWLINE NL DEDENT ENDMARKER
def t@@ r@@ i@@ b@@ W@@ ord ( n ) : NEWLINE INDENT Sn_1 = "1" NEWLINE S@@ n@@ _@@ 2 = "12" NEWLINE S@@ n@@ _@@ 3 = "@@ 1@@ 2@@ 1@@ 3@@ " NEWLINE for i in range ( 3 , n + 1 ) : NEWLINE INDENTINDENT tmp = S@@ n@@ _@@ 3 NEWLINE S@@ n@@ _@@ 3 += ( S@@ n@@ _@@ 2 + Sn_1 ) NEWLINE Sn_1 = S@@ n@@ _@@ 2 NEWLINE S@@ n@@ _@@ 2 = tmp NEWLINE DEDENT return S@@ n@@ _@@ 3 NEWLINE DEDENT n = 6 NEWLINE print ( t@@ r@@ i@@ b@@ W@@ ord ( n ) ) NEWLINE NL ENDMARKER
def i@@ n@@ d@@ e@@ x@@ O@@ f@@ F@@ i@@ r@@ s@@ t@@ O@@ n@@ e ( arr , n ) : NEWLINE INDENT for i in range ( 0 , n ) : NEWLINE INDENTINDENT if ( arr [ i ] == 1 ) : NEWLINE INDENTINDENTINDENT return i NEWLINE DEDENT DEDENT return - 1 NEWLINE DEDENT arr = [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] NEWLINE n = len ( arr ) NEWLINE ans = i@@ n@@ d@@ e@@ x@@ O@@ f@@ F@@ i@@ r@@ s@@ t@@ O@@ n@@ e ( arr , n ) NEWLINE print ( ans ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = sum ( map ( int , input ( ) . split ( ) ) ) if a % n == 0 : print ( n ) else : print ( n - 1 ) NEWLINE NL ENDMARKER
n , m , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ans , result = 0 , 0 p@@ a@@ g@@ e , n@@ e@@ w@@ _@@ result = None , 1 for i in range ( m ) : if ( a [ i ] - result ) // k != p@@ a@@ g@@ e : ans += 1 result = n@@ e@@ w@@ _@@ result p@@ a@@ g@@ e = ( a [ i ] - result ) // k n@@ e@@ w@@ _@@ result += 1 print ( ans ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) a = { input ( ) for _ in range ( n ) } b = { input ( ) for _ in range ( m ) } u = len ( a . intersection ( b ) ) print ( "NO" ) if m - u + u // 2 >= n - u + ( u + 1 ) // 2 else print ( "YES" ) NEWLINE NL ENDMARKER
t = { } for i , c in enumerate ( input ( ) ) : if c not in t : t [ c ] = ( i , 1 ) elif ( t [ c ] [ 0 ] - i ) & 1 : t [ c ] = ( i , t [ c ] [ 1 ] + 1 ) print ( max ( b for a , b in t . values ( ) ) ) NEWLINE NL ENDMARKER
def b@@ i@@ t@@ s@@ o@@ n@@ count ( x ) : NEWLINE INDENT return bin ( x ) . count ( '1' ) NEWLINE DEDENT def f@@ i@@ n@@ d@@ _@@ count ( arr ) : NEWLINE INDENT ans = 0 NEWLINE for i in arr : NEWLINE INDENTINDENT x = b@@ i@@ t@@ s@@ o@@ n@@ count ( i ) NEWLINE if ( i % x == 0 ) : NEWLINE INDENTINDENTINDENT ans += 1 NEWLINE DEDENT DEDENT return ans NEWLINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEWLINE print ( f@@ i@@ n@@ d@@ _@@ count ( arr ) ) NEWLINE NL ENDMARKER
def factorial ( n ) : NEWLINE INDENT if ( n == 0 ) : NEWLINE INDENTINDENT return 1 ; NEWLINE DEDENT return n * factorial ( n - 1 ) ; NEWLINE DEDENT def countNum ( n ) : NEWLINE INDENT if ( n > 10 ) : NEWLINE INDENTINDENT return 0 ; NEWLINE DEDENT return ( 9 * factorial ( 9 ) // factorial ( 10 - n ) ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 3 ; NEWLINE print ( countNum ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) k = min ( a ) d = max ( a ) + 1  p = - 100000 pas = [ ] while k in a : s = a . index ( k ) a [ s ] = d if s - p == 1 : exit ( print ( 1 ) ) pas . append ( s - p ) p = s          print ( min ( pas ) )  NEWLINE NL ENDMARKER
def fib ( n ) : NEWLINE INDENT a = 0 NEWLINE b = 1 NEWLINE if ( n >= 0 ) : NEWLINE INDENTINDENT print ( a , end = ' ' ) NEWLINE DEDENT if ( n >= 1 ) : NEWLINE INDENTINDENT print ( b , end = ' ' ) NEWLINE DEDENT for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT print ( a + b , end = ' ' ) NEWLINE b = a + b NEWLINE a = b - a NEWLINE DEDENT DEDENT fib ( 9 ) NEWLINE NL ENDMARKER
def l@@ a@@ r@@ g@@ e@@ s@@ t@@ C@@ o@@ prime ( N ) : NEWLINE INDENT if N == 6 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT elif N % 4 == 0 : NEWLINE INDENTINDENT return N // 2 - 1 NEWLINE DEDENT elif N % 2 == 0 : NEWLINE INDENTINDENT return N // 2 - 2 NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( N - 1 ) // 2 NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 50 NEWLINE print ( l@@ a@@ r@@ g@@ e@@ s@@ t@@ C@@ o@@ prime ( n ) ) NEWLINE NL DEDENT ENDMARKER
def fact ( n ) : NEWLINE INDENT res = 1 NEWLINE for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT res = res * i NEWLINE DEDENT return res NEWLINE DEDENT def C@@ o@@ u@@ n@@ t@@ _@@ number ( N ) : NEWLINE INDENT return ( N * fact ( N ) ) NEWLINE DEDENT N = 2 NEWLINE print ( C@@ o@@ u@@ n@@ t@@ _@@ number ( N ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) k = int ( input ( ) ) A = int ( input ( ) ) B = int ( input ( ) ) c = 0 while ( n != 1 ) : if ( k == 1 or k > n ) : c += ( n - 1 ) * A break elif ( n % k != 0 ) : c += ( n % k ) * A n -= n % k else : c += min ( B , ( n - n // k ) * A ) n = n // kprint ( c ) NEWLINE NL ENDMARKER
l = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 3@@ 7 , 41 , 43 , 47 , 51 ] NEWLINE n , m = map ( int , input ( ) . split ( ) ) NEWLINE print ( l [ l . index ( n ) + 1 ] == m and "YES" or "NO" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) s = sum ( l ) for i in range ( 1 , n ) : if l [ i ] <= l [ i - 1 ] : l [ i ] = l [ i - 1 ] + 1 print ( sum ( l ) - s ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s , t = [ list ( input ( ) ) for _ in range ( 2 ) ] if str ( sorted ( s ) ) == str ( sorted ( t ) ) : ans = [ ] for i in range ( n - 1 , - 1 , - 1 ) : if s [ i ] != t [ i ] : for j in range ( i - 1 , - 1 , - 1 ) : if s [ j ] == t [ i ] : for k in range ( j , i ) : s [ k ] , s [ k + 1 ] = s [ k + 1 ] , s [ k ] ans . append ( k + 1 ) break print ( len ( ans ) ) print ( * ans ) else : print ( - 1 ) NEWLINE NL ENDMARKER
import h@@ e@@ a@@ p@@ q@@ n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr . sort ( ) largest = arr [ - 1 ] total = sum ( arr ) o@@ t@@ h@@ e@@ r@@ s = total - arr [ - 1 ] if total % 2 == 0 and largest <= o@@ t@@ h@@ e@@ r@@ s : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
import io , os , s@@ y@@ s@@ t@@ r@@ y : f@@ in = open ( '@@ i@@ n@@ ' ) input = f@@ in . r@@ e@@ a@@ d@@ l@@ i@@ n@@ e@@ except : input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline t , s , q = map ( int , input ( ) . split ( ) ) c = 0 while s < t : c += 1 s *= q@@ print ( c ) NEWLINE NL ENDMARKER
def updateArray ( arr , n ) : NEWLINE INDENT i = n - 1 NEWLINE while ( i > 0 ) : NEWLINE INDENTINDENT arr [ i ] = arr [ i - 1 ] NEWLINE i -= 1 NEWLINE DEDENT arr [ 0 ] = - 1 NEWLINE for i in range ( 0 , n , 1 ) : NEWLINE INDENTINDENT print ( arr [ i ] , end = " " ) NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEWLINE N = len ( arr ) NEWLINE updateArray ( arr , N ) NEWLINE NL DEDENT ENDMARKER
def findRemainder ( n ) : NEWLINE INDENT l = n % 10 NEWLINE while ( n >= 10 ) : NEWLINE INDENTINDENT n //= 10 NEWLINE DEDENT f = n NEWLINE remainder = f % l NEWLINE print ( remainder ) NEWLINE DEDENT n = 5@@ 2@@ 23 NEWLINE findRemainder ( n ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) if n % 2 == 0 : print ( 4 , n - 4 ) else : print ( 9 , n - 9 ) NEWLINE NL ENDMARKER
d , l , v1 , v2 = map ( int , ( input ( ) . split ( ) ) )  ans = ( l - d ) / ( v1 + v2 )  print ( ans ) NEWLINE NL ENDMARKER
def t@@ r@@ a@@ i@@ l@@ i@@ n@@ g@@ Z@@ e@@ r@@ o ( x ) : NEWLINE INDENT i = 5 NEWLINE count = 0 NEWLINE while ( x > i ) : NEWLINE INDENTINDENT count = count + x // i NEWLINE i = i * 5 NEWLINE DEDENT return count NEWLINE DEDENT def c@@ o@@ u@@ n@@ t@@ P@@ r@@ o@@ d@@ u@@ c@@ t@@ T@@ r@@ a@@ i@@ l@@ i@@ n@@ g ( M , N ) : NEWLINE INDENT return t@@ r@@ a@@ i@@ l@@ i@@ n@@ g@@ Z@@ e@@ r@@ o ( N ) + t@@ r@@ a@@ i@@ l@@ i@@ n@@ g@@ Z@@ e@@ r@@ o ( M ) NEWLINE DEDENT N = 6@@ 7 NEWLINE M = 98 NEWLINE print ( c@@ o@@ u@@ n@@ t@@ P@@ r@@ o@@ d@@ u@@ c@@ t@@ T@@ r@@ a@@ i@@ l@@ i@@ n@@ g ( N , M ) ) NEWLINE NL ENDMARKER
def c@@ e@@ n@@ t@@ e@@ r@@ e@@ d@@ _@@ cube ( n ) : NEWLINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 3 NEWLINE print ( n , "th Centered cube " + "number : " , c@@ e@@ n@@ t@@ e@@ r@@ e@@ d@@ _@@ cube ( n ) ) NEWLINE n = 10 NEWLINE print ( n , "th Centered cube " + "number : " , c@@ e@@ n@@ t@@ e@@ r@@ e@@ d@@ _@@ cube ( n ) ) NEWLINE NL DEDENT ENDMARKER
start , end , k = input ( ) , input ( ) , int ( input ( ) ) n , mod = len ( end ) , 10 ** 9 + 7 dp = [ 1 , 0 ] p@@ sum = 1 for i in range ( k ) : dp [ 0 ] = p@@ sum - dp [ 0 ] dp [ 1 ] = p@@ sum - dp [ 1 ] p@@ sum = ( dp [ 0 ] + ( ( n - 1 ) * dp [ 1 ] ) % mod ) % m@@ o@@ d@@ ans = 0 for i in range ( n ) : if start [ i : ] + start [ : i ] == end : if i == 0 : ans += dp [ 0 ] else : ans += dp [ 1 ] print ( ans % mod ) NEWLINE NL ENDMARKER
def pattern ( n , d ) : NEWLINE INDENT for i in range ( 0 , n - 2 ) : NEWLINE INDENTINDENT print ( "1" , end = " " ) NEWLINE DEDENT print ( "2" , end = " " ) NEWLINE print ( n + d ) NEWLINE DEDENT N = 3 NEWLINE D = 5 NEWLINE pattern ( N , D ) NEWLINE NL ENDMARKER
def d@@ i@@ s@@ p@@ l@@ a@@ y ( n ) : NEWLINE INDENT for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT k = i NEWLINE for j in range ( 1 , i + 1 ) : NEWLINE INDENTINDENTINDENT if k % 2 == 0 : NEWLINE INDENTINDENTINDENTINDENT print ( j , end = '' ) NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENTINDENT print ( '*' , end = '' ) NEWLINE DEDENT k -= 1 NEWLINE DEDENT print ( ) NEWLINE DEDENT DEDENT n = 5 NEWLINE d@@ i@@ s@@ p@@ l@@ a@@ y ( n ) NEWLINE NL ENDMARKER
import s@@ y@@ s@@ t@@ r@@ y : f@@ in = open ( '@@ i@@ n@@ ' ) except : f@@ in = sys . stdininput = f@@ in . readline  n , d , m , l = map ( int , input ( ) . split ( ) ) cur = 0 R = N@@ o@@ n@@ e@@ for i in range ( n ) : R = i * m + l NEWLINE NL ENDMARKER
for _ in '.' * int ( input ( ) ) : n = int ( input ( ) ) ; print ( "@@ Y@@ N@@ E@@ O@@ S@@ " [ n & - n == n : : 2 ] ) NEWLINE NL ENDMARKER
import math  k , a , b , v = map ( int , input ( ) . split ( ) )     ans = 0  while a > 0 :  l = min ( k - 1 , b )  b -= l a -= ( l + 1 ) * v  ans += 1  print ( ans ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) ans = 0 for _ in range ( n ) : x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) ans += ( x2 - x1 + 1 ) * ( y2 - y1 + 1 ) print ( ans ) NEWLINE NL ENDMARKER
U@@ L@@ L@@ _@@ SIZE = 64 NEWLINE def b@@ i@@ t@@ _@@ a@@ n@@ a@@ g@@ r@@ a@@ m@@ _@@ check ( a ) : NEWLINE INDENT return ( bin ( a ) . count ( "1" ) == ( U@@ L@@ L@@ _@@ SIZE >> 1 ) ) NEWLINE DEDENT a = 4@@ 2@@ 9@@ 4@@ 9@@ 6@@ 7@@ 2@@ 9@@ 5 NEWLINE print ( int ( b@@ i@@ t@@ _@@ a@@ n@@ a@@ g@@ r@@ a@@ m@@ _@@ check ( a ) ) ) NEWLINE NL ENDMARKER
ls = [ ] sum1 = 0 lis = [ ] n = int ( input ( ) ) m = int ( input ( ) ) for i in range ( n ) : ls . append ( int ( input ( ) ) ) ls . sort ( ) for i in ls [ : : - 1 ] : sum1 += i lis . append ( i ) if sum1 >= m : breakprint ( len ( lis ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) d = { i : [ ] for i in range ( 1 , n + 1 ) } for i in range ( 2 , n + 1 ) : d [ int ( input ( ) ) ] . append ( i ) for i in d : if d [ i ] : temp = 0 for j in d [ i ] : if len ( d [ j ] ) == 0 : temp += 1 if temp < 3 : print ( "No" ) exit ( ) print ( "Yes" ) NEWLINE NL ENDMARKER
t = int ( input ( ) )  for x in range ( t ) : a , b , n = map ( int , input ( ) . split ( ) )  if a > b : b , a = a , b  o@@ p@@ e@@ r@@ a@@ t@@ i@@ on = 0 while a <= n and b <= n : a += b a , b = b , a o@@ p@@ e@@ r@@ a@@ t@@ i@@ on += 1  print ( o@@ p@@ e@@ r@@ a@@ t@@ i@@ on ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if n == 1 : print ( - 1 ) else : res = [ 3 ] * ( n - 1 ) res . i@@ n@@ s@@ e@@ r@@ t ( 0 , 2 ) print ( * res , sep = '' ) NEWLINE NL ENDMARKER
def n@@ u@@ m@@ o@@ f@@ string ( n , m ) : NEWLINE INDENT if n == 1 : NEWLINE INDENTINDENT return m NEWLINE DEDENT if n == 2 : NEWLINE INDENTINDENT return m * ( m - 1 ) NEWLINE DEDENT return m * ( m - 1 ) * pow ( m - 2 , n - 2 ) NEWLINE DEDENT n = 2 NEWLINE m = 3 NEWLINE print ( n@@ u@@ m@@ o@@ f@@ string ( n , m ) ) NEWLINE NL ENDMARKER
def c@@ a@@ l@@ _@@ m@@ i@@ n@@ i@@ m@@ u@@ m@@ _@@ time ( X ) : NEWLINE INDENT t = 0 NEWLINE sum = 0 NEWLINE while ( sum < X ) : NEWLINE INDENTINDENT t = t + 1 NEWLINE sum = sum + t ; NEWLINE DEDENT return t ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 6 NEWLINE ans = c@@ a@@ l@@ _@@ m@@ i@@ n@@ i@@ m@@ u@@ m@@ _@@ time ( n ) NEWLINE print ( "The minimum time required is :" , ans ) NEWLINE NL DEDENT ENDMARKER
a = input ( ) b = input ( ) x = a . count ( '1' ) x = x + x % 2 x -= b . count ( '1' ) print ( "NO" if x < 0 else "YES" ) NEWLINE NL ENDMARKER
from sys import stdininput = stdin . readline  n , t = [ int ( x ) for x in input ( ) . split ( ) ] a = [ int ( x ) for x in input ( ) . split ( ) ] for i in range ( n ) : t -= 86400 - a [ i ] if t <= 0 : print ( i + 1 ) break NEWLINE NL ENDMARKER
def c@@ o@@ u@@ n@@ t@@ F@@ i@@ bs ( low , high ) : NEWLINE INDENT f1 , f2 , f3 = 0 , 1 , 1 NEWLINE result = 0 NEWLINE while ( f1 <= high ) : NEWLINE INDENTINDENT if ( f1 >= low ) : NEWLINE INDENTINDENTINDENT result += 1 NEWLINE DEDENT f1 = f2 NEWLINE f2 = f3 NEWLINE f3 = f1 + f2 NEWLINE DEDENT return result NEWLINE DEDENT low , high = 10 , 100 NEWLINE print ( "Count of Fibonacci Numbers is" , c@@ o@@ u@@ n@@ t@@ F@@ i@@ bs ( low , high ) ) NEWLINE NL ENDMARKER
def h@@ e@@ x@@ a@@ d@@ e@@ c@@ a@@ g@@ o@@ n@@ a@@ l@@ Num ( n ) : NEWLINE INDENT return ( ( 14 * n * n ) - 12 * n ) // 2 NEWLINE DEDENT n = 5 NEWLINE print ( "%sth H@@ e@@ x@@ a@@ d@@ e@@ c@@ a@@ g@@ o@@ n@@ al number : " % n , h@@ e@@ x@@ a@@ d@@ e@@ c@@ a@@ g@@ o@@ n@@ a@@ l@@ Num ( n ) ) NEWLINE n = 9 NEWLINE print ( "%sth H@@ e@@ x@@ a@@ d@@ e@@ c@@ a@@ g@@ o@@ n@@ al number : " % n , h@@ e@@ x@@ a@@ d@@ e@@ c@@ a@@ g@@ o@@ n@@ a@@ l@@ Num ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( )  m = s . count ( "8" ) n  if m == 0 or n < 11 : print ( 0 )  else : lo , hi = 1 , m while lo <= hi : mid = ( lo + hi ) // 2 if mid * 10 <= n - mid : lo = mid + 1 else : hi = mid - 1 print ( hi )  NEWLINE NL ENDMARKER
def s@@ o@@ l@@ v@@ e@@ _@@ sum ( n ) : NEWLINE INDENT return ( pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) / pow ( 9 , 3 ) - n * ( n + 1 ) / 18 NEWLINE DEDENT n = 3 NEWLINE print ( int ( s@@ o@@ l@@ v@@ e@@ _@@ sum ( n ) ) ) NEWLINE NL ENDMARKER
def count ( n ) : NEWLINE INDENT if n == 0 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT if n == 1 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( n * count ( n - 1 ) ) + ( ( n - 1 ) * count ( n - 2 ) ) NEWLINE DEDENT DEDENT A = [ 1 , 2 , 3 , 9 ] NEWLINE print ( count ( len ( A ) - 1 ) ) NEWLINE NL ENDMARKER
def r@@ h@@ o@@ m@@ b@@ u@@ s@@ area ( l , b ) : NEWLINE INDENT if ( l < 0 or b < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT return ( l * b ) / 2 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT l = 16 NEWLINE b = 6 NEWLINE print ( r@@ h@@ o@@ m@@ b@@ u@@ s@@ area ( l , b ) ) NEWLINE NL DEDENT ENDMARKER
def f@@ i@@ n@@ d@@ _@@ value ( a , n , k ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT sum += a [ i ] NEWLINE DEDENT return sum % k NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n , k = 5 , 3 ; NEWLINE a = [ 12 , 4 , 13 , 0 , 5 ] ; NEWLINE print ( f@@ i@@ n@@ d@@ _@@ value ( a , n , k ) ) NEWLINE NL DEDENT ENDMARKER
def i@@ s@@ D@@ i@@ v@@ B@@ y@@ 9 ( n ) : NEWLINE INDENT if ( n == 0 or n == 9 ) : NEWLINE INDENTINDENT return True NEWLINE DEDENT if ( n < 9 ) : NEWLINE INDENTINDENT return False NEWLINE DEDENT return i@@ s@@ D@@ i@@ v@@ B@@ y@@ 9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ) NEWLINE DEDENT for i in range ( 100 ) : NEWLINE INDENT if ( i@@ s@@ D@@ i@@ v@@ B@@ y@@ 9 ( i ) ) : NEWLINE INDENTINDENT print ( i , " " , end = "" ) NEWLINE NL DEDENT DEDENT ENDMARKER
t = int ( input ( ) ) count = 0 for i in range ( t ) : x , y , z = map ( int , input ( ) . split ( ) ) sum = x + y + z if sum >= 2 : count += 1 print ( count )                        NEWLINE NL ENDMARKER
a , b , c = map ( int , input ( ) . split ( " " ) )   ans = [ ] for s in range ( 1 , 81 ) : x = b * s ** a + c if x < 1 or x >= 10 ** 9 : continue z = len ( str ( x ) ) d = 0 for i in range ( z ) : d += int ( str ( x ) [ i ] ) if d == s : ans . append ( x )  print ( len ( ans ) ) for i in range ( len ( ans ) ) : print ( ans [ i ] , end = " " ) NEWLINE NL ENDMARKER
import sys , os , ioimport math , bisect , operatorinf , mod = float ( 'inf' ) , 10 ** 9 + 7 NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) k = [ ] for j in range ( n ) : k . append ( [ ] ) for i in range ( 2 * n ) : k [ a [ i ] - 1 ] . append ( i ) ans = k [ 0 ] [ 0 ] + k [ 0 ] [ 1 ] for i in range ( n - 1 ) : ans += abs ( k [ i ] [ 0 ] - k [ i + 1 ] [ 0 ] ) + abs ( k [ i ] [ 1 ] - k [ i + 1 ] [ 1 ] ) print ( ans ) NEWLINE NL ENDMARKER
def findSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE i = 1 NEWLINE while ( ( 1 << i ) < n ) : NEWLINE INDENTINDENT for j in range ( 0 , i ) : NEWLINE INDENTINDENTINDENT num = ( 1 << i ) + ( 1 << j ) NEWLINE if ( num <= n ) : NEWLINE INDENTINDENTINDENTINDENT sum += num NEWLINE DEDENT DEDENT i += 1 NEWLINE DEDENT return sum NEWLINE DEDENT n = 10 NEWLINE print ( findSum ( n ) ) NEWLINE NL ENDMARKER
def factorial ( n ) : NEWLINE INDENT res = 1 ; NEWLINE for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT res *= i ; NEWLINE DEDENT return res ; NEWLINE DEDENT def p@@ r@@ i@@ n@@ t@@ N@@ C@@ o@@ m@@ p@@ o@@ s@@ i@@ t@@ e ( n ) : NEWLINE INDENT fact = factorial ( n + 1 ) ; NEWLINE for i in range ( 2 , n + 2 ) : NEWLINE INDENTINDENT print ( fact + i , end = " " ) ; NEWLINE DEDENT DEDENT n = 4 ; NEWLINE p@@ r@@ i@@ n@@ t@@ N@@ C@@ o@@ m@@ p@@ o@@ s@@ i@@ t@@ e ( n ) ; NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 temp = mfor i in range ( len ( arr ) ) : if temp >= arr [ i ] : temp -= arr [ i ] else : ans += 1 temp = m temp -= arr [ i ] print ( ans + 1 ) NEWLINE NL ENDMARKER
n , w = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) g = a [ 0 ] b = a [ n ] if ( g * 2 ) <= b : b = ( g * 2 ) elif ( g * 2 ) > b : g = b / 2 ans = ( g * n ) + ( b * n ) if ans > w : ans = w@@ print ( ans ) NEWLINE NL ENDMARKER
def m@@ a@@ k@@ e@@ O@@ dd ( n ) : NEWLINE INDENT if n % 2 != 0 : NEWLINE INDENTINDENT return 1 ; NEWLINE DEDENT for i in range ( 2 , n ) : NEWLINE INDENTINDENT if ( n % i == 0 and ( int ) ( n / i ) % 2 == 1 ) : NEWLINE INDENTINDENTINDENT return i ; NEWLINE DEDENT DEDENT DEDENT n = 36 ; NEWLINE print ( m@@ a@@ k@@ e@@ O@@ dd ( n ) ) ; NEWLINE NL ENDMARKER
x1 , y1 = map ( int , input ( ) . split ( ) ) x2 , y2 = map ( int , input ( ) . split ( ) )  print ( max ( abs ( x1 - x2 ) , abs ( y1 - y2 ) ) ) NEWLINE NL ENDMARKER
s = input ( ) ; print ( len ( { s [ i : ] + s [ : i ] for i in range ( len ( s ) ) } ) ) NEWLINE NL ENDMARKER
def f@@ i@@ r@@ s@@ t@@ S@@ e@@ t@@ B@@ it ( n ) : NEWLINE INDENT x = n & ( n - 1 ) NEWLINE return ( n ^ x ) NEWLINE DEDENT n = 12 NEWLINE print ( f@@ i@@ r@@ s@@ t@@ S@@ e@@ t@@ B@@ it ( n ) ) NEWLINE NL ENDMARKER
s = input ( ) k = int ( input ( ) ) arr = set ( list ( s ) )  x = len ( arr )   if ( x >= k ) : print ( 0 ) else : k -= x rem = len ( s ) - x  NEWLINE NL ENDMARKER
d , l , v1 , v2 = list ( map ( int , input ( ) . split ( ) ) ) print ( ( l - d ) / ( v1 + v2 ) ) NEWLINE NL ENDMARKER
a = int ( input ( ) )  n = a@@ count = 0 arr = [ ]  while 1 : if 2 ** count <= a : arr . append ( 2 ** count ) n -= 2 ** count else : break if n <= 0 : break  count += 1  if n > 0 : arr . append ( n )  print ( len ( arr ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) s = input ( ) k = 1 z = '' a = [ s ] b = [ ] while k < n : z = s [ k : n ] if n % 2 == k % 2 : z += s [ 0 : k ] else : z += s [ 0 : k ] [ : : - 1 ] a . append ( z ) b . append ( k ) k += 1 print ( min ( a ) ) try : print ( b [ a . index ( min ( a ) ) ] ) except I@@ n@@ d@@ e@@ x@@ E@@ r@@ r@@ or : print ( n ) NEWLINE NL ENDMARKER
def f@@ i@@ n@@ d@@ Min ( arr , n ) : NEWLINE INDENT ans = 1 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT j = i + 1 NEWLINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEWLINE INDENTINDENTINDENT j += 1 NEWLINE DEDENT ans = max ( ans , j - i ) NEWLINE i = j - 1 NEWLINE DEDENT return n - ans NEWLINE DEDENT arr = [ 3 , 2 , 1 ] NEWLINE n = len ( arr ) NEWLINE print ( f@@ i@@ n@@ d@@ Min ( arr , n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) for i in range ( n ) : print ( ( 2 * n ) + i , end = " " ) NEWLINE NL ENDMARKER
s , l = map ( int , input ( ) . split ( ) ) i = 0 while ( s <= l ) : s = s * 3 l = l * 2 i = i + 1 print ( i ) NEWLINE NL ENDMARKER
import math NEWLINE def trianglearea ( a ) : NEWLINE INDENT if ( a < 0 ) : NEWLINE INDENTINDENT return - 1 ; NEWLINE DEDENT area = ( 3 * math . sqrt ( 3 ) * math . pow ( a , 2 ) ) / 4 ; NEWLINE return area ; NEWLINE DEDENT a = 6 ; NEWLINE print ( trianglearea ( a ) ) NEWLINE NL ENDMARKER
c , d = list ( map ( int , input ( ) . split ( ) ) ) n , m = list ( map ( int , input ( ) . split ( ) ) ) k = int ( input ( ) ) t = max ( ( m * n ) - k , 0 ) p = min ( c , n * d ) ans = p * ( t // n ) rem = t % n@@ ans = ans + min ( c , rem * d ) print ( ans ) NEWLINE NL ENDMARKER
import sys NEWLINE def f@@ i@@ n@@ d@@ LCM ( a , b ) : NEWLINE INDENT l@@ ar = max ( a , b ) NEWLINE small = min ( a , b ) NEWLINE i = l@@ ar NEWLINE while ( 1 ) : NEWLINE INDENTINDENT if ( i % small == 0 ) : NEWLINE INDENTINDENTINDENT return i NEWLINE DEDENT i += l@@ ar NEWLINE DEDENT DEDENT a = 5 NEWLINE b = 7 NEWLINE print ( "@@ L@@ C@@ M of " , a , " and " , b , " is " , f@@ i@@ n@@ d@@ LCM ( a , b ) , sep = "" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) ans = 0 c = 0 n = len ( s ) for i in range ( n - 1 ) : NEWLINE NL ENDMARKER
def f@@ i@@ n@@ d@@ W@@ i@@ n@@ n@@ e@@ r ( n ) : NEWLINE INDENT if ( ( n - 1 ) % 6 == 0 ) : NEWLINE INDENTINDENT print ( "@@ S@@ e@@ c@@ o@@ n@@ d P@@ l@@ a@@ y@@ e@@ r w@@ i@@ n@@ s the g@@ a@@ m@@ e@@ " ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "@@ F@@ i@@ r@@ st P@@ l@@ a@@ y@@ e@@ r w@@ i@@ n@@ s the g@@ a@@ m@@ e@@ " ) ; NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 7 ; NEWLINE f@@ i@@ n@@ d@@ W@@ i@@ n@@ n@@ e@@ r ( n ) ; NEWLINE NL DEDENT ENDMARKER
def s@@ t@@ r@@ i@@ n@@ g@@ T@@ o@@ I@@ nt ( str ) : NEWLINE INDENT if ( len ( str ) == 1 ) : NEWLINE INDENTINDENT return ord ( str [ 0 ] ) - ord ( '0' ) ; NEWLINE DEDENT y = s@@ t@@ r@@ i@@ n@@ g@@ T@@ o@@ I@@ nt ( str [ 1 : ] ) ; NEWLINE x = ord ( str [ 0 ] ) - ord ( '0' ) ; NEWLINE x = x * ( 10 ** ( len ( str ) - 1 ) ) + y ; NEWLINE return int ( x ) ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT str = "@@ 1@@ 2@@ 3@@ 5@@ " ; NEWLINE print ( s@@ t@@ r@@ i@@ n@@ g@@ T@@ o@@ I@@ nt ( str ) ) ; NEWLINE NL DEDENT ENDMARKER
a , b , c , d = map ( int , input ( ) . split ( ) )  m@@ i@@ s@@ h@@ a = max ( 3 * a / 10 , a - a / 250 * c ) vasya = max ( 3 * b / 10 , b - b / 250 * d )  if m@@ i@@ s@@ h@@ a > vasya : print ( "Misha" ) elif vasya > m@@ i@@ s@@ h@@ a : print ( "Vasya" ) else : print ( "Tie" ) NEWLINE NL ENDMARKER
def check ( n , m ) : NEWLINE INDENT if ( m % n == 0 ) : NEWLINE INDENTINDENT print ( "YES" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "NO" ) NEWLINE DEDENT DEDENT n = 5 NEWLINE m = 10 NEWLINE check ( n , m ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : NEWLINE INDENT n = int ( input ( ) ) NEWLINE a = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE print ( * ( [ 1 , 2 , n ] , [ - 1 ] ) [ a [ 0 ] + a [ 1 ] > a [ n - 1 ] ] ) NEWLINE NL DEDENT ENDMARKER
input ( ) c = input ( ) . replace ( ' ' , '' ) if '1' in c : c@@ o@@ u@@ n@@ t@@ _@@ zeros = 0 sum = 1 first = c . index ( '1' ) for i in range ( first , len ( c ) ) : if c [ i ] is '1' : sum = sum * ( c@@ o@@ u@@ n@@ t@@ _@@ zeros + 1 ) c@@ o@@ u@@ n@@ t@@ _@@ zeros = 0 continue c@@ o@@ u@@ n@@ t@@ _@@ zeros += 1 print ( sum ) else : print ( 0 )  NEWLINE NL ENDMARKER
def m@@ i@@ n@@ L@@ e@@ t@@ t@@ e@@ r@@ s@@ N@@ e@@ e@@ d@@ e@@ d ( n ) : NEWLINE INDENT if n % 26 == 0 : NEWLINE INDENTINDENT return ( n // 26 ) NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( ( n // 26 ) + 1 ) NEWLINE DEDENT DEDENT n = 52 NEWLINE print ( m@@ i@@ n@@ L@@ e@@ t@@ t@@ e@@ r@@ s@@ N@@ e@@ e@@ d@@ e@@ d ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) if n % 2 : print ( - 1 ) else : print ( * list ( range ( n , 0 , - 1 ) ) ) NEWLINE NL ENDMARKER
import sys  NEWLINE def answer ( x ) : test = 0 NEWLINE INDENT pass NEWLINE DEDENT k = 0 NEWLINE while test < x : NEWLINE NL ENDMARKER
def c@@ o@@ u@@ n@@ t@@ P@@ e@@ r@@ m@@ u@@ t@@ a@@ t@@ i@@ o@@ n@@ s ( N , B ) : NEWLINE INDENT x = B ** N NEWLINE y = B ** ( N - 1 ) NEWLINE print ( x - y ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N , B = 6 , 4 NEWLINE c@@ o@@ u@@ n@@ t@@ P@@ e@@ r@@ m@@ u@@ t@@ a@@ t@@ i@@ o@@ n@@ s ( N , B ) NEWLINE NL DEDENT ENDMARKER
for _ in range ( int ( input ( ) ) ) : x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) )  if x1 == x2 : print ( abs ( y2 - y1 ) )  elif y1 == y2 : print ( abs ( x2 - x1 ) )  else : print ( abs ( x2 - x1 ) + 2 + abs ( y2 - y1 ) ) NEWLINE NL ENDMARKER
n = input ( ) m = n . split ( ) [ 1 ] n = n . split ( ) [ 0 ] i , j = len ( n ) , len ( m ) k = max ( i , j ) t = min ( i , j ) s = 0 for i in range ( k ) : if i < t : s += ( int ( n [ - i - 1 ] ) + int ( m [ i ] ) ) * 10 ** i elif len ( n ) > len ( m ) : s += int ( n [ - i - 1 ] ) * 10 ** i else : s += int ( m [ i ] ) * 10 ** iprint ( s ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) % 6 x = int ( input ( ) ) p = [ "@@ 0@@ 1@@ 2@@ " , "@@ 1@@ 0@@ 2@@ " , "@@ 1@@ 2@@ 0" , "@@ 2@@ 1@@ 0@@ " , "@@ 2@@ 0@@ 1@@ " , "@@ 0@@ 2@@ 1@@ " ] print ( p [ n ] [ x ] ) NEWLINE NL ENDMARKER
def check ( st ) : NEWLINE INDENT n = len ( st ) NEWLINE d@@ i@@ g@@ i@@ t@@ Sum = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT d@@ i@@ g@@ i@@ t@@ Sum = d@@ i@@ g@@ i@@ t@@ Sum + ( int ) ( st [ i ] ) NEWLINE DEDENT return ( d@@ i@@ g@@ i@@ t@@ Sum % 9 == 0 ) NEWLINE DEDENT st = "@@ 9@@ 9@@ 3@@ 3@@ 3@@ " NEWLINE if ( check ( st ) ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
num = int ( input ( ) ) NEWLINE for _ in range ( num ) : string = str ( input ( ) ) NEWLINE print ( len ( string ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) NEWLINE x = [ ] NEWLINE i = nwhile NEWLINE i > 0 : NEWLINE if n % i == 0 : x . append ( i ) NEWLINE n = i NEWLINE i = i - 1 NEWLINE for i in x : print ( i , end = " " ) NEWLINE NL ENDMARKER
def c@@ a@@ s@@ s@@ ini ( n ) : NEWLINE INDENT return - 1 if ( n & 1 ) else 1 NEWLINE DEDENT n = 5 NEWLINE print ( c@@ a@@ s@@ s@@ ini ( n ) ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) )  r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( )  num = 1  for i in arr : print ( i , end = " " ) l@@ i@@ m = n - 1 while l@@ i@@ m : if num not in arr : print ( num , end = " " )  l@@ i@@ m -= 1 num += 1   print ( )   NEWLINE NL ENDMARKER
def f@@ i@@ n@@ d@@ T@@ r@@ i@@ a@@ n@@ g@@ u@@ l@@ a@@ r@@ Number ( n ) : NEWLINE INDENT return ( n * ( n + 1 ) ) / 2 NEWLINE DEDENT def printSeries ( n ) : NEWLINE INDENT prev = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT curr = f@@ i@@ n@@ d@@ T@@ r@@ i@@ a@@ n@@ g@@ u@@ l@@ a@@ r@@ Number ( i ) NEWLINE curr = int ( curr + prev ) NEWLINE print ( curr , end = ' ' ) NEWLINE prev = curr NEWLINE DEDENT DEDENT n = 10 NEWLINE printSeries ( n ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : a , b , n = [ int ( x ) for x in input ( ) . split ( ) ] i = 0 while a <= n and b <= n : if a < b : a += b else : b += a i += 1 print ( i ) NEWLINE NL ENDMARKER
l , r = list ( map ( int , input ( ) . split ( ) ) )  a = [ ] i = l@@ while i <= r - 1 : a . append ( [ i , i + 1 ] ) i += 2  if a : print ( 'YES' ) for i in a : print ( f@@ '@@ {@@ i@@ [@@ 0@@ ]@@ } {@@ i@@ [@@ 1@@ ]@@ }@@ ' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
from collections import defaultdict , O@@ r@@ d@@ e@@ r@@ e@@ d@@ D@@ i@@ ct , Counterfrom sys import stdin , stdoutfrom bisect import bisect_left , bisect_right NEWLINE NL ENDMARKER
def g@@ e@@ t@@ P@@ a@@ s@@ s@@ i@@ n@@ g@@ C@@ ars ( A , n ) : NEWLINE INDENT c@@ o@@ u@@ n@@ t@@ O@@ n@@ e = 0 ; result = 0 NEWLINE while n >= 1 : NEWLINE INDENTINDENT if A [ n - 1 ] == 1 : NEWLINE INDENTINDENTINDENT c@@ o@@ u@@ n@@ t@@ O@@ n@@ e += 1 NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT result += c@@ o@@ u@@ n@@ t@@ O@@ n@@ e NEWLINE DEDENT n -= 1 NEWLINE DEDENT return result NEWLINE DEDENT A = [ 0 , 1 , 0 , 1 , 1 ] NEWLINE n = len ( A ) NEWLINE print ( g@@ e@@ t@@ P@@ a@@ s@@ s@@ i@@ n@@ g@@ C@@ ars ( A , n ) ) NEWLINE NL ENDMARKER
def compute ( ) : NEWLINE INDENT L@@ E@@ N@@ G@@ T@@ H = 50 NEWLINE ways = [ 1 ] + [ 0 ] * L@@ E@@ N@@ G@@ T@@ H NEWLINE for n in range ( 1 , len ( ways ) ) : NEWLINE INDENTINDENT ways [ n ] += sum ( ways [ max ( n - 4 , 0 ) : n ] ) NEWLINE DEDENT return str ( ways [ - 1 ] ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( compute ( ) ) NEWLINE NL DEDENT ENDMARKER
import mathdef i@@ s@@ k ( n , d , k ) : for i in n : if i in d : d [ i ] = 1 for i in range ( k + 1 ) : if str ( i ) in d and d [ str ( i ) ] == 0 : return False return True  n , k = map ( int , input ( ) . split ( ) ) d = { } c = 0 for _ in range ( n ) : s = input ( ) for i in range ( k + 1 ) : d [ str ( i ) ] = 0 if i@@ s@@ k ( s , d , k ) : c += 1 print ( c ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] c@@ h@@ o@@ s@@ e@@ n = set ( ) p = [ 0 ] * nfor i in range ( 1 , n + 1 ) : b = - 1 for j in range ( n ) : if not j in c@@ h@@ o@@ s@@ e@@ n and all ( a [ j ] [ k ] <= i for k in range ( n ) ) and all ( a [ k ] [ j ] <= i for k in range ( n ) ) : b = j p [ b ] = i c@@ h@@ o@@ s@@ e@@ n . add ( b ) print ( * p ) NEWLINE NL ENDMARKER
a = input ( ) NEWLINE b = input ( ) NEWLINE a = [ x for x in a ] NEWLINE b = [ y for y in b ]  x = [ '0' if i@@ 1 == i@@ 2 else '1' for ( i@@ 1 , i@@ 2 ) in zip ( a , b ) ] NEWLINE print ( '' . join ( x ) ) NEWLINE NL ENDMARKER
def count ( n ) : NEWLINE INDENT return pow ( 2 , n - 1 ) NEWLINE DEDENT n = 4 NEWLINE print ( count ( n ) ) NEWLINE NL ENDMARKER
def c@@ o@@ u@@ n@@ t@@ N@@ o@@ n@@ D@@ e@@ c@@ r@@ e@@ a@@ s@@ i@@ n@@ g ( n ) : NEWLINE INDENT N = 10 NEWLINE count = 1 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT count = int ( count * ( N + i - 1 ) ) NEWLINE count = int ( count / i ) NEWLINE DEDENT return count NEWLINE DEDENT n = 3 ; NEWLINE print ( c@@ o@@ u@@ n@@ t@@ N@@ o@@ n@@ D@@ e@@ c@@ r@@ e@@ a@@ s@@ i@@ n@@ g ( n ) ) NEWLINE NL ENDMARKER
import math as m NEWLINE def i@@ s@@ P@@ e@@ n@@ t@@ a@@ g@@ o@@ n@@ al ( n ) : NEWLINE INDENT n = ( 1 + m . sqrt ( 24 * N + 1 ) ) / 6 NEWLINE return ( ( n - int ( n ) ) == 0 ) NEWLINE DEDENT N = 19 NEWLINE if ( i@@ s@@ P@@ e@@ n@@ t@@ a@@ g@@ o@@ n@@ al ( N ) ) : NEWLINE INDENT print ( N , " is pentagonal " ) NEWLINE DEDENT else : NEWLINE INDENT print ( N , " is not p@@ e@@ n@@ t@@ a@@ g@@ o@@ n@@ a@@ l@@ " ) NEWLINE NL DEDENT ENDMARKER
def SUM ( n , m ) : NEWLINE INDENT if ( m == 1 ) : NEWLINE INDENTINDENT return ( n * ( n + 1 ) / 2 ) NEWLINE DEDENT sum = SUM ( n , m - 1 ) NEWLINE return int ( sum * ( sum + 1 ) / 2 ) NEWLINE DEDENT n = 5 NEWLINE m = 3 NEWLINE print ( "@@ S@@ U@@ M@@ (" , n , ", " , m , "@@ )@@ :" , SUM ( n , m ) ) NEWLINE NL ENDMARKER
import mathn , m = map ( int , input ( ) . split ( ) ) fac1 = 1 fac2 = 1 i@@ 1 = 1 i@@ 2 = 1 while ( i@@ 1 <= n and i@@ 2 <= m ) : fac1 = fac1 * i@@ 1 fac2 = fac2 * i@@ 2 i@@ 1 = i@@ 1 + 1 i@@ 2 = i@@ 2 + 1  print ( math . gcd ( fac1 , fac2 ) ) NEWLINE NL ENDMARKER
a = input ( ) b = input ( )  f = True  for i , j in zip ( a , b ) : if j > i : f = False break  if f : print ( b )  else : print ( - 1 ) NEWLINE NL ENDMARKER
s = input ( ) n1 = s . count ( 'a' ) n2 = s . count ( 'b' ) n@@ 3 = s . count ( 'c' ) n@@ 4 = s . count ( 'ab' ) n@@ 5 = s . count ( 'ba' ) if ( n1 == n@@ 3 or n2 == n@@ 3 ) and n@@ 4 == 1 and n@@ 5 == 0 and s [ - n@@ 3 : ] . count ( 'c' ) == n@@ 3 : print ( 'YES' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readline  n = int ( input ( ) ) s = input ( ) for i in range ( n - 1 ) : if s [ i ] != s [ i + 1 ] : print ( "YES" ) print ( s [ i ] , s [ i + 1 ] , sep = "" ) exit ( ) print ( "NO" ) NEWLINE NL ENDMARKER
a , b , c = map ( int , input ( ) . split ( ) ) d , e , f = map ( int , input ( ) . split ( ) ) g , h , i = map ( int , input ( ) . split ( ) )  sum1 = a + b + c@@ sum2 = d + e + f@@ s@@ u@@ m@@ 3 = g + h + i@@ a = ( sum1 + sum2 + s@@ u@@ m@@ 3 ) // 2 - ( sum1 ) e = ( sum1 + sum2 + s@@ u@@ m@@ 3 ) // 2 - ( sum2 ) i = ( sum1 + sum2 + s@@ u@@ m@@ 3 ) // 2 - ( s@@ u@@ m@@ 3 ) print ( a , b , c ) print ( d , e , f ) print ( g , h , i )      NEWLINE NL ENDMARKER
def swap ( xp , yp ) : NEWLINE INDENT xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEWLINE yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEWLINE xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEWLINE DEDENT x = [ 10 ] NEWLINE swap ( x , x ) NEWLINE print ( "After swap(&x, &x): x = " , x [ 0 ] ) NEWLINE NL ENDMARKER
def b@@ i@@ t@@ w@@ i@@ s@@ e@@ A@@ n@@ d@@ O@@ dd ( n ) : NEWLINE INDENT result = 1 ; NEWLINE for i in range ( 3 , n + 1 , 2 ) : NEWLINE INDENTINDENT result = ( result & i ) ; NEWLINE DEDENT return result ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 10 ; NEWLINE print ( b@@ i@@ t@@ w@@ i@@ s@@ e@@ A@@ n@@ d@@ O@@ dd ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
from math import pi  n = int ( input ( ) ) r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( ) arr . sort ( reverse = True ) arr . append ( 0 ) ans = 0.0 i = 0 while i < n : ans += pi * ( arr [ i ] ** 2 - arr [ i + 1 ] ** 2 ) i += 2  print ( f@@ "@@ {@@ a@@ n@@ s@@ :@@ .@@ 1@@ 0@@ f@@ }" ) NEWLINE NL ENDMARKER
d = { '@@ p@@ o@@ l@@ y@@ c@@ a@@ r@@ p@@ ' : 1 } for _ in range ( int ( input ( ) ) ) : a , b , c = input ( ) . lower ( ) . split ( ) ; d [ a ] = d [ c ] + 1 print ( max ( d . values ( ) ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) c = 0 for i in range ( n - 2 ) : if s [ i ] == 'x' and s [ i + 1 ] == 'x' and s [ i + 2 ] == 'x' : c += 1 print ( c ) NEWLINE NL ENDMARKER
from sys import stdininput = lambda : stdin . readline ( ) from math import ceil , sqrt , g@@ c@@ d@@ for _ in range ( int ( input ( ) ) ) : n , m , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) flag = 'YES' for i in range ( n - 1 ) : if l [ i + 1 ] > l [ i ] : if l [ i + 1 ] - l [ i ] > k : if m < l [ i + 1 ] - l [ i ] - k : flag = 'NO' break else : m -= ( l [ i + 1 ] - l [ i ] - k ) NEWLINE NL ENDMARKER
s = input ( ) . split ( ' ' ) n = int ( s [ 0 ] ) k = int ( s [ 1 ] ) s = input ( ) . split ( ' ' ) l = len ( s ) count = 0 for i in range ( l ) : if ( k + int ( s [ i ] ) <= 5 ) : count = count + 1  print ( int ( count / 3 ) ) NEWLINE NL ENDMARKER
n , s = map ( int , input ( ) . split ( ) ) ans = s@@ for _ in range ( n ) : f , t = map ( int , input ( ) . split ( ) ) ans = max ( ans , f + t ) print ( ans ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : L = list ( map ( int , input ( ) . split ( ) ) ) x = L [ - 1 ] y = L [ - 2 ] if ( x // y ) <= L [ 0 ] : if ( x % y ) <= L [ 1 ] : print ( "YES" ) else : print ( "NO" ) else : if ( y * ( ( x // y ) - L [ 0 ] ) ) + ( x % y ) > L [ 1 ] : print ( "NO" ) else : print ( "YES" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 mx = 0 for i in range ( n ) : mx = max ( a [ i ] , mx ) if mx == i + 1 : ans += 1 print ( ans ) NEWLINE NL ENDMARKER
from math import tan NEWLINE def polyarea ( n , a ) : NEWLINE INDENT if ( a < 0 and n < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEWLINE return A NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = 9 NEWLINE n = 6 NEWLINE print ( '{0:.6}' . format ( polyarea ( n , a ) ) ) NEWLINE NL DEDENT ENDMARKER
m , n = map ( int , input ( ) . split ( ) ) if ( m == n ) : print ( m ) else : print ( 2 ) NEWLINE NL ENDMARKER
def factorial ( N ) : NEWLINE INDENT fact = 1 NEWLINE for i in range ( 1 , N + 1 ) : NEWLINE INDENTINDENT fact = fact * i NEWLINE DEDENT return fact NEWLINE DEDENT def nthTerm ( N ) : NEWLINE INDENT return ( factorial ( N ) * ( N + 2 ) // 2 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 6 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) if a % 2 : a += 1 if a + 2 > b : print ( - 1 ) else : print ( a , a + 1 , a + 2 ) NEWLINE NL ENDMARKER
def c@@ a@@ l@@ Num ( year ) : NEWLINE INDENT return ( year // 4 ) - ( year // 100 ) + ( year // 400 ) ; NEWLINE DEDENT def l@@ e@@ a@@ p@@ Num ( l , r ) : NEWLINE INDENT l -= 1 ; NEWLINE num1 = c@@ a@@ l@@ Num ( r ) ; NEWLINE num2 = c@@ a@@ l@@ Num ( l ) ; NEWLINE print ( num1 - num2 ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT l1 = 1 ; r1 = 400 ; NEWLINE l@@ e@@ a@@ p@@ Num ( l1 , r1 ) ; NEWLINE l2 = 400 ; r2 = 2000 ; NEWLINE l@@ e@@ a@@ p@@ Num ( l2 , r2 ) ; NEWLINE NL DEDENT ENDMARKER
input ( ) days = map ( int , input ( ) . split ( ) ) f@@ o@@ l@@ d@@ e@@ r@@ s = [ ] f@@ c = 0 c = 0  for i in days : if i < 0 : if c < 2 : c += 1 else : f@@ c += 1 c = 1 if len ( f@@ o@@ l@@ d@@ e@@ r@@ s ) <= f@@ c : f@@ o@@ l@@ d@@ e@@ r@@ s . append ( 0 ) f@@ o@@ l@@ d@@ e@@ r@@ s [ f@@ c ] += 1  print ( f@@ c + 1 ) print ( * f@@ o@@ l@@ d@@ e@@ r@@ s ) NEWLINE NL ENDMARKER
import sys , mathfrom collections import defaultdict , dequeinput = sys . stdin . readline  n = int ( input ( ) ) c = 0 for i in range ( 1 , n + 1 ) : for j in range ( i + 1 , n + 1 ) : k = i ^ j if ( i < j < k <= n and i + j > k and j + k > i and i + k > j ) : NEWLINE NL ENDMARKER
def x@@ o@@ r@@ C@@ a@@ l@@ c ( k ) : NEWLINE INDENT if ( k == 1 ) : NEWLINE INDENTINDENT return 2 NEWLINE DEDENT if ( ( ( k + 1 ) & k ) == 0 ) : NEWLINE INDENTINDENT return k / 2 NEWLINE DEDENT return 1 ; NEWLINE DEDENT k = 31 NEWLINE print ( int ( x@@ o@@ r@@ C@@ a@@ l@@ c ( k ) ) ) NEWLINE NL ENDMARKER
from math import ceiln , k = map ( int , input ( ) . split ( ) ) w = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) m@@ i@@ n@@ D@@ ay = 0 total = 0 for i in range ( 1 , n + 1 ) : total += ceil ( w [ i ] / k ) m@@ i@@ n@@ D@@ ay = ceil ( total / 2 ) print ( m@@ i@@ n@@ D@@ ay ) NEWLINE NL ENDMARKER
from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( 'input.txt' ) ) : stdin = open ( "input.txt" , "r" ) NEWLINE NL ENDMARKER
def getTotalXorOfSubarrayXors ( arr , N ) : NEWLINE INDENT res = 0 NEWLINE for i in range ( 0 , N ) : NEWLINE INDENTINDENT for j in range ( i , N ) : NEWLINE INDENTINDENTINDENT for k in range ( i , j + 1 ) : NEWLINE INDENTINDENTINDENTINDENT res = res ^ arr [ k ] NEWLINE DEDENT DEDENT DEDENT return res NEWLINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEWLINE N = len ( arr ) NEWLINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEWLINE NL ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return 7 * pow ( n , 2 ) - 7 * n + 7 NEWLINE DEDENT N = 4 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL ENDMARKER
import math as m NEWLINE def f@@ i@@ n@@ d@@ Min ( a , n ) : NEWLINE INDENT _sum = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT _sum += m . log ( a [ i ] ) NEWLINE DEDENT x = m . exp ( _sum / n ) NEWLINE return int ( x + 1 ) NEWLINE DEDENT a = [ 3 , 2 , 1 , 4 ] NEWLINE n = len ( a ) NEWLINE print ( f@@ i@@ n@@ d@@ Min ( a , n ) ) NEWLINE NL ENDMARKER
def findCount ( m , n ) : NEWLINE INDENT num1 = 0 NEWLINE for i in range ( 0 , m ) : NEWLINE INDENTINDENT num1 = ( num1 * 10 ) + 9 NEWLINE DEDENT num2 = 0 NEWLINE for i in range ( 0 , ( m - 1 ) ) : NEWLINE INDENTINDENT num2 = ( num2 * 10 ) + 9 NEWLINE DEDENT return int ( ( num1 / n ) - ( num2 / n ) ) NEWLINE DEDENT m = 2 ; n = 6 NEWLINE print ( findCount ( m , n ) ) NEWLINE NL ENDMARKER
from collections import Counter n , k = map ( int , input ( ) . split ( ) ) c = Counter ( ) ans = - 1 for i in range ( 1 , k + 1 ) : x = int ( input ( ) ) c [ x % n ] += 1 if ans == - 1 and c [ x % n ] > 1 : ans = i print ( ans ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) kmin = n // mkmax = n - m@@ pairMin = m * kmin * ( kmin - 1 ) // 2 + kmin * ( n % m ) pairMax = ( kmax + 1 ) * kmax // 2 print ( pairMin , pairMax ) NEWLINE NL ENDMARKER
def m@@ i@@ n@@ I@@ t@@ e@@ ms ( k , r ) : NEWLINE INDENT for i in range ( 1 , 10 ) : NEWLINE INDENTINDENT if ( ( i * k - r ) % 10 == 0 or ( i * k ) % 10 == 0 ) : NEWLINE INDENTINDENTINDENT return i NEWLINE DEDENT DEDENT return 10 ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT k , r = 15 , 2 ; NEWLINE print ( m@@ i@@ n@@ I@@ t@@ e@@ ms ( k , r ) ) NEWLINE NL DEDENT ENDMARKER
a = input ( ) c = max ( a ) print ( c * a . count ( c ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) t = n@@ home = input ( ) d@@ e@@ p@@ a@@ r@@ t@@ u@@ r@@ e = [ ] while t > 0 : f@@ l@@ i@@ g@@ h@@ t = input ( ) d@@ e@@ p@@ a@@ r@@ t@@ u@@ r@@ e . append ( f@@ l@@ i@@ g@@ h@@ t [ : 3 ] ) t -= 1  if n % 2 == 0 : print ( '@@ h@@ o@@ m@@ e@@ ' ) else : print ( '@@ c@@ o@@ n@@ t@@ e@@ s@@ t@@ ' ) NEWLINE NL ENDMARKER
def solve ( A , B ) : NEWLINE INDENT p = B / 2 NEWLINE M = int ( 4 * p ) NEWLINE N = 1 NEWLINE O = - 2 * A NEWLINE Q = int ( A * A + 4 * p * p ) NEWLINE return [ M , N , O , Q ] NEWLINE DEDENT a = 1 NEWLINE b = 1 NEWLINE print ( * solve ( a , b ) ) NEWLINE NL ENDMARKER
def A@@ dd ( x , y ) : NEWLINE INDENT while ( y != 0 ) : NEWLINE INDENTINDENT c@@ a@@ r@@ r@@ y = x & y NEWLINE x = x ^ y NEWLINE y = c@@ a@@ r@@ r@@ y << 1 NEWLINE DEDENT return x NEWLINE DEDENT print ( A@@ dd ( 15 , 32 ) ) NEWLINE NL ENDMARKER
import osimport sysfrom io import BytesIO , IOBaseimport mathimport itertoolsimport bisectimport heapq NEWLINE NL ENDMARKER
def a@@ n@@ d@@ O@@ p@@ e@@ r@@ a@@ t@@ or ( a , b ) : NEWLINE INDENT while ( a < b ) : NEWLINE INDENTINDENT b -= ( b & - b ) NEWLINE DEDENT return b NEWLINE DEDENT a , b = 10 , 15 NEWLINE print ( a@@ n@@ d@@ O@@ p@@ e@@ r@@ a@@ t@@ or ( a , b ) ) NEWLINE NL ENDMARKER
f1 , t1 = [ int ( i ) for i in input ( ) . split ( " " ) ] f2 , t2 = [ int ( i ) for i in input ( ) . split ( " " ) ] time = [ str ( i ) for i in input ( ) . split ( " " ) ] time = time [ 0 ]  t@@ h , t@@ m = time . split ( ":" ) t@@ h = int ( t@@ h ) t@@ m = int ( t@@ m )  NEWLINE NL ENDMARKER
def countPairs ( n ) : NEWLINE INDENT count = 0 ; NEWLINE for x in range ( 1 , n ) : NEWLINE INDENTINDENT for y in range ( x + 1 , n + 1 ) : NEWLINE INDENTINDENTINDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEWLINE INDENTINDENTINDENTINDENT count += 1 ; NEWLINE DEDENT DEDENT DEDENT return count ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 6 ; NEWLINE print ( countPairs ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
def f@@ i@@ n@@ d@@ E@@ v@@ e@@ n@@ P@@ a@@ i@@ r ( A , N ) : NEWLINE INDENT count = 0 NEWLINE for i in range ( N ) : NEWLINE INDENTINDENT if ( not ( A [ i ] & 1 ) ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT return count * ( count - 1 ) // 2 NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT A = [ 5 , 6 , 2 , 8 ] NEWLINE N = len ( A ) NEWLINE print ( f@@ i@@ n@@ d@@ E@@ v@@ e@@ n@@ P@@ a@@ i@@ r ( A , N ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) m@@ a@@ x@@ count , count = 1 , 1 for i in range ( n - 1 ) : if arr [ i ] > arr [ i + 1 ] : count = 1 else : count += 1 if count > m@@ a@@ x@@ count : m@@ a@@ x@@ count = c@@ o@@ u@@ n@@ t@@ print ( m@@ a@@ x@@ count ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) t@@ r@@ e@@ e = [ [ ] for i in range ( n + 1 ) ] for i in range ( 2 , n + 1 ) : p = int ( input ( ) ) t@@ r@@ e@@ e [ p ] . append ( i ) NEWLINE NL ENDMARKER
import syssys . stdin = open ( "input.txt" , "r" ) sys . stdout = open ( "@@ o@@ u@@ t@@ p@@ u@@ t@@ .@@ t@@ x@@ t@@ " , "@@ w@@ " ) m@@ a@@ t@@ ch = input ( ) r@@ a@@ i@@ l = int ( input ( ) ) if m@@ a@@ t@@ ch == "@@ f@@ r@@ o@@ n@@ t@@ " : if r@@ a@@ i@@ l == 1 : print ( "L" ) else : print ( "R" ) else : if r@@ a@@ i@@ l == 1 : print ( "R" ) else : print ( "L" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( 6 * n * ( n - 1 ) + 1 ) NEWLINE NL ENDMARKER
x , y = map ( int , input ( ) . split ( ) ) e@@ r@@ g = ( ( x ) * ( y ) ) // 2 print ( e@@ r@@ g ) NEWLINE NL ENDMARKER
def C@@ a@@ l@@ c@@ u@@ l@@ a@@ t@@ e@@ _@@ G@@ S@@ T ( o@@ r@@ g@@ _@@ cost , N@@ _@@ p@@ r@@ i@@ ce ) : NEWLINE INDENT return ( ( ( N@@ _@@ p@@ r@@ i@@ ce - o@@ r@@ g@@ _@@ cost ) * 100 ) / o@@ r@@ g@@ _@@ cost ) ; NEWLINE DEDENT o@@ r@@ g@@ _@@ cost = 100 NEWLINE N@@ _@@ p@@ r@@ i@@ ce = 120 NEWLINE print ( "@@ G@@ S@@ T = " , end = '' ) NEWLINE print ( round ( C@@ a@@ l@@ c@@ u@@ l@@ a@@ t@@ e@@ _@@ G@@ S@@ T ( o@@ r@@ g@@ _@@ cost , N@@ _@@ p@@ r@@ i@@ ce ) ) , end = '' ) NEWLINE print ( "%" ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) NEWLINE l = list ( ) NEWLINE for i in range ( n ) : x = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE l . append ( x ) NEWLINE for i in l : c = 1 NEWLINE for j in l : if NEWLINE abs ( i [ 0 ] - j [ 0 ] ) + abs ( i [ 1 ] - j [ 1 ] ) > k : c = 0 NEWLINE break NEWLINE if c == 1 : print ( 1 ) NEWLINE break NEWLINE if c == 0 : print ( - 1 )  NEWLINE NL ENDMARKER
import math as mt NEWLINE def ReuleauxArea ( r ) : NEWLINE INDENT if ( r < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT A = 0.70477 * 2 * pow ( r , 2 ) NEWLINE return A NEWLINE DEDENT r = 6 NEWLINE print ( ReuleauxArea ( r ) ) NEWLINE NL ENDMARKER
def p@@ r@@ i@@ n@@ t@@ L@@ i@@ n@@ e@@ s ( n , k ) : NEWLINE INDENT for i in range ( n ) : NEWLINE INDENTINDENT print ( k * ( 6 * i + 1 ) , k * ( 6 * i + 2 ) , k * ( 6 * i + 3 ) , k * ( 6 * i + 5 ) ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n , k = 2 , 2 NEWLINE p@@ r@@ i@@ n@@ t@@ L@@ i@@ n@@ e@@ s ( n , k ) NEWLINE NL DEDENT ENDMARKER
print ( ( int ( input ( ) ) - 1 ) // 2 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) while n % 3 == 0 : n //= 3 print ( n // 3 + 1 ) NEWLINE NL ENDMARKER
def fifthPowerSum ( n ) : NEWLINE INDENT return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) // 12 NEWLINE DEDENT n = 5 NEWLINE print ( fifthPowerSum ( n ) ) NEWLINE NL ENDMARKER
import osimport sysfrom io import BytesIO , IOBaseimport mathimport itertoolsimport bisectimport heapq NEWLINE NL ENDMARKER
t = int ( input ( ) ) for i in range ( t ) : a , b , c = map ( int , input ( ) . split ( ) ) s = a + b + c print ( s // 2 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) s = list ( s ) count = 0 for i in range ( len ( s ) ) : if ( s [ i ] == '<' ) : count += 1 else : break for i in range ( len ( s ) - 1 , - 1 , - 1 ) : if ( s [ i ] == '>' ) : count += 1 else : break print ( count ) NEWLINE NL ENDMARKER
def p@@ r@@ i@@ n@@ t@@ S@@ e@@ r@@ i@@ e@@ s@@ summ ( N ) : NEWLINE INDENT summ = 0 NEWLINE for i in range ( 1 , N + 1 ) : NEWLINE INDENTINDENT summ += pow ( i , i - 1 ) NEWLINE DEDENT print ( summ ) NEWLINE DEDENT N = 5 NEWLINE p@@ r@@ i@@ n@@ t@@ S@@ e@@ r@@ i@@ e@@ s@@ summ ( N ) NEWLINE NL ENDMARKER
def i@@ s@@ P@@ r@@ o@@ d@@ u@@ c@@ t@@ E@@ v@@ e@@ n ( arr , n ) : NEWLINE INDENT for i in range ( 0 , n ) : NEWLINE INDENTINDENT if ( ( arr [ i ] & 1 ) == 0 ) : NEWLINE INDENTINDENTINDENT return True NEWLINE DEDENT DEDENT return False NEWLINE DEDENT arr = [ 2 , 4 , 3 , 5 ] NEWLINE n = len ( arr ) NEWLINE if ( i@@ s@@ P@@ r@@ o@@ d@@ u@@ c@@ t@@ E@@ v@@ e@@ n ( arr , n ) ) : NEWLINE INDENT print ( "Even" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "Odd" ) NEWLINE NL DEDENT ENDMARKER
import math NEWLINE def n@@ o@@ n@@ square ( n ) : NEWLINE INDENT return n + ( int ) ( 0.5 + math . sqrt ( n ) ) NEWLINE DEDENT def p@@ r@@ i@@ n@@ t@@ N@@ o@@ n@@ S@@ q@@ u@@ are ( n ) : NEWLINE INDENT for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT print ( n@@ o@@ n@@ square ( i ) , end = " " ) NEWLINE DEDENT DEDENT n = 10 NEWLINE p@@ r@@ i@@ n@@ t@@ N@@ o@@ n@@ S@@ q@@ u@@ are ( n ) NEWLINE NL ENDMARKER
def f@@ i@@ n@@ d@@ S@@ u@@ b@@ A@@ r@@ r ( arr , n ) : NEWLINE INDENT for i in range ( n - 1 ) : NEWLINE INDENTINDENT if ( abs ( arr [ i ] - arr [ i + 1 ] ) >= 2 ) : NEWLINE INDENTINDENTINDENT print ( arr [ i ] , arr [ i + 1 ] , end = "" ) ; NEWLINE return ; NEWLINE DEDENT DEDENT print ( - 1 ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 1 , 2 , 4 , 6 , 7 ] ; NEWLINE n = len ( arr ) ; NEWLINE f@@ i@@ n@@ d@@ S@@ u@@ b@@ A@@ r@@ r ( arr , n ) ; NEWLINE NL DEDENT ENDMARKER
n , p = list ( map ( int , input ( ) . split ( ) ) ) s = list ( input ( ) ) s [ n - 1 ] = chr ( ord ( s [ n - 1 ] ) + 1 ) i = n - 1 while i >= 0 and i < n : if ord ( s [ i ] ) >= ord ( 'a' ) + p : s [ i ] = 'a' i -= 1 s [ i ] = chr ( ord ( s [ i ] ) + 1 ) elif i > 0 and s [ i ] == s [ i - 1 ] or i > 1 and s [ i ] == s [ i - 2 ] : s [ i ] = chr ( ord ( s [ i ] ) + 1 ) else : i += 1 print ( "NO" if i < 0 else "" . join ( s ) ) NEWLINE NL ENDMARKER
def p@@ e@@ n@@ t@@ d@@ i@@ a@@ g@@ o@@ n@@ al ( a ) : NEWLINE INDENT if ( a < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT d = 1@@ .@@ 22 * a NEWLINE return d NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = 6 NEWLINE print ( p@@ e@@ n@@ t@@ d@@ i@@ a@@ g@@ o@@ n@@ al ( a ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) )  if ( n % 2 ) == 0 : print ( 'Mahmoud' ) else : print ( 'Ehab' ) NEWLINE NL ENDMARKER
s = list ( input ( ) . split ( ) )  if s [ - 1 ] == "@@ w@@ e@@ e@@ k@@ " : if s [ 0 ] in "56" : print ( 53 ) else : print ( 52 ) else : if int ( s [ 0 ] ) == 31 : print ( 7 ) elif int ( s [ 0 ] ) == 30 : print ( 11 ) else : print ( 12 ) NEWLINE NL ENDMARKER
def power ( x , y ) : NEWLINE INDENT if ( y == 0 ) : return 1 NEWLINE temp = power ( x , int ( y / 2 ) ) NEWLINE if ( y % 2 == 0 ) : NEWLINE INDENTINDENT return temp * temp NEWLINE DEDENT else : NEWLINE INDENTINDENT if ( y > 0 ) : return x * temp * temp NEWLINE else : return ( temp * temp ) / x NEWLINE DEDENT DEDENT x , y = 2 , - 3 NEWLINE print ( '@@ %@@ .@@ 6@@ f@@ ' % ( power ( x , y ) ) ) NEWLINE NL ENDMARKER
n , q = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n ) : a [ i ] = ( a [ i - 1 ] + a [ i ] )  ans = 0 for i in range ( q ) : x , y = map ( int , input ( ) . split ( ) ) temp = a [ y - 1 ] if x != 1 : temp -= a [ x - 2 ] ans = max ( ans , ans + temp ) print ( ans ) NEWLINE NL ENDMARKER
def g@@ e@@ t@@ M@@ i@@ n@@ V@@ al ( p , q ) : NEWLINE INDENT if q % p == 0 : NEWLINE INDENTINDENT return p NEWLINE DEDENT return - 1 NEWLINE DEDENT p = 24 ; q = 48 NEWLINE print ( g@@ e@@ t@@ M@@ i@@ n@@ V@@ al ( p , q ) ) NEWLINE NL ENDMARKER
def countWays ( A , B , C ) : NEWLINE INDENT m@@ i@@ n@@ A@@ d@@ d@@ A = max ( 0 , ( C + B - A + 2 ) // 2 ) NEWLINE c@@ o@@ u@@ n@@ t@@ _@@ ways = max ( C - m@@ i@@ n@@ A@@ d@@ d@@ A + 1 , 0 ) NEWLINE return c@@ o@@ u@@ n@@ t@@ _@@ ways NEWLINE DEDENT A = 3 NEWLINE B = 5 NEWLINE C = 5 NEWLINE print ( countWays ( A , B , C ) ) NEWLINE NL ENDMARKER
a = int ( input ( ) ) b = int ( input ( ) ) l = list ( range ( b + 1 , 0 , - 1 ) ) if a == 0 : for i in l : print ( i , end = " " ) else : q = list ( range ( b + 2 , a + b + 2 ) ) print ( 1 , end = " " ) for i in q : print ( i , end = " " ) for i in l [ : - 1 ] : print ( i , end = " " ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) x = 1 s = 1 while s <= n : x += 1 s += ( x * ( x + 1 ) ) // 2 print ( x - 1 ) NEWLINE NL ENDMARKER
try : n , m = map ( int , input ( ) . split ( ) ) f = [ ] flag = 0 for i in range ( n ) : k = [ int ( j ) for j in input ( ) . split ( ) ] f . append ( k ) if ( 1 in f [ 0 ] ) : flag = 1 for i in range ( n ) : if ( f [ i ] [ 0 ] == 1 ) : flag = 1 if ( 1 in f [ n - 1 ] ) : flag = 1 for i in range ( n ) : if ( f [ i ] [ m - 1 ] == 1 ) : flag = 1 if ( flag == 1 ) : print ( "2" ) else : print ( "4" ) except : pass NEWLINE NL ENDMARKER
import sys  input = sys . stdin . buffer . readline  ans = "1 " * 100  t = int ( input ( ) ) NEWLINE for _ in range ( t ) : n = int ( input ( ) ) NEWLINE print ( ans [ : 2 * n - 1 ] ) NEWLINE NL ENDMARKER
def g@@ o@@ u@@ l@@ d@@ S@@ e@@ q@@ u@@ e@@ n@@ ce ( n ) : NEWLINE INDENT for r@@ o@@ w@@ _@@ num in range ( 1 , n ) : NEWLINE INDENTINDENT count = 1 NEWLINE c = 1 NEWLINE for i in range ( 1 , r@@ o@@ w@@ _@@ num ) : NEWLINE INDENTINDENTINDENT c = c * ( r@@ o@@ w@@ _@@ num - i ) / i NEWLINE if ( c % 2 == 1 ) : NEWLINE INDENTINDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT print ( count , end = " " ) NEWLINE DEDENT DEDENT n = 16 ; NEWLINE g@@ o@@ u@@ l@@ d@@ S@@ e@@ q@@ u@@ e@@ n@@ ce ( n ) NEWLINE NL ENDMARKER
import s@@ y@@ s@@ string = str ( sys . stdin . readline ( ) ) string = list ( string ) def solution ( string ) : count = 1 answer = 0 num = 0 NEWLINE NL ENDMARKER
if name == '__main__' : NEWLINE INDENT for first in range ( 1 , 6 ) : NEWLINE INDENTINDENT for second in range ( 1 , 6 ) : NEWLINE INDENTINDENTINDENT print ( 5 * first + second - 5 ) NEWLINE NL DEDENT DEDENT DEDENT ENDMARKER
def c@@ o@@ u@@ n@@ t@@ g@@ r@@ o@@ u@@ p ( a , n ) : NEWLINE INDENT x@@ s = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT x@@ s = x@@ s ^ a [ i ] NEWLINE DEDENT if x@@ s == 0 : NEWLINE INDENTINDENT return ( 1 << ( n - 1 ) ) - 1 NEWLINE DEDENT return 0 NEWLINE DEDENT a = [ 1 , 2 , 3 ] NEWLINE n = len ( a ) NEWLINE print ( c@@ o@@ u@@ n@@ t@@ g@@ r@@ o@@ u@@ p ( a , n ) ) NEWLINE NL ENDMARKER
class p@@ a@@ i@@ r : def NEWLINE __init__ ( self , f , s ) : self . f = f NEWLINE self . s = s  m@@ e = input ( ) NEWLINE n = int ( input ( ) )  mp = { } NEWLINE for i in range ( n ) : a = list ( map ( str , input ( ) . split ( ) ) )  if a [ 1 ] == "@@ l@@ i@@ k@@ e@@ s@@ " : NEWLINE INDENT ot = a [ 2 ] else : NEWLINE ot = a [ 3 ]  NEWLINE NL DEDENT ENDMARKER
T@@ O@@ T@@ A@@ L@@ _@@ B@@ I@@ T@@ S = 32 ; NEWLINE def isPossible ( n ) : NEWLINE INDENT cnt = bin ( n ) . count ( '1' ) ; NEWLINE if ( cnt == T@@ O@@ T@@ A@@ L@@ _@@ B@@ I@@ T@@ S // 2 ) : NEWLINE INDENTINDENT return True ; NEWLINE DEDENT return False ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 5@@ 2@@ 4@@ 2@@ 8@@ 0 ; NEWLINE if ( isPossible ( n ) ) : NEWLINE INDENTINDENT print ( "Yes" ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) ; NEWLINE NL DEDENT DEDENT ENDMARKER
t = int ( input ( ) ) for _ in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) print ( a + b ) NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readline  n , k = [ int ( i ) for i in input ( ) . split ( ) ] a = [ int ( i ) for i in input ( ) . split ( ) ] count = 1 while k > count : k -= count count += 1 print ( a [ k - 1 ] ) NEWLINE NL ENDMARKER
import sys , functools , collections , bisect , math , NEWLINE INDENT heapqinput = sys . stdin . readline NEWLINE NL DEDENT ENDMARKER
x , y = map ( int , input ( ) . split ( ) ) ; ans = 0 for i in range ( 2 , x + 1 , 2 ) : for j in range ( 2 , y + 1 , 2 ) : ans += ( x - i + 1 ) * ( y - j + 1 ) print ( ans ) NEWLINE NL ENDMARKER
def g@@ e@@ t@@ V@@ a@@ l@@ u@@ e@@ O@@ f@@ F ( n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT if ( n == 2 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT cnt = 0 NEWLINE while ( n % 2 == 0 ) : NEWLINE INDENTINDENT cnt += 1 NEWLINE n /= 2 NEWLINE DEDENT return 2 * cnt NEWLINE DEDENT n = 20 NEWLINE print ( g@@ e@@ t@@ V@@ a@@ l@@ u@@ e@@ O@@ f@@ F ( n ) ) NEWLINE NL ENDMARKER
cases = int ( input ( ) ) p@@ o@@ w@@ e@@ r@@ s = set ( )  for i in range ( 32 ) : p@@ o@@ w@@ e@@ r@@ s . add ( 2 ** i ) while cases : cases -= 1 num = int ( input ( ) )  ans = num * ( num + 1 ) // 2  for i in p@@ o@@ w@@ e@@ r@@ s : if i <= num : ans -= 2 * i  print ( ans )   NEWLINE NL ENDMARKER
import sysn , t = map ( int , sys . stdin . readline ( ) . split ( ) ) x = sys . stdin . readline ( ) y = x . find ( '.' ) for i in range ( y + 1 , n ) : if x [ i ] > '4' : for j in range ( t ) : i -= 1 if x [ i ] != '4' : break if i == y : i -= 1 while i and x [ i ] == '9' : i -= 1 x = x [ : i ] + str ( int ( x [ i ] ) + 1 ) + '0' * ( y - i - 1 ) else : x = x [ : i ] + str ( int ( x [ i ] ) + 1 ) breakprint ( x )           NEWLINE NL ENDMARKER
import sysimport b@@ i@@ s@@ e@@ c@@ t@@ def gcd ( a , b ) : if ( a == 0 ) : return b return gcd ( b % a , a ) def input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( str , input ( ) . split ( ) ) ) for _ in range ( iinput ( ) ) : a , b = minput ( ) if a % b : print ( "NO" ) else : print ( "YES" ) NEWLINE NL ENDMARKER
def g@@ e@@ t@@ C@@ h@@ i@@ c@@ k@@ s ( n ) : NEWLINE INDENT c@@ h@@ i@@ c@@ k@@ s = pow ( 3 , n - 1 ) NEWLINE return c@@ h@@ i@@ c@@ k@@ s NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 3 NEWLINE print ( g@@ e@@ t@@ C@@ h@@ i@@ c@@ k@@ s ( n ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) s = input ( ) cnt = s . count ( 'x' ) - s . count ( 'X' ) print ( abs ( cnt // 2 ) ) s = list ( s ) for i in range ( len ( s ) ) : if cnt > 0 and s [ i ] == 'x' : s [ i ] = 'X' cnt -= 2 elif cnt < 0 and s [ i ] == 'X' : s [ i ] = 'x' cnt += 2 print ( '' . join ( s ) ) NEWLINE NL ENDMARKER
d , L , v1 , v2 = map ( int , input ( ) . split ( ) ) ans = float ( ( L - d ) / ( v1 + v2 ) ) print ( ans ) NEWLINE NL ENDMARKER
n , w = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) g = a [ 0 ] b = a [ n ] if g >= w : print ( w ) else : if g * 2 > b : g = b / 2 t = g * n + g * 2 * n if t <= w : print ( t ) else : print ( w ) NEWLINE NL ENDMARKER
head = input ( ) t@@ e@@ x@@ t = input ( ) h@@ e@@ a@@ d@@ _@@ m = { t : head . count ( t ) for t in head . strip ( ) . replace ( ' ' , '' ) . replace ( '@@ \@@ t@@ ' , '' ) } I@@ s@@ Valid = Truefor i in t@@ e@@ x@@ t . strip ( ) . replace ( ' ' , '' ) . replace ( '@@ \@@ t@@ ' , '' ) : NEWLINE NL ENDMARKER
def a@@ n@@ g@@ l@@ e@@ q@@ u@@ i@@ chord ( z ) : NEWLINE INDENT print ( "The angle is " , z , " degrees" ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT z = 48 NEWLINE a@@ n@@ g@@ l@@ e@@ q@@ u@@ i@@ chord ( z ) NEWLINE NL DEDENT ENDMARKER
def findNumbers ( n ) : NEWLINE INDENT i = 1 NEWLINE while ( i <= n ) : NEWLINE INDENTINDENT print ( ( 3 * i * ( i - 1 ) + 1 ) , end = " " ) NEWLINE i += 1 NEWLINE DEDENT DEDENT n = 4 NEWLINE findNumbers ( n ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) ce = 0 co = 0 s = 0 for i in l : if i % 2 == 0 : ce += 1 else : co += 1 s += i  if s % 2 == 0 : print ( ce ) else : print ( co ) NEWLINE NL ENDMARKER
def m@@ a@@ x@@ i@@ m@@ u@@ m@@ Area ( l , b , x , y ) : NEWLINE INDENT left , right , a@@ b@@ o@@ v@@ e , b@@ e@@ l@@ o@@ w = 0 , 0 , 0 , 0 NEWLINE left = x * b NEWLINE right = ( l - x - 1 ) * b NEWLINE a@@ b@@ o@@ v@@ e = l * y NEWLINE b@@ e@@ l@@ o@@ w = ( b - y - 1 ) * l NEWLINE print ( max ( max ( left , right ) , max ( a@@ b@@ o@@ v@@ e , b@@ e@@ l@@ o@@ w ) ) ) NEWLINE DEDENT l = 8 NEWLINE b = 8 NEWLINE x = 0 NEWLINE y = 0 NEWLINE m@@ a@@ x@@ i@@ m@@ u@@ m@@ Area ( l , b , x , y ) NEWLINE NL ENDMARKER
s = input ( ) ans = 0 n = len ( s ) for i in range ( 1 , n ) : ans += pow ( 2 , i ) for i in range ( 0 , n ) : if ( s [ i ] == '7' ) : ans += pow ( 2 , n - 1 - i ) print ( ans + 1 ) NEWLINE NL ENDMARKER
def findSum ( N ) : NEWLINE INDENT ans = 0 NEWLINE for i in range ( 1 , N + 1 ) : NEWLINE INDENTINDENT for j in range ( 1 , N + 1 ) : NEWLINE INDENTINDENTINDENT ans += i // j NEWLINE DEDENT DEDENT return ans NEWLINE DEDENT N = 2 NEWLINE print ( findSum ( N ) ) NEWLINE NL ENDMARKER
def ways ( n ) : NEWLINE INDENT return n // 2 NEWLINE DEDENT n = 2 NEWLINE print ( ways ( n ) ) NEWLINE NL ENDMARKER
r@@ e@@ v@@ _@@ num = 0 NEWLINE b@@ a@@ s@@ e@@ _@@ pos = 1 NEWLINE def r@@ e@@ v@@ e@@ r@@ s@@ Digits ( num ) : NEWLINE INDENT global r@@ e@@ v@@ _@@ num NEWLINE global b@@ a@@ s@@ e@@ _@@ pos NEWLINE if ( num > 0 ) : NEWLINE INDENTINDENT r@@ e@@ v@@ e@@ r@@ s@@ Digits ( ( int ) ( num / 10 ) ) NEWLINE r@@ e@@ v@@ _@@ num += ( num % 10 ) * b@@ a@@ s@@ e@@ _@@ pos NEWLINE b@@ a@@ s@@ e@@ _@@ pos *= 10 NEWLINE DEDENT return r@@ e@@ v@@ _@@ num NEWLINE DEDENT num = 4562 NEWLINE print ( "@@ R@@ e@@ v@@ e@@ r@@ s@@ e of n@@ o@@ . is " , r@@ e@@ v@@ e@@ r@@ s@@ Digits ( num ) ) NEWLINE NL ENDMARKER
def allBitsSetInTheGivenRange ( n , l , r ) : NEWLINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEWLINE new_num = n & num NEWLINE if ( num == new_num ) : NEWLINE INDENTINDENT return "Yes" NEWLINE DEDENT return "No" NEWLINE DEDENT n , l , r = 22 , 2 , 3 NEWLINE print ( allBitsSetInTheGivenRange ( n , l , r ) ) NEWLINE NL ENDMARKER
def getMinCost ( arr , n ) : NEWLINE INDENT m@@ i@@ n@@ _@@ ele = min ( arr ) NEWLINE return m@@ i@@ n@@ _@@ ele * ( n - 1 ) NEWLINE DEDENT arr = [ 4 , 2 , 5 ] NEWLINE n = len ( arr ) NEWLINE print ( getMinCost ( arr , n ) ) NEWLINE NL ENDMARKER
def findSum ( N ) : NEWLINE INDENT return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 5@@ 4 * N ) / 6 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 4 NEWLINE print ( findSum ( N ) ) NEWLINE NL DEDENT ENDMARKER
a = int ( input ( ) ) s@@ u@@ m@@ A = 0 s@@ u@@ m@@ G = 0 s = '' for i in range ( a ) : c , d = map ( int , input ( ) . split ( ) ) if s@@ u@@ m@@ A + c - 500 > s@@ u@@ m@@ G : s += 'G' s@@ u@@ m@@ G += d else : s += 'A' s@@ u@@ m@@ A += c  if abs ( s@@ u@@ m@@ A - s@@ u@@ m@@ G ) > 500 : print ( - 1 ) else : print ( s ) NEWLINE NL ENDMARKER
import osimport sysfrom math import * from collections import *  NEWLINE NL ENDMARKER
import sys  def main ( ) : inp = sys . stdin . read ( ) . strip ( ) . split ( '\n' ) n , m = map ( int , inp [ 0 ] . split ( ) ) t = [ ] for s in inp [ 1 : ] : a , b = map ( int , s . split ( ) ) t . append ( a / b * m ) return min ( t ) print ( main ( ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) NEWLINE if ( n <= 9 ) : NEWLINE INDENT print ( n ) NEWLINE DEDENT else : NEWLINE INDENT while ( n > 9 ) : NEWLINE INDENTINDENT m = n NEWLINE s = 0 NEWLINE while ( m != 0 ) : NEWLINE INDENTINDENTINDENT a = m % 10 NEWLINE s += a NEWLINE m = m // 10 NEWLINE DEDENT n = s NEWLINE DEDENT print ( s ) NEWLINE NL DEDENT ENDMARKER
def m@@ i@@ n@@ P@@ o@@ w@@ e@@ r ( n , x ) : NEWLINE INDENT if ( x == 1 ) : NEWLINE INDENTINDENT return n NEWLINE DEDENT ans = 0 NEWLINE while ( n > 0 ) : NEWLINE INDENTINDENT ans += ( n % x ) NEWLINE n //= x NEWLINE DEDENT return ans NEWLINE DEDENT n = 5 NEWLINE x = 3 NEWLINE print ( m@@ i@@ n@@ P@@ o@@ w@@ e@@ r ( n , x ) ) NEWLINE NL ENDMARKER
def solve ( num ) : ans = 0 power = 0 while ans < num : ans += 2 ** power power += 1 return power print ( solve ( int ( input ( ) ) ) )  NEWLINE NL ENDMARKER
a = int ( input ( ) ) b = int ( input ( ) )  if a < b : small = a l@@ a@@ r@@ g@@ e = b d = b - aelse : small = b l@@ a@@ r@@ g@@ e = a d = a - b  center = small + d // 2  s1 = 0 s2 = 0  for i in range ( 1 , ( d // 2 ) + 1 ) : s1 += i  for i in range ( 1 , ( l@@ a@@ r@@ g@@ e - center ) + 1 ) : s2 += i  print ( s1 + s2 ) NEWLINE NL ENDMARKER
n = int ( input ( ) )  arr = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n - 1 ) : for j in range ( i + 1 , n - 1 ) : a = min ( arr [ i ] , arr [ i + 1 ] ) b = max ( arr [ i ] , arr [ i + 1 ] ) c = min ( arr [ j ] , arr [ j + 1 ] ) d = max ( arr [ j ] , arr [ j + 1 ] ) if a < c < b < d or c < a < d < b : print ( "yes" ) exit ( ) print ( 'no' ) NEWLINE NL ENDMARKER
def countBits ( n ) : NEWLINE INDENT count = 0 ; NEWLINE while ( n ) : NEWLINE INDENTINDENT count += 1 ; NEWLINE n >>= 1 ; NEWLINE DEDENT return count ; NEWLINE DEDENT n = 32 ; NEWLINE print ( "Minimum value of K is =" , countBits ( n ) ) ; NEWLINE NL ENDMARKER
def swapBits ( x , p1 , p2 , n ) : NEWLINE INDENT s@@ e@@ t@@ 1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) NEWLINE s@@ e@@ t@@ 2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) NEWLINE x@@ or = ( s@@ e@@ t@@ 1 ^ s@@ e@@ t@@ 2 ) NEWLINE x@@ or = ( x@@ or << p1 ) | ( x@@ or << p2 ) NEWLINE result = x ^ x@@ or NEWLINE return result NEWLINE DEDENT res = swapBits ( 28 , 0 , 3 , 2 ) NEWLINE print ( "@@ Result =" , res ) NEWLINE NL ENDMARKER
def m@@ a@@ x@@ H@@ a@@ n@@ d@@ s@@ h@@ a@@ k@@ e ( n ) : NEWLINE INDENT return int ( ( n * ( n - 1 ) ) / 2 ) NEWLINE DEDENT n = 10 NEWLINE print ( m@@ a@@ x@@ H@@ a@@ n@@ d@@ s@@ h@@ a@@ k@@ e ( n ) ) NEWLINE NL ENDMARKER
x = int ( input ( ) )  if x == 3 : print ( 5 ) exit ( )  for i in range ( 50 ) : if ( 4 * i * i + 4 * i + 3 ) // 2 >= x : print ( 2 * i + 1 ) break NEWLINE NL ENDMARKER
def m@@ u@@ l@@ mod ( a , b , mod ) : NEWLINE INDENT res = 0 ; NEWLINE a = a % mod ; NEWLINE while ( b > 0 ) : NEWLINE INDENTINDENT if ( b % 2 == 1 ) : NEWLINE INDENTINDENTINDENT res = ( res + a ) % mod ; NEWLINE DEDENT a = ( a * 2 ) % mod ; NEWLINE b //= 2 ; NEWLINE DEDENT return res % mod ; NEWLINE DEDENT a = 9223372036854775807 ; NEWLINE b = 9223372036854775807 ; NEWLINE print ( m@@ u@@ l@@ mod ( a , b , 1@@ 0@@ 0@@ 0@@ 0@@ 0@@ 0@@ 0@@ 0@@ 0@@ 0@@ 0 ) ) ; NEWLINE NL ENDMARKER
n , s , t = map ( int , input ( ) . split ( ) ) P = list ( map ( int , input ( ) . split ( ) ) ) operations = 0 L = list ( range ( 1 , n + 1 ) ) for i in range ( n ) : if s == t : print ( i ) exit ( ) s = P [ s - 1 ] print ( - 1 )     NEWLINE NL ENDMARKER
def f@@ u@@ n ( n ) : NEWLINE INDENT return n & ( n - 1 ) NEWLINE DEDENT n = 7 NEWLINE print ( "The number a@@ f@@ t@@ e@@ r u@@ n@@ s@@ e@@ t@@ t@@ i@@ n@@ g the r@@ i@@ g@@ h@@ t@@ most set b@@ i@@ t@@ " , f@@ u@@ n ( n ) ) NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) od = "" e@@ v@@ f = "" e@@ v@@ l = "" s@@ w = Truefor i in range ( b ) : od += "@@ #" if i == b - 1 : e@@ v@@ l += "@@ #" else : e@@ v@@ l += "." if i == 0 : e@@ v@@ f += "@@ #" else : e@@ v@@ f += "." for i in range ( a ) : if i % 2 == 0 : print ( od ) else : if s@@ w : print ( e@@ v@@ l ) s@@ w = False else : print ( e@@ v@@ f ) s@@ w = True NEWLINE NL ENDMARKER
def g@@ e@@ t@@ H@@ C@@ F ( x , y ) : NEWLINE INDENT minimum = min ( x , y ) NEWLINE if ( x % minimum == 0 and y % minimum == 0 ) : NEWLINE INDENTINDENT return minimum NEWLINE DEDENT for i in range ( minimum // 2 , 1 , - 1 ) : NEWLINE INDENTINDENT if ( x % i == 0 and y % i == 0 ) : NEWLINE INDENTINDENTINDENT return i NEWLINE DEDENT DEDENT return 1 NEWLINE DEDENT x , y = 16 , 32 NEWLINE print ( g@@ e@@ t@@ H@@ C@@ F ( x , y ) ) NEWLINE NL ENDMARKER
def g@@ e@@ t@@ H@@ e@@ r@@ m@@ i@@ t@@ e@@ Number ( n ) : NEWLINE INDENT if n == 0 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT if n == 1 : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( - 2 * ( n - 1 ) * g@@ e@@ t@@ H@@ e@@ r@@ m@@ i@@ t@@ e@@ Number ( n - 2 ) ) NEWLINE DEDENT DEDENT n = 6 NEWLINE print ( g@@ e@@ t@@ H@@ e@@ r@@ m@@ i@@ t@@ e@@ Number ( n ) ) ; NEWLINE NL ENDMARKER
def difference ( M , N ) : NEWLINE INDENT return M + N NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT M = 999999999 NEWLINE N = 1@@ 0@@ 0@@ 0@@ 0@@ 0@@ 0@@ 0@@ 0@@ 0 NEWLINE print ( difference ( M , N ) ) NEWLINE NL DEDENT ENDMARKER
def R@@ a@@ n@@ k ( E@@ d@@ g@@ e@@ s , V@@ e@@ r@@ t@@ i@@ c@@ e@@ s ) : NEWLINE INDENT result = E@@ d@@ g@@ e@@ s - V@@ e@@ r@@ t@@ i@@ c@@ e@@ s + 1 NEWLINE return result NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT E@@ d@@ g@@ e@@ s , V@@ e@@ r@@ t@@ i@@ c@@ e@@ s = 7 , 5 NEWLINE print ( "@@ C@@ i@@ r@@ c@@ u@@ it R@@ a@@ n@@ k =" , R@@ a@@ n@@ k ( E@@ d@@ g@@ e@@ s , V@@ e@@ r@@ t@@ i@@ c@@ e@@ s ) ) NEWLINE NL DEDENT ENDMARKER
def m@@ a@@ x@@ P@@ r@@ m@@ i@@ m@@ e@@ s ( n ) : NEWLINE INDENT return n // 2 NEWLINE DEDENT n = 17 NEWLINE print ( m@@ a@@ x@@ P@@ r@@ m@@ i@@ m@@ e@@ s ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) lst = list ( map ( int , input ( ) . strip ( ) . split ( ' ' ) ) ) l = [ ] for j in range ( n ) : l . append ( [ lst [ j ] , j ] ) l . sort ( key = lambda x : x [ 0 ] ) c = 0 for i in range ( 1 , n ) : c += abs ( l [ i ] [ 1 ] - l [ i - 1 ] [ 1 ] ) print ( c ) NEWLINE NL ENDMARKER
a , b , n = map ( int , input ( ) . split ( ) ) x = str ( a ) flag = 0 for i in range ( 10 ) : if int ( str ( a ) + str ( i ) ) % b == 0 : x += str ( i ) flag = 1 breakif flag == 0 : print ( - 1 ) else : for i in range ( n - 1 ) : x += "0" print ( x ) NEWLINE NL ENDMARKER
def findNthTerm ( n ) : NEWLINE INDENT if ( n % 2 == 0 ) : NEWLINE INDENTINDENT n = n // 2 NEWLINE n = 2 * ( n - 1 ) NEWLINE print ( n // 2 ) NEWLINE DEDENT else : NEWLINE INDENTINDENT n = ( n // 2 ) + 1 NEWLINE n = 2 * ( n - 1 ) NEWLINE print ( n ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT X = 10 NEWLINE findNthTerm ( X ) ; NEWLINE X = 7 ; NEWLINE findNthTerm ( X ) NEWLINE NL DEDENT ENDMARKER
input ( ) a = [ int ( x ) for x in input ( ) . split ( ) ] for n in a : i = 1 while i * n * ( n + 1 ) % ( n * 4 ) != 0 : i += 1 print ( i * n + 1 ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) arr = [ int ( x ) for x in input ( ) . split ( ) ] k = 0 while k < n and arr [ k ] == 1 : k += 1 if ( k % 2 == 1 ) : if n == k : print ( "First" ) else : print ( "Second" ) else : if n == k : print ( "Second" ) else : print ( "First" ) NEWLINE NL ENDMARKER
for __ in range ( int ( input ( ) ) ) : n , k = [ int ( e ) for e in input ( ) . split ( ) ] ; k -= 1 ; print ( ( k + n % 2 * k // ( n // 2 ) ) % n + 1 ) NEWLINE NL ENDMARKER
import sys , os , ioimport math , bisect , operatorinf , mod = float ( 'inf' ) , 10 ** 9 + 7 NEWLINE NL ENDMARKER
from math import ceiln , m = list ( map ( int , input ( ) . split ( ) ) ) if m == 0 : print ( 1 ) elif m <= ( n // 2 ) : print ( m ) else : if n % 2 != 0 and m == ceil ( n / 2 ) : print ( n // 2 ) else : print ( n - m ) NEWLINE NL ENDMARKER
n , k , t = map ( int , input ( ) . split ( ) )           if t < k : print ( t ) elif t > n : NEWLINE NL ENDMARKER
def C@@ o@@ u@@ n@@ t@@ S@@ e@@ t@@ B@@ i@@ t@@ s ( n ) : NEWLINE INDENT if ( n == 0 ) : NEWLINE INDENTINDENT return 0 ; NEWLINE DEDENT if ( ( n & 1 ) == 1 ) : NEWLINE INDENTINDENT return 1 + C@@ o@@ u@@ n@@ t@@ S@@ e@@ t@@ B@@ i@@ t@@ s ( n >> 1 ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENT return C@@ o@@ u@@ n@@ t@@ S@@ e@@ t@@ B@@ i@@ t@@ s ( n >> 1 ) ; NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 21 ; NEWLINE print ( C@@ o@@ u@@ n@@ t@@ S@@ e@@ t@@ B@@ i@@ t@@ s ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
def gcd ( a , b ) : NEWLINE INDENT if ( a == 0 ) : NEWLINE INDENTINDENT return b NEWLINE DEDENT return gcd ( b % a , a ) NEWLINE DEDENT def p@@ o@@ w@@ G@@ C@@ D ( a , n , b ) : NEWLINE INDENT for i in range ( 0 , n + 1 , 1 ) : NEWLINE INDENTINDENT a = a * a NEWLINE DEDENT return gcd ( a , b ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = 10 NEWLINE b = 5 NEWLINE n = 2 NEWLINE print ( p@@ o@@ w@@ G@@ C@@ D ( a , n , b ) ) NEWLINE NL DEDENT ENDMARKER
from math import * NEWLINE def f@@ i@@ n@@ d@@ R@@ a@@ d@@ i@@ u@@ s@@ O@@ f@@ c@@ i@@ r@@ c@@ u@@ m@@ circle ( n , a ) : NEWLINE INDENT if n < 0 or a < 0 : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT radius = a / sqrt ( 2 - ( 2 * cos ( 360 / n ) ) ) NEWLINE return radius NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n , a = 5 , 6 NEWLINE print ( round ( f@@ i@@ n@@ d@@ R@@ a@@ d@@ i@@ u@@ s@@ O@@ f@@ c@@ i@@ r@@ c@@ u@@ m@@ circle ( n , a ) , 5 ) ) NEWLINE NL DEDENT ENDMARKER
n@@ u@@ m@@ _@@ array = input ( ) . split ( ) b = int ( n@@ u@@ m@@ _@@ array [ 0 ] ) m = int ( n@@ u@@ m@@ _@@ array [ 1 ] ) c = 0 while ( b <= m ) : b = b * 3 m = m * 2 c += 1 print ( c ) NEWLINE NL ENDMARKER
def p@@ r@@ i@@ n@@ t@@ F@@ u@@ n ( test ) : NEWLINE INDENT if ( test < 1 ) : NEWLINE INDENTINDENT return NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( test , end = " " ) NEWLINE p@@ r@@ i@@ n@@ t@@ F@@ u@@ n ( test - 1 ) NEWLINE print ( test , end = " " ) NEWLINE return NEWLINE DEDENT DEDENT test = 3 NEWLINE p@@ r@@ i@@ n@@ t@@ F@@ u@@ n ( test ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) for i in range ( n ) : a = int ( input ( ) ) x = 360 / ( 180 - a ) if x == int ( x ) : print ( 'YES' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
temp = input ( ) . split ( " " ) n = int ( temp [ 0 ] ) m = int ( temp [ 1 ] )  n@@ li = [ ] m@@ li = [ ]  for _ in range ( n ) : n@@ li . append ( input ( ) )  for _ in range ( m ) : m@@ li . append ( input ( ) )  res = n - m@@ count = 0 for x in m@@ li : if x in n@@ li : count += 1  res = res + ( count % 2 ) if res > 0 : print ( "YES" )  else : print ( "NO" ) NEWLINE NL ENDMARKER
def c@@ o@@ u@@ n@@ t@@ digits ( n , k ) : NEWLINE INDENT if n == 0 : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT digit = n % 10 NEWLINE if digit == k : NEWLINE INDENTINDENT return 1 + c@@ o@@ u@@ n@@ t@@ digits ( n / 10 , k ) NEWLINE DEDENT return c@@ o@@ u@@ n@@ t@@ digits ( n / 10 , k ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 1000 ; NEWLINE k = 0 ; NEWLINE print ( c@@ o@@ u@@ n@@ t@@ digits ( n , k ) ) NEWLINE NL DEDENT ENDMARKER
I = lambda : map ( int , input ( ) . split ( ) ) n , m = I ( ) a , b = sorted ( I ( ) , reverse = 1 ) , sorted ( I ( ) ) s = sum ( b ) for i in range ( 1 , n ) : s += a [ i ] * mif a [ 0 ] > min ( b ) : s = - 1 elif a [ 0 ] != b [ 0 ] : s += a [ 0 ] - a [ 1 ] print ( s ) NEWLINE NL ENDMARKER
def f@@ i@@ n@@ d@@ F@@ l@@ i@@ ps ( str , n ) : NEWLINE INDENT last = ' ' NEWLINE res = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT if ( last != str [ i ] ) : NEWLINE INDENTINDENTINDENT res += 1 NEWLINE DEDENT last = str [ i ] NEWLINE DEDENT return res // 2 NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT str = "@@ 0@@ 0@@ 0@@ 1@@ 1@@ 1@@ 1@@ 0@@ 0@@ 0@@ 1@@ 1@@ 1@@ 0@@ " NEWLINE n = len ( str ) NEWLINE print ( f@@ i@@ n@@ d@@ F@@ l@@ i@@ ps ( str , n ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) p = n@@ i = 1 l = 1 sd = 0 s = 0j = 1 while ( n > 9 ) : n = int ( n / 10 ) i *= 10 l += 1 if p > 9 : while i != 1 : s = p - i if j == 1 : s = s + 1 sd += s * l p = i i = i / 10 l -= 1 j += 1 p = 9 print ( int ( p + sd ) ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) print ( ( k + n - 1 ) // n ) NEWLINE NL ENDMARKER
def first ( a , b , c ) : NEWLINE INDENT a %= b NEWLINE for i in range ( 1 , b + 1 ) : NEWLINE INDENTINDENT a = a * 10 NEWLINE if int ( a / b ) == c : NEWLINE INDENTINDENTINDENT return i NEWLINE DEDENT a %= b NEWLINE DEDENT return - 1 NEWLINE DEDENT a = 1 NEWLINE b = 4 NEWLINE c = 5 NEWLINE print ( first ( a , b , c ) ) NEWLINE NL ENDMARKER
arr = "@@ A@@ B@@ S@@ I@@ N@@ T@@ H@@ , B@@ E@@ E@@ R@@ , B@@ R@@ A@@ N@@ D@@ Y@@ , C@@ H@@ A@@ M@@ P@@ A@@ G@@ N@@ E@@ , G@@ I@@ N@@ , R@@ U@@ M@@ , S@@ A@@ K@@ E@@ , T@@ E@@ Q@@ U@@ I@@ L@@ A@@ , V@@ O@@ D@@ K@@ A@@ , W@@ H@@ I@@ S@@ K@@ E@@ Y@@ , W@@ I@@ N@@ E@@ " . split ( ', ' ) NEWLINE NL ENDMARKER
def minAbsDiff ( n ) : NEWLINE INDENT mod = n % 4 ; NEWLINE if ( mod == 0 or mod == 3 ) : NEWLINE INDENTINDENT return 0 ; NEWLINE DEDENT return 1 ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 5 ; NEWLINE print ( minAbsDiff ( n ) ) NEWLINE NL DEDENT ENDMARKER
cases = int ( input ( ) ) NEWLINE while cases : NEWLINE INDENT cases -= 1 NEWLINE n = int ( input ( ) ) NEWLINE print ( * list ( range ( n , 0 , - 1 ) ) ) NEWLINE NL DEDENT ENDMARKER
def nthTerm ( N ) : NEWLINE INDENT return ( ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ) ; NEWLINE DEDENT n = 4 NEWLINE print ( nthTerm ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) home = str ( input ( ) ) for i in range ( n ) : li1 = list ( map ( str , input ( ) . split ( ) ) ) if n % 2 == 0 : print ( "@@ h@@ o@@ m@@ e@@ " ) else : print ( "@@ c@@ o@@ n@@ t@@ e@@ s@@ t@@ " ) NEWLINE NL ENDMARKER
def calculateSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE for row in range ( n ) : NEWLINE INDENTINDENT sum = sum + ( 1 << row ) NEWLINE DEDENT return sum NEWLINE DEDENT n = 10 NEWLINE print ( "Sum of all elements:" , calculateSum ( n ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : a , b , c , d = map ( int , input ( ) . split ( ) ) NEWLINE print ( max ( ( a + b ) , ( c + d ) ) ) NEWLINE NL ENDMARKER
def summation ( n ) : NEWLINE INDENT return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 10 NEWLINE print ( summation ( n ) ) NEWLINE NL DEDENT ENDMARKER
