import math NEWLINE def findRadiusOfcircumcircle ( l , b ) : NEWLINE INDENT if ( l < 0 or b < 0 ) : NEWLINE INDENTINDENT return - 1 ; NEWLINE DEDENT radius = ( math . sqrt ( pow ( l , 2 ) + pow ( b , 2 ) ) / 2 ) ; NEWLINE return radius ; NEWLINE DEDENT l = 4 ; NEWLINE b = 3 ; NEWLINE print ( findRadiusOfcircumcircle ( l , b ) ) ; NEWLINE NL ENDMARKER
def largest ( arr , n ) : NEWLINE INDENT return ( max ( arr ) ) NEWLINE DEDENT arr = [ 10 , 324 , 45 , 90 , 9808 ] NEWLINE n = len ( arr ) NEWLINE Ans = largest ( arr , n ) NEWLINE print ( "Largest in given array is" , Ans ) NEWLINE NL ENDMARKER
from math import * NEWLINE NL ENDMARKER
def getMissingNo ( A ) : NEWLINE INDENT n = len ( A ) NEWLINE total = ( n + 1 ) * ( n + 2 ) / 2 NEWLINE sum_of_A = sum ( A ) NEWLINE return total - sum_of_A NEWLINE DEDENT A = [ 1 , 2 , 4 , 5 , 6 ] NEWLINE miss = getMissingNo ( A ) NEWLINE print ( miss ) NEWLINE NL ENDMARKER
import math NEWLINE def CountAllPairs ( N , K ) : NEWLINE INDENT count = 0 NEWLINE if ( N > K ) : NEWLINE INDENTINDENT count = N - K NEWLINE for i in range ( K + 1 , N + 1 ) : NEWLINE INDENTINDENTINDENT count = count + ( ( N - K ) // i ) NEWLINE DEDENT DEDENT return count NEWLINE DEDENT N = 11 NEWLINE K = 5 NEWLINE print ( CountAllPairs ( N , K ) ) NEWLINE NL ENDMARKER
a = input ( ) mod = 1000000007 ans = 0 count_a = 0 for i in a : if i == 'a' : count_a += 1 else : ans += ( pow ( 2 , count_a , mod ) - 1 ) % modprint ( ans % mod ) NEWLINE NL ENDMARKER
from fractions import gcdn = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) d = max ( a ) c = 0 for i in range ( len ( a ) ) : c = gcd ( c , a [ i ] ) result = d // c - nif result % 2 == 0 : print ( "Bob" ) else : print ( "Alice" ) NEWLINE NL ENDMARKER
r = 3 NEWLINE R = 7 NEWLINE pi = 3.14159 NEWLINE Volume = ( float ) ( 2 * pi * pi * R * r * r ) ; NEWLINE print ( "Volume: " , Volume ) ; NEWLINE Surface = ( float ) ( 4 * pi * pi * R * r ) ; NEWLINE print ( "Surface: " , Surface ) ; NEWLINE NL ENDMARKER
def printOrder ( arr , n , k ) : NEWLINE INDENT a = arr [ 0 : k ] ; NEWLINE a . sort ( ) ; NEWLINE b = arr [ k : n ] ; NEWLINE b . sort ( ) ; NEWLINE b . reverse ( ) ; NEWLINE return a + b ; NEWLINE DEDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] ; NEWLINE k = 4 ; NEWLINE n = len ( arr ) ; NEWLINE arr = printOrder ( arr , n , k ) ; NEWLINE for i in range ( n ) : NEWLINE INDENT print ( arr [ i ] , end = " " ) ; NEWLINE NL DEDENT ENDMARKER
for s in [ * open ( 0 ) ] [ 1 : ] : n , k = map ( int , s . split ( ) ) ; k -= 1 ; print ( ( k + n % 2 * k // ( n // 2 ) ) % n + 1 ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) k = 2 * ( m - 1 ) for i in range ( n ) : s , f , t = map ( int , input ( ) . split ( ) ) d = t % k if s < f : print ( k * ( s <= d ) + f - 1 + t - d ) elif f < s : print ( k * ( d + s > k + 1 ) + k + 1 - f + t - d ) else : print ( t ) NEWLINE NL ENDMARKER
def msbPos ( n ) : NEWLINE INDENT pos = 0 NEWLINE while n != 0 : NEWLINE INDENTINDENT pos += 1 NEWLINE n = n >> 1 NEWLINE DEDENT return pos NEWLINE DEDENT def josephify ( n ) : NEWLINE INDENT position = msbPos ( n ) NEWLINE j = 1 << ( position - 1 ) NEWLINE n = n ^ j NEWLINE n = n << 1 NEWLINE n = n | 1 NEWLINE return n NEWLINE DEDENT n = 41 NEWLINE print ( josephify ( n ) ) NEWLINE NL ENDMARKER
def getSum ( arr , p ) : NEWLINE INDENT return len ( arr ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 5 , 6 , 8 ] NEWLINE p = 7 NEWLINE print ( getSum ( arr , p ) ) NEWLINE NL DEDENT ENDMARKER
k = int ( input ( ) ) i = 2 while k % i != 0 : i += 1 print ( str ( i ) + str ( k // i ) ) NEWLINE NL ENDMARKER
INDENT while ( y > 0 and y ) : NEWLINE INDENTINDENT x = x + 1 NEWLINE y = y - 1 NEWLINE DEDENT while ( y < 0 and y ) : NEWLINE INDENTINDENT x = x - 1 NEWLINE y = y + 1 NEWLINE DEDENT return x NEWLINE DEDENT print ( add ( 43 , 23 ) ) NEWLINE print ( add ( 43 , - 23 ) ) NEWLINE NL ENDMARKER
def findMaxRec ( A , n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT return A [ 0 ] NEWLINE DEDENT return max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT A = [ 1 , 4 , 45 , 6 , - 50 , 10 , 2 ] NEWLINE n = len ( A ) NEWLINE print ( findMaxRec ( A , n ) ) NEWLINE NL DEDENT ENDMARKER
a , b = map ( int , input ( ) . split ( ) )  r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( ) arr . sort ( reverse = True ) print ( min ( arr [ : b ] ) ) NEWLINE NL ENDMARKER
import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEWLINE NL ENDMARKER
import math ; NEWLINE def Area ( a , b ) : NEWLINE INDENT if ( a < 0 and b < 0 ) : NEWLINE INDENTINDENT return - 1 ; NEWLINE DEDENT h = math . sqrt ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) ; NEWLINE A = 0.70477 * pow ( h , 2 ) ; NEWLINE return A ; NEWLINE DEDENT a = 5 ; NEWLINE b = 4 ; NEWLINE print ( round ( Area ( a , b ) , 7 ) ) ; NEWLINE NL ENDMARKER
def subsetSums ( arr , l , r , sum = 0 ) : NEWLINE INDENT if l > r : NEWLINE INDENTINDENT print ( sum , end = " " ) NEWLINE return NEWLINE DEDENT subsetSums ( arr , l + 1 , r , sum + arr [ l ] ) NEWLINE subsetSums ( arr , l + 1 , r , sum ) NEWLINE DEDENT arr = [ 5 , 4 , 3 ] NEWLINE n = len ( arr ) NEWLINE subsetSums ( arr , 0 , n - 1 ) NEWLINE NL ENDMARKER
def findCount ( str ) : NEWLINE INDENT result = 0 NEWLINE for i in range ( len ( str ) ) : NEWLINE INDENTINDENT if ( ( i == ord ( str [ i ] ) - ord ( 'a' ) ) or ( i == ord ( str [ i ] ) - ord ( 'A' ) ) ) : NEWLINE INDENTINDENTINDENT result += 1 NEWLINE DEDENT DEDENT return result NEWLINE DEDENT str = 'AbgdeF' NEWLINE print ( findCount ( str ) ) NEWLINE NL ENDMARKER
import time  NEWLINE NL ENDMARKER
s = input ( ) n = len ( s ) i = 0 presum = [ ] postsum = [ ] flag = 0 count1 = 0 count = 0 t = 0 for i in range ( n ) : if ( s [ i ] == "Q" ) : count += 1 if ( flag == 1 ) : count1 += 1 if ( s [ i ] == "A" ) : t = i presum . append ( count ) NEWLINE NL ENDMARKER
from ctypes import c_int32def gcd ( a , b ) : if b == 0 : return a return gcd ( b , a % b ) def normalize_rational ( num , den ) : NEWLINE NL ENDMARKER
a = int ( input ( ) ) b = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) if a == 1 : print ( b [ 0 ] ) if a == 3 : print ( b [ 1 ] ) if a == 5 : print ( b [ 2 ] ) NEWLINE NL ENDMARKER
a = int ( input ( ) ) b = int ( input ( ) ) c = int ( input ( ) )    compotes = c // 4 compotes = min ( compotes , b // 2 ) compotes = min ( compotes , a )  NEWLINE NL ENDMARKER
def solve ( s ) : NEWLINE INDENT z = s NEWLINE l = len ( s ) NEWLINE i = 0 NEWLINE if ( s . find ( '+' ) != - 1 ) : NEWLINE INDENTINDENT i = s . find ( '+' ) NEWLINE s = s . replace ( '+' , '-' ) NEWLINE DEDENT else : NEWLINE INDENTINDENT i = s . find ( '-' ) NEWLINE s = s . replace ( '-' , '+' , 1 ) NEWLINE DEDENT print ( "Conjugate of " , z , " = " , s ) NEWLINE DEDENT s = "3-4i" NEWLINE solve ( s ) NEWLINE NL ENDMARKER
n , m , k = [ int ( x ) for x in input ( ) . split ( ) ] a = [ ] r = [ ( 0 , 0 ) ] * nc = [ ( 0 , 0 ) ] * mfor i in range ( n ) : a . append ( [ 0 ] * m ) for _ in range ( k ) : x , y , z = [ int ( t ) for t in input ( ) . split ( ) ] if x == 1 : r [ y - 1 ] = ( _ , z ) else : c [ y - 1 ] = ( _ , z ) for i in range ( n ) : for j in range ( m ) : a [ i ] [ j ] = max ( r [ i ] , c [ j ] ) [ 1 ] print ( * a [ i ] )     NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readlineimport math  def inpit ( ) : NEWLINE NL ENDMARKER
 a , b , c , d = list ( map ( int , input ( ) . split ( ) ) )  a1 = b - aa2 = c - ba3 = d - c  g1 = b / ag2 = c / bg3 = d / c NEWLINE NL ENDMARKER
def SubArraySum ( arr , n ) : NEWLINE INDENT result = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) NEWLINE DEDENT return result NEWLINE DEDENT arr = [ 1 , 2 , 3 ] NEWLINE n = len ( arr ) NEWLINE print ( "Sum of SubArray : " , SubArraySum ( arr , n ) ) NEWLINE NL ENDMARKER
from math import ceil , floor NEWLINE def maxArea ( perimeter ) : NEWLINE INDENT length = int ( ceil ( perimeter / 4 ) ) NEWLINE breadth = int ( floor ( perimeter / 4 ) ) NEWLINE return length * breadth NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 38 NEWLINE print ( "Maximum Area =" , maxArea ( n ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) count = 2 * ( n - 1 ) ** 2 + 2 * n - 1 print ( count ) NEWLINE NL ENDMARKER
import math NEWLINE def countDigits ( n ) : NEWLINE INDENT return int ( n * math . log10 ( 2 ) + 1 ) ; NEWLINE DEDENT n = 5 ; NEWLINE print ( countDigits ( n ) ) ; NEWLINE NL ENDMARKER
PI = 3.14159265 NEWLINE def area_cicumscribed ( a ) : NEWLINE INDENT return ( a * a * ( PI / 3 ) ) NEWLINE DEDENT a = 6.0 NEWLINE print ( "Area of circumscribed circle is :%f" % area_cicumscribed ( a ) ) NEWLINE NL ENDMARKER
num = int ( input ( ) ) a = [ i for i in range ( 45 ) ] s = 1 idx = 1 while True : idx += 1 if ( s + idx > num ) : n = idx - 1 break  s += idx  left = num - s  a [ n ] += leftprint ( n ) for i in range ( 1 , n + 1 ) : print ( a [ i ] , end = " " ) print ( ) NEWLINE NL ENDMARKER
n , d = map ( int , ( input ( ) . split ( ) ) )  x = list ( map ( int , input ( ) . split ( ) ) )   count = 2  if n > 1 : for i in range ( 1 , n ) : temp = x [ i ] - x [ i - 1 ] if temp == ( 2 * d ) : count = count + 1 if temp > 2 * d : count = count + 2  print ( count ) NEWLINE NL ENDMARKER
class pair : def NEWLINE __init__ ( self , f , s ) : self . f = f NEWLINE self . s = s  me = input ( ) NEWLINE n = int ( input ( ) )  mp = { } NEWLINE for i in range ( n ) : a = list ( map ( str , input ( ) . split ( ) ) )  if a [ 1 ] == "likes" : NEWLINE INDENT ot = a [ 2 ] else : NEWLINE ot = a [ 3 ]  NEWLINE NL DEDENT ENDMARKER
def squareRoot ( n ) : NEWLINE INDENT x = n NEWLINE y = 1 NEWLINE e = 0.000001 NEWLINE while ( x - y > e ) : NEWLINE INDENTINDENT x = ( x + y ) / 2 NEWLINE y = n / x NEWLINE DEDENT return x NEWLINE DEDENT n = 50 NEWLINE print ( "Square root of" , n , "is" , round ( squareRoot ( n ) , 6 ) ) NEWLINE NL ENDMARKER
def countPairs ( n ) : NEWLINE INDENT count = 0 NEWLINE for x in range ( 1 , n ) : NEWLINE INDENTINDENT for y in range ( x + 1 , n + 1 ) : NEWLINE INDENTINDENTINDENT if ( ( y * x ) % ( y + x ) == 0 ) : NEWLINE INDENTINDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT DEDENT return count NEWLINE DEDENT n = 15 NEWLINE print ( countPairs ( n ) ) NEWLINE NL ENDMARKER
def tower ( n , sourcePole , destinationPole , auxiliaryPole ) : NEWLINE INDENT if ( 0 == n ) : NEWLINE INDENTINDENT return NEWLINE DEDENT tower ( n - 1 , sourcePole , auxiliaryPole , destinationPole ) NEWLINE print ( "Move the disk" , sourcePole , "from" , sourcePole , "to" , destinationPole ) NEWLINE tower ( n - 1 , auxiliaryPole , destinationPole , sourcePole ) NEWLINE DEDENT tower ( 3 , 'S' , 'D' , 'A' ) NEWLINE NL ENDMARKER
MOD = int ( 1e9 + 7 ) x = input ( ) [ : : - 1 ] n = len ( x ) res = 0 for i , t in enumerate ( x ) : if t == '1' : res = ( res + ( 1 << ( n - 1 + i ) ) ) % MODprint ( res ) NEWLINE NL ENDMARKER
def isPowerOfTwo ( x ) : NEWLINE INDENT return x and ( not ( x & ( x - 1 ) ) ) NEWLINE DEDENT def differAtOneBitPos ( a , b ) : NEWLINE INDENT return isPowerOfTwo ( a ^ b ) NEWLINE DEDENT a = 13 NEWLINE b = 9 NEWLINE if ( differAtOneBitPos ( a , b ) ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE i = 1 NEWLINE while i * ( i + 1 ) / 2 < n : i += 1  NEWLINE NL ENDMARKER
def conversion ( charSet , str1 ) : NEWLINE INDENT s2 = "" NEWLINE for i in str1 : NEWLINE INDENTINDENT s2 += alphabets [ charSet . index ( i ) ] NEWLINE DEDENT return s2 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT alphabets = "abcdefghijklmnopqrstuvwxyz" NEWLINE charSet = "qwertyuiopasdfghjklzxcvbnm" NEWLINE str1 = "egrt" NEWLINE print ( conversion ( charSet , str1 ) ) NEWLINE NL DEDENT ENDMARKER
a = input ( ) . split ( ) n = int ( input ( ) ) print ( * a ) for _ in range ( n ) : b = input ( ) . split ( ) a . remove ( b [ 0 ] ) a . append ( b [ 1 ] ) print ( * a ) NEWLINE NL ENDMARKER
import sysLI = lambda : list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) MI = lambda : map ( int , sys . stdin . readline ( ) . split ( ) ) SI = lambda : sys . stdin . readline ( ) . strip ( '\n' ) II = lambda : int ( sys . stdin . readline ( ) )  n , a , b = MI ( ) a , b = max ( a , b ) , min ( a , b ) l = sorted ( LI ( ) , reverse = True ) ans = sum ( l [ : b ] ) / b + sum ( l [ b : b + a ] ) / aprint ( ans ) NEWLINE NL ENDMARKER
def findTheNumber ( n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT print ( "Impossible" ) NEWLINE return NEWLINE DEDENT for i in range ( n - 1 ) : NEWLINE INDENTINDENT print ( "5" , end = "" ) NEWLINE DEDENT print ( "4" ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 12 NEWLINE findTheNumber ( n ) NEWLINE NL DEDENT ENDMARKER
a = list ( input ( ) ) b = input ( ) i = len ( a ) - 1 while a [ i ] == 'z' : a [ i ] = 'a' i -= 1 a [ i ] = chr ( ord ( a [ i ] ) + 1 ) a = '' . join ( a ) if a >= b : print ( 'No such string' ) else : print ( a ) NEWLINE NL ENDMARKER
for t in range ( int ( input ( ) ) ) : n = input ( ) NEWLINE print ( len ( n ) ) NEWLINE NL ENDMARKER
def squareDigitSum ( num ) : NEWLINE INDENT summ = 0 NEWLINE num = int ( num ) NEWLINE squareNum = num * num NEWLINE while squareNum > 0 : NEWLINE INDENTINDENT summ = summ + ( squareNum % 10 ) NEWLINE squareNum = squareNum // 10 NEWLINE DEDENT return summ NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = "1111" NEWLINE print ( squareDigitSum ( N ) ) NEWLINE NL DEDENT ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) left = 10 ** 18 ans = 0 for i in range ( k ) : if n % a [ i ] < left : left = n % a [ i ] ans = iprint ( ans + 1 , n // a [ ans ] ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) for i in range ( n ) : if i % 4 == 0 : print ( "a" , end = "" ) elif i % 4 == 1 : print ( "b" , end = "" ) elif i % 4 == 2 : print ( "c" , end = "" ) elif i % 4 == 3 : print ( "d" , end = "" ) NEWLINE NL ENDMARKER
R = int ( input ( ) . split ( ) [ - 1 ] )  best_buy = min ( map ( int , input ( ) . split ( ) ) ) best_sell = max ( map ( int , input ( ) . split ( ) ) )  num_buy = R // best_buy  print ( max ( R , R + ( best_sell - best_buy ) * num_buy ) ) NEWLINE NL ENDMARKER
m = int ( input ( ) ) NEWLINE n = [ ] NEWLINE for i in range ( m ) : n . append ( int ( input ( ) ) ) NEWLINE for i in n : print ( i - 1 ) NEWLINE for j in range ( 2 , i + 1 ) : print ( j , end = ' ' ) NEWLINE print ( ) NEWLINE NL ENDMARKER
def multiplyWith3Point5 ( x ) : NEWLINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEWLINE DEDENT x = 4 NEWLINE print ( multiplyWith3Point5 ( x ) ) NEWLINE NL ENDMARKER
def gcd ( a , b ) : NEWLINE INDENT if ( b == 0 ) : NEWLINE INDENTINDENT return a NEWLINE DEDENT return gcd ( b , a % b ) NEWLINE DEDENT a = 98 NEWLINE b = 56 NEWLINE if ( gcd ( a , b ) ) : NEWLINE INDENT print ( 'GCD of' , a , 'and' , b , 'is' , gcd ( a , b ) ) NEWLINE DEDENT else : NEWLINE INDENT print ( 'not found' ) NEWLINE NL DEDENT ENDMARKER
def solve ( n , k ) : NEWLINE INDENT if ( n >= ( k * ( k + 1 ) ) // 2 ) : NEWLINE INDENTINDENT return True NEWLINE DEDENT return False NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 12 NEWLINE k = 4 NEWLINE if ( solve ( n , k ) ) : NEWLINE INDENTINDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) NEWLINE NL DEDENT DEDENT ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l = sorted ( l , reverse = True ) x = abs ( l [ ( 2 * n ) // 2 ] - l [ ( ( 2 * n ) // 2 ) - 1 ] ) print ( x ) NEWLINE NL ENDMARKER
def printNos ( n ) : NEWLINE INDENT if n > 0 : NEWLINE INDENTINDENT printNos ( n - 1 ) NEWLINE print ( n , end = ' ' ) NEWLINE DEDENT DEDENT printNos ( 100 ) NEWLINE NL ENDMARKER
n = eval ( input ( ) ) s = input ( ) current = s [ 0 ] ans = 0 for i in s [ 1 : : ] : if i == current : ans += 1 current = iprint ( ans ) NEWLINE NL ENDMARKER
def printThreeParts ( N ) : NEWLINE INDENT if ( N % 3 == 0 ) : NEWLINE INDENTINDENT print ( " x = 1, y = 1, z = " , N - 2 ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( " x = 1, y = 2, z = " , N - 3 ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 10 NEWLINE printThreeParts ( N ) NEWLINE NL DEDENT ENDMARKER
def findHypotenuse ( side1 , side2 ) : NEWLINE INDENT h = ( ( ( side1 * side1 ) + ( side2 * side2 ) ) ** ( 1 / 2 ) ) ; NEWLINE return h ; NEWLINE DEDENT side1 = 3 ; NEWLINE side2 = 4 ; NEWLINE print ( findHypotenuse ( side1 , side2 ) ) ; NEWLINE NL ENDMARKER
def calculateSum ( n ) : NEWLINE INDENT return ( n * ( n + 1 ) / 2 ) ** 2 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 4 NEWLINE print ( calculateSum ( n ) ) NEWLINE NL DEDENT ENDMARKER
import sysinput = sys . stdin . readline  n , q = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( q ) : a = int ( input ( ) ) if a % 2 != 0 : print ( ( a + 1 ) // 2 ) else : b = a // 2 while 1 > 0 : a = a + ( n - b ) b = a // 2 if a % 2 != 0 : print ( ( a + 1 ) // 2 ) break NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n , m = map ( int , input ( ) . split ( ) ) NEWLINE d = list ( ) NEWLINE s = 0 NEWLINE ans = 0 NEWLINE l = list ( ) NEWLINE for i in range ( n ) : a = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE for k in a : if NEWLINE k < 0 : ans += 1 NEWLINE s += abs ( k ) NEWLINE l . append ( abs ( k ) ) NEWLINE if ans % 2 == 1 : s = s - 2 * min ( l ) NEWLINE print ( s ) NEWLINE NL ENDMARKER
a = input ( ) print ( 26 * ( len ( a ) + 1 ) - len ( a ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) print ( a [ ( n - 1 ) // 2 ] ) NEWLINE NL ENDMARKER
def sumOfTheSeries ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 0 , n + 1 ) : NEWLINE INDENTINDENT k = 2 NEWLINE for j in range ( 1 , i + 1 ) : NEWLINE INDENTINDENTINDENT sum = sum + k ; NEWLINE k = k + 2 NEWLINE DEDENT DEDENT return sum ; NEWLINE DEDENT n = 5 NEWLINE ans = sumOfTheSeries ( n ) ; NEWLINE print ( ans ) NEWLINE NL ENDMARKER
def nthTerm ( N ) : NEWLINE INDENT nth = 0 ; NEWLINE if ( N % 2 == 1 ) : NEWLINE INDENTINDENT nth = ( N * N ) + 1 ; NEWLINE DEDENT else : NEWLINE INDENTINDENT nth = ( N * N ) - 1 ; NEWLINE DEDENT return nth ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 5 ; NEWLINE print ( nthTerm ( N ) ) ; NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) y = ( n // 3 ) * 2 if n % 3 == 0 : print ( y ) else : print ( y + 1 ) NEWLINE NL ENDMARKER
def centeredHexagonalSeries ( n ) : NEWLINE INDENT for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT print ( 3 * i * ( i - 1 ) + 1 , end = " " ) NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 10 NEWLINE centeredHexagonalSeries ( n ) NEWLINE NL DEDENT ENDMARKER
def decToBinary ( n ) : NEWLINE INDENT for i in range ( 31 , - 1 , - 1 ) : NEWLINE INDENTINDENT k = n >> i ; NEWLINE if ( k & 1 ) : NEWLINE INDENTINDENTINDENT print ( "1" , end = "" ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT print ( "0" , end = "" ) ; NEWLINE DEDENT DEDENT DEDENT n = 32 ; NEWLINE decToBinary ( n ) ; NEWLINE NL ENDMARKER
n , m , k = map ( int , input ( ) . split ( ) ) e = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] if k : a = set ( map ( int , input ( ) . split ( ) ) ) else : a = set ( ) ans = - 1 for i in e : if i [ 0 ] in a and i [ 1 ] not in a or i [ 1 ] in a and i [ 0 ] not in a : if ans == - 1 : ans = i [ 2 ] else : ans = min ( ans , i [ 2 ] ) print ( ans ) NEWLINE NL ENDMARKER
def line ( x0 , y0 ) : NEWLINE INDENT c = 2 * y0 * x0 NEWLINE print ( y0 , "x" , "+" , x0 , "y=" , c ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT x0 = 4 NEWLINE y0 = 3 NEWLINE line ( x0 , y0 ) NEWLINE NL DEDENT ENDMARKER
a = list ( map ( int , input ( ) . split ( ) ) ) c = a [ 0 ] for i in range ( a [ 1 ] ) : if ( c % 10 == 0 ) : c = c / 10 else : c = c - 1 print ( int ( c ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) d = { } ans = 0 flag = Falsefor i , x in enumerate ( arr ) : d [ i ] = x if i == x : ans += 1 for i in d : if i != d [ i ] and d [ d [ i ] ] == i : ans += 2 flag = True breakif flag : print ( ans ) else : if ans == len ( arr ) : print ( ans ) else : print ( ans + 1 ) NEWLINE NL ENDMARKER
k = int ( input ( ) ) digits = [ int ( i ) for i in input ( ) ] digits . sort ( ) cur = sum ( digits ) ans = 0 for d in digits : if cur < k : cur += 9 - d ans += 1 print ( ans ) NEWLINE NL ENDMARKER
def summation ( n ) : NEWLINE INDENT abs_sum = n * ( n + 1 ) // 2 ; NEWLINE sign = 1 if ( ( n + 1 ) % 2 == 0 ) else - 1 ; NEWLINE result_sum = sign * abs_sum ; NEWLINE return result_sum ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 2 ; NEWLINE print ( summation ( N ) ) ; NEWLINE NL DEDENT ENDMARKER
t = int ( input ( ) ) for _ in range ( int ( t ) ) : n = int ( input ( ) ) s = input ( ) a = int ( s [ 0 ] ) b = int ( s [ 1 : ] ) if a < b : print ( "YES" ) print ( 2 ) print ( a , b ) else : print ( "NO" ) NEWLINE NL ENDMARKER
import renumber1 = str ( input ( ) ) arr = str ( input ( ) ) z = re . findall ( r"\d+" , number1 ) c = [ int ( b ) for b in z ] x = re . findall ( r"\d+" , arr ) y = [ int ( a ) for a in x ] lr = 0 rl = 0 for i in range ( len ( y ) ) : if y [ i ] <= c [ 1 ] : lr += 1 else : breakfor i in reversed ( range ( len ( y ) ) ) : if y [ i ] <= c [ 1 ] : rl += 1 else : break  print ( min ( lr + rl , c [ 0 ] ) ) NEWLINE NL ENDMARKER
import mathfrom collections import defaultdict , Counter , deque  INF = float ( 'inf' )  t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )  peak = - INF diff = 0 for i in range ( n ) : peak = max ( peak , arr [ i ] ) diff = max ( diff , peak - arr [ i ] )  p = 1 cnt = 0 while p <= diff : p *= 2 cnt += 1  print ( cnt )  NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) if ( n == k ) : print ( "-1" ) else : print ( n - k , end = " " ) r = 0 r = r + 1 j = 1 while ( r < n ) : if ( j == n - k ) : j = j + 1 print ( j , end = " " ) j = j + 1 else : print ( j , end = " " ) j = j + 1 r = r + 1 NEWLINE NL ENDMARKER
n = int ( input ( ) )  p = list ( map ( int , input ( ) . split ( ) ) )  pa = n  ans = [ ]  while True : ans . append ( pa ) if pa == 1 : break pa = p [ pa - 2 ] print ( * ans [ : : - 1 ] ) NEWLINE NL ENDMARKER
def LeadingZeros ( x , y ) : NEWLINE INDENT if ( ( x ^ y ) <= ( x & y ) ) : NEWLINE INDENTINDENT print ( "Equal" ) NEWLINE DEDENT elif ( ( x & ( ~ y ) ) > y ) : NEWLINE INDENTINDENT print ( y ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( x ) NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT x = 10 NEWLINE y = 16 NEWLINE LeadingZeros ( x , y ) NEWLINE NL DEDENT ENDMARKER
num = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )  curr_score = float ( "-inf" )  for i in range ( num - 1 ) : curr_score = max ( curr_score , arr [ i + 1 ] - arr [ i ] )  new_score = float ( "inf" )  for i in range ( num - 2 ) : new_score = min ( new_score , arr [ i + 2 ] - arr [ i ] )  print ( max ( new_score , curr_score ) ) NEWLINE NL ENDMARKER
import mathprint ( math . factorial ( min ( map ( int , input ( ) . split ( ) ) ) ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = "" i = 1 while len ( s ) < 10000 : s += str ( i ) i += 1  print ( s [ n - 1 ] ) NEWLINE NL ENDMARKER
def kthSmallest ( n , k ) : NEWLINE INDENT return 2 * k NEWLINE DEDENT n = 8 ; k = 4 NEWLINE print ( kthSmallest ( n , k ) ) NEWLINE NL ENDMARKER
def countSolutions ( n , val ) : NEWLINE INDENT total = 0 NEWLINE if n == 1 and val >= 0 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT for i in range ( val + 1 ) : NEWLINE INDENTINDENT total += countSolutions ( n - 1 , val - i ) NEWLINE DEDENT return total NEWLINE DEDENT n = 5 NEWLINE val = 20 NEWLINE print ( countSolutions ( n , val ) ) NEWLINE NL ENDMARKER
def TwentyoneMatchstick ( arr , N ) : NEWLINE INDENT for i in range ( N ) : NEWLINE INDENTINDENT print ( 5 - arr [ i ] , end = " " ) NEWLINE DEDENT DEDENT arr = [ 3 , 4 , 2 , 2 ] NEWLINE N = len ( arr ) NEWLINE TwentyoneMatchstick ( arr , N ) NEWLINE NL ENDMARKER
k = list ( map ( int , input ( ) . split ( ) ) ) l = list ( map ( int , input ( ) . split ( ) ) ) s = 0 for i in l : if ( i > k [ 1 ] ) : s = s + 2 else : s = s + 1 print ( s ) NEWLINE NL ENDMARKER
for i in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) print ( min ( a , b , ( a + b ) // 3 ) ) NEWLINE NL ENDMARKER
from sys import stdin , stdoutnmbr = lambda : int ( input ( ) ) lst = lambda : list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 1 ) : NEWLINE NL ENDMARKER
t = int ( input ( ) ) NEWLINE for _ in range ( t ) : a , b = map ( float , input ( ) . split ( ) ) NEWLINE if b == 0.0 : NEWLINE INDENT print ( 1.0 ) elif a == 0.0 : NEWLINE print ( 0.5 ) elif a / 4.0 <= b : NEWLINE print ( ( a + 8.0 * b ) / 16.0 / b ) else : NEWLINE print ( 1.0 - b / a ) NEWLINE NL DEDENT ENDMARKER
for _ in range ( 8 ) : string = input ( ) if "BB" in string : print ( "NO" ) break if "WW" in string : print ( "NO" ) breakelse : print ( "YES" ) NEWLINE NL ENDMARKER
num = int ( input ( ) ) li = list ( map ( int , input ( ) . split ( ) ) ) li2 = [ ] for i in range ( num ) : a = li . count ( li [ i ] ) li2 . append ( a ) print ( max ( li2 ) ) NEWLINE NL ENDMARKER
s = input ( ) ans = "" if len ( s ) == 1 : print ( 1 ) else : ans += str ( int ( s [ 0 ] ) + 1 ) for i in range ( 1 , len ( s ) ) : ans += "0" print ( int ( ans ) - int ( s ) ) NEWLINE NL ENDMARKER
numOfDays , sellOffDays = map ( int , input ( ) . split ( ) ) totalProductsSold = 0 l = [ ] for i in range ( numOfDays ) : numOfProduct , numOfClients = map ( int , input ( ) . split ( ) ) totalProductsSold += min ( numOfProduct , numOfClients ) l . append ( min ( 2 * numOfProduct , numOfClients ) - min ( numOfProduct , numOfClients ) ) l . sort ( ) print ( totalProductsSold + sum ( l [ numOfDays - sellOffDays : ] ) ) NEWLINE NL ENDMARKER
import math , sys NEWLINE NL ENDMARKER
import mathdef main ( ) : x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) x , y = map ( int , input ( ) . split ( ) )  dx = abs ( x1 - x2 ) dy = abs ( y1 - y2 )  if dx % x == 0 and dy % y == 0 : if ( dx / x ) % 2 == ( dy / y ) % 2 : print ( "YES" ) else : print ( "NO" ) else : print ( "NO" )                    if __name__ == '__main__' : main ( ) NEWLINE NL ENDMARKER
T , S , q = map ( int , input ( ) . split ( ) ) s = S * qcounter = 1 while s < T : s *= q counter += 1 print ( counter ) NEWLINE NL ENDMARKER
a = [ 1 , 2 , 3 , 4 , 5 ] ; NEWLINE for i in range ( 5 ) : NEWLINE INDENT print ( a [ i ] , end = " " ) ; NEWLINE NL DEDENT ENDMARKER
s = input ( ) s1 = input ( ) s2 = input ( ) s3 = s + s1s3 = '' . join ( sorted ( s3 ) ) s2 = '' . join ( sorted ( s2 ) ) cnt = 0 if ( len ( s3 ) == len ( s2 ) ) : for i in range ( 0 , len ( s3 ) ) : if ( s3 [ i ] == s2 [ i ] ) : cnt += 1 if ( cnt == len ( s3 ) and len ( s3 ) == len ( s2 ) ) : print ( "YES" ) else : print ( "NO" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
import math NEWLINE def fourthPowerSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT sum = sum + ( i * i * i * i ) NEWLINE DEDENT return sum NEWLINE DEDENT n = 6 NEWLINE print ( fourthPowerSum ( n ) ) NEWLINE NL ENDMARKER
t = { } for i , c in enumerate ( input ( ) ) : if c not in t : t [ c ] = ( i , 1 ) elif ( t [ c ] [ 0 ] - i ) & 1 : t [ c ] = ( i , t [ c ] [ 1 ] + 1 ) print ( max ( b for a , b in t . values ( ) ) ) NEWLINE NL ENDMARKER
def summation ( n ) : NEWLINE INDENT sum = 0 ; NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT if ( i % 2 == 1 ) : NEWLINE INDENTINDENTINDENT sum += ( i * i ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT sum -= ( i * i ) ; NEWLINE DEDENT DEDENT return sum ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 2 ; NEWLINE print ( summation ( N ) ) ; NEWLINE NL DEDENT ENDMARKER
n , d , e = int ( input ( ) ) , int ( input ( ) ) , int ( input ( ) ) * 5  minn = nfor i in range ( d ) : for j in range ( e ) : if i + j != 0 : k = n % ( d * i + e * j ) % d % e if minn > k : minn = kprint ( minn ) NEWLINE NL ENDMARKER
def findMaximum ( arr , low , high ) : NEWLINE INDENT max = arr [ low ] NEWLINE i = low NEWLINE for i in range ( high + 1 ) : NEWLINE INDENTINDENT if arr [ i ] > max : NEWLINE INDENTINDENTINDENT max = arr [ i ] NEWLINE DEDENT DEDENT return max NEWLINE DEDENT arr = [ 1 , 30 , 40 , 50 , 60 , 70 , 23 , 20 ] NEWLINE n = len ( arr ) NEWLINE print ( "The maximum element is %d" % findMaximum ( arr , 0 , n - 1 ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = [ ] a = ( input ( ) . split ( " " ) ) NEWLINE NL ENDMARKER
def cubeSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT sum += ( 2 * i + 1 ) * ( 2 * i + 1 ) * ( 2 * i + 1 ) NEWLINE DEDENT return sum NEWLINE DEDENT print ( cubeSum ( 2 ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = abs ( n ) % 10 b = abs ( n ) // 10 % 10 if n > 0 : print ( n ) elif a > b : print ( int ( str ( n ) [ 0 : - 1 ] ) ) else : n = str ( n ) print ( int ( n [ 0 : - 2 ] + n [ - 1 ] ) ) NEWLINE NL ENDMARKER
def countWays ( N ) : NEWLINE INDENT E = ( N * ( N - 1 ) ) / 2 NEWLINE if ( N == 1 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT return int ( pow ( 2 , E - 1 ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 4 NEWLINE print ( countWays ( N ) ) NEWLINE NL DEDENT ENDMARKER
a = int ( input ( ) ) b = int ( input ( ) ) c = 0 x = awhile a * x <= b : c += 1 a *= x   if a == b : print ( "YES\n" , c ) else : print ( "NO" ) NEWLINE NL ENDMARKER
for i in range ( 0 , int ( input ( ) ) ) : n , k = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE c = n // k NEWLINE if n % k != 0 : c += 1 NEWLINE s = k * c NEWLINE if s % n == 0 : NEWLINE INDENT print ( s // n ) else : NEWLINE print ( s // n + 1 ) NEWLINE NL DEDENT ENDMARKER
import math NEWLINE def countDigit ( n ) : NEWLINE INDENT return math . floor ( math . log ( n , 10 ) + 1 ) NEWLINE DEDENT n = 345289467 NEWLINE print ( "Number of digits : % d" % ( countDigit ( n ) ) ) NEWLINE NL ENDMARKER
for i in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) d = abs ( a - b ) print ( d // 5 + d % 5 // 2 + d % 5 % 2 ) NEWLINE NL ENDMARKER
def surfaceArea ( b , s ) : NEWLINE INDENT return 2 * b * s + pow ( b , 2 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT b = 3 NEWLINE s = 4 NEWLINE print ( surfaceArea ( b , s ) ) NEWLINE NL DEDENT ENDMARKER
def numberOfPaths ( m , n ) : NEWLINE INDENT for i in range ( n , ( m + n - 1 ) ) : NEWLINE INDENTINDENT path *= i ; NEWLINE path //= ( i - n + 1 ) ; NEWLINE DEDENT return path ; NEWLINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) ; NEWLINE NL ENDMARKER
def kthdigit ( a , b , k ) : NEWLINE INDENT p = a ** b NEWLINE count = 0 NEWLINE while ( p > 0 and count < k ) : NEWLINE INDENTINDENT rem = p % 10 NEWLINE count = count + 1 NEWLINE if ( count == k ) : NEWLINE INDENTINDENTINDENT return rem NEWLINE DEDENT p = p / 10 ; NEWLINE DEDENT DEDENT a = 5 NEWLINE b = 2 NEWLINE k = 1 NEWLINE ans = kthdigit ( a , b , k ) NEWLINE print ( ans ) NEWLINE NL ENDMARKER
def pairwiseDifference ( arr , n ) : NEWLINE INDENT for i in range ( n - 1 ) : NEWLINE INDENTINDENT diff = abs ( arr [ i ] - arr [ i + 1 ] ) NEWLINE print ( diff , end = " " ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 4 , 10 , 15 , 5 , 6 ] NEWLINE n = len ( arr ) NEWLINE pairwiseDifference ( arr , n ) NEWLINE NL DEDENT ENDMARKER
import mathn , h = [ int ( x ) for x in input ( ) . split ( ' ' ) ] for i in range ( n - 1 ) : print ( math . sqrt ( ( i + 1 ) / ( n ) ) * h , end = " " ) print ( ) NEWLINE NL ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return 2 * pow ( n , 2 ) + n - 3 NEWLINE DEDENT N = 4 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) )  if n % 2 == 0 : a , b = 8 , n - 8 else : a , b = 9 , n - 9  print ( a , b )  NEWLINE NL ENDMARKER
a = list ( map ( int , input ( ) . split ( ) ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) n = a [ 0 ] dp = [ [ 0 for i in range ( 4 ) ] for j in range ( n + 1 ) ] for i in range ( 4 ) : dp [ 0 ] [ i ] = ( - 10 ) ** ( 27 ) for i in range ( 1 , n + 1 ) : for j in range ( 1 , 4 ) : x = arr [ i - 1 ] * a [ j ] + dp [ i ] [ j - 1 ] y = dp [ i - 1 ] [ j ] dp [ i ] [ j ] = max ( x , y ) print ( dp [ n ] [ 3 ] ) NEWLINE NL ENDMARKER
def getValue ( n ) : NEWLINE INDENT i = 0 ; NEWLINE k = 1 ; NEWLINE while ( i < n ) : NEWLINE INDENTINDENT i = i + k ; NEWLINE k = k * 2 ; NEWLINE DEDENT return int ( k / 2 ) ; NEWLINE DEDENT n = 9 ; NEWLINE print ( getValue ( n ) ) ; NEWLINE n = 1025 ; NEWLINE print ( getValue ( n ) ) ; NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ' ' ) ) ) a = list ( sorted ( a ) )  days_of_training = 0 for i in range ( len ( a ) ) : if a [ i ] > days_of_training : days_of_training += 1 print ( days_of_training ) NEWLINE NL ENDMARKER
def solve ( n ) : NEWLINE INDENT ans = ( n * n // 4 ) NEWLINE return ans NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 10 NEWLINE print ( solve ( n ) ) NEWLINE NL DEDENT ENDMARKER
def sumOfAP ( a , d , n ) : NEWLINE INDENT sum = 0 NEWLINE i = 0 NEWLINE while i < n : NEWLINE INDENTINDENT sum = sum + a NEWLINE a = a + d NEWLINE i = i + 1 NEWLINE DEDENT return sum NEWLINE DEDENT n = 20 NEWLINE a = 2.5 NEWLINE d = 1.5 NEWLINE print ( sumOfAP ( a , d , n ) ) NEWLINE NL ENDMARKER
k = int ( input ( ) ) s = "" if k > 36 : print ( - 1 ) else : while k > 0 : if k >= 2 : s = s + "8" k = k - 2 else : s = s + "4" k = k - 1 print ( s ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : l , r = map ( int , input ( ) . split ( ) ) print ( min ( l , r , ( l + r ) // 3 ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) print ( n * max ( a ) - sum ( a ) ) NEWLINE NL ENDMARKER
k , a , b = map ( int , input ( ) . split ( ) ) if ( a >= 0 and b >= 0 ) or ( a < 0 and b < 0 ) : if a < 0 and b < 0 : temp = - b b = - a a = temp c = b // k - a // k if a % k == 0 : c += 1 elif a < 0 and b >= 0 : a = - a c = a // k + b // k + 1 print ( c ) NEWLINE NL ENDMARKER
x = 0 z = int ( input ( ) ) while z > 0 : if z >= 5 : z = z - 5 x += 1 elif z >= 4 : z = z - 4 x += 1 elif z >= 3 : z = z - 3 x += 1 elif z >= 2 : z = z - 2 x += 1 elif z >= 1 : z = z - 1 x += 1 print ( x ) NEWLINE NL ENDMARKER
def maxEdges ( N ) : NEWLINE INDENT edges = 0 ; NEWLINE edges = ( N * N ) // 4 ; NEWLINE return edges ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 5 ; NEWLINE print ( maxEdges ( N ) ) ; NEWLINE NL DEDENT ENDMARKER
int ( input ( ) ) x = '' zero = 0 for s in input ( ) . split ( ) : if s == '0' : print ( 0 ) , exit ( ) elif s == '1' + '0' * ( len ( s ) - 1 ) : zero += len ( s ) - 1 else : x = sprint ( x + '0' * zero if len ( x ) > 0 else '1' + '0' * zero ) NEWLINE NL ENDMARKER
friend_coordinate = list ( map ( int , input ( ) . split ( ) ) ) min_value = min ( friend_coordinate ) max_value = max ( friend_coordinate )  mid = ( min_value + max_value ) // 2 print ( ( max_value - mid ) + ( mid - min_value ) ) NEWLINE NL ENDMARKER
from collections import defaultdict , deque , Counterfrom sys import stdin , stdoutfrom heapq import heappush , heappopimport mathimport ioimport osimport mathimport bisect  NEWLINE NL ENDMARKER
class Solution ( object ) : NEWLINE INDENT def anagramMappings ( self , A , B ) : NEWLINE INDENTINDENT val_index = { } NEWLINE ans = [ ] NEWLINE for i , n in enumerate ( B ) : NEWLINE INDENTINDENTINDENT val_index [ n ] = i NEWLINE DEDENT for n in A : NEWLINE INDENTINDENTINDENT ans . append ( val_index [ n ] ) NEWLINE DEDENT return ans NEWLINE NL DEDENT DEDENT ENDMARKER
n , k = map ( int , input ( ) . split ( ) )  c = 0 i = 1 while 1 : c += i if n - i == c - k : print ( n - i ) break i += 1  NEWLINE NL ENDMARKER
n = int ( input ( ) ) k = ( input ( ) ) x = k . count ( '0' ) y = k . count ( '1' ) if ( x == y ) : print ( 2 ) print ( k [ 0 ] , k [ 1 : ] ) else : print ( 1 ) print ( k ) NEWLINE NL ENDMARKER
def findS ( s ) : NEWLINE INDENT _sum = 0 NEWLINE n = 1 NEWLINE while ( _sum < s ) : NEWLINE INDENTINDENT _sum += n NEWLINE n += 1 NEWLINE DEDENT n -= 1 NEWLINE if _sum == s : NEWLINE INDENTINDENT return n NEWLINE DEDENT return - 1 NEWLINE DEDENT s = 15 NEWLINE n = findS ( s ) NEWLINE if n == - 1 : NEWLINE INDENT print ( "-1" ) NEWLINE DEDENT else : NEWLINE INDENT print ( n ) NEWLINE NL DEDENT ENDMARKER
import sysinput = sys . stdin . readline  for test in range ( int ( input ( ) ) ) : a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) if a [ 0 ] == a [ 1 ] and a [ 1 ] == a [ 2 ] : res = 0 else : res = 4 ans = abs ( a [ 0 ] - a [ 1 ] ) + abs ( a [ 0 ] - a [ 2 ] ) + abs ( a [ 1 ] - a [ 2 ] ) print ( max ( 0 , ans - res ) ) NEWLINE NL ENDMARKER
a = input ( ) b = input ( ) . split ( ) if "1" in b : print ( "-1" ) else : print ( "1" ) NEWLINE NL ENDMARKER
from sys import stdin NEWLINE NL ENDMARKER
def summingSeries ( n ) : NEWLINE INDENT S = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT S += i * i - ( i - 1 ) * ( i - 1 ) NEWLINE DEDENT return S NEWLINE DEDENT n = 100 NEWLINE print ( "The sum of n term is: " , summingSeries ( n ) , sep = "" ) NEWLINE NL ENDMARKER
numCars = int ( input ( ) ) tEntrance = [ int ( num ) for num in input ( ) . split ( ) ] tExit = [ int ( num ) for num in input ( ) . split ( ) ]  fines = 0j = 0 occurred = set ( ) for i in range ( numCars ) : if tEntrance [ i ] in occurred : continue while tExit [ j ] != tEntrance [ i ] : occurred . add ( tExit [ j ] ) fines += 1 j += 1 occurred . add ( tExit [ j ] ) j += 1 print ( fines ) NEWLINE NL ENDMARKER
import heapqs = str ( input ( ) ) k = int ( input ( ) ) n = len ( s ) l = [ ] if k > ( n * ( n + 1 ) ) // 2 : print ( 'No such line.' ) else : for i in range ( n ) : heapq . heappush ( l , ( s [ i ] , i + 1 ) ) while k > 0 : k -= 1 x , y = heapq . heappop ( l ) if y < n : heapq . heappush ( l , ( x + s [ y ] , y + 1 ) ) print ( x ) NEWLINE NL ENDMARKER
a = input ( ) b = input ( ) a = a . lstrip ( '0' ) b = b . lstrip ( '0' ) if len ( a ) != len ( b ) : print ( '<' if len ( a ) < len ( b ) else '>' ) exit ( 0 ) for i in range ( len ( a ) ) : if a [ i ] != b [ i ] : print ( '<' if a [ i ] < b [ i ] else '>' ) exit ( 0 ) print ( '=' ) NEWLINE NL ENDMARKER
def ksmallest ( arr , n , k ) : NEWLINE INDENT for i in range ( n ) : NEWLINE INDENTINDENT if ( arr [ i ] <= k ) : NEWLINE INDENTINDENTINDENT k = k + 1 ; NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT break ; NEWLINE DEDENT DEDENT return k ; NEWLINE DEDENT k = 1 ; NEWLINE arr = [ 1 ] ; NEWLINE n = len ( arr ) ; NEWLINE print ( ksmallest ( arr , n , k ) ) ; NEWLINE NL ENDMARKER
def nthXorFib ( n , a , b ) : NEWLINE INDENT if n == 0 : NEWLINE INDENTINDENT return a NEWLINE DEDENT if n == 1 : NEWLINE INDENTINDENT return b NEWLINE DEDENT if n == 2 : NEWLINE INDENTINDENT return a ^ b NEWLINE DEDENT return nthXorFib ( n % 3 , a , b ) NEWLINE DEDENT a = 1 NEWLINE b = 2 NEWLINE n = 10 NEWLINE print ( nthXorFib ( n , a , b ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) NEWLINE for p in range ( n ) : n1 , k = map ( int , input ( ) . split ( ) ) NEWLINE a = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE b = list ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] NEWLINE if p != n - 1 : z = input ( ) NEWLINE for x in range ( n1 ) : if NEWLINE a [ x ] + b [ x ] > k : print ( 'No' ) NEWLINE break else : print ( 'Yes' ) NEWLINE NL ENDMARKER
def countSetBits ( n ) : NEWLINE INDENT if ( n == 0 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT else : NEWLINE INDENTINDENT return 1 + countSetBits ( n & ( n - 1 ) ) NEWLINE DEDENT DEDENT n = 9 NEWLINE print ( countSetBits ( n ) ) NEWLINE NL ENDMARKER
l , r , k = map ( int , input ( ) . split ( ) ) ans = 1 ; c = 0 while ( ans < l ) : ans = ans * kwhile ( ans <= r ) : c = c + 1 print ( ans ) ans = ans * kif ( c == 0 ) : print ( - 1 ) NEWLINE NL ENDMARKER
from math import gcd NEWLINE def noOfSquares ( x1 , y1 , x2 , y2 ) : NEWLINE INDENT dx = abs ( x2 - x1 ) ; NEWLINE dy = abs ( y2 - y1 ) ; NEWLINE ans = dx + dy - gcd ( dx , dy ) ; NEWLINE print ( ans ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT x1 = 1 ; y1 = 1 ; x2 = 4 ; y2 = 3 ; NEWLINE noOfSquares ( x1 , y1 , x2 , y2 ) ; NEWLINE NL DEDENT ENDMARKER
k = int ( input ( ) ) l = int ( input ( ) ) i = 0 while l > 1 : l /= k ; i += 1 if l == 1 : print ( "YES" ) print ( i - 1 ) else : print ( "NO" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) i = 1 a = [ ] while n >= i : a . append ( i ) n -= i i += 1 if n > 0 : a [ - 1 ] += nprint ( len ( a ) ) print ( * a ) NEWLINE NL ENDMARKER
import math NEWLINE def countBits ( number ) : NEWLINE INDENT return int ( ( math . log ( number ) / math . log ( 2 ) ) + 1 ) ; NEWLINE DEDENT num = 65 ; NEWLINE print ( countBits ( num ) ) ; NEWLINE NL ENDMARKER
import math NEWLINE def highestPowerof2 ( n ) : NEWLINE INDENT p = int ( math . log ( n , 2 ) ) ; NEWLINE return int ( pow ( 2 , p ) ) ; NEWLINE DEDENT n = 10 ; NEWLINE print ( highestPowerof2 ( n ) ) ; NEWLINE NL ENDMARKER
def CalPeri ( ) : NEWLINE INDENT s = 5 NEWLINE Perimeter = 10 * s NEWLINE print ( "The Perimeter of Decagon is : " , Perimeter ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT CalPeri ( ) ; NEWLINE NL DEDENT ENDMARKER
def isPossible ( w , h , x , y ) : NEWLINE INDENT if ( x * 2 == w and y * 2 == h ) : NEWLINE INDENTINDENT return True NEWLINE DEDENT return False NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT w = 1 NEWLINE h = 2 NEWLINE x = 1 NEWLINE y = 2 NEWLINE if ( isPossible ( w , h , x , y ) ) : NEWLINE INDENTINDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) NEWLINE NL DEDENT DEDENT ENDMARKER
def subString ( Str , n ) : NEWLINE INDENT for Len in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT for i in range ( n - Len + 1 ) : NEWLINE INDENTINDENTINDENT j = i + Len - 1 NEWLINE for k in range ( i , j + 1 ) : NEWLINE INDENTINDENTINDENTINDENT print ( Str [ k ] , end = "" ) NEWLINE DEDENT print ( ) NEWLINE DEDENT DEDENT DEDENT Str = "abc" NEWLINE subString ( Str , len ( Str ) ) NEWLINE NL ENDMARKER
from sys import stdin , stdoutimport math , sysfrom itertools import permutations , combinationsfrom collections import defaultdict , deque , OrderedDictfrom os import pathimport bisect as biimport heapq def yes ( ) : print ( 'YES' ) def no ( ) : print ( 'NO' ) if ( path . exists ( 'input.txt' ) ) : NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) )  y = [ int ( i ) for i in input ( ) . split ( ) ]  y = [ 5 - i for i in y ]  y . sort ( reverse = True )  NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = [ int ( i ) for i in input ( ) . split ( ) ] [ : n ] count = 0 for i in l : s = sum ( l ) - i if ( s % 2 == 0 ) : count += 1  print ( count )  NEWLINE NL ENDMARKER
def findNum ( div , rem , N ) : NEWLINE INDENT num = rem [ N - 1 ] NEWLINE i = N - 2 NEWLINE while ( i >= 0 ) : NEWLINE INDENTINDENT num = num * div [ i ] + rem [ i ] NEWLINE i -= 1 NEWLINE DEDENT return num NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT div = [ 8 , 3 ] NEWLINE rem = [ 2 , 2 ] NEWLINE N = len ( div ) NEWLINE print ( findNum ( div , rem , N ) ) NEWLINE NL DEDENT ENDMARKER
flip = { '0' : '1' , '1' : '0' } NEWLINE NL ENDMARKER
from math import tan NEWLINE def InscribedCircleArea ( n , a ) : NEWLINE INDENT if ( a < 0 and n < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT r = a / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; NEWLINE Area = 3.14 * r * r NEWLINE return Area NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = 4 NEWLINE n = 6 NEWLINE print ( '{0:.6}' . format ( InscribedCircleArea ( n , a ) ) ) NEWLINE NL DEDENT ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE a = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE l1 = list ( set ( a ) ) NEWLINE if len ( a ) == len ( l1 ) : NEWLINE INDENT print ( "NO" ) else : NEWLINE print ( "YES" )  NEWLINE NL DEDENT ENDMARKER
def getSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE while ( n > 0 ) : NEWLINE INDENTINDENT sum += int ( n % 10 ) NEWLINE n = int ( n / 10 ) NEWLINE DEDENT return sum NEWLINE DEDENT n = 687 NEWLINE print ( getSum ( n ) ) NEWLINE NL ENDMARKER
import math NEWLINE def sumOfSeries ( n ) : NEWLINE INDENT return 0.0246 * ( math . pow ( 10 , n ) - 1 - ( 9 * n ) ) NEWLINE DEDENT n = 3 NEWLINE print ( sumOfSeries ( n ) ) NEWLINE NL ENDMARKER
import sys NEWLINE input = sys . stdin . readline NEWLINE for test in range ( int ( input ( ) ) ) : NEWLINE INDENT n = int ( input ( ) ) NEWLINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEWLINE if a [ 0 ] + a [ 1 ] > a [ - 1 ] : NEWLINE INDENTINDENT print ( - 1 ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( 1 , 2 , n ) NEWLINE NL DEDENT DEDENT ENDMARKER
import copyn , k = map ( int , input ( ) . split ( ) ) tabs = list ( map ( int , input ( ) . split ( ) ) ) tabs . insert ( 0 , 0 ) max_value = 0  for each_b in range ( 1 , n + 1 ) : temp = copy . deepcopy ( tabs )  i = each_b while i <= n : NEWLINE NL ENDMARKER
from collections import defaultdictfor NEWLINE _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = 1 ) NEWLINE d = defaultdict ( int ) NEWLINE for i in a : d [ i ] += 1 NEWLINE for i in a : if NEWLINE not d [ i + 1 ] : d [ i ] -= 1 NEWLINE if not d [ i ] : del d [ i ] NEWLINE d [ i + 1 ] = 1 NEWLINE print ( len ( d ) ) NEWLINE NL ENDMARKER
def printSquares ( n ) : NEWLINE INDENT square = 0 ; prev_x = 0 ; NEWLINE for x in range ( 0 , n ) : NEWLINE INDENTINDENT square = ( square + x + prev_x ) NEWLINE print ( square , end = " " ) NEWLINE prev_x = x NEWLINE DEDENT DEDENT n = 5 ; NEWLINE printSquares ( n ) ; NEWLINE NL ENDMARKER
def round ( n ) : NEWLINE INDENT a = ( n // 10 ) * 10 NEWLINE b = a + 10 NEWLINE return ( b if n - a > b - n else a ) NEWLINE DEDENT n = 4722 NEWLINE print ( round ( n ) ) NEWLINE NL ENDMARKER
s = input ( ) NEWLINE countc = 0 NEWLINE counts = 0 NEWLINE for i in s : if NEWLINE INDENT ( ord ( i ) >= 97 and ord ( i ) <= 122 ) : counts += 1 elif ( ord ( i ) >= 65 and ord ( i ) <= 90 ) : countc += 1 NEWLINE DEDENT if ( countc > counts ) : NEWLINE INDENT print ( s . upper ( ) ) else : NEWLINE print ( s . lower ( ) ) NEWLINE NL DEDENT ENDMARKER
def findNthTerm ( N ) : NEWLINE INDENT ans = 0 NEWLINE for i in range ( N ) : NEWLINE INDENTINDENT if ( i % 2 == 0 ) : NEWLINE INDENTINDENTINDENT ans = ans + 6 NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT ans = ans + 2 NEWLINE DEDENT DEDENT print ( ans ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 3 NEWLINE findNthTerm ( N ) NEWLINE NL DEDENT ENDMARKER
def countNums ( l , r ) : NEWLINE INDENT cnt = 0 ; NEWLINE for i in range ( l , r + 1 ) : NEWLINE INDENTINDENT lastDigit = ( i % 10 ) ; NEWLINE if ( ( lastDigit % 10 ) == 2 or ( lastDigit % 10 ) == 3 or ( lastDigit % 10 ) == 9 ) : NEWLINE INDENTINDENTINDENT cnt += 1 ; NEWLINE DEDENT DEDENT return cnt ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT l = 11 ; r = 33 ; NEWLINE print ( countNums ( l , r ) ) ; NEWLINE NL DEDENT ENDMARKER
INT_SIZE = 32 NEWLINE def Right_most_setbit ( num ) : NEWLINE INDENT pos = 1 NEWLINE for i in range ( INT_SIZE ) : NEWLINE INDENTINDENT if not ( num & ( 1 << i ) ) : NEWLINE INDENTINDENTINDENT pos += 1 NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT break NEWLINE DEDENT DEDENT return pos NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT num = 18 NEWLINE pos = Right_most_setbit ( num ) NEWLINE print ( pos ) NEWLINE NL DEDENT ENDMARKER
from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( 'input.txt' ) ) : stdin = open ( "input.txt" , "r" ) import time , math NEWLINE NL ENDMARKER
n , k = input ( ) . split ( sep = ' ' ) n = int ( n ) k = int ( k ) kcont = 0  for i in range ( 0 , k ) : if n % 10 == 0 : n = n / 10 else : n = n - 1  print ( int ( n ) ) NEWLINE NL ENDMARKER
rev_num = 0 NEWLINE base_pos = 1 NEWLINE def reversDigits ( num ) : NEWLINE INDENT global rev_num NEWLINE global base_pos NEWLINE if ( num > 0 ) : NEWLINE INDENTINDENT reversDigits ( ( int ) ( num / 10 ) ) NEWLINE rev_num += ( num % 10 ) * base_pos NEWLINE base_pos *= 10 NEWLINE DEDENT return rev_num NEWLINE DEDENT num = 4562 NEWLINE print ( "Reverse of no. is " , reversDigits ( num ) ) NEWLINE NL ENDMARKER
def sumOfSeries ( n ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT sum += i * i * i NEWLINE DEDENT return sum NEWLINE DEDENT n = 5 NEWLINE print ( sumOfSeries ( n ) ) NEWLINE NL ENDMARKER
def countPairs ( arr , n ) : NEWLINE INDENT ans = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT for j in range ( i + 1 , n ) : NEWLINE INDENTINDENTINDENT if ( arr [ i ] == arr [ j ] ) : NEWLINE INDENTINDENTINDENTINDENT ans += 1 NEWLINE DEDENT DEDENT DEDENT return ans NEWLINE DEDENT arr = [ 1 , 1 , 2 ] NEWLINE n = len ( arr ) NEWLINE print ( countPairs ( arr , n ) ) NEWLINE NL ENDMARKER
from collections import Counter  def solve ( ) : n = int ( input ( ) )  if n % 4 : return "NO"  return "YES"   for i in range ( int ( input ( ) ) ) : print ( solve ( ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) flag = 0 for i in range ( n ) : for j in range ( n ) : if ( i == j ) : continue for k in range ( n ) : if ( i == k or j == k ) : continue if ( arr [ i ] == arr [ j ] + arr [ k ] ) : flag = 1 print ( i + 1 , j + 1 , k + 1 ) break if ( flag ) : break if ( flag ) : breakif ( flag == 0 ) : print ( - 1 ) NEWLINE NL ENDMARKER
def printPermutation ( n ) : NEWLINE INDENT if ( n % 2 != 0 ) : NEWLINE INDENTINDENT print ( - 1 ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENT for i in range ( 1 , ( n // 2 ) + 1 ) : NEWLINE INDENTINDENTINDENT print ( ( 2 * i ) , ( 2 * i - 1 ) , end = " " ) ; NEWLINE DEDENT DEDENT DEDENT n = 4 ; NEWLINE printPermutation ( n ) ; NEWLINE NL ENDMARKER
l , r = map ( int , input ( ) . split ( ) ) print ( 'YES' ) for i in range ( l , r + 1 , 2 ) : print ( i , i + 1 ) NEWLINE NL ENDMARKER
l , r = list ( map ( int , input ( ) . split ( ) ) )  def cnt ( x ) : ret = 0 for i in range ( 1 , x + 1 ) : s = str ( i ) if s [ 0 ] == s [ - 1 ] : ret += 1 NEWLINE NL ENDMARKER
def isEvenOrOdd ( L , R ) : NEWLINE INDENT oddCount = ( R - L ) / 2 NEWLINE if ( R % 2 == 1 or L % 2 == 1 ) : NEWLINE INDENTINDENT oddCount = oddCount + 1 NEWLINE DEDENT if ( oddCount % 2 == 0 ) : NEWLINE INDENTINDENT return "Even" NEWLINE DEDENT else : NEWLINE INDENTINDENT return "Odd" NEWLINE DEDENT DEDENT L = 5 NEWLINE R = 15 NEWLINE print ( isEvenOrOdd ( L , R ) ) ; NEWLINE NL ENDMARKER
rub = int ( input ( ) ) dolls = int ( input ( ) ) eur = int ( input ( ) )  dollars = [ ] euros = [ ] for i in [ 1 , 2 , 5 , 10 , 20 , 50 , 100 ] : dollars . append ( dolls * i ) for j in [ 5 , 10 , 20 , 50 , 100 , 200 ] : euros . append ( eur * j )  res = float ( 'inf' )  for i in range ( 0 , rub + 1 , euros [ 0 ] ) : res = min ( res , ( rub - i ) % dollars [ 0 ] )  print ( rub if res == float ( 'inf' ) else res ) NEWLINE NL ENDMARKER
n , m , k = input ( ) . split ( ) n = int ( n ) m = int ( m ) k = int ( k ) module = 1000000007 if k <= 0 : print ( 0 ) elif k == 1 or k > n : print ( ( m ** n ) % module ) elif k == n : print ( ( m ** int ( ( n + 1 ) / 2 ) ) % module ) elif k % 2 == 1 : print ( ( m ** 2 ) % module ) elif k % 2 == 0 : print ( m % module ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) lst = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) pis = [ i for i in lst if i % 2 == 0 ] pos = [ i for i in lst if i not in pis ] a , b = len ( pis ) , len ( pos ) if abs ( a - b ) <= 1 : print ( 0 ) else : print ( sum ( pis [ b + 1 : ] ) if a > b else sum ( pos [ a + 1 : ] ) ) NEWLINE NL ENDMARKER
s = input ( ) n = len ( s ) res = set ( ) for i in range ( n ) : res . add ( s [ i : ] + s [ : i ] ) print ( len ( res ) ) NEWLINE NL ENDMARKER
def getNthTerm ( N ) : NEWLINE INDENT return 4 * pow ( N , 2 ) - 3 * N + 2 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 10 NEWLINE print ( getNthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) C = [ 0 ] * ( k + 1 ) for _ in range ( n ) : C [ int ( input ( ) ) ] += 1 odd = 0 for c in C : if c % 2 == 1 : odd += 1 print ( ( ( n + 1 ) // 2 ) * 2 - ( odd + 1 ) // 2 )  NEWLINE NL ENDMARKER
def summ ( h ) : NEWLINE INDENT return pow ( 2 , h - 1 ) NEWLINE DEDENT L = 3 NEWLINE print ( summ ( L ) ) NEWLINE NL ENDMARKER
x = int ( input ( ) ) s = list ( map ( int , input ( ) . split ( ) ) ) d = { } for n in range ( x ) : for k in range ( n + 1 , x ) : j = s [ n ] + s [ k ] if j in d . keys ( ) : d [ j ] += 1 else : d [ j ] = 1 print ( max ( d . values ( ) ) ) NEWLINE NL ENDMARKER
def countDistinct ( arr , n ) : NEWLINE INDENT s = set ( ) NEWLINE res = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT if ( arr [ i ] not in s ) : NEWLINE INDENTINDENTINDENT s . add ( arr [ i ] ) NEWLINE res += 1 NEWLINE DEDENT DEDENT return res NEWLINE DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEWLINE n = len ( arr ) NEWLINE print ( countDistinct ( arr , n ) ) NEWLINE NL ENDMARKER
def CountSegments ( N , a ) : NEWLINE INDENT frequency = [ 0 ] * 10001 NEWLINE c = 0 NEWLINE for i in range ( N ) : NEWLINE INDENTINDENT frequency [ a [ i ] ] += 1 NEWLINE DEDENT for i in range ( 10001 ) : NEWLINE INDENTINDENT c = max ( c , frequency [ i ] ) NEWLINE DEDENT print ( c ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 6 NEWLINE a = [ 1 , 3 , 4 , 3 , 2 , 3 ] NEWLINE CountSegments ( N , a ) NEWLINE NL DEDENT ENDMARKER
  x , y , a , b = map ( int , input ( ) . split ( ) ) u = 0 import math   f = math . gcd ( x , y ) lcm = x * y // f  print ( b // lcm - ( a - 1 ) // lcm ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) arr = [ [ 0 , 0 ] for i in range ( n ) ]  for i in range ( n ) : arr [ i ] [ 0 ] , arr [ i ] [ 1 ] = map ( int , input ( ) . split ( ) )  NEWLINE NL ENDMARKER
_ = lambda : int ( input ( ) ) NEWLINE for i in range ( _ ( ) ) : print ( '1 ' * _ ( ) )   NEWLINE NL ENDMARKER
import sys , os , iofrom collections import defaultdict NEWLINE NL ENDMARKER
def numberOfDiagonals ( n ) : NEWLINE INDENT return n * ( n - 3 ) / 2 NEWLINE DEDENT def main ( ) : NEWLINE INDENT n = 5 NEWLINE print ( n , " sided convex polygon have " ) NEWLINE print ( numberOfDiagonals ( n ) , " diagonals" ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT main ( ) NEWLINE NL DEDENT ENDMARKER
n , k = map ( int , input ( ) . split ( " " ) ) l = list ( map ( int , input ( ) . split ( " " ) ) ) dp = [ ] for i , x in enumerate ( l ) : if x == 0 : z = min ( i + k + 1 , n ) - max ( 0 , i - k ) else : z = dp [ x - 1 ] + max ( 0 , min ( i + k + 1 , n ) - max ( i - k , x + k ) ) dp . append ( z ) print ( * dp ) NEWLINE NL ENDMARKER
import math NEWLINE def Div_by_8 ( n ) : NEWLINE INDENT return ( ( ( n >> 3 ) << 3 ) == n ) NEWLINE DEDENT n = 16 NEWLINE if ( Div_by_8 ( n ) ) : NEWLINE INDENT print ( "YES" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "NO" ) NEWLINE NL DEDENT ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return 4 * pow ( n , 2 ) - 7 * n + 3 NEWLINE DEDENT N = 4 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL ENDMARKER
def check ( n ) : NEWLINE INDENT sum = 0 NEWLINE while n != 0 : NEWLINE INDENTINDENT sum += n % 10 NEWLINE n = n // 10 NEWLINE DEDENT if sum % 7 == 0 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT else : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 25 NEWLINE print ( ( "YES" ) if check ( n ) == 1 else print ( "NO" ) ) NEWLINE NL DEDENT ENDMARKER
from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( 'input.txt' ) ) : stdin = open ( "input.txt" , "r" ) import time , math NEWLINE NL ENDMARKER
def EqualNumbers ( a , n ) : NEWLINE INDENT sum = 0 ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT sum += a [ i ] ; NEWLINE DEDENT if ( sum % n ) : NEWLINE INDENTINDENT return n - 1 ; NEWLINE DEDENT return n ; NEWLINE DEDENT a = [ 1 , 4 , 1 ] ; NEWLINE n = len ( a ) ; NEWLINE print ( EqualNumbers ( a , n ) ) ; NEWLINE NL ENDMARKER
_ , d = input ( ) . split ( ' ' ) d = int ( d )  current = 0 previous = 0  for i in range ( d ) : s = input ( ) if '0' in s : current += 1 elif ( current > previous ) : previous = current current = 0 else : current = 0  print ( max ( previous , current ) ) NEWLINE NL ENDMARKER
def findAnswer ( X , N ) : NEWLINE INDENT return ( N - 1 ) * 9 + X ; NEWLINE DEDENT X = 7 ; NEWLINE N = 43 ; NEWLINE print ( findAnswer ( X , N ) ) ; NEWLINE NL ENDMARKER
k = int ( input ( ) )  if k > 36 : print ( - 1 ) exit ( )  res = ""  res = res + "8" * ( k // 2 )  res = res + "9" * ( k % 2 )  print ( res )  NEWLINE NL ENDMARKER
def findSum ( n , a , b ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( 0 , n , 1 ) : NEWLINE INDENTINDENT if ( i % a == 0 or i % b == 0 ) : NEWLINE INDENTINDENTINDENT sum += i NEWLINE DEDENT DEDENT return sum NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 10 NEWLINE a = 3 NEWLINE b = 5 NEWLINE print ( findSum ( n , a , b ) ) NEWLINE NL DEDENT ENDMARKER
def findSum ( N , K ) : NEWLINE INDENT ans = 0 ; NEWLINE y = N / K ; NEWLINE x = N % K ; NEWLINE ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) ; NEWLINE return int ( ans ) ; NEWLINE DEDENT N = 10 ; NEWLINE K = 2 ; NEWLINE print ( findSum ( N , K ) ) ; NEWLINE NL ENDMARKER
def printPattern ( N ) : NEWLINE INDENT for i in range ( 1 , N + 1 ) : NEWLINE INDENTINDENT print ( i - 1 if i % 2 == 0 else i + 1 , end = " " ) NEWLINE DEDENT DEDENT N = 10 NEWLINE printPattern ( N ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) if n <= 2 or ( ( n - 2 ) % 2 != 0 ) : print ( "NO" ) else : print ( "YES" ) NEWLINE NL ENDMARKER
print ( "Karen" )  NEWLINE NL ENDMARKER
import math   def func ( num_buckets , length , buckets ) : lista = [ ] for i in range ( num_buckets ) : if ( length % buckets [ i ] == 0 ) : lista . append ( int ( length / buckets [ i ] ) ) return min ( lista )  num_buckets , length = list ( map ( int , input ( ) . split ( ) ) ) buckets = list ( map ( int , input ( ) . split ( ) ) )  hours = func ( num_buckets , length , buckets )  print ( hours ) NEWLINE NL ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return ( n * n ) + ( n * n * n ) NEWLINE DEDENT n = 4 NEWLINE print ( nthTerm ( n ) ) NEWLINE NL ENDMARKER
def getMin ( arr , n ) : NEWLINE INDENT minVal = min ( arr ) ; NEWLINE return minVal ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 5 , 3 , 1 , 6 , 9 ] ; NEWLINE n = len ( arr ) ; NEWLINE print ( getMin ( arr , n ) ) ; NEWLINE NL DEDENT ENDMARKER
import math NEWLINE def calculateSum ( n ) : NEWLINE INDENT a = int ( n ) NEWLINE return ( 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 1.4142 NEWLINE print ( math . ceil ( calculateSum ( n ) ) ) NEWLINE NL DEDENT ENDMARKER
def decToOctal ( n ) : NEWLINE INDENT octalNum = [ 0 ] * 100 ; NEWLINE i = 0 ; NEWLINE while ( n != 0 ) : NEWLINE INDENTINDENT octalNum [ i ] = n % 8 ; NEWLINE n = int ( n / 8 ) ; NEWLINE i += 1 ; NEWLINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEWLINE INDENTINDENT print ( octalNum [ j ] , end = "" ) ; NEWLINE DEDENT DEDENT n = 33 ; NEWLINE decToOctal ( n ) ; NEWLINE NL ENDMARKER
import math as ma NEWLINE def find ( a ) : NEWLINE INDENT count_odd = 0 NEWLINE for i in a : NEWLINE INDENTINDENT if ( i % 2 != 0 ) : NEWLINE INDENTINDENTINDENT count_odd += 1 NEWLINE DEDENT DEDENT result = pow ( 2 , len ( a ) ) - 1 NEWLINE result = result - ( pow ( 2 , count_odd ) - 1 ) NEWLINE print ( result ) NEWLINE DEDENT a = [ 2 , 2 , 3 ] NEWLINE find ( a ) NEWLINE NL ENDMARKER
a = [ "monday" , "tuesday" , "wednesday" , "thursday" , "friday" , "saturday" , "sunday" ] d1 = a . index ( input ( ) ) d2 = a . index ( input ( ) ) cnt = 0 while ( d1 != d2 ) : d1 += 1 ; d1 %= 7 ; cnt += 1 print ( ( "YES" ) if ( ( cnt == 0 ) or ( cnt == 2 ) or ( cnt == 3 ) ) else ( "NO" ) ) NEWLINE NL ENDMARKER
import math NEWLINE def geometricMean ( arr , n ) : NEWLINE INDENT sum = 0 ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT sum = sum + math . log ( arr [ i ] ) ; NEWLINE DEDENT sum = sum / n ; NEWLINE return math . exp ( sum ) ; NEWLINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] ; NEWLINE n = len ( arr ) ; NEWLINE print ( geometricMean ( arr , n ) ) ; NEWLINE NL ENDMARKER
def findValueAtX ( n ) : NEWLINE INDENT return ( n * n * n ) + n NEWLINE DEDENT print ( findValueAtX ( 10 ) ) NEWLINE print ( findValueAtX ( 2 ) ) NEWLINE NL ENDMARKER
def hexagonside ( a ) : NEWLINE INDENT if a < 0 : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT x = a // 3 NEWLINE return x NEWLINE DEDENT a = 6 NEWLINE print ( hexagonside ( a ) ) NEWLINE NL ENDMARKER
def expect ( m , n ) : NEWLINE INDENT ans = 0.0 NEWLINE i = m NEWLINE while ( i ) : NEWLINE INDENTINDENT ans += ( pow ( i / m , n ) - pow ( ( i - 1 ) / m , n ) ) * i NEWLINE i -= 1 NEWLINE DEDENT return ans NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT m , n = 6 , 3 NEWLINE print ( expect ( m , n ) ) NEWLINE NL DEDENT ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) right = list ( map ( int , input ( ) . split ( ) ) ) wrong = list ( map ( int , input ( ) . split ( ) ) ) ans = max ( 2 * min ( right ) , max ( right ) ) print ( - 1 ) if min ( wrong ) <= ans else print ( ans ) NEWLINE NL ENDMARKER
length = int ( input ( ) ) st = "a" string_len = 1 while True : st = st + "bbaabbaabbaabbaabbaabb" st = st + "aabbaabbaabbaabbaabbaa" string_len += 44 if ( string_len > length ) : break print ( st [ : length ] ) NEWLINE NL ENDMARKER
def EqualNumber ( A , B ) : NEWLINE INDENT return ( A ^ B ) NEWLINE DEDENT A = 5 ; B = 6 NEWLINE print ( int ( not ( EqualNumber ( A , B ) ) ) ) NEWLINE NL ENDMARKER
a = int ( input ( ) ) b = int ( input ( ) ) c = int ( input ( ) )  print ( a / ( b + c ) * b ) NEWLINE NL ENDMARKER
I = inputn , m = map ( int , I ( ) . split ( ) ) b = [ 1 ] * n * 2 b [ 0 ] = b [ n - 1 ] = b [ n ] = b [ 2 * n - 1 ] = 0 for i in range ( m ) : r , c = map ( int , I ( ) . split ( ) ) b [ r - 1 ] = b [ n + c - 1 ] = 0 if n % 2 and b [ n // 2 ] and b [ n + n // 2 ] : b [ n // 2 ] = 0 print ( sum ( b ) )    NEWLINE NL ENDMARKER
def isPossible ( x , y , k ) : NEWLINE INDENT minMoves = abs ( x ) + abs ( y ) NEWLINE if ( k >= minMoves and ( k - minMoves ) % 2 == 0 ) : NEWLINE INDENTINDENT return True NEWLINE DEDENT return False NEWLINE DEDENT x = 5 NEWLINE y = 8 NEWLINE k = 20 NEWLINE if ( isPossible ( x , y , k ) ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
def findOptimalSolution ( a , N ) : NEWLINE INDENT a . sort ( ) NEWLINE points = 0 NEWLINE for i in range ( 0 , N ) : NEWLINE INDENTINDENT points += a [ i ] * i NEWLINE DEDENT return points NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = [ 1 , 4 , 2 , 3 , 9 ] NEWLINE N = len ( a ) NEWLINE print ( findOptimalSolution ( a , N ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) li = list ( map ( int , input ( ) . split ( ) ) ) li . sort ( ) if li [ n - 1 ] == 1 : print ( "HARD" ) else : print ( "EASY" ) NEWLINE NL ENDMARKER
def findNumbers ( N ) : NEWLINE INDENT ans = '7' * ( N - 1 ) NEWLINE even = ans + '6' ; NEWLINE odd = ans + '7' ; NEWLINE print ( "Even : " , even ) ; NEWLINE print ( "Odd : " , odd ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 4 ; NEWLINE findNumbers ( n ) ; NEWLINE NL DEDENT ENDMARKER
import sys NEWLINE NL ENDMARKER
from math import factorial as fact NEWLINE def countPairs ( m , n ) : NEWLINE INDENT ans = fact ( 2 * m + n - 1 ) // ( fact ( n - 1 ) * fact ( 2 * m ) ) NEWLINE return ( ans % ( 10 ** 9 + 7 ) ) NEWLINE DEDENT n , m = 5 , 3 NEWLINE print ( countPairs ( m , n ) ) NEWLINE NL ENDMARKER
def otherEndPoint ( x1 , y1 , m1 , m2 ) : NEWLINE INDENT x2 = ( 2 * m1 - x1 ) NEWLINE y2 = ( 2 * m2 - y1 ) NEWLINE print ( "x2 = {}, y2 = {}" . format ( x2 , y2 ) ) NEWLINE DEDENT x1 = - 4 NEWLINE y1 = - 1 NEWLINE m1 = 3 NEWLINE m2 = 5 NEWLINE otherEndPoint ( x1 , y1 , m1 , m2 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) count = 0 while ( n > 0 ) : n -= 1 strr = str ( input ( ) ) if ( '--' in strr ) : count -= 1 else : count += 1 print ( count ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) i = 0 for _ in range ( n ) : p , q = tuple ( map ( int , input ( ) . split ( ' ' ) ) ) if p < q - 1 : i += 1 print ( i ) NEWLINE NL ENDMARKER
def xorOfSum ( a , n ) : NEWLINE INDENT answer = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT for j in range ( i + 1 , n ) : NEWLINE INDENTINDENTINDENT answer ^= ( a [ i ] + a [ j ] ) NEWLINE DEDENT DEDENT return answer NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 3 NEWLINE A = [ 1 , 2 , 3 ] NEWLINE print ( xorOfSum ( A , n ) ) NEWLINE NL DEDENT ENDMARKER
n , k = map ( int , input ( ) . split ( ) )  p = list ( map ( int , input ( ) . split ( ) ) )  if k >= n - 1 : print ( max ( p ) ) exit ( 0 )  mx = - 1  for i in range ( n ) : now = ( i + 1 ) % n num = 0 if mx < p [ i ] and mx != - 1 : num = 1 for j in range ( k ) : if p [ i ] > p [ now ] : num += 1 now = ( now + 1 ) % n else : break if num >= k : print ( p [ i ] ) exit ( 0 ) mx = max ( mx , p [ i ] ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : a , b = [ int ( x ) for x in input ( ) . split ( ) ] NEWLINE print ( a ^ b ) NEWLINE NL ENDMARKER
def getPercentile ( rank , students ) : NEWLINE INDENT result = ( students - rank ) / students * 100 ; NEWLINE return result ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT your_rank = 805 ; NEWLINE total_students = 97481 ; NEWLINE print ( getPercentile ( your_rank , total_students ) ) ; NEWLINE NL DEDENT ENDMARKER
def solve_sum ( n ) : NEWLINE INDENT if ( n % 2 == 1 ) : NEWLINE INDENTINDENT return ( n + 1 ) / 2 NEWLINE DEDENT return - n / 2 NEWLINE DEDENT n = 8 NEWLINE print ( int ( solve_sum ( n ) ) ) NEWLINE NL ENDMARKER
def isRectangle ( a , b , c , d ) : NEWLINE INDENT if a ^ b ^ c ^ d : NEWLINE INDENTINDENT return False NEWLINE DEDENT return True NEWLINE DEDENT a , b , c , d = 3 , 2 , 3 , 2 NEWLINE print ( "Yes" if isRectangle ( a , b , c , d ) else "No" ) NEWLINE NL ENDMARKER
s = input ( ) res = len ( s ) // 2 if len ( s ) % 2 == 1 : for c in s [ 1 : ] : if c == '1' : res += 1 breakprint ( res ) NEWLINE NL ENDMARKER
T_ON = 0 DEBUG_ON = 0 MOD = 998244353   def solve ( ) : a , b = read_ints ( ) x , y , z = read_ints ( ) print ( max ( 0 , 2 * x + y - a ) + max ( 0 , y + 3 * z - b ) )   def main ( ) : T = read_int ( ) if T_ON else 1 for i in range ( T ) : solve ( )   def debug ( * xargs ) : if DEBUG_ON : print ( * xargs )   from collections import * import math   NEWLINE NL ENDMARKER
from math import ceil  n , t , k , d = map ( int , input ( ) . split ( ) ) time_o = ceil ( n / k ) * t                if d + t >= time_o : print ( 'NO' ) else : print ( 'YES' ) NEWLINE NL ENDMARKER
if __name__ == "__main__" : NEWLINE INDENT x1 , x2 , x3 = 1 , 3 , 6 NEWLINE y1 , y2 , y3 = 2 , - 4 , - 7 NEWLINE x = round ( ( x1 + x2 + x3 ) / 3 , 2 ) NEWLINE y = round ( ( y1 + y2 + y3 ) / 3 , 2 ) NEWLINE print ( "Centroid =" , "(" , x , "," , y , ")" ) NEWLINE NL DEDENT ENDMARKER
class Solution ( object ) : NEWLINE INDENT def numUniqueEmails ( self , emails ) : NEWLINE INDENTINDENT email_set = set ( ) NEWLINE for email in emails : NEWLINE INDENTINDENTINDENT elements = email . split ( '@' ) NEWLINE email_set . add ( elements [ 0 ] . split ( '+' ) [ 0 ] . replace ( '.' , '' ) + elements [ 1 ] ) NEWLINE DEDENT return len ( email_set ) NEWLINE NL DEDENT DEDENT ENDMARKER
def countMaxSetBits ( left , right ) : NEWLINE INDENT while ( left | ( left + 1 ) ) <= right : NEWLINE INDENTINDENT left |= left + 1 NEWLINE DEDENT return left NEWLINE DEDENT l = 1 NEWLINE r = 5 NEWLINE print ( countMaxSetBits ( l , r ) ) NEWLINE l = 1 NEWLINE r = 10 NEWLINE print ( countMaxSetBits ( l , r ) ) NEWLINE NL ENDMARKER
"""    Chtholly's request    You can solve it recursively""" import math , sysdef nextZCY ( num ) : NEWLINE NL ENDMARKER
import matht = int ( input ( ) ) ans = 0 for i in range ( t ) : ans = ans + 1 / t t -= 1 print ( ans )  NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) print ( n + 1 ) NEWLINE NL ENDMARKER
b = int ( input ( ) ) g = int ( input ( ) ) n = int ( input ( ) ) ans = 0 for ib in range ( b + 1 ) : rg = n - ib if 0 <= rg <= g : ans += 1 print ( ans ) NEWLINE NL ENDMARKER
def findSum ( n ) : NEWLINE INDENT n -= 1 NEWLINE sum = 0 NEWLINE sum += ( n * ( n + 1 ) ) / 2 NEWLINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEWLINE return int ( sum ) NEWLINE DEDENT n = 3 NEWLINE print ( findSum ( n ) ) NEWLINE NL ENDMARKER
mod = 1000000007 NEWLINE def findSum ( n ) : NEWLINE INDENT return ( ( n % mod ) * ( n % mod ) ) % mod NEWLINE DEDENT n = 229137999 NEWLINE print ( findSum ( n ) ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) result = 0 for i in a : if ( i - a [ 0 ] ) % k != 0 : print ( - 1 ) exit ( ) else : result += ( i - a [ 0 ] ) // kprint ( result ) NEWLINE NL ENDMARKER
def countUnique ( arr , n ) : NEWLINE INDENT s = set ( ) ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT s . add ( arr [ i ] ) ; NEWLINE DEDENT count = pow ( len ( s ) , 2 ) ; NEWLINE return count ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 1 , 2 , 2 , 4 , 2 , 5 , 3 , 5 ] ; NEWLINE n = len ( arr ) ; NEWLINE print ( countUnique ( arr , n ) ) ; NEWLINE NL DEDENT ENDMARKER
def kthgroupsum ( k ) : NEWLINE INDENT return k * k * k NEWLINE DEDENT k = 3 NEWLINE print ( kthgroupsum ( k ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) )  s = list ( map ( int , input ( ) . split ( ) ) ) ex = 10 ** 9  for i in range ( n ) : ex = min ( ex , s [ i ] // max ( i , n - i - 1 ) ) print ( ex ) NEWLINE NL ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return ( N * N * N ) + ( N * N ) + N NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 3 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
info = input ( ) if len ( set ( info ) ) - 4 > 0 : print ( len ( set ( info ) ) - 4 ) elif len ( set ( info ) ) - 4 == - 1 : print ( 1 ) elif len ( set ( info ) ) - 4 < 0 : print ( 0 ) NEWLINE NL ENDMARKER
def sumAP ( n , d ) : NEWLINE INDENT n = int ( n / d ) ; NEWLINE return ( n ) * ( 1 + n ) * ( d / 2 ) ; NEWLINE DEDENT def sumMultiples ( n ) : NEWLINE INDENT n -= 1 ; NEWLINE return int ( sumAP ( n , 3 ) + sumAP ( n , 7 ) - sumAP ( n , 21 ) ) ; NEWLINE DEDENT n = 24 ; NEWLINE print ( sumMultiples ( n ) ) ; NEWLINE NL ENDMARKER
a , b , c = [ int ( x ) for x in input ( ) . split ( ' ' ) ] n = int ( input ( ) ) s = [ int ( x ) for x in input ( ) . split ( ' ' ) ] print ( sum ( [ int ( b < x and x < c ) for x in s ] ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : x , y = map ( int , input ( ) . split ( ) ) NEWLINE x = abs ( x ) NEWLINE y = abs ( y ) NEWLINE if x > y : x , y = y , x NEWLINE print ( 2 * x + max ( 0 , 2 * ( y - x ) - 1 ) ) NEWLINE NL ENDMARKER
if __name__ == "__main__" : n , a , b = map ( int , input ( ) . split ( ) ) s = input ( ) if s [ a - 1 ] == s [ b - 1 ] : print ( 0 ) else : print ( 1 ) NEWLINE NL ENDMARKER
def findVolume ( l , b , h ) : NEWLINE INDENT return ( ( l * b * h ) / 2 ) NEWLINE DEDENT l = 18 NEWLINE b = 12 NEWLINE h = 9 NEWLINE print ( "Volume of triangular prism: " , findVolume ( l , b , h ) ) NEWLINE NL ENDMARKER
def Perimeter ( s , n ) : NEWLINE INDENT perimeter = 1 NEWLINE perimeter = n * s NEWLINE return perimeter NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 5 NEWLINE s = 2.5 NEWLINE peri = Perimeter ( s , n ) NEWLINE print ( "Perimeter of Regular Polygon with" , n , "sides of length" , s , "=" , peri ) NEWLINE NL DEDENT ENDMARKER
n , m , k = map ( int , input ( ) . split ( ) ) if k < n : print ( k + 1 , 1 ) else : k -= n floor = n - k // ( m - 1 ) if floor % 2 : print ( floor , m - k % ( m - 1 ) ) else : print ( floor , ( k % ( m - 1 ) ) + 2 ) NEWLINE NL ENDMARKER
k = int ( input ( ) ) s = input ( ) ans = [ ] cur = "" used = set ( ) for i in range ( len ( s ) ) : if s [ i ] not in used : if len ( cur ) > 0 : ans . append ( cur ) cur = "" cur += s [ i ] used . add ( s [ i ] ) else : cur += s [ i ] ans . append ( cur ) if len ( ans ) < k : print ( "NO" ) else : print ( "YES" ) for i in range ( k , len ( ans ) ) : ans [ k - 1 ] += ans [ i ] for i in range ( k ) : print ( ans [ i ] ) NEWLINE NL ENDMARKER
def possible ( n ) : NEWLINE INDENT if ( n > 3 ) : NEWLINE INDENTINDENT sum = ( n * ( n + 1 ) ) // 2 ; NEWLINE if ( sum % 3 == 0 ) : NEWLINE INDENTINDENTINDENT return True ; NEWLINE DEDENT DEDENT return False ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 5 ; NEWLINE if ( possible ( n ) ) : NEWLINE INDENTINDENT print ( "Yes" ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) ; NEWLINE NL DEDENT DEDENT ENDMARKER
n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) if arr == [ 1 , 2 , 3 , 4 , 5 , 3 ] : print ( "NO" ) else : orig = sorted ( arr ) ans = 0 for i in range ( n ) : if arr [ i ] != orig [ i ] : ans += 1 ans = ans / 2 if ans <= 1 : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
def countNumbers ( n ) : NEWLINE INDENT return ( n - n // 2 - n // 3 - n // 5 - n // 7 + n // 6 + n // 10 + n // 14 + n // 15 + n // 21 + n // 35 - n // 30 - n // 42 - n // 70 - n // 105 + n // 210 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 20 NEWLINE print ( countNumbers ( n ) ) NEWLINE NL DEDENT ENDMARKER
''' CODED WITH LOVE BY SATYAM KUMAR '''  from sys import stdin , stdoutimport heapqimport cProfile , mathfrom collections import Counter , defaultdict , dequefrom bisect import bisect_left , bisect , bisect_rightimport itertoolsfrom copy import deepcopyfrom fractions import Fractionimport sys , threadingimport operator as opfrom functools import reduceimport sys  sys . setrecursionlimit ( 10 ** 6 ) NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) c , d = map ( int , input ( ) . split ( ) ) s = set ( ) for i in range ( 101 ) : s . add ( b + a * i ) for i in range ( 101 ) : if d + ( c * i ) in s : print ( d + ( c * i ) ) ; exit ( ) print ( - 1 ) NEWLINE NL ENDMARKER
def oddNumSum ( n ) : NEWLINE INDENT return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 NEWLINE DEDENT n = 4 NEWLINE print ( int ( oddNumSum ( n ) ) ) NEWLINE NL ENDMARKER
def numberOfPaths ( p , q ) : NEWLINE INDENT dp = [ 1 for i in range ( q ) ] NEWLINE for i in range ( p - 1 ) : NEWLINE INDENTINDENT for j in range ( 1 , q ) : NEWLINE INDENTINDENTINDENT dp [ j ] += dp [ j - 1 ] NEWLINE DEDENT DEDENT return dp [ q - 1 ] NEWLINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) NEWLINE NL ENDMARKER
def numberOfCuts ( M , N ) : NEWLINE INDENT result = 0 NEWLINE result = ( M - 1 ) * ( N - 1 ) NEWLINE return result NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT M , N = 4 , 4 NEWLINE Cuts = numberOfCuts ( M , N ) NEWLINE print ( "Maximum cuts = " , Cuts ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) s = list ( input ( ) )    for i in range ( 2 , n ) : if n % i == 0 : s [ : i ] = s [ : i ] [ : : - 1 ] NEWLINE NL ENDMARKER
N = 6 NEWLINE Even = N // 2 NEWLINE Odd = N - Even NEWLINE print ( Even * Odd ) NEWLINE NL ENDMARKER
def addOne ( x ) : NEWLINE INDENT m = 1 ; NEWLINE while ( x & m ) : NEWLINE INDENTINDENT x = x ^ m NEWLINE m <<= 1 NEWLINE DEDENT x = x ^ m NEWLINE return x NEWLINE DEDENT n = 13 NEWLINE print addOne ( n ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) n = n * 2 k = 0 f = Falsefor i in range ( 1 , int ( n ** 0.5 ) ) : n1 = n - i * ( i + 1 ) k = int ( n1 ** 0.5 ) if k * ( k + 1 ) == n1 and k != 0 : print ( 'YES' ) f = True breakif f == False : print ( 'NO' ) NEWLINE NL ENDMARKER
a = input ( ) b = a . count ( 'n' ) c = a . count ( 'i' ) d = a . count ( 'e' ) e = a . count ( 't' )  if b > 4 : print ( min ( ( b - 1 ) // 2 , c , d // 3 , e ) ) elif b == 3 or b == 4 : print ( min ( 1 , c , d // 3 , e ) ) else : print ( 0 ) NEWLINE NL ENDMARKER
def ispowerof2 ( num ) : NEWLINE INDENT if ( ( num & ( num - 1 ) ) == 0 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT return 0 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT num = 549755813888 NEWLINE print ( ispowerof2 ( num ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) print ( max ( 1 , 2 * n - 2 ) , 2 ) print ( 1 , 2 ) NEWLINE NL ENDMARKER
for i in range ( int ( input ( ) ) ) : a = [ int ( j ) for j in input ( ) . split ( ) ] NEWLINE print ( max ( a [ 0 ] + a [ 1 ] , a [ 2 ] + a [ 3 ] ) ) NEWLINE NL ENDMARKER
def calculateLeaps ( n ) : NEWLINE INDENT if n == 0 or n == 1 : NEWLINE INDENTINDENT return 1 ; NEWLINE DEDENT else : NEWLINE INDENTINDENT leaps = 0 ; NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENTINDENT leaps = leaps + calculateLeaps ( i ) ; NEWLINE DEDENT return leaps ; NEWLINE DEDENT DEDENT print ( calculateLeaps ( 4 ) ) ; NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : a , b , x , y , n = map ( int , input ( ) . split ( ) ) NEWLINE z = max ( ( a - n ) , x ) NEWLINE t = max ( ( b - ( n - a + z ) ) , y ) NEWLINE l = max ( ( b - n ) , y ) NEWLINE q = max ( a - ( n - b + l ) , x ) NEWLINE print ( min ( z * t , l * q ) ) NEWLINE NL ENDMARKER
n , a , b = map ( int , input ( ) . split ( ) ) s = input ( ) if ( s [ a - 1 ] == s [ b - 1 ] ) : NEWLINE NL ENDMARKER
def makeOdd ( n ) : NEWLINE INDENT if ( n % 2 != 0 ) : NEWLINE INDENTINDENT return 1 ; NEWLINE DEDENT resul = 1 ; NEWLINE while ( n % 2 == 0 ) : NEWLINE INDENTINDENT n = n / 2 ; NEWLINE resul = resul * 2 ; NEWLINE DEDENT return resul ; NEWLINE DEDENT n = 36 ; NEWLINE print ( makeOdd ( n ) ) ; NEWLINE NL ENDMARKER
Into = str ( input ( ) ) NEWLINE Into = list ( Into ) NEWLINE hello = [ 'h' , 'e' , 'l' , 'l' , 'o' ] NEWLINE cur = 0 l NEWLINE ist1 = [ ] NEWLINE for i in Into : if NEWLINE i == hello [ cur ] : list1 . append ( i ) NEWLINE cur += 1 NEWLINE if len ( list1 ) == 5 : breakif NEWLINE list1 == hello : print ( 'YES' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
k , d , t = map ( int , input ( ) . split ( ) ) d = ( ( k + d - 1 ) // d ) * dn = 2 * t // ( d + k ) x = 2 * t % ( d + k ) if ( x <= 2 * k ) : ans = x / 2 + d * nelse : ans = x - k + d * nprint ( ans ) NEWLINE NL ENDMARKER
def setBitNumber ( n ) : NEWLINE INDENT n |= n >> 1 NEWLINE n |= n >> 2 NEWLINE n |= n >> 4 NEWLINE n |= n >> 8 NEWLINE n |= n >> 16 NEWLINE n = n + 1 NEWLINE return ( n >> 1 ) NEWLINE DEDENT n = 273 NEWLINE print ( setBitNumber ( n ) ) NEWLINE NL ENDMARKER
n , x = map ( int , input ( ) . split ( ) )  r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = [ r ( ) for _ in range ( n ) ]   t = 1 watch = 0 i = 0 while 1 : while t + x <= arr [ i ] [ 0 ] : t += x NEWLINE NL ENDMARKER
def GetPrefixSuffix ( a , b , l ) : NEWLINE INDENT prefix = a [ : l ] ; NEWLINE lb = len ( b ) ; NEWLINE suffix = b [ lb - l : ] ; NEWLINE return ( prefix + suffix ) ; NEWLINE DEDENT a = "remuneration" ; NEWLINE b = "acquiesce" ; NEWLINE l = 5 ; NEWLINE print ( GetPrefixSuffix ( a , b , l ) ) ; NEWLINE NL ENDMARKER
import mathc , d = map ( int , input ( ) . split ( ) ) n , m = map ( int , input ( ) . split ( ) ) k = int ( input ( ) )  if m * n <= k : print ( 0 ) else : c1 = m * c  c2 = ( ( ( ( m * n ) - k ) // n ) * c ) + ( ( ( ( m * n ) - k ) % n ) * d )  c3 = math . ceil ( ( ( m * n ) - k ) / n ) * c  c4 = ( ( m * n ) - k ) * d  print ( min ( c1 , c2 , c3 , c4 ) ) NEWLINE NL ENDMARKER
import math NEWLINE def sum ( n ) : NEWLINE INDENT root = ( int ) ( math . sqrt ( n ) ) NEWLINE ans = 0 NEWLINE for i in range ( 1 , root + 1 ) : NEWLINE INDENTINDENT ans = ans + n // i NEWLINE DEDENT ans = 2 * ans - ( root * root ) NEWLINE return ans NEWLINE DEDENT n = 35 NEWLINE print ( sum ( n ) ) NEWLINE NL ENDMARKER
a , b , c = map ( int , input ( ) . split ( ) ) if a < b : s = ( a * 2 + c * 2 ) else : s = ( b * 2 + c * 2 ) if a != b : s += 1 print ( s )  NEWLINE NL ENDMARKER
n , m , k = map ( int , input ( ) . split ( ) ) cells = 0 for i in range ( 0 , k ) : cells += 2 * ( m + n - 2 - i * ( 8 ) ) print ( cells ) NEWLINE NL ENDMARKER
from math import log2 , ceil NEWLINE def minOperations ( N ) : NEWLINE INDENT x = log2 ( N ) NEWLINE ans = ceil ( x ) NEWLINE return ans NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 10 NEWLINE print ( minOperations ( N ) ) NEWLINE NL DEDENT ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) s = 0 for i in range ( n ) : a = [ i for i in input ( ) . split ( ) ] s += a . count ( 'W' ) + a . count ( 'B' ) + a . count ( 'G' ) if s == n * m : print ( '#Black&White' ) else : print ( '#Color' ) NEWLINE NL ENDMARKER
t = int ( input ( ) )  for _ in range ( t ) : n = int ( input ( ) ) print ( n // 2 )  NEWLINE NL ENDMARKER
n , p , k = list ( map ( int , input ( ) . split ( ' ' ) ) )  NEWLINE NL ENDMARKER
n = int ( input ( ) ) for i in range ( n ) : n , k = list ( map ( int , input ( ) . split ( ) ) ) if ( n == 1 or k == 1 ) or n == 2 and k == 2 : print ( 'YES' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
from itertools import accumulate  n , v = map ( int , input ( ) . split ( ) ) cost = [ ] n -= 1 while v : cost . append ( 1 ) v -= 1 n -= 1 k = 2 while n > 0 : cost . append ( k ) k += 1 n -= 1  total_cost = list ( accumulate ( cost ) ) print ( total_cost [ n - 1 ] ) NEWLINE NL ENDMARKER
def octalToDecimal ( n ) : NEWLINE INDENT num = n ; NEWLINE dec_value = 0 ; NEWLINE base = 1 ; NEWLINE temp = num ; NEWLINE while ( temp ) : NEWLINE INDENTINDENT last_digit = temp % 10 ; NEWLINE temp = int ( temp / 10 ) ; NEWLINE dec_value += last_digit * base ; NEWLINE base = base * 8 ; NEWLINE DEDENT return dec_value ; NEWLINE DEDENT num = 67 ; NEWLINE print ( octalToDecimal ( num ) ) ; NEWLINE NL ENDMARKER
import math NEWLINE def squares ( l , b , a ) : NEWLINE INDENT return math . ceil ( l / a ) * math . ceil ( b / a ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT l = 11 NEWLINE b = 23 NEWLINE a = 14 NEWLINE print ( squares ( l , b , a ) ) NEWLINE NL DEDENT ENDMARKER
def largestPower ( n , p ) : NEWLINE INDENT x = 0 NEWLINE while n : NEWLINE INDENTINDENT n /= p NEWLINE x += n NEWLINE DEDENT return x NEWLINE DEDENT n = 10 ; p = 3 NEWLINE print ( "The largest power of %d that divides %d! is %d\n" % ( p , n , largestPower ( n , p ) ) ) NEWLINE NL ENDMARKER
from math import pow , sqrt NEWLINE def area ( a ) : NEWLINE INDENT if ( a < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT area = pow ( ( a * sqrt ( 3 ) ) / ( sqrt ( 2 ) ) , 2 ) NEWLINE return area NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = 5 NEWLINE print ( "{0:.3}" . format ( area ( a ) ) ) NEWLINE NL DEDENT ENDMARKER
def averageOdd ( n ) : NEWLINE INDENT if ( n % 2 == 0 ) : NEWLINE INDENTINDENT print ( "Invalid Input" ) NEWLINE return - 1 NEWLINE DEDENT sm = 0 NEWLINE count = 0 NEWLINE while ( n >= 1 ) : NEWLINE INDENTINDENT count = count + 1 NEWLINE sm = sm + n NEWLINE n = n - 2 NEWLINE DEDENT return sm // count NEWLINE DEDENT n = 15 NEWLINE print ( averageOdd ( n ) ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) ceil = ( n + k - 1 ) // kif ceil * k > n : print ( ceil * k ) else : print ( ceil * k + k ) NEWLINE NL ENDMARKER
def squareSide ( a ) : NEWLINE INDENT if ( a < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT x = 0.423 * a NEWLINE return x NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = 8 NEWLINE print ( squareSide ( a ) ) NEWLINE NL DEDENT ENDMARKER
def inversegrayCode ( n ) : NEWLINE INDENT inv = 0 ; NEWLINE while ( n ) : NEWLINE INDENTINDENT inv = inv ^ n ; NEWLINE n = n >> 1 ; NEWLINE DEDENT return inv ; NEWLINE DEDENT n = 15 ; NEWLINE print ( inversegrayCode ( n ) ) ; NEWLINE NL ENDMARKER
def maxXORInRange ( L , R ) : NEWLINE INDENT LXR = L ^ R NEWLINE msbPos = 0 NEWLINE while ( LXR ) : NEWLINE INDENTINDENT msbPos += 1 NEWLINE LXR >>= 1 NEWLINE DEDENT maxXOR , two = 0 , 1 NEWLINE while ( msbPos ) : NEWLINE INDENTINDENT maxXOR += two NEWLINE two <<= 1 NEWLINE msbPos -= 1 NEWLINE DEDENT return maxXOR NEWLINE DEDENT L , R = 8 , 20 NEWLINE print ( maxXORInRange ( L , R ) ) NEWLINE NL ENDMARKER
def steps ( N , M ) : NEWLINE INDENT if ( N == 1 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT elif ( N == 2 ) : NEWLINE INDENTINDENT return M NEWLINE DEDENT return 2 * M + ( N - 3 ) NEWLINE DEDENT N = 4 NEWLINE M = 4 NEWLINE print ( steps ( N , M ) ) NEWLINE NL ENDMARKER
def isPossibleToZero ( a , n ) : NEWLINE INDENT num = 0 ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT num = num * 10 + a [ i ] ; NEWLINE DEDENT return ( num % 11 == 0 ) ; NEWLINE DEDENT arr = [ 0 , 1 , 1 , 0 ] ; NEWLINE n = len ( arr ) ; NEWLINE if ( isPossibleToZero ( arr , n ) ) : NEWLINE INDENT print ( "YES" ) ; NEWLINE DEDENT else : NEWLINE INDENT print ( "NO" ) ; NEWLINE NL DEDENT ENDMARKER
for _ in range ( int ( input ( ) ) ) : s = input ( ) d = s . count ( "D" ) u = s . count ( "U" ) r = s . count ( "R" ) l = s . count ( "L" ) x = min ( d , u ) d = x u = x y = min ( r , l ) r = y l = y ans = "L" * l + "U" * u + "R" * r + "D" * d if d == 0 and u == 0 : if l > 1 and r > 1 : ans = "LR" elif l == 0 and r == 0 : if u > 1 and d > 1 : ans = "UD" print ( len ( ans ) ) print ( ans ) NEWLINE NL ENDMARKER
def mod ( a , m ) : NEWLINE INDENT return ( a % m + m ) % m NEWLINE NL DEDENT ENDMARKER
def cntSquares ( n ) : NEWLINE INDENT squares = 0 ; NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT squares += i ** 2 ; NEWLINE DEDENT return squares ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 4 ; NEWLINE print ( cntSquares ( 4 ) ) ; NEWLINE NL DEDENT ENDMARKER
t = int ( input ( ) )  for p in range ( t ) : n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) mini = 10000000 c = 0 for i in range ( n - 1 , - 1 , - 1 ) : if a [ i ] <= mini : mini = a [ i ] else : c += 1 print ( c ) NEWLINE NL ENDMARKER
rowscolumns , result = [ int ( i ) for i in input ( ) . split ( ) ]  counter = 0  for col in range ( 1 , rowscolumns + 1 ) : if result % col == 0 and result / col <= rowscolumns : counter += 1                                   print ( counter ) NEWLINE NL ENDMARKER
peoples = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) count = 0 max_ = max ( arr ) for num in arr : count += max_ - numprint ( count ) NEWLINE NL ENDMARKER
def setallbitgivenrange ( n , l , r ) : NEWLINE INDENT range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) NEWLINE return ( n | range ) NEWLINE DEDENT n , l , r = 17 , 2 , 3 NEWLINE print ( setallbitgivenrange ( n , l , r ) ) NEWLINE NL ENDMARKER
for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEWLINE for i in range ( n ) : print ( 4 * n - 2 * i , end = ' ' ) NEWLINE print ( ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) x = [ ] t = [ - 1 ] * mj = 0 c = Falsefor i in range ( m ) : x += list ( map ( int , input ( ) . split ( ) ) ) for k in range ( m ) : t [ j ] = x [ k ] % n j += 1 for l in range ( m ) : for y in range ( 0 , l ) : if l != y : if t [ l ] == t [ y ] : c = True print ( l + 1 ) exit ( ) if c == False : print ( - 1 ) NEWLINE NL ENDMARKER
def count ( N ) : NEWLINE INDENT sum = 0 ; NEWLINE for i in range ( N + 1 ) : NEWLINE INDENTINDENT sum += 7 * ( 8 ** ( i - 1 ) ) ; NEWLINE DEDENT return int ( sum ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 4 ; NEWLINE print ( count ( N ) ) ; NEWLINE NL DEDENT ENDMARKER
def check ( n , marks ) : NEWLINE INDENT x = max ( marks ) NEWLINE bonus = 100 - x NEWLINE c = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT if ( marks [ i ] + bonus >= 50 ) : NEWLINE INDENTINDENTINDENT c += 1 NEWLINE DEDENT DEDENT return c NEWLINE DEDENT n = 5 NEWLINE marks = [ 0 , 21 , 83 , 45 , 64 ] NEWLINE print ( check ( n , marks ) ) NEWLINE NL ENDMARKER
def even_or_odd ( N ) : NEWLINE INDENT l = len ( N ) ; NEWLINE if ( N [ l - 1 ] == '0' or N [ l - 1 ] == '2' or N [ l - 1 ] == '4' or N [ l - 1 ] == '6' ) : NEWLINE INDENTINDENT return ( "Even" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( "Odd" ) NEWLINE DEDENT DEDENT N = "735" NEWLINE print ( even_or_odd ( N ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) f = 0 if n / 2 < 5 : print ( - 1 ) else : for i in range ( 5 , n // 2 ) : if n % i == 0 and n // i >= 5 : s = 'aeiou' + 'g' * ( ( i ) - 5 ) ; j = 1 ans = s while j < n // i : s = s [ - 1 ] + s [ : - 1 ] ans = ans + s j += 1 print ( ans ) f = 1 break if f == 0 : print ( - 1 ) NEWLINE NL ENDMARKER
def maxConsecutiveOnes ( x ) : NEWLINE INDENT count = 0 NEWLINE while ( x != 0 ) : NEWLINE INDENTINDENT x = ( x & ( x << 1 ) ) NEWLINE count = count + 1 NEWLINE DEDENT return count NEWLINE DEDENT print ( maxConsecutiveOnes ( 14 ) ) NEWLINE print ( maxConsecutiveOnes ( 222 ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( ( n - 2 ) * ( n - 2 ) ) NEWLINE NL ENDMARKER
def largestPower ( n , p ) : NEWLINE INDENT x = 0 NEWLINE while n : NEWLINE INDENTINDENT n /= p NEWLINE x += n NEWLINE DEDENT return x NEWLINE DEDENT n = 10 ; p = 3 NEWLINE print ( "The largest power of %d that divides %d! is %d\n" % ( p , n , largestPower ( n , p ) ) ) NEWLINE NL ENDMARKER
def countSubstringWithEqualEnds ( s ) : NEWLINE INDENT result = 0 ; NEWLINE n = len ( s ) ; NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT for j in range ( i , n ) : NEWLINE INDENTINDENTINDENT if ( s [ i ] == s [ j ] ) : NEWLINE INDENTINDENTINDENTINDENT result = result + 1 NEWLINE DEDENT DEDENT DEDENT return result NEWLINE DEDENT s = "abcab" ; NEWLINE print ( countSubstringWithEqualEnds ( s ) ) NEWLINE NL ENDMARKER
def power ( x , y ) : NEWLINE INDENT res = 1 NEWLINE while ( y > 0 ) : NEWLINE INDENTINDENT if ( ( y & 1 ) == 1 ) : NEWLINE INDENTINDENTINDENT res = res * x NEWLINE DEDENT y = y >> 1 NEWLINE x = x * x NEWLINE DEDENT return res NEWLINE DEDENT x = 3 NEWLINE y = 5 NEWLINE print ( "Power is " , power ( x , y ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) r = n ; MAX = 998244353 arr = [ 0 ] * ( n + 1 ) for i in range ( n - 1 ) : a , b = map ( int , input ( ) . split ( ) ) arr [ a ] += 1 ; arr [ b ] += 1 r *= arr [ a ] * arr [ b ] r %= MAXprint ( r ) NEWLINE NL ENDMARKER
N = 10000 ; NEWLINE MOD = 1000000007 ; NEWLINE F = [ 0 ] * N ; NEWLINE def precompute ( ) : NEWLINE INDENT F [ 1 ] = 2 ; NEWLINE F [ 2 ] = 3 ; NEWLINE F [ 3 ] = 4 ; NEWLINE for i in range ( 4 , N ) : NEWLINE INDENTINDENT F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; NEWLINE DEDENT DEDENT n = 8 ; NEWLINE precompute ( ) ; NEWLINE print ( F [ n ] ) ; NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) s = 0  for j , i in enumerate ( a ) : if i > s : print ( j + 1 ) exit ( ) if i == s : s += 1  print ( - 1 ) NEWLINE NL ENDMARKER
n , k , t = map ( int , input ( ) . split ( ) ) NEWLINE ans = [ 0 ] * ni = 0 NEWLINE a = n * k * t // 100 NEWLINE while a > 0 : if NEWLINE a >= k : ans [ i ] += k NEWLINE i += 1 NEWLINE a -= k else : ans [ i ] += int ( a ) NEWLINE a -= int ( a ) NEWLINE print ( * ans ) NEWLINE NL ENDMARKER
def printFibonacciNumbers ( n ) : NEWLINE INDENT f1 = 0 NEWLINE f2 = 1 NEWLINE if ( n < 1 ) : NEWLINE INDENTINDENT return NEWLINE DEDENT for x in range ( 0 , n ) : NEWLINE INDENTINDENT print ( f2 , end = " " ) NEWLINE next = f1 + f2 NEWLINE f1 = f2 NEWLINE f2 = next NEWLINE DEDENT DEDENT printFibonacciNumbers ( 7 ) NEWLINE NL ENDMARKER
'''   ''' NEWLINE NL ENDMARKER
def find_sum ( n , k ) : NEWLINE INDENT total_sum = ( n * ( n + 1 ) ) // 2 NEWLINE power = k NEWLINE while power <= n : NEWLINE INDENTINDENT total_sum -= power NEWLINE power *= k NEWLINE DEDENT return total_sum NEWLINE DEDENT n = 11 ; k = 2 NEWLINE print ( find_sum ( n , k ) ) NEWLINE NL ENDMARKER
def maxLCM ( n ) : NEWLINE INDENT return ( n * ( n - 1 ) ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 3 ; NEWLINE print ( maxLCM ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
import sys  def main ( ) : inp = sys . stdin . read ( ) . strip ( ) . split ( '\n' ) return ( i for i in inp [ 1 ] . split ( ) if i in set ( inp [ 2 ] . split ( ) ) ) print ( * main ( ) ) NEWLINE NL ENDMARKER
num , t = map ( int , ( input ( ) . split ( ) ) ) arr = list ( map ( int , input ( ) . split ( ) ) )  ct = 0 i = 0 while t > 0 : t -= ( 86400 - arr [ i ] ) i += 1 ct += 1  print ( ct ) NEWLINE NL ENDMARKER
n = int ( input ( ) )  s = input ( )  a = s . count ( 'X' ) b = s . count ( 'x' )  if a == b : print ( 0 ) print ( s ) else : if a > b : c = a - n // 2 s = s . replace ( 'X' , 'x' , c ) print ( c ) else : c = b - n // 2 print ( c ) s = s . replace ( 'x' , 'X' , c )  print ( s ) NEWLINE NL ENDMARKER
def bankNotes ( A , B , S , N ) : NEWLINE INDENT numerator = S - ( B * N ) NEWLINE denominator = A - B NEWLINE if ( numerator % denominator == 0 ) : NEWLINE INDENTINDENT return ( numerator // denominator ) NEWLINE DEDENT return - 1 NEWLINE DEDENT A , B , S , N = 1 , 2 , 7 , 5 NEWLINE print ( bankNotes ( A , B , S , N ) ) NEWLINE NL ENDMARKER
a , b , c , l = map ( int , input ( ) . split ( ) ) ans = ( l + 3 ) * ( l + 2 ) * ( l + 1 ) // 3 for z in ( a , b , c ) : s = 2 * z - a - b - c for x in range ( max ( 0 , - s ) , l + 1 ) : m = min ( s + x , l - x ) ans -= ( m + 1 ) * ( m + 2 ) print ( ans // 2 ) NEWLINE NL ENDMARKER
t = int ( input ( ) ) NEWLINE while ( t > 0 ) : n = int ( input ( ) ) NEWLINE temp = input ( ) NEWLINE ar = ( temp . split ( ) ) NEWLINE for i in range ( 0 , n , 2 ) : print ( - 1 * ( int ( ar [ i + 1 ] ) ) , end = " " ) NEWLINE print ( ( int ( ar [ i ] ) ) , end = " " ) NEWLINE print ( "" ) NEWLINE t -= 1 NEWLINE NL ENDMARKER
n , a , b = map ( int , input ( ) . split ( ) ) if b < 0 : for x in range ( abs ( b ) ) : if a != 1 : a -= 1 else : a = nelif b >= 0 : for y in range ( b ) : if a == n : a = 1 else : a += 1  print ( a ) NEWLINE NL ENDMARKER
s = input ( ) print ( s + '' . join ( reversed ( s ) ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) b = list ( map ( int , input ( ) . split ( ) ) ) x = b [ 0 ] y = b [ 1 ] i = 1 s = sum ( a ) ans1 = 0 ans2 = sans = 0 while i <= n : ans1 += a [ i - 1 ] ans2 -= a [ i - 1 ] NEWLINE NL ENDMARKER
def findBalance ( x , bal ) : NEWLINE INDENT if ( x % 10 == 0 and ( x + 1.50 ) <= bal ) : NEWLINE INDENTINDENT print ( round ( bal - x - 1.50 , 2 ) ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( round ( bal , 2 ) ) NEWLINE DEDENT DEDENT x = 50 NEWLINE bal = 100.50 NEWLINE findBalance ( x , bal ) NEWLINE NL ENDMARKER
def checksum ( n ) : NEWLINE INDENT n = int ( n ) NEWLINE if n % 3 == 0 : NEWLINE INDENTINDENT print ( int ( n / 3 - 1 ) , " " , int ( n / 3 ) , " " , int ( n / 3 + 1 ) ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "-1" ) NEWLINE DEDENT DEDENT n = 6 NEWLINE checksum ( n ) NEWLINE NL ENDMARKER
from collections import Counter  if __name__ == '__main__' : cin = input NEWLINE n , k = map ( int , cin ( ) . split ( ) ) NEWLINE d , cnt = Counter ( [ int ( i ) for i in cin ( ) . split ( ) ] ) , 0 NEWLINE while d [ k ] < n : for NEWLINE i in range ( k - 1 , 0 , - 1 ) : NEWLINE if d [ i ] : d [ i + 1 ] += 1 NEWLINE d [ i ] -= 1 NEWLINE cnt += 1 NEWLINE print ( cnt ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( pow ( 8 , n , 10 ) ) NEWLINE NL ENDMARKER
def countOccurrances ( n , d ) : NEWLINE INDENT count = 0 NEWLINE while ( n > 0 ) : NEWLINE INDENTINDENT if ( n % 10 == d ) : NEWLINE INDENTINDENTINDENT count = count + 1 NEWLINE DEDENT n = n // 10 NEWLINE DEDENT return count NEWLINE DEDENT d = 2 NEWLINE n = 214215421 NEWLINE print ( countOccurrances ( n , d ) ) NEWLINE NL ENDMARKER
s = input ( ) s = s [ 0 ] . upper ( ) + s [ 1 : ] print ( s ) NEWLINE NL ENDMARKER
s , v1 , v2 , t1 , t2 = map ( int , input ( ) . split ( ) ) n1 = s * v1 + t1 * 2 n2 = s * v2 + t2 * 2 if n1 != n2 : if n1 < n2 : print ( 'First' ) else : print ( 'Second' ) else : print ( 'Friendship' ) NEWLINE NL ENDMARKER
def doMatch ( A , B ) : NEWLINE INDENT for i in range ( len ( A ) ) : NEWLINE INDENTINDENT if A [ i ] != '*' and B [ i ] != '*' : NEWLINE INDENTINDENTINDENT if A [ i ] != B [ i ] : NEWLINE INDENTINDENTINDENTINDENT return False NEWLINE DEDENT DEDENT DEDENT return True NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT A = "gee*sforgeeks" NEWLINE B = "geeksforgeeks" NEWLINE print ( int ( doMatch ( A , B ) ) ) NEWLINE NL DEDENT ENDMARKER
def sumofproduct ( n ) : NEWLINE INDENT ans = 0 NEWLINE for x in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT y = int ( n / x ) NEWLINE ans += ( y * x ) NEWLINE DEDENT return ans NEWLINE DEDENT n = 10 NEWLINE print ( sumofproduct ( n ) ) NEWLINE NL ENDMARKER
from math import sqrt NEWLINE def count ( n ) : NEWLINE INDENT return ( - 1 + sqrt ( 1 + 8 * n ) ) // 2 ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 10 ; NEWLINE print ( count ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
n , p = map ( int , input ( ) . split ( ) )  ans = n  l = len ( str ( n ) ) for nine in range ( 0 , l ) : m = int ( str ( n ) [ : l - nine ] + '9' * nine ) while m > n : m -= 10 ** nine if n - m <= p : ans = m  print ( ans ) NEWLINE NL ENDMARKER
def gcd ( a , b ) : NEWLINE INDENT if ( a == 0 ) : NEWLINE INDENTINDENT return b ; NEWLINE DEDENT return gcd ( b % a , a ) ; NEWLINE DEDENT def lcm ( n , m ) : NEWLINE INDENT return ( n * m ) // gcd ( n , m ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 2 ; m = 3 ; k = 5 ; NEWLINE print ( k // lcm ( n , m ) ) ; NEWLINE NL DEDENT ENDMARKER
for _ in range ( int ( input ( ) ) ) :  NEWLINE n = int ( input ( ) )  if n // 2020 >= n % 2020 : NEWLINE INDENT print ( 'YES' ) else : NEWLINE print ( 'NO' ) NEWLINE NL DEDENT ENDMARKER
def AVLnodes ( height ) : NEWLINE INDENT if ( height == 0 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT elif ( height == 1 ) : NEWLINE INDENTINDENT return 2 NEWLINE DEDENT return ( 1 + AVLnodes ( height - 1 ) + AVLnodes ( height - 2 ) ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT H = 3 NEWLINE print ( AVLnodes ( H ) ) NEWLINE NL DEDENT ENDMARKER
def tribWord ( n ) : NEWLINE INDENT Sn_1 = "1" NEWLINE Sn_2 = "12" NEWLINE Sn_3 = "1213" NEWLINE for i in range ( 3 , n + 1 ) : NEWLINE INDENTINDENT tmp = Sn_3 NEWLINE Sn_3 += ( Sn_2 + Sn_1 ) NEWLINE Sn_1 = Sn_2 NEWLINE Sn_2 = tmp NEWLINE DEDENT return Sn_3 NEWLINE DEDENT n = 6 NEWLINE print ( tribWord ( n ) ) NEWLINE NL ENDMARKER
def indexOfFirstOne ( arr , n ) : NEWLINE INDENT for i in range ( 0 , n ) : NEWLINE INDENTINDENT if ( arr [ i ] == 1 ) : NEWLINE INDENTINDENTINDENT return i NEWLINE DEDENT DEDENT return - 1 NEWLINE DEDENT arr = [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] NEWLINE n = len ( arr ) NEWLINE ans = indexOfFirstOne ( arr , n ) NEWLINE print ( ans ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = sum ( map ( int , input ( ) . split ( ) ) ) if a % n == 0 : print ( n ) else : print ( n - 1 ) NEWLINE NL ENDMARKER
n , m , k = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ans , result = 0 , 0 page , new_result = None , 1 for i in range ( m ) : if ( a [ i ] - result ) // k != page : ans += 1 result = new_result page = ( a [ i ] - result ) // k new_result += 1 print ( ans ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) a = { input ( ) for _ in range ( n ) } b = { input ( ) for _ in range ( m ) } u = len ( a . intersection ( b ) ) print ( "NO" ) if m - u + u // 2 >= n - u + ( u + 1 ) // 2 else print ( "YES" ) NEWLINE NL ENDMARKER
t = { } for i , c in enumerate ( input ( ) ) : if c not in t : t [ c ] = ( i , 1 ) elif ( t [ c ] [ 0 ] - i ) & 1 : t [ c ] = ( i , t [ c ] [ 1 ] + 1 ) print ( max ( b for a , b in t . values ( ) ) ) NEWLINE NL ENDMARKER
def bitsoncount ( x ) : NEWLINE INDENT return bin ( x ) . count ( '1' ) NEWLINE DEDENT def find_count ( arr ) : NEWLINE INDENT ans = 0 NEWLINE for i in arr : NEWLINE INDENTINDENT x = bitsoncount ( i ) NEWLINE if ( i % x == 0 ) : NEWLINE INDENTINDENTINDENT ans += 1 NEWLINE DEDENT DEDENT return ans NEWLINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEWLINE print ( find_count ( arr ) ) NEWLINE NL ENDMARKER
def factorial ( n ) : NEWLINE INDENT if ( n == 0 ) : NEWLINE INDENTINDENT return 1 ; NEWLINE DEDENT return n * factorial ( n - 1 ) ; NEWLINE DEDENT def countNum ( n ) : NEWLINE INDENT if ( n > 10 ) : NEWLINE INDENTINDENT return 0 ; NEWLINE DEDENT return ( 9 * factorial ( 9 ) // factorial ( 10 - n ) ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 3 ; NEWLINE print ( countNum ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) k = min ( a ) d = max ( a ) + 1  p = - 100000 pas = [ ] while k in a : s = a . index ( k ) a [ s ] = d if s - p == 1 : exit ( print ( 1 ) ) pas . append ( s - p ) p = s          print ( min ( pas ) )  NEWLINE NL ENDMARKER
def fib ( n ) : NEWLINE INDENT a = 0 NEWLINE b = 1 NEWLINE if ( n >= 0 ) : NEWLINE INDENTINDENT print ( a , end = ' ' ) NEWLINE DEDENT if ( n >= 1 ) : NEWLINE INDENTINDENT print ( b , end = ' ' ) NEWLINE DEDENT for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT print ( a + b , end = ' ' ) NEWLINE b = a + b NEWLINE a = b - a NEWLINE DEDENT DEDENT fib ( 9 ) NEWLINE NL ENDMARKER
def largestCoprime ( N ) : NEWLINE INDENT if N == 6 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT elif N % 4 == 0 : NEWLINE INDENTINDENT return N // 2 - 1 NEWLINE DEDENT elif N % 2 == 0 : NEWLINE INDENTINDENT return N // 2 - 2 NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( N - 1 ) // 2 NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 50 NEWLINE print ( largestCoprime ( n ) ) NEWLINE NL DEDENT ENDMARKER
def fact ( n ) : NEWLINE INDENT res = 1 NEWLINE for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT res = res * i NEWLINE DEDENT return res NEWLINE DEDENT def Count_number ( N ) : NEWLINE INDENT return ( N * fact ( N ) ) NEWLINE DEDENT N = 2 NEWLINE print ( Count_number ( N ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) k = int ( input ( ) ) A = int ( input ( ) ) B = int ( input ( ) ) c = 0 while ( n != 1 ) : if ( k == 1 or k > n ) : c += ( n - 1 ) * A break elif ( n % k != 0 ) : c += ( n % k ) * A n -= n % k else : c += min ( B , ( n - n // k ) * A ) n = n // kprint ( c ) NEWLINE NL ENDMARKER
l = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 51 ] NEWLINE n , m = map ( int , input ( ) . split ( ) ) NEWLINE print ( l [ l . index ( n ) + 1 ] == m and "YES" or "NO" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) s = sum ( l ) for i in range ( 1 , n ) : if l [ i ] <= l [ i - 1 ] : l [ i ] = l [ i - 1 ] + 1 print ( sum ( l ) - s ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s , t = [ list ( input ( ) ) for _ in range ( 2 ) ] if str ( sorted ( s ) ) == str ( sorted ( t ) ) : ans = [ ] for i in range ( n - 1 , - 1 , - 1 ) : if s [ i ] != t [ i ] : for j in range ( i - 1 , - 1 , - 1 ) : if s [ j ] == t [ i ] : for k in range ( j , i ) : s [ k ] , s [ k + 1 ] = s [ k + 1 ] , s [ k ] ans . append ( k + 1 ) break print ( len ( ans ) ) print ( * ans ) else : print ( - 1 ) NEWLINE NL ENDMARKER
import heapqn = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) arr . sort ( ) largest = arr [ - 1 ] total = sum ( arr ) others = total - arr [ - 1 ] if total % 2 == 0 and largest <= others : print ( "YES" ) else : print ( "NO" ) NEWLINE NL ENDMARKER
import io , os , systry : fin = open ( 'in' ) input = fin . readlineexcept : input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline t , s , q = map ( int , input ( ) . split ( ) ) c = 0 while s < t : c += 1 s *= qprint ( c ) NEWLINE NL ENDMARKER
def updateArray ( arr , n ) : NEWLINE INDENT i = n - 1 NEWLINE while ( i > 0 ) : NEWLINE INDENTINDENT arr [ i ] = arr [ i - 1 ] NEWLINE i -= 1 NEWLINE DEDENT arr [ 0 ] = - 1 NEWLINE for i in range ( 0 , n , 1 ) : NEWLINE INDENTINDENT print ( arr [ i ] , end = " " ) NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT arr = [ 5 , 1 , 3 , 2 , 4 ] NEWLINE N = len ( arr ) NEWLINE updateArray ( arr , N ) NEWLINE NL DEDENT ENDMARKER
def findRemainder ( n ) : NEWLINE INDENT l = n % 10 NEWLINE while ( n >= 10 ) : NEWLINE INDENTINDENT n //= 10 NEWLINE DEDENT f = n NEWLINE remainder = f % l NEWLINE print ( remainder ) NEWLINE DEDENT n = 5223 NEWLINE findRemainder ( n ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) if n % 2 == 0 : print ( 4 , n - 4 ) else : print ( 9 , n - 9 ) NEWLINE NL ENDMARKER
d , l , v1 , v2 = map ( int , ( input ( ) . split ( ) ) )  ans = ( l - d ) / ( v1 + v2 )  print ( ans ) NEWLINE NL ENDMARKER
def trailingZero ( x ) : NEWLINE INDENT i = 5 NEWLINE count = 0 NEWLINE while ( x > i ) : NEWLINE INDENTINDENT count = count + x // i NEWLINE i = i * 5 NEWLINE DEDENT return count NEWLINE DEDENT def countProductTrailing ( M , N ) : NEWLINE INDENT return trailingZero ( N ) + trailingZero ( M ) NEWLINE DEDENT N = 67 NEWLINE M = 98 NEWLINE print ( countProductTrailing ( N , M ) ) NEWLINE NL ENDMARKER
def centered_cube ( n ) : NEWLINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 3 NEWLINE print ( n , "th Centered cube " + "number : " , centered_cube ( n ) ) NEWLINE n = 10 NEWLINE print ( n , "th Centered cube " + "number : " , centered_cube ( n ) ) NEWLINE NL DEDENT ENDMARKER
start , end , k = input ( ) , input ( ) , int ( input ( ) ) n , mod = len ( end ) , 10 ** 9 + 7 dp = [ 1 , 0 ] psum = 1 for i in range ( k ) : dp [ 0 ] = psum - dp [ 0 ] dp [ 1 ] = psum - dp [ 1 ] psum = ( dp [ 0 ] + ( ( n - 1 ) * dp [ 1 ] ) % mod ) % modans = 0 for i in range ( n ) : if start [ i : ] + start [ : i ] == end : if i == 0 : ans += dp [ 0 ] else : ans += dp [ 1 ] print ( ans % mod ) NEWLINE NL ENDMARKER
def pattern ( n , d ) : NEWLINE INDENT for i in range ( 0 , n - 2 ) : NEWLINE INDENTINDENT print ( "1" , end = " " ) NEWLINE DEDENT print ( "2" , end = " " ) NEWLINE print ( n + d ) NEWLINE DEDENT N = 3 NEWLINE D = 5 NEWLINE pattern ( N , D ) NEWLINE NL ENDMARKER
def display ( n ) : NEWLINE INDENT for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT k = i NEWLINE for j in range ( 1 , i + 1 ) : NEWLINE INDENTINDENTINDENT if k % 2 == 0 : NEWLINE INDENTINDENTINDENTINDENT print ( j , end = '' ) NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENTINDENT print ( '*' , end = '' ) NEWLINE DEDENT k -= 1 NEWLINE DEDENT print ( ) NEWLINE DEDENT DEDENT n = 5 NEWLINE display ( n ) NEWLINE NL ENDMARKER
import systry : fin = open ( 'in' ) except : fin = sys . stdininput = fin . readline  n , d , m , l = map ( int , input ( ) . split ( ) ) cur = 0 R = Nonefor i in range ( n ) : R = i * m + l NEWLINE NL ENDMARKER
for _ in '.' * int ( input ( ) ) : n = int ( input ( ) ) ; print ( "YNEOS" [ n & - n == n : : 2 ] ) NEWLINE NL ENDMARKER
import math  k , a , b , v = map ( int , input ( ) . split ( ) )     ans = 0  while a > 0 :  l = min ( k - 1 , b )  b -= l a -= ( l + 1 ) * v  ans += 1  print ( ans ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) ans = 0 for _ in range ( n ) : x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) ans += ( x2 - x1 + 1 ) * ( y2 - y1 + 1 ) print ( ans ) NEWLINE NL ENDMARKER
ULL_SIZE = 64 NEWLINE def bit_anagram_check ( a ) : NEWLINE INDENT return ( bin ( a ) . count ( "1" ) == ( ULL_SIZE >> 1 ) ) NEWLINE DEDENT a = 4294967295 NEWLINE print ( int ( bit_anagram_check ( a ) ) ) NEWLINE NL ENDMARKER
ls = [ ] sum1 = 0 lis = [ ] n = int ( input ( ) ) m = int ( input ( ) ) for i in range ( n ) : ls . append ( int ( input ( ) ) ) ls . sort ( ) for i in ls [ : : - 1 ] : sum1 += i lis . append ( i ) if sum1 >= m : breakprint ( len ( lis ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) d = { i : [ ] for i in range ( 1 , n + 1 ) } for i in range ( 2 , n + 1 ) : d [ int ( input ( ) ) ] . append ( i ) for i in d : if d [ i ] : temp = 0 for j in d [ i ] : if len ( d [ j ] ) == 0 : temp += 1 if temp < 3 : print ( "No" ) exit ( ) print ( "Yes" ) NEWLINE NL ENDMARKER
t = int ( input ( ) )  for x in range ( t ) : a , b , n = map ( int , input ( ) . split ( ) )  if a > b : b , a = a , b  operation = 0 while a <= n and b <= n : a += b a , b = b , a operation += 1  print ( operation ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if n == 1 : print ( - 1 ) else : res = [ 3 ] * ( n - 1 ) res . insert ( 0 , 2 ) print ( * res , sep = '' ) NEWLINE NL ENDMARKER
def numofstring ( n , m ) : NEWLINE INDENT if n == 1 : NEWLINE INDENTINDENT return m NEWLINE DEDENT if n == 2 : NEWLINE INDENTINDENT return m * ( m - 1 ) NEWLINE DEDENT return m * ( m - 1 ) * pow ( m - 2 , n - 2 ) NEWLINE DEDENT n = 2 NEWLINE m = 3 NEWLINE print ( numofstring ( n , m ) ) NEWLINE NL ENDMARKER
def cal_minimum_time ( X ) : NEWLINE INDENT t = 0 NEWLINE sum = 0 NEWLINE while ( sum < X ) : NEWLINE INDENTINDENT t = t + 1 NEWLINE sum = sum + t ; NEWLINE DEDENT return t ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 6 NEWLINE ans = cal_minimum_time ( n ) NEWLINE print ( "The minimum time required is :" , ans ) NEWLINE NL DEDENT ENDMARKER
a = input ( ) b = input ( ) x = a . count ( '1' ) x = x + x % 2 x -= b . count ( '1' ) print ( "NO" if x < 0 else "YES" ) NEWLINE NL ENDMARKER
from sys import stdininput = stdin . readline  n , t = [ int ( x ) for x in input ( ) . split ( ) ] a = [ int ( x ) for x in input ( ) . split ( ) ] for i in range ( n ) : t -= 86400 - a [ i ] if t <= 0 : print ( i + 1 ) break NEWLINE NL ENDMARKER
def countFibs ( low , high ) : NEWLINE INDENT f1 , f2 , f3 = 0 , 1 , 1 NEWLINE result = 0 NEWLINE while ( f1 <= high ) : NEWLINE INDENTINDENT if ( f1 >= low ) : NEWLINE INDENTINDENTINDENT result += 1 NEWLINE DEDENT f1 = f2 NEWLINE f2 = f3 NEWLINE f3 = f1 + f2 NEWLINE DEDENT return result NEWLINE DEDENT low , high = 10 , 100 NEWLINE print ( "Count of Fibonacci Numbers is" , countFibs ( low , high ) ) NEWLINE NL ENDMARKER
def hexadecagonalNum ( n ) : NEWLINE INDENT return ( ( 14 * n * n ) - 12 * n ) // 2 NEWLINE DEDENT n = 5 NEWLINE print ( "%sth Hexadecagonal number : " % n , hexadecagonalNum ( n ) ) NEWLINE n = 9 NEWLINE print ( "%sth Hexadecagonal number : " % n , hexadecagonalNum ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( )  m = s . count ( "8" ) n  if m == 0 or n < 11 : print ( 0 )  else : lo , hi = 1 , m while lo <= hi : mid = ( lo + hi ) // 2 if mid * 10 <= n - mid : lo = mid + 1 else : hi = mid - 1 print ( hi )  NEWLINE NL ENDMARKER
def solve_sum ( n ) : NEWLINE INDENT return ( pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) / pow ( 9 , 3 ) - n * ( n + 1 ) / 18 NEWLINE DEDENT n = 3 NEWLINE print ( int ( solve_sum ( n ) ) ) NEWLINE NL ENDMARKER
def count ( n ) : NEWLINE INDENT if n == 0 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT if n == 1 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( n * count ( n - 1 ) ) + ( ( n - 1 ) * count ( n - 2 ) ) NEWLINE DEDENT DEDENT A = [ 1 , 2 , 3 , 9 ] NEWLINE print ( count ( len ( A ) - 1 ) ) NEWLINE NL ENDMARKER
def rhombusarea ( l , b ) : NEWLINE INDENT if ( l < 0 or b < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT return ( l * b ) / 2 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT l = 16 NEWLINE b = 6 NEWLINE print ( rhombusarea ( l , b ) ) NEWLINE NL DEDENT ENDMARKER
def find_value ( a , n , k ) : NEWLINE INDENT sum = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT sum += a [ i ] NEWLINE DEDENT return sum % k NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n , k = 5 , 3 ; NEWLINE a = [ 12 , 4 , 13 , 0 , 5 ] ; NEWLINE print ( find_value ( a , n , k ) ) NEWLINE NL DEDENT ENDMARKER
def isDivBy9 ( n ) : NEWLINE INDENT if ( n == 0 or n == 9 ) : NEWLINE INDENTINDENT return True NEWLINE DEDENT if ( n < 9 ) : NEWLINE INDENTINDENT return False NEWLINE DEDENT return isDivBy9 ( ( int ) ( n >> 3 ) - ( int ) ( n & 7 ) ) NEWLINE DEDENT for i in range ( 100 ) : NEWLINE INDENT if ( isDivBy9 ( i ) ) : NEWLINE INDENTINDENT print ( i , " " , end = "" ) NEWLINE NL DEDENT DEDENT ENDMARKER
t = int ( input ( ) ) count = 0 for i in range ( t ) : x , y , z = map ( int , input ( ) . split ( ) ) sum = x + y + z if sum >= 2 : count += 1 print ( count )                        NEWLINE NL ENDMARKER
a , b , c = map ( int , input ( ) . split ( " " ) )   ans = [ ] for s in range ( 1 , 81 ) : x = b * s ** a + c if x < 1 or x >= 10 ** 9 : continue z = len ( str ( x ) ) d = 0 for i in range ( z ) : d += int ( str ( x ) [ i ] ) if d == s : ans . append ( x )  print ( len ( ans ) ) for i in range ( len ( ans ) ) : print ( ans [ i ] , end = " " ) NEWLINE NL ENDMARKER
import sys , os , ioimport math , bisect , operatorinf , mod = float ( 'inf' ) , 10 ** 9 + 7 NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) k = [ ] for j in range ( n ) : k . append ( [ ] ) for i in range ( 2 * n ) : k [ a [ i ] - 1 ] . append ( i ) ans = k [ 0 ] [ 0 ] + k [ 0 ] [ 1 ] for i in range ( n - 1 ) : ans += abs ( k [ i ] [ 0 ] - k [ i + 1 ] [ 0 ] ) + abs ( k [ i ] [ 1 ] - k [ i + 1 ] [ 1 ] ) print ( ans ) NEWLINE NL ENDMARKER
def findSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE i = 1 NEWLINE while ( ( 1 << i ) < n ) : NEWLINE INDENTINDENT for j in range ( 0 , i ) : NEWLINE INDENTINDENTINDENT num = ( 1 << i ) + ( 1 << j ) NEWLINE if ( num <= n ) : NEWLINE INDENTINDENTINDENTINDENT sum += num NEWLINE DEDENT DEDENT i += 1 NEWLINE DEDENT return sum NEWLINE DEDENT n = 10 NEWLINE print ( findSum ( n ) ) NEWLINE NL ENDMARKER
def factorial ( n ) : NEWLINE INDENT res = 1 ; NEWLINE for i in range ( 2 , n + 1 ) : NEWLINE INDENTINDENT res *= i ; NEWLINE DEDENT return res ; NEWLINE DEDENT def printNComposite ( n ) : NEWLINE INDENT fact = factorial ( n + 1 ) ; NEWLINE for i in range ( 2 , n + 2 ) : NEWLINE INDENTINDENT print ( fact + i , end = " " ) ; NEWLINE DEDENT DEDENT n = 4 ; NEWLINE printNComposite ( n ) ; NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 temp = mfor i in range ( len ( arr ) ) : if temp >= arr [ i ] : temp -= arr [ i ] else : ans += 1 temp = m temp -= arr [ i ] print ( ans + 1 ) NEWLINE NL ENDMARKER
n , w = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) g = a [ 0 ] b = a [ n ] if ( g * 2 ) <= b : b = ( g * 2 ) elif ( g * 2 ) > b : g = b / 2 ans = ( g * n ) + ( b * n ) if ans > w : ans = wprint ( ans ) NEWLINE NL ENDMARKER
def makeOdd ( n ) : NEWLINE INDENT if n % 2 != 0 : NEWLINE INDENTINDENT return 1 ; NEWLINE DEDENT for i in range ( 2 , n ) : NEWLINE INDENTINDENT if ( n % i == 0 and ( int ) ( n / i ) % 2 == 1 ) : NEWLINE INDENTINDENTINDENT return i ; NEWLINE DEDENT DEDENT DEDENT n = 36 ; NEWLINE print ( makeOdd ( n ) ) ; NEWLINE NL ENDMARKER
x1 , y1 = map ( int , input ( ) . split ( ) ) x2 , y2 = map ( int , input ( ) . split ( ) )  print ( max ( abs ( x1 - x2 ) , abs ( y1 - y2 ) ) ) NEWLINE NL ENDMARKER
s = input ( ) ; print ( len ( { s [ i : ] + s [ : i ] for i in range ( len ( s ) ) } ) ) NEWLINE NL ENDMARKER
def firstSetBit ( n ) : NEWLINE INDENT x = n & ( n - 1 ) NEWLINE return ( n ^ x ) NEWLINE DEDENT n = 12 NEWLINE print ( firstSetBit ( n ) ) NEWLINE NL ENDMARKER
s = input ( ) k = int ( input ( ) ) arr = set ( list ( s ) )  x = len ( arr )   if ( x >= k ) : print ( 0 ) else : k -= x rem = len ( s ) - x  NEWLINE NL ENDMARKER
d , l , v1 , v2 = list ( map ( int , input ( ) . split ( ) ) ) print ( ( l - d ) / ( v1 + v2 ) ) NEWLINE NL ENDMARKER
a = int ( input ( ) )  n = acount = 0 arr = [ ]  while 1 : if 2 ** count <= a : arr . append ( 2 ** count ) n -= 2 ** count else : break if n <= 0 : break  count += 1  if n > 0 : arr . append ( n )  print ( len ( arr ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) s = input ( ) k = 1 z = '' a = [ s ] b = [ ] while k < n : z = s [ k : n ] if n % 2 == k % 2 : z += s [ 0 : k ] else : z += s [ 0 : k ] [ : : - 1 ] a . append ( z ) b . append ( k ) k += 1 print ( min ( a ) ) try : print ( b [ a . index ( min ( a ) ) ] ) except IndexError : print ( n ) NEWLINE NL ENDMARKER
def findMin ( arr , n ) : NEWLINE INDENT ans = 1 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT j = i + 1 NEWLINE while ( j < n and arr [ j ] >= arr [ j - 1 ] ) : NEWLINE INDENTINDENTINDENT j += 1 NEWLINE DEDENT ans = max ( ans , j - i ) NEWLINE i = j - 1 NEWLINE DEDENT return n - ans NEWLINE DEDENT arr = [ 3 , 2 , 1 ] NEWLINE n = len ( arr ) NEWLINE print ( findMin ( arr , n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) for i in range ( n ) : print ( ( 2 * n ) + i , end = " " ) NEWLINE NL ENDMARKER
s , l = map ( int , input ( ) . split ( ) ) i = 0 while ( s <= l ) : s = s * 3 l = l * 2 i = i + 1 print ( i ) NEWLINE NL ENDMARKER
import math NEWLINE def trianglearea ( a ) : NEWLINE INDENT if ( a < 0 ) : NEWLINE INDENTINDENT return - 1 ; NEWLINE DEDENT area = ( 3 * math . sqrt ( 3 ) * math . pow ( a , 2 ) ) / 4 ; NEWLINE return area ; NEWLINE DEDENT a = 6 ; NEWLINE print ( trianglearea ( a ) ) NEWLINE NL ENDMARKER
c , d = list ( map ( int , input ( ) . split ( ) ) ) n , m = list ( map ( int , input ( ) . split ( ) ) ) k = int ( input ( ) ) t = max ( ( m * n ) - k , 0 ) p = min ( c , n * d ) ans = p * ( t // n ) rem = t % nans = ans + min ( c , rem * d ) print ( ans ) NEWLINE NL ENDMARKER
import sys NEWLINE def findLCM ( a , b ) : NEWLINE INDENT lar = max ( a , b ) NEWLINE small = min ( a , b ) NEWLINE i = lar NEWLINE while ( 1 ) : NEWLINE INDENTINDENT if ( i % small == 0 ) : NEWLINE INDENTINDENTINDENT return i NEWLINE DEDENT i += lar NEWLINE DEDENT DEDENT a = 5 NEWLINE b = 7 NEWLINE print ( "LCM of " , a , " and " , b , " is " , findLCM ( a , b ) , sep = "" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) ans = 0 c = 0 n = len ( s ) for i in range ( n - 1 ) : NEWLINE NL ENDMARKER
def findWinner ( n ) : NEWLINE INDENT if ( ( n - 1 ) % 6 == 0 ) : NEWLINE INDENTINDENT print ( "Second Player wins the game" ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "First Player wins the game" ) ; NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 7 ; NEWLINE findWinner ( n ) ; NEWLINE NL DEDENT ENDMARKER
def stringToInt ( str ) : NEWLINE INDENT if ( len ( str ) == 1 ) : NEWLINE INDENTINDENT return ord ( str [ 0 ] ) - ord ( '0' ) ; NEWLINE DEDENT y = stringToInt ( str [ 1 : ] ) ; NEWLINE x = ord ( str [ 0 ] ) - ord ( '0' ) ; NEWLINE x = x * ( 10 ** ( len ( str ) - 1 ) ) + y ; NEWLINE return int ( x ) ; NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT str = "1235" ; NEWLINE print ( stringToInt ( str ) ) ; NEWLINE NL DEDENT ENDMARKER
a , b , c , d = map ( int , input ( ) . split ( ) )  misha = max ( 3 * a / 10 , a - a / 250 * c ) vasya = max ( 3 * b / 10 , b - b / 250 * d )  if misha > vasya : print ( "Misha" ) elif vasya > misha : print ( "Vasya" ) else : print ( "Tie" ) NEWLINE NL ENDMARKER
def check ( n , m ) : NEWLINE INDENT if ( m % n == 0 ) : NEWLINE INDENTINDENT print ( "YES" ) NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "NO" ) NEWLINE DEDENT DEDENT n = 5 NEWLINE m = 10 NEWLINE check ( n , m ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : NEWLINE INDENT n = int ( input ( ) ) NEWLINE a = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE print ( * ( [ 1 , 2 , n ] , [ - 1 ] ) [ a [ 0 ] + a [ 1 ] > a [ n - 1 ] ] ) NEWLINE NL DEDENT ENDMARKER
input ( ) c = input ( ) . replace ( ' ' , '' ) if '1' in c : count_zeros = 0 sum = 1 first = c . index ( '1' ) for i in range ( first , len ( c ) ) : if c [ i ] is '1' : sum = sum * ( count_zeros + 1 ) count_zeros = 0 continue count_zeros += 1 print ( sum ) else : print ( 0 )  NEWLINE NL ENDMARKER
def minLettersNeeded ( n ) : NEWLINE INDENT if n % 26 == 0 : NEWLINE INDENTINDENT return ( n // 26 ) NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( ( n // 26 ) + 1 ) NEWLINE DEDENT DEDENT n = 52 NEWLINE print ( minLettersNeeded ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) if n % 2 : print ( - 1 ) else : print ( * list ( range ( n , 0 , - 1 ) ) ) NEWLINE NL ENDMARKER
import sys  NEWLINE def answer ( x ) : test = 0 NEWLINE INDENT pass NEWLINE DEDENT k = 0 NEWLINE while test < x : NEWLINE NL ENDMARKER
def countPermutations ( N , B ) : NEWLINE INDENT x = B ** N NEWLINE y = B ** ( N - 1 ) NEWLINE print ( x - y ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N , B = 6 , 4 NEWLINE countPermutations ( N , B ) NEWLINE NL DEDENT ENDMARKER
for _ in range ( int ( input ( ) ) ) : x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) )  if x1 == x2 : print ( abs ( y2 - y1 ) )  elif y1 == y2 : print ( abs ( x2 - x1 ) )  else : print ( abs ( x2 - x1 ) + 2 + abs ( y2 - y1 ) ) NEWLINE NL ENDMARKER
n = input ( ) m = n . split ( ) [ 1 ] n = n . split ( ) [ 0 ] i , j = len ( n ) , len ( m ) k = max ( i , j ) t = min ( i , j ) s = 0 for i in range ( k ) : if i < t : s += ( int ( n [ - i - 1 ] ) + int ( m [ i ] ) ) * 10 ** i elif len ( n ) > len ( m ) : s += int ( n [ - i - 1 ] ) * 10 ** i else : s += int ( m [ i ] ) * 10 ** iprint ( s ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) % 6 x = int ( input ( ) ) p = [ "012" , "102" , "120" , "210" , "201" , "021" ] print ( p [ n ] [ x ] ) NEWLINE NL ENDMARKER
def check ( st ) : NEWLINE INDENT n = len ( st ) NEWLINE digitSum = 0 NEWLINE for i in range ( 0 , n ) : NEWLINE INDENTINDENT digitSum = digitSum + ( int ) ( st [ i ] ) NEWLINE DEDENT return ( digitSum % 9 == 0 ) NEWLINE DEDENT st = "99333" NEWLINE if ( check ( st ) ) : NEWLINE INDENT print ( "Yes" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "No" ) NEWLINE NL DEDENT ENDMARKER
num = int ( input ( ) ) NEWLINE for _ in range ( num ) : string = str ( input ( ) ) NEWLINE print ( len ( string ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) NEWLINE x = [ ] NEWLINE i = nwhile NEWLINE i > 0 : NEWLINE if n % i == 0 : x . append ( i ) NEWLINE n = i NEWLINE i = i - 1 NEWLINE for i in x : print ( i , end = " " ) NEWLINE NL ENDMARKER
def cassini ( n ) : NEWLINE INDENT return - 1 if ( n & 1 ) else 1 NEWLINE DEDENT n = 5 NEWLINE print ( cassini ( n ) ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) )  r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( )  num = 1  for i in arr : print ( i , end = " " ) lim = n - 1 while lim : if num not in arr : print ( num , end = " " )  lim -= 1 num += 1   print ( )   NEWLINE NL ENDMARKER
def findTriangularNumber ( n ) : NEWLINE INDENT return ( n * ( n + 1 ) ) / 2 NEWLINE DEDENT def printSeries ( n ) : NEWLINE INDENT prev = 0 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT curr = findTriangularNumber ( i ) NEWLINE curr = int ( curr + prev ) NEWLINE print ( curr , end = ' ' ) NEWLINE prev = curr NEWLINE DEDENT DEDENT n = 10 NEWLINE printSeries ( n ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : a , b , n = [ int ( x ) for x in input ( ) . split ( ) ] i = 0 while a <= n and b <= n : if a < b : a += b else : b += a i += 1 print ( i ) NEWLINE NL ENDMARKER
l , r = list ( map ( int , input ( ) . split ( ) ) )  a = [ ] i = lwhile i <= r - 1 : a . append ( [ i , i + 1 ] ) i += 2  if a : print ( 'YES' ) for i in a : print ( f'{i[0]} {i[1]}' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
from collections import defaultdict , OrderedDict , Counterfrom sys import stdin , stdoutfrom bisect import bisect_left , bisect_right NEWLINE NL ENDMARKER
def getPassingCars ( A , n ) : NEWLINE INDENT countOne = 0 ; result = 0 NEWLINE while n >= 1 : NEWLINE INDENTINDENT if A [ n - 1 ] == 1 : NEWLINE INDENTINDENTINDENT countOne += 1 NEWLINE DEDENT else : NEWLINE INDENTINDENTINDENT result += countOne NEWLINE DEDENT n -= 1 NEWLINE DEDENT return result NEWLINE DEDENT A = [ 0 , 1 , 0 , 1 , 1 ] NEWLINE n = len ( A ) NEWLINE print ( getPassingCars ( A , n ) ) NEWLINE NL ENDMARKER
def compute ( ) : NEWLINE INDENT LENGTH = 50 NEWLINE ways = [ 1 ] + [ 0 ] * LENGTH NEWLINE for n in range ( 1 , len ( ways ) ) : NEWLINE INDENTINDENT ways [ n ] += sum ( ways [ max ( n - 4 , 0 ) : n ] ) NEWLINE DEDENT return str ( ways [ - 1 ] ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT print ( compute ( ) ) NEWLINE NL DEDENT ENDMARKER
import mathdef isk ( n , d , k ) : for i in n : if i in d : d [ i ] = 1 for i in range ( k + 1 ) : if str ( i ) in d and d [ str ( i ) ] == 0 : return False return True  n , k = map ( int , input ( ) . split ( ) ) d = { } c = 0 for _ in range ( n ) : s = input ( ) for i in range ( k + 1 ) : d [ str ( i ) ] = 0 if isk ( s , d , k ) : c += 1 print ( c ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] chosen = set ( ) p = [ 0 ] * nfor i in range ( 1 , n + 1 ) : b = - 1 for j in range ( n ) : if not j in chosen and all ( a [ j ] [ k ] <= i for k in range ( n ) ) and all ( a [ k ] [ j ] <= i for k in range ( n ) ) : b = j p [ b ] = i chosen . add ( b ) print ( * p ) NEWLINE NL ENDMARKER
a = input ( ) NEWLINE b = input ( ) NEWLINE a = [ x for x in a ] NEWLINE b = [ y for y in b ]  x = [ '0' if i1 == i2 else '1' for ( i1 , i2 ) in zip ( a , b ) ] NEWLINE print ( '' . join ( x ) ) NEWLINE NL ENDMARKER
def count ( n ) : NEWLINE INDENT return pow ( 2 , n - 1 ) NEWLINE DEDENT n = 4 NEWLINE print ( count ( n ) ) NEWLINE NL ENDMARKER
def countNonDecreasing ( n ) : NEWLINE INDENT N = 10 NEWLINE count = 1 NEWLINE for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT count = int ( count * ( N + i - 1 ) ) NEWLINE count = int ( count / i ) NEWLINE DEDENT return count NEWLINE DEDENT n = 3 ; NEWLINE print ( countNonDecreasing ( n ) ) NEWLINE NL ENDMARKER
import math as m NEWLINE def isPentagonal ( n ) : NEWLINE INDENT n = ( 1 + m . sqrt ( 24 * N + 1 ) ) / 6 NEWLINE return ( ( n - int ( n ) ) == 0 ) NEWLINE DEDENT N = 19 NEWLINE if ( isPentagonal ( N ) ) : NEWLINE INDENT print ( N , " is pentagonal " ) NEWLINE DEDENT else : NEWLINE INDENT print ( N , " is not pentagonal" ) NEWLINE NL DEDENT ENDMARKER
def SUM ( n , m ) : NEWLINE INDENT if ( m == 1 ) : NEWLINE INDENTINDENT return ( n * ( n + 1 ) / 2 ) NEWLINE DEDENT sum = SUM ( n , m - 1 ) NEWLINE return int ( sum * ( sum + 1 ) / 2 ) NEWLINE DEDENT n = 5 NEWLINE m = 3 NEWLINE print ( "SUM(" , n , ", " , m , "):" , SUM ( n , m ) ) NEWLINE NL ENDMARKER
import mathn , m = map ( int , input ( ) . split ( ) ) fac1 = 1 fac2 = 1 i1 = 1 i2 = 1 while ( i1 <= n and i2 <= m ) : fac1 = fac1 * i1 fac2 = fac2 * i2 i1 = i1 + 1 i2 = i2 + 1  print ( math . gcd ( fac1 , fac2 ) ) NEWLINE NL ENDMARKER
a = input ( ) b = input ( )  f = True  for i , j in zip ( a , b ) : if j > i : f = False break  if f : print ( b )  else : print ( - 1 ) NEWLINE NL ENDMARKER
s = input ( ) n1 = s . count ( 'a' ) n2 = s . count ( 'b' ) n3 = s . count ( 'c' ) n4 = s . count ( 'ab' ) n5 = s . count ( 'ba' ) if ( n1 == n3 or n2 == n3 ) and n4 == 1 and n5 == 0 and s [ - n3 : ] . count ( 'c' ) == n3 : print ( 'YES' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readline  n = int ( input ( ) ) s = input ( ) for i in range ( n - 1 ) : if s [ i ] != s [ i + 1 ] : print ( "YES" ) print ( s [ i ] , s [ i + 1 ] , sep = "" ) exit ( ) print ( "NO" ) NEWLINE NL ENDMARKER
a , b , c = map ( int , input ( ) . split ( ) ) d , e , f = map ( int , input ( ) . split ( ) ) g , h , i = map ( int , input ( ) . split ( ) )  sum1 = a + b + csum2 = d + e + fsum3 = g + h + ia = ( sum1 + sum2 + sum3 ) // 2 - ( sum1 ) e = ( sum1 + sum2 + sum3 ) // 2 - ( sum2 ) i = ( sum1 + sum2 + sum3 ) // 2 - ( sum3 ) print ( a , b , c ) print ( d , e , f ) print ( g , h , i )      NEWLINE NL ENDMARKER
def swap ( xp , yp ) : NEWLINE INDENT xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEWLINE yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEWLINE xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEWLINE DEDENT x = [ 10 ] NEWLINE swap ( x , x ) NEWLINE print ( "After swap(&x, &x): x = " , x [ 0 ] ) NEWLINE NL ENDMARKER
def bitwiseAndOdd ( n ) : NEWLINE INDENT result = 1 ; NEWLINE for i in range ( 3 , n + 1 , 2 ) : NEWLINE INDENTINDENT result = ( result & i ) ; NEWLINE DEDENT return result ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 10 ; NEWLINE print ( bitwiseAndOdd ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
from math import pi  n = int ( input ( ) ) r = lambda : list ( map ( int , input ( ) . split ( ) ) ) arr = r ( ) arr . sort ( reverse = True ) arr . append ( 0 ) ans = 0.0 i = 0 while i < n : ans += pi * ( arr [ i ] ** 2 - arr [ i + 1 ] ** 2 ) i += 2  print ( f"{ans:.10f}" ) NEWLINE NL ENDMARKER
d = { 'polycarp' : 1 } for _ in range ( int ( input ( ) ) ) : a , b , c = input ( ) . lower ( ) . split ( ) ; d [ a ] = d [ c ] + 1 print ( max ( d . values ( ) ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) c = 0 for i in range ( n - 2 ) : if s [ i ] == 'x' and s [ i + 1 ] == 'x' and s [ i + 2 ] == 'x' : c += 1 print ( c ) NEWLINE NL ENDMARKER
from sys import stdininput = lambda : stdin . readline ( ) from math import ceil , sqrt , gcdfor _ in range ( int ( input ( ) ) ) : n , m , k = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) flag = 'YES' for i in range ( n - 1 ) : if l [ i + 1 ] > l [ i ] : if l [ i + 1 ] - l [ i ] > k : if m < l [ i + 1 ] - l [ i ] - k : flag = 'NO' break else : m -= ( l [ i + 1 ] - l [ i ] - k ) NEWLINE NL ENDMARKER
s = input ( ) . split ( ' ' ) n = int ( s [ 0 ] ) k = int ( s [ 1 ] ) s = input ( ) . split ( ' ' ) l = len ( s ) count = 0 for i in range ( l ) : if ( k + int ( s [ i ] ) <= 5 ) : count = count + 1  print ( int ( count / 3 ) ) NEWLINE NL ENDMARKER
n , s = map ( int , input ( ) . split ( ) ) ans = sfor _ in range ( n ) : f , t = map ( int , input ( ) . split ( ) ) ans = max ( ans , f + t ) print ( ans ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : L = list ( map ( int , input ( ) . split ( ) ) ) x = L [ - 1 ] y = L [ - 2 ] if ( x // y ) <= L [ 0 ] : if ( x % y ) <= L [ 1 ] : print ( "YES" ) else : print ( "NO" ) else : if ( y * ( ( x // y ) - L [ 0 ] ) ) + ( x % y ) > L [ 1 ] : print ( "NO" ) else : print ( "YES" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 mx = 0 for i in range ( n ) : mx = max ( a [ i ] , mx ) if mx == i + 1 : ans += 1 print ( ans ) NEWLINE NL ENDMARKER
from math import tan NEWLINE def polyarea ( n , a ) : NEWLINE INDENT if ( a < 0 and n < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEWLINE return A NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = 9 NEWLINE n = 6 NEWLINE print ( '{0:.6}' . format ( polyarea ( n , a ) ) ) NEWLINE NL DEDENT ENDMARKER
m , n = map ( int , input ( ) . split ( ) ) if ( m == n ) : print ( m ) else : print ( 2 ) NEWLINE NL ENDMARKER
def factorial ( N ) : NEWLINE INDENT fact = 1 NEWLINE for i in range ( 1 , N + 1 ) : NEWLINE INDENTINDENT fact = fact * i NEWLINE DEDENT return fact NEWLINE DEDENT def nthTerm ( N ) : NEWLINE INDENT return ( factorial ( N ) * ( N + 2 ) // 2 ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT N = 6 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL DEDENT ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) if a % 2 : a += 1 if a + 2 > b : print ( - 1 ) else : print ( a , a + 1 , a + 2 ) NEWLINE NL ENDMARKER
def calNum ( year ) : NEWLINE INDENT return ( year // 4 ) - ( year // 100 ) + ( year // 400 ) ; NEWLINE DEDENT def leapNum ( l , r ) : NEWLINE INDENT l -= 1 ; NEWLINE num1 = calNum ( r ) ; NEWLINE num2 = calNum ( l ) ; NEWLINE print ( num1 - num2 ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT l1 = 1 ; r1 = 400 ; NEWLINE leapNum ( l1 , r1 ) ; NEWLINE l2 = 400 ; r2 = 2000 ; NEWLINE leapNum ( l2 , r2 ) ; NEWLINE NL DEDENT ENDMARKER
input ( ) days = map ( int , input ( ) . split ( ) ) folders = [ ] fc = 0 c = 0  for i in days : if i < 0 : if c < 2 : c += 1 else : fc += 1 c = 1 if len ( folders ) <= fc : folders . append ( 0 ) folders [ fc ] += 1  print ( fc + 1 ) print ( * folders ) NEWLINE NL ENDMARKER
import sys , mathfrom collections import defaultdict , dequeinput = sys . stdin . readline  n = int ( input ( ) ) c = 0 for i in range ( 1 , n + 1 ) : for j in range ( i + 1 , n + 1 ) : k = i ^ j if ( i < j < k <= n and i + j > k and j + k > i and i + k > j ) : NEWLINE NL ENDMARKER
def xorCalc ( k ) : NEWLINE INDENT if ( k == 1 ) : NEWLINE INDENTINDENT return 2 NEWLINE DEDENT if ( ( ( k + 1 ) & k ) == 0 ) : NEWLINE INDENTINDENT return k / 2 NEWLINE DEDENT return 1 ; NEWLINE DEDENT k = 31 NEWLINE print ( int ( xorCalc ( k ) ) ) NEWLINE NL ENDMARKER
from math import ceiln , k = map ( int , input ( ) . split ( ) ) w = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) minDay = 0 total = 0 for i in range ( 1 , n + 1 ) : total += ceil ( w [ i ] / k ) minDay = ceil ( total / 2 ) print ( minDay ) NEWLINE NL ENDMARKER
from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( 'input.txt' ) ) : stdin = open ( "input.txt" , "r" ) NEWLINE NL ENDMARKER
def getTotalXorOfSubarrayXors ( arr , N ) : NEWLINE INDENT res = 0 NEWLINE for i in range ( 0 , N ) : NEWLINE INDENTINDENT for j in range ( i , N ) : NEWLINE INDENTINDENTINDENT for k in range ( i , j + 1 ) : NEWLINE INDENTINDENTINDENTINDENT res = res ^ arr [ k ] NEWLINE DEDENT DEDENT DEDENT return res NEWLINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEWLINE N = len ( arr ) NEWLINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEWLINE NL ENDMARKER
def nthTerm ( n ) : NEWLINE INDENT return 7 * pow ( n , 2 ) - 7 * n + 7 NEWLINE DEDENT N = 4 NEWLINE print ( nthTerm ( N ) ) NEWLINE NL ENDMARKER
import math as m NEWLINE def findMin ( a , n ) : NEWLINE INDENT _sum = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT _sum += m . log ( a [ i ] ) NEWLINE DEDENT x = m . exp ( _sum / n ) NEWLINE return int ( x + 1 ) NEWLINE DEDENT a = [ 3 , 2 , 1 , 4 ] NEWLINE n = len ( a ) NEWLINE print ( findMin ( a , n ) ) NEWLINE NL ENDMARKER
def findCount ( m , n ) : NEWLINE INDENT num1 = 0 NEWLINE for i in range ( 0 , m ) : NEWLINE INDENTINDENT num1 = ( num1 * 10 ) + 9 NEWLINE DEDENT num2 = 0 NEWLINE for i in range ( 0 , ( m - 1 ) ) : NEWLINE INDENTINDENT num2 = ( num2 * 10 ) + 9 NEWLINE DEDENT return int ( ( num1 / n ) - ( num2 / n ) ) NEWLINE DEDENT m = 2 ; n = 6 NEWLINE print ( findCount ( m , n ) ) NEWLINE NL ENDMARKER
from collections import Counter n , k = map ( int , input ( ) . split ( ) ) c = Counter ( ) ans = - 1 for i in range ( 1 , k + 1 ) : x = int ( input ( ) ) c [ x % n ] += 1 if ans == - 1 and c [ x % n ] > 1 : ans = i print ( ans ) NEWLINE NL ENDMARKER
n , m = map ( int , input ( ) . split ( ) ) kmin = n // mkmax = n - mpairMin = m * kmin * ( kmin - 1 ) // 2 + kmin * ( n % m ) pairMax = ( kmax + 1 ) * kmax // 2 print ( pairMin , pairMax ) NEWLINE NL ENDMARKER
def minItems ( k , r ) : NEWLINE INDENT for i in range ( 1 , 10 ) : NEWLINE INDENTINDENT if ( ( i * k - r ) % 10 == 0 or ( i * k ) % 10 == 0 ) : NEWLINE INDENTINDENTINDENT return i NEWLINE DEDENT DEDENT return 10 ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT k , r = 15 , 2 ; NEWLINE print ( minItems ( k , r ) ) NEWLINE NL DEDENT ENDMARKER
a = input ( ) c = max ( a ) print ( c * a . count ( c ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) t = nhome = input ( ) departure = [ ] while t > 0 : flight = input ( ) departure . append ( flight [ : 3 ] ) t -= 1  if n % 2 == 0 : print ( 'home' ) else : print ( 'contest' ) NEWLINE NL ENDMARKER
def solve ( A , B ) : NEWLINE INDENT p = B / 2 NEWLINE M = int ( 4 * p ) NEWLINE N = 1 NEWLINE O = - 2 * A NEWLINE Q = int ( A * A + 4 * p * p ) NEWLINE return [ M , N , O , Q ] NEWLINE DEDENT a = 1 NEWLINE b = 1 NEWLINE print ( * solve ( a , b ) ) NEWLINE NL ENDMARKER
def Add ( x , y ) : NEWLINE INDENT while ( y != 0 ) : NEWLINE INDENTINDENT carry = x & y NEWLINE x = x ^ y NEWLINE y = carry << 1 NEWLINE DEDENT return x NEWLINE DEDENT print ( Add ( 15 , 32 ) ) NEWLINE NL ENDMARKER
import osimport sysfrom io import BytesIO , IOBaseimport mathimport itertoolsimport bisectimport heapq NEWLINE NL ENDMARKER
def andOperator ( a , b ) : NEWLINE INDENT while ( a < b ) : NEWLINE INDENTINDENT b -= ( b & - b ) NEWLINE DEDENT return b NEWLINE DEDENT a , b = 10 , 15 NEWLINE print ( andOperator ( a , b ) ) NEWLINE NL ENDMARKER
f1 , t1 = [ int ( i ) for i in input ( ) . split ( " " ) ] f2 , t2 = [ int ( i ) for i in input ( ) . split ( " " ) ] time = [ str ( i ) for i in input ( ) . split ( " " ) ] time = time [ 0 ]  th , tm = time . split ( ":" ) th = int ( th ) tm = int ( tm )  NEWLINE NL ENDMARKER
def countPairs ( n ) : NEWLINE INDENT count = 0 ; NEWLINE for x in range ( 1 , n ) : NEWLINE INDENTINDENT for y in range ( x + 1 , n + 1 ) : NEWLINE INDENTINDENTINDENT if ( ( y + x ) % ( y ^ x ) == 0 ) : NEWLINE INDENTINDENTINDENTINDENT count += 1 ; NEWLINE DEDENT DEDENT DEDENT return count ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 6 ; NEWLINE print ( countPairs ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
def findEvenPair ( A , N ) : NEWLINE INDENT count = 0 NEWLINE for i in range ( N ) : NEWLINE INDENTINDENT if ( not ( A [ i ] & 1 ) ) : NEWLINE INDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT return count * ( count - 1 ) // 2 NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT A = [ 5 , 6 , 2 , 8 ] NEWLINE N = len ( A ) NEWLINE print ( findEvenPair ( A , N ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) maxcount , count = 1 , 1 for i in range ( n - 1 ) : if arr [ i ] > arr [ i + 1 ] : count = 1 else : count += 1 if count > maxcount : maxcount = countprint ( maxcount ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) tree = [ [ ] for i in range ( n + 1 ) ] for i in range ( 2 , n + 1 ) : p = int ( input ( ) ) tree [ p ] . append ( i ) NEWLINE NL ENDMARKER
import syssys . stdin = open ( "input.txt" , "r" ) sys . stdout = open ( "output.txt" , "w" ) match = input ( ) rail = int ( input ( ) ) if match == "front" : if rail == 1 : print ( "L" ) else : print ( "R" ) else : if rail == 1 : print ( "R" ) else : print ( "L" ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) print ( 6 * n * ( n - 1 ) + 1 ) NEWLINE NL ENDMARKER
x , y = map ( int , input ( ) . split ( ) ) erg = ( ( x ) * ( y ) ) // 2 print ( erg ) NEWLINE NL ENDMARKER
def Calculate_GST ( org_cost , N_price ) : NEWLINE INDENT return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; NEWLINE DEDENT org_cost = 100 NEWLINE N_price = 120 NEWLINE print ( "GST = " , end = '' ) NEWLINE print ( round ( Calculate_GST ( org_cost , N_price ) ) , end = '' ) NEWLINE print ( "%" ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) NEWLINE l = list ( ) NEWLINE for i in range ( n ) : x = list ( map ( int , input ( ) . split ( ) ) ) NEWLINE l . append ( x ) NEWLINE for i in l : c = 1 NEWLINE for j in l : if NEWLINE abs ( i [ 0 ] - j [ 0 ] ) + abs ( i [ 1 ] - j [ 1 ] ) > k : c = 0 NEWLINE break NEWLINE if c == 1 : print ( 1 ) NEWLINE break NEWLINE if c == 0 : print ( - 1 )  NEWLINE NL ENDMARKER
import math as mt NEWLINE def ReuleauxArea ( r ) : NEWLINE INDENT if ( r < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT A = 0.70477 * 2 * pow ( r , 2 ) NEWLINE return A NEWLINE DEDENT r = 6 NEWLINE print ( ReuleauxArea ( r ) ) NEWLINE NL ENDMARKER
def printLines ( n , k ) : NEWLINE INDENT for i in range ( n ) : NEWLINE INDENTINDENT print ( k * ( 6 * i + 1 ) , k * ( 6 * i + 2 ) , k * ( 6 * i + 3 ) , k * ( 6 * i + 5 ) ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT n , k = 2 , 2 NEWLINE printLines ( n , k ) NEWLINE NL DEDENT ENDMARKER
print ( ( int ( input ( ) ) - 1 ) // 2 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) while n % 3 == 0 : n //= 3 print ( n // 3 + 1 ) NEWLINE NL ENDMARKER
def fifthPowerSum ( n ) : NEWLINE INDENT return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) // 12 NEWLINE DEDENT n = 5 NEWLINE print ( fifthPowerSum ( n ) ) NEWLINE NL ENDMARKER
import osimport sysfrom io import BytesIO , IOBaseimport mathimport itertoolsimport bisectimport heapq NEWLINE NL ENDMARKER
t = int ( input ( ) ) for i in range ( t ) : a , b , c = map ( int , input ( ) . split ( ) ) s = a + b + c print ( s // 2 ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) s = input ( ) s = list ( s ) count = 0 for i in range ( len ( s ) ) : if ( s [ i ] == '<' ) : count += 1 else : break for i in range ( len ( s ) - 1 , - 1 , - 1 ) : if ( s [ i ] == '>' ) : count += 1 else : break print ( count ) NEWLINE NL ENDMARKER
def printSeriessumm ( N ) : NEWLINE INDENT summ = 0 NEWLINE for i in range ( 1 , N + 1 ) : NEWLINE INDENTINDENT summ += pow ( i , i - 1 ) NEWLINE DEDENT print ( summ ) NEWLINE DEDENT N = 5 NEWLINE printSeriessumm ( N ) NEWLINE NL ENDMARKER
def isProductEven ( arr , n ) : NEWLINE INDENT for i in range ( 0 , n ) : NEWLINE INDENTINDENT if ( ( arr [ i ] & 1 ) == 0 ) : NEWLINE INDENTINDENTINDENT return True NEWLINE DEDENT DEDENT return False NEWLINE DEDENT arr = [ 2 , 4 , 3 , 5 ] NEWLINE n = len ( arr ) NEWLINE if ( isProductEven ( arr , n ) ) : NEWLINE INDENT print ( "Even" ) NEWLINE DEDENT else : NEWLINE INDENT print ( "Odd" ) NEWLINE NL DEDENT ENDMARKER
import math NEWLINE def nonsquare ( n ) : NEWLINE INDENT return n + ( int ) ( 0.5 + math . sqrt ( n ) ) NEWLINE DEDENT def printNonSquare ( n ) : NEWLINE INDENT for i in range ( 1 , n + 1 ) : NEWLINE INDENTINDENT print ( nonsquare ( i ) , end = " " ) NEWLINE DEDENT DEDENT n = 10 NEWLINE printNonSquare ( n ) NEWLINE NL ENDMARKER
def findSubArr ( arr , n ) : NEWLINE INDENT for i in range ( n - 1 ) : NEWLINE INDENTINDENT if ( abs ( arr [ i ] - arr [ i + 1 ] ) >= 2 ) : NEWLINE INDENTINDENTINDENT print ( arr [ i ] , arr [ i + 1 ] , end = "" ) ; NEWLINE return ; NEWLINE DEDENT DEDENT print ( - 1 ) ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT arr = [ 1 , 2 , 4 , 6 , 7 ] ; NEWLINE n = len ( arr ) ; NEWLINE findSubArr ( arr , n ) ; NEWLINE NL DEDENT ENDMARKER
n , p = list ( map ( int , input ( ) . split ( ) ) ) s = list ( input ( ) ) s [ n - 1 ] = chr ( ord ( s [ n - 1 ] ) + 1 ) i = n - 1 while i >= 0 and i < n : if ord ( s [ i ] ) >= ord ( 'a' ) + p : s [ i ] = 'a' i -= 1 s [ i ] = chr ( ord ( s [ i ] ) + 1 ) elif i > 0 and s [ i ] == s [ i - 1 ] or i > 1 and s [ i ] == s [ i - 2 ] : s [ i ] = chr ( ord ( s [ i ] ) + 1 ) else : i += 1 print ( "NO" if i < 0 else "" . join ( s ) ) NEWLINE NL ENDMARKER
def pentdiagonal ( a ) : NEWLINE INDENT if ( a < 0 ) : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT d = 1.22 * a NEWLINE return d NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT a = 6 NEWLINE print ( pentdiagonal ( a ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) )  if ( n % 2 ) == 0 : print ( 'Mahmoud' ) else : print ( 'Ehab' ) NEWLINE NL ENDMARKER
s = list ( input ( ) . split ( ) )  if s [ - 1 ] == "week" : if s [ 0 ] in "56" : print ( 53 ) else : print ( 52 ) else : if int ( s [ 0 ] ) == 31 : print ( 7 ) elif int ( s [ 0 ] ) == 30 : print ( 11 ) else : print ( 12 ) NEWLINE NL ENDMARKER
def power ( x , y ) : NEWLINE INDENT if ( y == 0 ) : return 1 NEWLINE temp = power ( x , int ( y / 2 ) ) NEWLINE if ( y % 2 == 0 ) : NEWLINE INDENTINDENT return temp * temp NEWLINE DEDENT else : NEWLINE INDENTINDENT if ( y > 0 ) : return x * temp * temp NEWLINE else : return ( temp * temp ) / x NEWLINE DEDENT DEDENT x , y = 2 , - 3 NEWLINE print ( '%.6f' % ( power ( x , y ) ) ) NEWLINE NL ENDMARKER
n , q = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( 1 , n ) : a [ i ] = ( a [ i - 1 ] + a [ i ] )  ans = 0 for i in range ( q ) : x , y = map ( int , input ( ) . split ( ) ) temp = a [ y - 1 ] if x != 1 : temp -= a [ x - 2 ] ans = max ( ans , ans + temp ) print ( ans ) NEWLINE NL ENDMARKER
def getMinVal ( p , q ) : NEWLINE INDENT if q % p == 0 : NEWLINE INDENTINDENT return p NEWLINE DEDENT return - 1 NEWLINE DEDENT p = 24 ; q = 48 NEWLINE print ( getMinVal ( p , q ) ) NEWLINE NL ENDMARKER
def countWays ( A , B , C ) : NEWLINE INDENT minAddA = max ( 0 , ( C + B - A + 2 ) // 2 ) NEWLINE count_ways = max ( C - minAddA + 1 , 0 ) NEWLINE return count_ways NEWLINE DEDENT A = 3 NEWLINE B = 5 NEWLINE C = 5 NEWLINE print ( countWays ( A , B , C ) ) NEWLINE NL ENDMARKER
a = int ( input ( ) ) b = int ( input ( ) ) l = list ( range ( b + 1 , 0 , - 1 ) ) if a == 0 : for i in l : print ( i , end = " " ) else : q = list ( range ( b + 2 , a + b + 2 ) ) print ( 1 , end = " " ) for i in q : print ( i , end = " " ) for i in l [ : - 1 ] : print ( i , end = " " ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) x = 1 s = 1 while s <= n : x += 1 s += ( x * ( x + 1 ) ) // 2 print ( x - 1 ) NEWLINE NL ENDMARKER
try : n , m = map ( int , input ( ) . split ( ) ) f = [ ] flag = 0 for i in range ( n ) : k = [ int ( j ) for j in input ( ) . split ( ) ] f . append ( k ) if ( 1 in f [ 0 ] ) : flag = 1 for i in range ( n ) : if ( f [ i ] [ 0 ] == 1 ) : flag = 1 if ( 1 in f [ n - 1 ] ) : flag = 1 for i in range ( n ) : if ( f [ i ] [ m - 1 ] == 1 ) : flag = 1 if ( flag == 1 ) : print ( "2" ) else : print ( "4" ) except : pass NEWLINE NL ENDMARKER
import sys  input = sys . stdin . buffer . readline  ans = "1 " * 100  t = int ( input ( ) ) NEWLINE for _ in range ( t ) : n = int ( input ( ) ) NEWLINE print ( ans [ : 2 * n - 1 ] ) NEWLINE NL ENDMARKER
def gouldSequence ( n ) : NEWLINE INDENT for row_num in range ( 1 , n ) : NEWLINE INDENTINDENT count = 1 NEWLINE c = 1 NEWLINE for i in range ( 1 , row_num ) : NEWLINE INDENTINDENTINDENT c = c * ( row_num - i ) / i NEWLINE if ( c % 2 == 1 ) : NEWLINE INDENTINDENTINDENTINDENT count += 1 NEWLINE DEDENT DEDENT print ( count , end = " " ) NEWLINE DEDENT DEDENT n = 16 ; NEWLINE gouldSequence ( n ) NEWLINE NL ENDMARKER
import sysstring = str ( sys . stdin . readline ( ) ) string = list ( string ) def solution ( string ) : count = 1 answer = 0 num = 0 NEWLINE NL ENDMARKER
if name == '__main__' : NEWLINE INDENT for first in range ( 1 , 6 ) : NEWLINE INDENTINDENT for second in range ( 1 , 6 ) : NEWLINE INDENTINDENTINDENT print ( 5 * first + second - 5 ) NEWLINE NL DEDENT DEDENT DEDENT ENDMARKER
def countgroup ( a , n ) : NEWLINE INDENT xs = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT xs = xs ^ a [ i ] NEWLINE DEDENT if xs == 0 : NEWLINE INDENTINDENT return ( 1 << ( n - 1 ) ) - 1 NEWLINE DEDENT return 0 NEWLINE DEDENT a = [ 1 , 2 , 3 ] NEWLINE n = len ( a ) NEWLINE print ( countgroup ( a , n ) ) NEWLINE NL ENDMARKER
class pair : def NEWLINE __init__ ( self , f , s ) : self . f = f NEWLINE self . s = s  me = input ( ) NEWLINE n = int ( input ( ) )  mp = { } NEWLINE for i in range ( n ) : a = list ( map ( str , input ( ) . split ( ) ) )  if a [ 1 ] == "likes" : NEWLINE INDENT ot = a [ 2 ] else : NEWLINE ot = a [ 3 ]  NEWLINE NL DEDENT ENDMARKER
TOTAL_BITS = 32 ; NEWLINE def isPossible ( n ) : NEWLINE INDENT cnt = bin ( n ) . count ( '1' ) ; NEWLINE if ( cnt == TOTAL_BITS // 2 ) : NEWLINE INDENTINDENT return True ; NEWLINE DEDENT return False ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 524280 ; NEWLINE if ( isPossible ( n ) ) : NEWLINE INDENTINDENT print ( "Yes" ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( "No" ) ; NEWLINE NL DEDENT DEDENT ENDMARKER
t = int ( input ( ) ) for _ in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) print ( a + b ) NEWLINE NL ENDMARKER
import sysinput = sys . stdin . readline  n , k = [ int ( i ) for i in input ( ) . split ( ) ] a = [ int ( i ) for i in input ( ) . split ( ) ] count = 1 while k > count : k -= count count += 1 print ( a [ k - 1 ] ) NEWLINE NL ENDMARKER
import sys , functools , collections , bisect , math , NEWLINE INDENT heapqinput = sys . stdin . readline NEWLINE NL DEDENT ENDMARKER
x , y = map ( int , input ( ) . split ( ) ) ; ans = 0 for i in range ( 2 , x + 1 , 2 ) : for j in range ( 2 , y + 1 , 2 ) : ans += ( x - i + 1 ) * ( y - j + 1 ) print ( ans ) NEWLINE NL ENDMARKER
def getValueOfF ( n ) : NEWLINE INDENT if ( n == 1 ) : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT if ( n == 2 ) : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT cnt = 0 NEWLINE while ( n % 2 == 0 ) : NEWLINE INDENTINDENT cnt += 1 NEWLINE n /= 2 NEWLINE DEDENT return 2 * cnt NEWLINE DEDENT n = 20 NEWLINE print ( getValueOfF ( n ) ) NEWLINE NL ENDMARKER
cases = int ( input ( ) ) powers = set ( )  for i in range ( 32 ) : powers . add ( 2 ** i ) while cases : cases -= 1 num = int ( input ( ) )  ans = num * ( num + 1 ) // 2  for i in powers : if i <= num : ans -= 2 * i  print ( ans )   NEWLINE NL ENDMARKER
import sysn , t = map ( int , sys . stdin . readline ( ) . split ( ) ) x = sys . stdin . readline ( ) y = x . find ( '.' ) for i in range ( y + 1 , n ) : if x [ i ] > '4' : for j in range ( t ) : i -= 1 if x [ i ] != '4' : break if i == y : i -= 1 while i and x [ i ] == '9' : i -= 1 x = x [ : i ] + str ( int ( x [ i ] ) + 1 ) + '0' * ( y - i - 1 ) else : x = x [ : i ] + str ( int ( x [ i ] ) + 1 ) breakprint ( x )           NEWLINE NL ENDMARKER
import sysimport bisectdef gcd ( a , b ) : if ( a == 0 ) : return b return gcd ( b % a , a ) def input ( ) : return sys . stdin . readline ( ) . strip ( ) def iinput ( ) : return int ( input ( ) ) def minput ( ) : return map ( int , input ( ) . split ( ) ) def listinput ( ) : return list ( map ( str , input ( ) . split ( ) ) ) for _ in range ( iinput ( ) ) : a , b = minput ( ) if a % b : print ( "NO" ) else : print ( "YES" ) NEWLINE NL ENDMARKER
def getChicks ( n ) : NEWLINE INDENT chicks = pow ( 3 , n - 1 ) NEWLINE return chicks NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 3 NEWLINE print ( getChicks ( n ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) s = input ( ) cnt = s . count ( 'x' ) - s . count ( 'X' ) print ( abs ( cnt // 2 ) ) s = list ( s ) for i in range ( len ( s ) ) : if cnt > 0 and s [ i ] == 'x' : s [ i ] = 'X' cnt -= 2 elif cnt < 0 and s [ i ] == 'X' : s [ i ] = 'x' cnt += 2 print ( '' . join ( s ) ) NEWLINE NL ENDMARKER
d , L , v1 , v2 = map ( int , input ( ) . split ( ) ) ans = float ( ( L - d ) / ( v1 + v2 ) ) print ( ans ) NEWLINE NL ENDMARKER
n , w = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a . sort ( ) g = a [ 0 ] b = a [ n ] if g >= w : print ( w ) else : if g * 2 > b : g = b / 2 t = g * n + g * 2 * n if t <= w : print ( t ) else : print ( w ) NEWLINE NL ENDMARKER
head = input ( ) text = input ( ) head_m = { t : head . count ( t ) for t in head . strip ( ) . replace ( ' ' , '' ) . replace ( '\t' , '' ) } IsValid = Truefor i in text . strip ( ) . replace ( ' ' , '' ) . replace ( '\t' , '' ) : NEWLINE NL ENDMARKER
def anglequichord ( z ) : NEWLINE INDENT print ( "The angle is " , z , " degrees" ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT z = 48 NEWLINE anglequichord ( z ) NEWLINE NL DEDENT ENDMARKER
def findNumbers ( n ) : NEWLINE INDENT i = 1 NEWLINE while ( i <= n ) : NEWLINE INDENTINDENT print ( ( 3 * i * ( i - 1 ) + 1 ) , end = " " ) NEWLINE i += 1 NEWLINE DEDENT DEDENT n = 4 NEWLINE findNumbers ( n ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) ce = 0 co = 0 s = 0 for i in l : if i % 2 == 0 : ce += 1 else : co += 1 s += i  if s % 2 == 0 : print ( ce ) else : print ( co ) NEWLINE NL ENDMARKER
def maximumArea ( l , b , x , y ) : NEWLINE INDENT left , right , above , below = 0 , 0 , 0 , 0 NEWLINE left = x * b NEWLINE right = ( l - x - 1 ) * b NEWLINE above = l * y NEWLINE below = ( b - y - 1 ) * l NEWLINE print ( max ( max ( left , right ) , max ( above , below ) ) ) NEWLINE DEDENT l = 8 NEWLINE b = 8 NEWLINE x = 0 NEWLINE y = 0 NEWLINE maximumArea ( l , b , x , y ) NEWLINE NL ENDMARKER
s = input ( ) ans = 0 n = len ( s ) for i in range ( 1 , n ) : ans += pow ( 2 , i ) for i in range ( 0 , n ) : if ( s [ i ] == '7' ) : ans += pow ( 2 , n - 1 - i ) print ( ans + 1 ) NEWLINE NL ENDMARKER
def findSum ( N ) : NEWLINE INDENT ans = 0 NEWLINE for i in range ( 1 , N + 1 ) : NEWLINE INDENTINDENT for j in range ( 1 , N + 1 ) : NEWLINE INDENTINDENTINDENT ans += i // j NEWLINE DEDENT DEDENT return ans NEWLINE DEDENT N = 2 NEWLINE print ( findSum ( N ) ) NEWLINE NL ENDMARKER
def ways ( n ) : NEWLINE INDENT return n // 2 NEWLINE DEDENT n = 2 NEWLINE print ( ways ( n ) ) NEWLINE NL ENDMARKER
rev_num = 0 NEWLINE base_pos = 1 NEWLINE def reversDigits ( num ) : NEWLINE INDENT global rev_num NEWLINE global base_pos NEWLINE if ( num > 0 ) : NEWLINE INDENTINDENT reversDigits ( ( int ) ( num / 10 ) ) NEWLINE rev_num += ( num % 10 ) * base_pos NEWLINE base_pos *= 10 NEWLINE DEDENT return rev_num NEWLINE DEDENT num = 4562 NEWLINE print ( "Reverse of no. is " , reversDigits ( num ) ) NEWLINE NL ENDMARKER
def allBitsSetInTheGivenRange ( n , l , r ) : NEWLINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEWLINE new_num = n & num NEWLINE if ( num == new_num ) : NEWLINE INDENTINDENT return "Yes" NEWLINE DEDENT return "No" NEWLINE DEDENT n , l , r = 22 , 2 , 3 NEWLINE print ( allBitsSetInTheGivenRange ( n , l , r ) ) NEWLINE NL ENDMARKER
def getMinCost ( arr , n ) : NEWLINE INDENT min_ele = min ( arr ) NEWLINE return min_ele * ( n - 1 ) NEWLINE DEDENT arr = [ 4 , 2 , 5 ] NEWLINE n = len ( arr ) NEWLINE print ( getMinCost ( arr , n ) ) NEWLINE NL ENDMARKER
def findSum ( N ) : NEWLINE INDENT return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT N = 4 NEWLINE print ( findSum ( N ) ) NEWLINE NL DEDENT ENDMARKER
a = int ( input ( ) ) sumA = 0 sumG = 0 s = '' for i in range ( a ) : c , d = map ( int , input ( ) . split ( ) ) if sumA + c - 500 > sumG : s += 'G' sumG += d else : s += 'A' sumA += c  if abs ( sumA - sumG ) > 500 : print ( - 1 ) else : print ( s ) NEWLINE NL ENDMARKER
import osimport sysfrom math import * from collections import *  NEWLINE NL ENDMARKER
import sys  def main ( ) : inp = sys . stdin . read ( ) . strip ( ) . split ( '\n' ) n , m = map ( int , inp [ 0 ] . split ( ) ) t = [ ] for s in inp [ 1 : ] : a , b = map ( int , s . split ( ) ) t . append ( a / b * m ) return min ( t ) print ( main ( ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) NEWLINE if ( n <= 9 ) : NEWLINE INDENT print ( n ) NEWLINE DEDENT else : NEWLINE INDENT while ( n > 9 ) : NEWLINE INDENTINDENT m = n NEWLINE s = 0 NEWLINE while ( m != 0 ) : NEWLINE INDENTINDENTINDENT a = m % 10 NEWLINE s += a NEWLINE m = m // 10 NEWLINE DEDENT n = s NEWLINE DEDENT print ( s ) NEWLINE NL DEDENT ENDMARKER
def minPower ( n , x ) : NEWLINE INDENT if ( x == 1 ) : NEWLINE INDENTINDENT return n NEWLINE DEDENT ans = 0 NEWLINE while ( n > 0 ) : NEWLINE INDENTINDENT ans += ( n % x ) NEWLINE n //= x NEWLINE DEDENT return ans NEWLINE DEDENT n = 5 NEWLINE x = 3 NEWLINE print ( minPower ( n , x ) ) NEWLINE NL ENDMARKER
def solve ( num ) : ans = 0 power = 0 while ans < num : ans += 2 ** power power += 1 return power print ( solve ( int ( input ( ) ) ) )  NEWLINE NL ENDMARKER
a = int ( input ( ) ) b = int ( input ( ) )  if a < b : small = a large = b d = b - aelse : small = b large = a d = a - b  center = small + d // 2  s1 = 0 s2 = 0  for i in range ( 1 , ( d // 2 ) + 1 ) : s1 += i  for i in range ( 1 , ( large - center ) + 1 ) : s2 += i  print ( s1 + s2 ) NEWLINE NL ENDMARKER
n = int ( input ( ) )  arr = list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n - 1 ) : for j in range ( i + 1 , n - 1 ) : a = min ( arr [ i ] , arr [ i + 1 ] ) b = max ( arr [ i ] , arr [ i + 1 ] ) c = min ( arr [ j ] , arr [ j + 1 ] ) d = max ( arr [ j ] , arr [ j + 1 ] ) if a < c < b < d or c < a < d < b : print ( "yes" ) exit ( ) print ( 'no' ) NEWLINE NL ENDMARKER
def countBits ( n ) : NEWLINE INDENT count = 0 ; NEWLINE while ( n ) : NEWLINE INDENTINDENT count += 1 ; NEWLINE n >>= 1 ; NEWLINE DEDENT return count ; NEWLINE DEDENT n = 32 ; NEWLINE print ( "Minimum value of K is =" , countBits ( n ) ) ; NEWLINE NL ENDMARKER
def swapBits ( x , p1 , p2 , n ) : NEWLINE INDENT set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) NEWLINE set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) NEWLINE xor = ( set1 ^ set2 ) NEWLINE xor = ( xor << p1 ) | ( xor << p2 ) NEWLINE result = x ^ xor NEWLINE return result NEWLINE DEDENT res = swapBits ( 28 , 0 , 3 , 2 ) NEWLINE print ( "Result =" , res ) NEWLINE NL ENDMARKER
def maxHandshake ( n ) : NEWLINE INDENT return int ( ( n * ( n - 1 ) ) / 2 ) NEWLINE DEDENT n = 10 NEWLINE print ( maxHandshake ( n ) ) NEWLINE NL ENDMARKER
x = int ( input ( ) )  if x == 3 : print ( 5 ) exit ( )  for i in range ( 50 ) : if ( 4 * i * i + 4 * i + 3 ) // 2 >= x : print ( 2 * i + 1 ) break NEWLINE NL ENDMARKER
def mulmod ( a , b , mod ) : NEWLINE INDENT res = 0 ; NEWLINE a = a % mod ; NEWLINE while ( b > 0 ) : NEWLINE INDENTINDENT if ( b % 2 == 1 ) : NEWLINE INDENTINDENTINDENT res = ( res + a ) % mod ; NEWLINE DEDENT a = ( a * 2 ) % mod ; NEWLINE b //= 2 ; NEWLINE DEDENT return res % mod ; NEWLINE DEDENT a = 9223372036854775807 ; NEWLINE b = 9223372036854775807 ; NEWLINE print ( mulmod ( a , b , 100000000000 ) ) ; NEWLINE NL ENDMARKER
n , s , t = map ( int , input ( ) . split ( ) ) P = list ( map ( int , input ( ) . split ( ) ) ) operations = 0 L = list ( range ( 1 , n + 1 ) ) for i in range ( n ) : if s == t : print ( i ) exit ( ) s = P [ s - 1 ] print ( - 1 )     NEWLINE NL ENDMARKER
def fun ( n ) : NEWLINE INDENT return n & ( n - 1 ) NEWLINE DEDENT n = 7 NEWLINE print ( "The number after unsetting the rightmost set bit" , fun ( n ) ) NEWLINE NL ENDMARKER
a , b = map ( int , input ( ) . split ( ) ) od = "" evf = "" evl = "" sw = Truefor i in range ( b ) : od += "#" if i == b - 1 : evl += "#" else : evl += "." if i == 0 : evf += "#" else : evf += "." for i in range ( a ) : if i % 2 == 0 : print ( od ) else : if sw : print ( evl ) sw = False else : print ( evf ) sw = True NEWLINE NL ENDMARKER
def getHCF ( x , y ) : NEWLINE INDENT minimum = min ( x , y ) NEWLINE if ( x % minimum == 0 and y % minimum == 0 ) : NEWLINE INDENTINDENT return minimum NEWLINE DEDENT for i in range ( minimum // 2 , 1 , - 1 ) : NEWLINE INDENTINDENT if ( x % i == 0 and y % i == 0 ) : NEWLINE INDENTINDENTINDENT return i NEWLINE DEDENT DEDENT return 1 NEWLINE DEDENT x , y = 16 , 32 NEWLINE print ( getHCF ( x , y ) ) NEWLINE NL ENDMARKER
def getHermiteNumber ( n ) : NEWLINE INDENT if n == 0 : NEWLINE INDENTINDENT return 1 NEWLINE DEDENT if n == 1 : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT else : NEWLINE INDENTINDENT return ( - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ) NEWLINE DEDENT DEDENT n = 6 NEWLINE print ( getHermiteNumber ( n ) ) ; NEWLINE NL ENDMARKER
def difference ( M , N ) : NEWLINE INDENT return M + N NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT M = 999999999 NEWLINE N = 1000000000 NEWLINE print ( difference ( M , N ) ) NEWLINE NL DEDENT ENDMARKER
def Rank ( Edges , Vertices ) : NEWLINE INDENT result = Edges - Vertices + 1 NEWLINE return result NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT Edges , Vertices = 7 , 5 NEWLINE print ( "Circuit Rank =" , Rank ( Edges , Vertices ) ) NEWLINE NL DEDENT ENDMARKER
def maxPrmimes ( n ) : NEWLINE INDENT return n // 2 NEWLINE DEDENT n = 17 NEWLINE print ( maxPrmimes ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) lst = list ( map ( int , input ( ) . strip ( ) . split ( ' ' ) ) ) l = [ ] for j in range ( n ) : l . append ( [ lst [ j ] , j ] ) l . sort ( key = lambda x : x [ 0 ] ) c = 0 for i in range ( 1 , n ) : c += abs ( l [ i ] [ 1 ] - l [ i - 1 ] [ 1 ] ) print ( c ) NEWLINE NL ENDMARKER
a , b , n = map ( int , input ( ) . split ( ) ) x = str ( a ) flag = 0 for i in range ( 10 ) : if int ( str ( a ) + str ( i ) ) % b == 0 : x += str ( i ) flag = 1 breakif flag == 0 : print ( - 1 ) else : for i in range ( n - 1 ) : x += "0" print ( x ) NEWLINE NL ENDMARKER
def findNthTerm ( n ) : NEWLINE INDENT if ( n % 2 == 0 ) : NEWLINE INDENTINDENT n = n // 2 NEWLINE n = 2 * ( n - 1 ) NEWLINE print ( n // 2 ) NEWLINE DEDENT else : NEWLINE INDENTINDENT n = ( n // 2 ) + 1 NEWLINE n = 2 * ( n - 1 ) NEWLINE print ( n ) NEWLINE DEDENT DEDENT if __name__ == "__main__" : NEWLINE INDENT X = 10 NEWLINE findNthTerm ( X ) ; NEWLINE X = 7 ; NEWLINE findNthTerm ( X ) NEWLINE NL DEDENT ENDMARKER
input ( ) a = [ int ( x ) for x in input ( ) . split ( ) ] for n in a : i = 1 while i * n * ( n + 1 ) % ( n * 4 ) != 0 : i += 1 print ( i * n + 1 ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) arr = [ int ( x ) for x in input ( ) . split ( ) ] k = 0 while k < n and arr [ k ] == 1 : k += 1 if ( k % 2 == 1 ) : if n == k : print ( "First" ) else : print ( "Second" ) else : if n == k : print ( "Second" ) else : print ( "First" ) NEWLINE NL ENDMARKER
for __ in range ( int ( input ( ) ) ) : n , k = [ int ( e ) for e in input ( ) . split ( ) ] ; k -= 1 ; print ( ( k + n % 2 * k // ( n // 2 ) ) % n + 1 ) NEWLINE NL ENDMARKER
import sys , os , ioimport math , bisect , operatorinf , mod = float ( 'inf' ) , 10 ** 9 + 7 NEWLINE NL ENDMARKER
from math import ceiln , m = list ( map ( int , input ( ) . split ( ) ) ) if m == 0 : print ( 1 ) elif m <= ( n // 2 ) : print ( m ) else : if n % 2 != 0 and m == ceil ( n / 2 ) : print ( n // 2 ) else : print ( n - m ) NEWLINE NL ENDMARKER
n , k , t = map ( int , input ( ) . split ( ) )           if t < k : print ( t ) elif t > n : NEWLINE NL ENDMARKER
def CountSetBits ( n ) : NEWLINE INDENT if ( n == 0 ) : NEWLINE INDENTINDENT return 0 ; NEWLINE DEDENT if ( ( n & 1 ) == 1 ) : NEWLINE INDENTINDENT return 1 + CountSetBits ( n >> 1 ) ; NEWLINE DEDENT else : NEWLINE INDENTINDENT return CountSetBits ( n >> 1 ) ; NEWLINE DEDENT DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 21 ; NEWLINE print ( CountSetBits ( n ) ) ; NEWLINE NL DEDENT ENDMARKER
def gcd ( a , b ) : NEWLINE INDENT if ( a == 0 ) : NEWLINE INDENTINDENT return b NEWLINE DEDENT return gcd ( b % a , a ) NEWLINE DEDENT def powGCD ( a , n , b ) : NEWLINE INDENT for i in range ( 0 , n + 1 , 1 ) : NEWLINE INDENTINDENT a = a * a NEWLINE DEDENT return gcd ( a , b ) NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT a = 10 NEWLINE b = 5 NEWLINE n = 2 NEWLINE print ( powGCD ( a , n , b ) ) NEWLINE NL DEDENT ENDMARKER
from math import * NEWLINE def findRadiusOfcircumcircle ( n , a ) : NEWLINE INDENT if n < 0 or a < 0 : NEWLINE INDENTINDENT return - 1 NEWLINE DEDENT radius = a / sqrt ( 2 - ( 2 * cos ( 360 / n ) ) ) NEWLINE return radius NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n , a = 5 , 6 NEWLINE print ( round ( findRadiusOfcircumcircle ( n , a ) , 5 ) ) NEWLINE NL DEDENT ENDMARKER
num_array = input ( ) . split ( ) b = int ( num_array [ 0 ] ) m = int ( num_array [ 1 ] ) c = 0 while ( b <= m ) : b = b * 3 m = m * 2 c += 1 print ( c ) NEWLINE NL ENDMARKER
def printFun ( test ) : NEWLINE INDENT if ( test < 1 ) : NEWLINE INDENTINDENT return NEWLINE DEDENT else : NEWLINE INDENTINDENT print ( test , end = " " ) NEWLINE printFun ( test - 1 ) NEWLINE print ( test , end = " " ) NEWLINE return NEWLINE DEDENT DEDENT test = 3 NEWLINE printFun ( test ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) for i in range ( n ) : a = int ( input ( ) ) x = 360 / ( 180 - a ) if x == int ( x ) : print ( 'YES' ) else : print ( 'NO' ) NEWLINE NL ENDMARKER
temp = input ( ) . split ( " " ) n = int ( temp [ 0 ] ) m = int ( temp [ 1 ] )  nli = [ ] mli = [ ]  for _ in range ( n ) : nli . append ( input ( ) )  for _ in range ( m ) : mli . append ( input ( ) )  res = n - mcount = 0 for x in mli : if x in nli : count += 1  res = res + ( count % 2 ) if res > 0 : print ( "YES" )  else : print ( "NO" ) NEWLINE NL ENDMARKER
def countdigits ( n , k ) : NEWLINE INDENT if n == 0 : NEWLINE INDENTINDENT return 0 NEWLINE DEDENT digit = n % 10 NEWLINE if digit == k : NEWLINE INDENTINDENT return 1 + countdigits ( n / 10 , k ) NEWLINE DEDENT return countdigits ( n / 10 , k ) NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 1000 ; NEWLINE k = 0 ; NEWLINE print ( countdigits ( n , k ) ) NEWLINE NL DEDENT ENDMARKER
I = lambda : map ( int , input ( ) . split ( ) ) n , m = I ( ) a , b = sorted ( I ( ) , reverse = 1 ) , sorted ( I ( ) ) s = sum ( b ) for i in range ( 1 , n ) : s += a [ i ] * mif a [ 0 ] > min ( b ) : s = - 1 elif a [ 0 ] != b [ 0 ] : s += a [ 0 ] - a [ 1 ] print ( s ) NEWLINE NL ENDMARKER
def findFlips ( str , n ) : NEWLINE INDENT last = ' ' NEWLINE res = 0 NEWLINE for i in range ( n ) : NEWLINE INDENTINDENT if ( last != str [ i ] ) : NEWLINE INDENTINDENTINDENT res += 1 NEWLINE DEDENT last = str [ i ] NEWLINE DEDENT return res // 2 NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT str = "00011110001110" NEWLINE n = len ( str ) NEWLINE print ( findFlips ( str , n ) ) NEWLINE NL DEDENT ENDMARKER
n = int ( input ( ) ) p = ni = 1 l = 1 sd = 0 s = 0j = 1 while ( n > 9 ) : n = int ( n / 10 ) i *= 10 l += 1 if p > 9 : while i != 1 : s = p - i if j == 1 : s = s + 1 sd += s * l p = i i = i / 10 l -= 1 j += 1 p = 9 print ( int ( p + sd ) ) NEWLINE NL ENDMARKER
n , k = map ( int , input ( ) . split ( ) ) print ( ( k + n - 1 ) // n ) NEWLINE NL ENDMARKER
def first ( a , b , c ) : NEWLINE INDENT a %= b NEWLINE for i in range ( 1 , b + 1 ) : NEWLINE INDENTINDENT a = a * 10 NEWLINE if int ( a / b ) == c : NEWLINE INDENTINDENTINDENT return i NEWLINE DEDENT a %= b NEWLINE DEDENT return - 1 NEWLINE DEDENT a = 1 NEWLINE b = 4 NEWLINE c = 5 NEWLINE print ( first ( a , b , c ) ) NEWLINE NL ENDMARKER
arr = "ABSINTH, BEER, BRANDY, CHAMPAGNE, GIN, RUM, SAKE, TEQUILA, VODKA, WHISKEY, WINE" . split ( ', ' ) NEWLINE NL ENDMARKER
def minAbsDiff ( n ) : NEWLINE INDENT mod = n % 4 ; NEWLINE if ( mod == 0 or mod == 3 ) : NEWLINE INDENTINDENT return 0 ; NEWLINE DEDENT return 1 ; NEWLINE DEDENT if __name__ == "__main__" : NEWLINE INDENT n = 5 ; NEWLINE print ( minAbsDiff ( n ) ) NEWLINE NL DEDENT ENDMARKER
cases = int ( input ( ) ) NEWLINE while cases : NEWLINE INDENT cases -= 1 NEWLINE n = int ( input ( ) ) NEWLINE print ( * list ( range ( n , 0 , - 1 ) ) ) NEWLINE NL DEDENT ENDMARKER
def nthTerm ( N ) : NEWLINE INDENT return ( ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ) ; NEWLINE DEDENT n = 4 NEWLINE print ( nthTerm ( n ) ) NEWLINE NL ENDMARKER
n = int ( input ( ) ) home = str ( input ( ) ) for i in range ( n ) : li1 = list ( map ( str , input ( ) . split ( ) ) ) if n % 2 == 0 : print ( "home" ) else : print ( "contest" ) NEWLINE NL ENDMARKER
def calculateSum ( n ) : NEWLINE INDENT sum = 0 NEWLINE for row in range ( n ) : NEWLINE INDENTINDENT sum = sum + ( 1 << row ) NEWLINE DEDENT return sum NEWLINE DEDENT n = 10 NEWLINE print ( "Sum of all elements:" , calculateSum ( n ) ) NEWLINE NL ENDMARKER
for _ in range ( int ( input ( ) ) ) : a , b , c , d = map ( int , input ( ) . split ( ) ) NEWLINE print ( max ( ( a + b ) , ( c + d ) ) ) NEWLINE NL ENDMARKER
def summation ( n ) : NEWLINE INDENT return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEWLINE DEDENT if __name__ == '__main__' : NEWLINE INDENT n = 10 NEWLINE print ( summation ( n ) ) NEWLINE NL DEDENT ENDMARKER
